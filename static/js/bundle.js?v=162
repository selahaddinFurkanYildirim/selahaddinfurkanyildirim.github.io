define('bundle', ['exports'], (function (exports) { 'use strict';

    class DispatcherHandle {
      constructor(dispatcher, callback) {
        this.dispatcher = dispatcher;
        this.callback = callback;
      }
      remove() {
        if (!this.dispatcher) {
          console.warn("Removing a dispatcher twice");
          return;
        }
        this.dispatcher.removeListener(this.callback);
        this.dispatcher = undefined;
        this.callback = undefined;
      }
      cleanup() {
        this.remove();
      }
    }
    class Dispatcher {
      constructor(options = {}) {
        this.options = options;
        this.listeners = [];
      }
      callbackExists(callback) {
        for (let i = 0; i < this.listeners.length; i += 1) {
          if (this.listeners[i] === callback) {
            return true;
          }
        }
        return false;
      }
      addListener(callback) {
        if (!(typeof callback === "function")) {
          console.error("The listener needs to be a function: ", callback);
          return;
        }
        if (this.callbackExists(callback)) {
          console.error("Can't re-register for the same callback: ", this, " ", callback);
          return;
        }
        this.listeners.push(callback);
        return new DispatcherHandle(this, callback);
      }
      addListenerOnce(callback) {
        let handler = this.addListener(function () {
          callback(...arguments);
          handler.remove();
        });
        return handler;
      }
      async awaitOnce() {
        return new Promise(resolve => this.addListenerOnce((...args) => resolve(...args)));
      }
      removeListener(callback) {
        for (let i = 0; i < this.listeners.length; i += 1) {
          if (this.listeners[i] === callback) {
            // Erase and return
            return this.listeners.splice(i, 1)[0];
          }
        }
      }
      removeAllListeners() {
        this.listeners = [];
      }
      dispatch(payload) {
        for (let i = 0; i < this.listeners.length;) {
          let listener = this.listeners[i];
          listener(...arguments);
          // In case the current listener deleted itself, keep the loop counter the same
          // If it deleted listeners that were executed before it, that's just wrong and there are no guaranteed about
          if (listener === this.listeners[i]) {
            i++;
          }
        }
      }
    }
    const DispatchersSymbol = Symbol("Dispatchers");
    class Dispatchable {
      get dispatchers() {
        return this[DispatchersSymbol] || (this[DispatchersSymbol] = new Map());
      }
      getDispatcher(name, addIfMissing = true) {
        let dispatcher = this.dispatchers.get(name);
        if (!dispatcher && addIfMissing) {
          dispatcher = new Dispatcher();
          this.dispatchers.set(name, dispatcher);
        }
        return dispatcher;
      }
      dispatch(name, payload) {
        let dispatcher = this.getDispatcher(name, false);
        if (dispatcher) {
          // Optimize the average case
          if (arguments.length <= 2) {
            dispatcher.dispatch(payload);
          } else {
            let args = Array.prototype.slice.call(arguments, 1);
            dispatcher.dispatch(...args);
          }
        }
      }
      addListenerGeneric(methodName, name, callback) {
        if (Array.isArray(name)) {
          return new CleanupJobs(name.map(x => this[methodName](x, callback)));
        }
        return this.getDispatcher(name)[methodName](callback);
      }
      addListener(name, callback) {
        return this.addListenerGeneric("addListener", name, callback);
      }
      addListenerOnce(name, callback) {
        return this.addListenerGeneric("addListenerOnce", name, callback);
      }
      removeListener(name, callback) {
        const dispatcher = this.getDispatcher(name, false);
        dispatcher?.removeListener(callback);
      }
      removeAllListeners(name) {
        const dispatcher = this.getDispatcher(name, false);
        dispatcher?.removeAllListeners();
      }
      cleanup() {
        this.runCleanupJobs();
        delete this[DispatchersSymbol];
      }

      // These function don't really belong here, but they don't really hurt here and I don't want a long proto chain
      // Add anything that needs to be called on cleanup here (dispatchers, etc)
      addCleanupJob(cleanupJob) {
        if (!this.hasOwnProperty("_cleanupJobs")) {
          this._cleanupJobs = new CleanupJobs();
        }
        this._cleanupJobs.add(cleanupJob);
        return cleanupJob;
      }
      runCleanupJobs() {
        if (this._cleanupJobs) {
          this._cleanupJobs.cleanup();
        }
      }
      detachListener(dispatcherHandle) {
        if (this._cleanupJobs) {
          this._cleanupJobs.remove(dispatcherHandle);
        } else {
          dispatcherHandle.remove();
        }
      }
      attachTimeout(callback, timeout) {
        // TODO when the timeout executes, it doesn't get cleared from the cleanup jobs and would leak
        const timeoutId = setTimeout(callback, timeout);
        this.addCleanupJob(() => clearTimeout(timeoutId));
        return timeoutId;
      }
      attachInterval(callback, timeout) {
        const intervalId = setInterval(callback, timeout);
        this.addCleanupJob(() => clearInterval(intervalId));
        return intervalId;
      }
      attachAnimationFrame(callback) {
        const animationId = requestAnimationFrame(callback);
        this.addCleanupJob(() => cancelAnimationFrame(animationId));
        return animationId;
      }
      addChangeListener(callback) {
        return this.addListener("change", callback);
      }
      dispatchChange(...args) {
        this.dispatch("change", ...args, this);
      }
    }

    // Creates a method that calls the method methodName on obj, and adds the result as a cleanup task
    function getAttachCleanupJobMethod(methodName) {
      let addMethodName = "add" + methodName;
      let removeMethodName = "remove" + methodName;
      return function (obj) {
        let args = Array.prototype.slice.call(arguments, 1);
        let handler = obj[addMethodName](...args);
        // TODO: This should be changed. It is bad to receive 2 different types of handlers.
        if (!handler) {
          handler = () => {
            obj[removeMethodName](...args);
          };
        }
        this.addCleanupJob(handler);
        return handler;
      };
    }

    // TODO maybe this can be handle better through a Proxy?
    // Not sure if these should be added like this, but meh
    Dispatchable.prototype.attachListener = getAttachCleanupJobMethod("Listener");
    Dispatchable.prototype.attachEventListener = getAttachCleanupJobMethod("EventListener");
    Dispatchable.prototype.attachCreateListener = getAttachCleanupJobMethod("CreateListener");
    Dispatchable.prototype.attachDeleteListener = getAttachCleanupJobMethod("DeleteListener");
    Dispatchable.prototype.attachChangeListener = getAttachCleanupJobMethod("ChangeListener");
    Dispatchable.prototype.attachListenerOnce = getAttachCleanupJobMethod("ListenerOnce");
    Dispatcher.Global = new Dispatchable();
    class OncePerTickRunner {
      constructor(callback) {
        this.callback = callback;
        this.throttle = new WeakMap();
      }
      maybeEnqueue(obj, ...args) {
        const existingArgs = this.throttle.get(obj);
        this.throttle.set(obj, args);
        if (existingArgs) {
          // We just updated the args
          return false;
        }
        queueMicrotask(() => {
          const existingArgs = this.throttle.get(obj);
          if (!existingArgs) {
            // We have been canceled
            return;
          }
          this.clear(obj);
          this.callback(obj, ...existingArgs);
        });
        return true;
      }
      clear(obj) {
        this.throttle.delete(obj);
      }
    }
    class CleanupJobs {
      constructor(jobs = []) {
        this.jobs = jobs;
      }
      add(job) {
        this.jobs.push(job);
      }
      cleanup() {
        for (let job of this.jobs) {
          if (typeof job.cleanup === "function") {
            job.cleanup();
          } else if (typeof job.remove === "function") {
            job.remove();
          } else {
            job();
          }
        }
        this.jobs = [];
      }
      remove(job) {
        if (job) {
          const index = this.jobs.indexOf(job);
          if (index >= 0) {
            this.jobs.splice(index, 1);
          }
          job.remove();
        } else {
          this.cleanup();
        }
      }
    }

    // Class that can be used to pass around ownership of a resource.
    // It informs the previous owner of the change (once) and dispatches the new element for all listeners
    // TODO: a better name
    class SingleActiveElementDispatcher extends Dispatcher {
      setActive(element, addChangeListener, forceDispatch) {
        if (!forceDispatch && element === this._active) {
          return;
        }
        this._active = element;
        this.dispatch(element);
        if (addChangeListener) {
          this.addListenerOnce(newElement => {
            if (newElement != element) {
              addChangeListener(newElement);
            }
          });
        }
      }
      getActive() {
        return this._active;
      }
    }

    let State$1 = class State extends Dispatchable {
      constructor(...args) {
        super(...args);
        this.stores = new Map();
      }
      getStore(objectType) {
        objectType = objectType?.objectType || objectType?.toLowerCase();
        return this.stores.get(objectType);
      }
      getStoreForEvent(event) {
        const objectType = event.objectType || event.store;
        return this.getStore(objectType);
      }
      addStore(store) {
        const objectType = store.objectType;
        if (!this.stores.has(objectType)) {
          this.stores.set(objectType, store);
        } else {
          throw Error("GlobalState: Adding a store for an existing object type: " + store.objectType);
        }
      }
      applyEvent(event) {
        if (event == null) {
          return;
        }
        if (Array.isArray(event)) {
          for (let individualEvent of event) {
            this.applyEvent(individualEvent);
          }
          return;
        }
        if (event.state) {
          this.importState(event.state);
          // We can have events that only have a state
          if (!this.getStoreForEvent(event)) {
            return;
          }
        }
        const store = this.getStoreForEvent(event);
        if (store) {
          return store.applyEvent(event);
        } else {
          console.log("GlobalState: Missing store for event: ", event);
        }
      }
      get(objectType, objectId) {
        const store = this.getStore(objectType);
        if (store) {
          let args = Array.prototype.slice.call(arguments, 1);
          return store.get(...args);
        } else {
          console.error("GlobalState: Can't find store ", objectType);
          return null;
        }
      }

      // Import the store for objectType and remove it from stateMap
      importStateFromTempMap(objectType, stateMap) {
        const storeState = stateMap.get(objectType);
        stateMap.delete(objectType);
        if (storeState == null) {
          // Probably a dependency that isn't in the state
          return;
        }
        const store = this.getStore(objectType);
        if (!store) {
          console.error("Failed to import state, can't find store ", objectType);
          return;
        }
        for (const dependency of store.dependencies) {
          this.importStateFromTempMap(dependency.toLowerCase(), stateMap);
        }
        store.importState(storeState);
      }

      // Imports the state information from a plain object
      importState(state) {
        if (Array.isArray(state)) {
          for (const obj of state) {
            this.importState(obj);
          }
          return;
        }
        if (state.state) {
          // Must have been a recursive object
          // TODO Technically not correct since we need to respect disableState/Event import
          this.load(state);
          return;
        }
        // Import everything in a map and then do an implicit topological sort by dependencies
        const stateMap = new Map();
        for (const [objectType, objects] of Object.entries(state)) {
          stateMap.set(objectType.toLowerCase(), objects);
        }
        while (stateMap.size > 0) {
          const allKeys = stateMap.keys();
          const objectType = allKeys.next().value;
          this.importStateFromTempMap(objectType, stateMap);
        }
      }

      // Loads both the state and the events
      load({
        state,
        events
      }, disableStateImport, disableEventsImport) {
        if (state && !disableStateImport) {
          this.importState(state);
        }
        if (events && !disableEventsImport) {
          this.applyEvent(events);
        }
      }
      clear() {
        for (const store of this.stores.values()) {
          store.clear && store.clear();
        }
      }
      toJSON() {
        const state = {};
        for (const store of this.stores.values()) {
          state[store.objectType] = store.toJSON();
        }
        return state;
      }
    };

    // When creating a store without an explicit state, this value should be assumed
    const GlobalState$1 = new State$1();

    // The store information is kept in a symbol, to not interfere with serialization/deserialization
    const StoreSymbol = Symbol("Store");
    const EventDispatcherSymbol = Symbol("EventDispatcher");
    class StoreObject extends Dispatchable {
      constructor(obj, event = null) {
        super();
        Object.assign(this, obj);
      }
      static makeFieldLoader(fieldDescriptor) {
        fieldDescriptor.cacheField = false;
        fieldDescriptor.rawField = fieldDescriptor.rawField || (key => key + "Id");
        return (value, obj) => {
          const store = obj.getStore(this[StoreSymbol].objectType);
          return store.get(value);
        };
      }
      setStore(store) {
        this[StoreSymbol] = store;
      }
      getStore(storeName) {
        const ownStore = this[StoreSymbol];
        if (storeName) {
          return ownStore.getState().getStore(storeName);
        }
        return ownStore;
      }

      // By default, applying an event just shallow copies the fields from event.data
      applyEvent(event) {
        Object.assign(this, event.data);
      }
      applyEventAndDispatch(event) {
        this.applyEvent(event);
        this.dispatchChange(event);
      }
      addDeleteListener(callback) {
        return this.addListener("delete", callback);
      }

      // Add a listener on updates from events with this specific type.
      // Can accept an array as eventType
      addEventListener(eventType, callback) {
        if (Array.isArray(eventType)) {
          const handlers = eventType.map(e => this.addEventListener(e, callback));
          return new CleanupJobs(handlers);
        }
        // Ensure the private event dispatcher exists
        if (!this[EventDispatcherSymbol]) {
          this[EventDispatcherSymbol] = new Dispatchable();
          this.addChangeListener(event => {
            this[EventDispatcherSymbol].dispatch(event.type, event, this);
          });
        }
        return this[EventDispatcherSymbol].addListener(eventType, callback);
      }
      toJSON() {
        const obj = {};
        for (const key in this) {
          if (this.hasOwnProperty(key)) {
            obj[key] = this[key];
          }
        }
        return obj;
      }
    }
    class BaseStore extends Dispatchable {
      constructor(objectType, ObjectClass = StoreObject, options = {}) {
        super();
        this.objectType = objectType.toLowerCase();
        this.ObjectClass = ObjectClass;
        Object.assign(this, {
          state: GlobalState$1,
          // Can be null as well
          dependencies: [],
          // A list of other stores we want imported first
          ...options
        });
        this.state?.addStore(this);
      }
      loadRaw(responseOrState) {
        const state = responseOrState?.state || responseOrState || {};

        // Since the backend might have a different lettering case, need a more complex search here
        for (const [key, value] of Object.entries(state)) {
          if (String(key).toLowerCase() === this.objectType) {
            return value || [];
          }
        }
        return [];
      }

      // For a response/state raw object, return the objects that we have in store
      load(responseOrState) {
        const rawObjects = this.loadRaw(responseOrState);
        return rawObjects.map(obj => this.get(obj.id));
      }
      loadObject(responseOrState, index = 0) {
        return this.load(responseOrState)?.[index];
      }
      getState() {
        return this.state;
      }
    }

    // Store type primarily intended to store objects that come from a server DB, and have a unique numeric .id field
    // TODO: do we ever decouple this from BaseStore? Maybe merge.
    class GenericObjectStore extends BaseStore {
      constructor(...args) {
        super(...args);
        this.objects = new Map();
      }
      get(id) {
        if (id == null) {
          return null;
        }
        return this.objects.get(String(id));
      }
      addObject(id, obj) {
        this.objects.set(String(id), obj);
      }
      clear() {
        this.objects.clear();
        this.dispatch("change", null, null);
      }
      getObjectIdForEvent(event) {
        return String(event.objectId || event.data.id);
      }
      getObjectForEvent(event) {
        let objectId = this.getObjectIdForEvent(event);
        return this.get(objectId);
      }
      all(asIterable) {
        let values = this.objects.values();
        if (!asIterable) {
          values = Array.from(values);
        }
        return values;
      }
      find(callback) {
        return this.all().find(callback);
      }
      filter(callback) {
        return this.all().filter(callback);
      }

      // TODO Stores should have configurable indexes from FK ids, for quick filtering
      filterBy(filter) {
        const entries = Object.entries(filter); // Some minimal caching

        return this.filter(obj => {
          for (const [key, value] of entries) {
            const objectValue = obj[key];
            // Can match by array (any value) or otherwise exact match
            if (Array.isArray(value)) {
              if (!value.includes(objectValue)) {
                return false;
              }
            } else {
              if (objectValue != value) {
                return false;
              }
            }
          }
          return true;
        });
      }
      findBy(filter) {
        // TODO - need a better implementation with rapid termination
        return this.filterBy(filter)[0];
      }
      toJSON() {
        return this.all().map(entry => entry.toJSON());
      }
      applyCreateOrUpdateEvent(event, sendDispatch = true) {
        let obj = this.getObjectForEvent(event);
        if (obj) {
          obj.applyEventAndDispatch(event);
        } else {
          obj = new this.ObjectClass(event.data, event, this);
          obj.setStore(this);
          this.addObject(this.getObjectIdForEvent(event), obj);
          if (sendDispatch) {
            this.dispatch("create", obj, event);
          }
        }
        if (sendDispatch) {
          this.dispatchChange(obj, event);
        }
        return obj;
      }
      applyDeleteEvent(event) {
        const obj = this.getObjectForEvent(event);
        if (obj) {
          this.objects.delete(this.getObjectIdForEvent(event));
          obj.dispatch("delete", event, obj);
          this.dispatch("delete", obj, event);
          this.dispatch("change", obj, event);
        }
        return obj;
      }
      applyEvent(event) {
        event.data = event.data || {};
        if (event.type === "create" || event.type === "createOrUpdate") {
          return this.applyCreateOrUpdateEvent(event);
        }
        if (event.type === "delete") {
          return this.applyDeleteEvent(event);
        }

        // We're in the general case
        const obj = this.getObjectForEvent(event);
        if (!obj) {
          console.error("Missing object of type ", this.objectType, " ", event.objectId);
          return null;
        }
        obj.applyEventAndDispatch(event);
        this.dispatch("change", obj, event); // TODO this is not a store event, but how can we still register for all of these?

        return obj;
      }
      importState(objects = []) {
        for (const obj of objects) {
          this.create(obj);
        }
      }
      makeEventFromObject(obj, eventExtra = null) {
        return {
          isFake: true,
          type: "create",
          objectType: this.objectType,
          objectId: obj.id,
          data: obj,
          ...eventExtra
        };
      }

      // Create a fake creation event, to insert the raw object
      create(obj, eventExtra = null, dispatchEvent = true) {
        if (!obj) {
          return;
        }
        const event = this.makeEventFromObject(obj, eventExtra);
        return this.applyCreateOrUpdateEvent(event, dispatchEvent);
      }

      // Add a listener on all object creation events
      // If fakeExisting, will also pass existing objects to your callback
      addCreateListener(callback, fakeExisting) {
        if (fakeExisting) {
          for (const obj of this.objects.values()) {
            const event = this.makeEventFromObject(obj);
            callback(obj, event);
          }
        }
        return this.addListener("create", callback);
      }

      // Add a listener for any object deletions
      addDeleteListener(callback) {
        return this.addListener("delete", callback);
      }
    }
    class SingletonStore extends BaseStore {
      constructor(objectType, options = {}) {
        super(objectType, SingletonStore, options);
        // Use the same logic as StoreObject when listening to events
        this.addEventListener = StoreObject.prototype.addEventListener.bind(this);
      }
      get() {
        return this;
      }
      all() {
        return [this];
      }
      toJSON() {
        return JSON.stringify([this]);
      }
      applyEvent(event) {
        Object.assign(this, event.data);
        this.dispatchChange(event);
      }
      importState(obj) {
        Object.assign(this, obj);
        this.dispatchChange(obj);
      }
    }
    const Store = (objectType, ObjectClass, options = {}) => class Store extends GenericObjectStore {
      constructor() {
        super(objectType, ObjectClass, options);
      }
    };
    function MakeStore(...args) {
      const Cls = Store(...args);
      return new Cls();
    }

    // A basic store that can be used to keep objects that map to ISO-code backed languages
    class LanguageObject extends StoreObject {
      constructor(obj) {
        super(obj);
        this.translationMap = new Map();
      }
      toString() {
        let name = this.name;
        if (this.localName && this.localName != this.name) {
          name += " (" + this.localName + ")";
        }
        return name;
      }
      buildTranslation(callback) {
        Language.dispatch("buildTranslationMap", this);
        callback(this.translationMap);
      }
    }
    class LanguageStoreClass extends GenericObjectStore {
      constructor() {
        super("Language", LanguageObject);
      }
      getLanguageForCode(isoCode) {
        for (let language of this.all()) {
          if (language.isoCode === isoCode) {
            return language;
          }
        }
      }
      setLocale(language) {
        if (this.Locale == language) {
          return;
        }
        this.Locale = language;
        this.dispatch("localeChange", language);
      }
      getLocale() {
        return this.Locale;
      }
    }
    var Language = new LanguageStoreClass();

    // TODO @cleanup merge with unwrapArray
    function toArray(objOrArray) {
      if (objOrArray == null) {
        return [];
      }
      return Array.isArray(objOrArray) ? objOrArray : [objOrArray];
    }
    function unwrapElementPlain(element) {
      if (element == null || element === false) {
        return undefined;
      }
      return element;
    }
    function unwrapElementWithFunc(element) {
      while (isFunction(element)) {
        element = element();
      }
      return unwrapElementPlain(element);
    }
    function unwrapArray(elements, unwrapFunc = unwrapElementPlain) {
      if (elements == null || elements === false) {
        return [];
      }
      if (!Array.isArray(elements)) {
        // Convert to an array
        if (elements[Symbol.iterator] && !isString(elements)) {
          elements = Array.from(elements);
        } else {
          elements = [elements];
        }
      }
      let result = [];
      for (const rawElement of elements) {
        if (rawElement == null) {
          continue;
        }
        const element = Array.isArray(rawElement) ? rawElement : unwrapFunc(rawElement); // First unwrap the element
        if (element == null) {
          continue;
        }
        if (Array.isArray(element)) {
          const subelements = unwrapArray(element, unwrapFunc);
          for (const subelement of subelements) {
            result.push(subelement);
          }
        } else {
          result.push(element);
        }
      }
      let sameAsInput = result.length === elements.length;
      for (let index = 0; sameAsInput && index < result.length; index += 1) {
        if (result[index] !== elements[index]) {
          sameAsInput = false;
        }
      }
      return sameAsInput ? elements : result;
    }
    function areSetsEqual(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const element of a) {
        if (!b.has(element)) {
          return false;
        }
      }
      return true;
    }
    function isLocalUrl(url, host = self.location.host, origin = self.location.origin) {
      // Empty url is considered local
      if (!url) {
        return true;
      }
      // Protocol-relative url is local if the host matches
      if (url.startsWith("//")) {
        return url.startsWith("//" + host);
      }
      // Absolute url is local if the origin matches
      let r = new RegExp("^(?:[a-z]+:)?//", "i");
      if (r.test(url)) {
        return url.startsWith(origin);
      }
      // Root-relative and document-relative urls are always local
      return true;
    }

    // Trims a local url to root-relative or document-relative url.
    // If the url is protocol-relative, removes the starting "//"+host, transforming it in a root-relative url.
    // If the url is absolute, removes the origin, transforming it in a root-relative url.
    // If the url is root-relative or document-relative, leaves it as is.
    function trimLocalUrl(url, host = self.location.host, origin = self.location.origin) {
      if (!isLocalUrl(url, host, origin)) {
        throw Error("Trying to trim non-local url!");
      }
      if (!url) {
        return url;
      }
      if (url.startsWith("//" + host)) {
        return url.slice(("//" + host).length);
      }
      if (url.startsWith(origin)) {
        return url.slice(origin.length);
      }
      return url;
    }

    // Split the passed in array into arrays with at most maxChunkSize elements
    function splitInChunks(array, maxChunkSize) {
      let chunks = [];
      while (array.length > 0) {
        chunks.push(array.splice(0, maxChunkSize));
      }
      return chunks;
    }
    function defaultComparator(a, b) {
      if (a == null && b == null) {
        return 0;
      }
      if (b == null) {
        return 1;
      }
      if (a == null) {
        return -1;
      }

      // TODO: might want to use valueof here
      if (isNumber(a) && isNumber(b)) {
        return a - b;
      }
      let aStr = a.toString();
      let bStr = b.toString();
      if (aStr === bStr) {
        return 0;
      }
      return aStr < bStr ? -1 : 1;
    }
    function slugify(string) {
      string = string.trim();
      string = string.replace(/[^a-zA-Z0-9-\s]/g, ""); // remove anything non-latin alphanumeric
      string = string.replace(/\s+/g, "-"); // replace whitespace with dashes
      string = string.replace(/-{2,}/g, "-"); // remove consecutive dashes
      string = string.toLowerCase();
      return string;
    }

    // If the first argument is a number, it's returned concatenated with the suffix, otherwise it's returned unchanged
    function suffixNumber(value, suffix) {
      return isNumber(value) ? value + suffix : value;
    }
    function capitalize(text) {
      return text && text.charAt(0).toUpperCase() + text.slice(1);
    }
    function setObjectPrototype(obj, Class) {
      obj.__proto__ = Class.prototype;
      return obj;
    }
    function isFunction(obj) {
      return typeof obj === "function";
    }
    function isNumber(obj) {
      return typeof obj === "number" || obj instanceof Number;
    }
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function isNumericString(str, acceptPadding = false) {
      if (!isString(str)) {
        return false;
      }
      if (!acceptPadding && str.trim() !== str) {
        return false;
      }
      // Both of these are needed to cover all cases
      return !isNaN(str) && !isNaN(parseFloat(str));
    }
    function isPlainObject(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (obj.constructor && obj.constructor != Object) {
        return false;
      }
      return true;
    }
    function FILTER_NULLS(key, value) {
      return value != null;
    }
    function FILTER_NULLS_AND_EMPTY_STR(key, value) {
      return value != null && value !== "";
    }
    function cleanObject(obj, {
      skipEmptyString = true,
      filterFunc = null,
      emptyAsNull = false
    } = {}) {
      const cleanObject = {};
      if (!filterFunc) {
        filterFunc = skipEmptyString ? FILTER_NULLS_AND_EMPTY_STR : FILTER_NULLS;
      }
      for (const [key, value] of Object.entries(obj)) {
        if (filterFunc(key, value)) {
          cleanObject[key] = value;
        }
      }
      if (emptyAsNull && Object.keys(cleanObject).length === 0) {
        return null;
      }
      return cleanObject;
    }
    function deepCopy() {
      let target = arguments[0] || {};
      // Handle case when target is a string or something (possible in deep copy)
      if (typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (let i = 1; i < arguments.length; i += 1) {
        let obj = arguments[i];
        if (obj == null) {
          continue;
        }

        // Extend the base object
        for (let [key, value] of Object.entries(obj)) {
          // Recurse if we're merging plain objects or arrays
          if (value && isPlainObject(value) || Array.isArray(value)) {
            let clone;
            let src = target[key];
            if (Array.isArray(value)) {
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject(src) ? src : {};
            }
            target[key] = deepCopy(clone, value);
          } else {
            // TODO: if value has .clone() method, use that?
            target[key] = value;
          }
        }
      }
      return target;
    }
    function dashCase(str) {
      let rez = "";
      for (let i = 0; i < str.length; i++) {
        if ("A" <= str[i] && str[i] <= "Z") {
          if (i > 0) {
            rez += "-";
          }
          rez += str[i].toLowerCase();
        } else {
          rez += str[i];
        }
      }
      return rez == str ? str : rez;
    }

    // TODO: have a Cookie helper file
    function getCookie(name) {
      let cookies = (document.cookie || "").split(";");
      for (let cookie of cookies) {
        cookie = cookie.trim();
        if (cookie.startsWith(name + "=")) {
          return cookie.substring(name.length + 1);
        }
      }
      return "";
    }
    function uniqueId(obj) {
      if (!uniqueId.objectWeakMap) {
        uniqueId.objectWeakMap = new WeakMap();
        uniqueId.constructorWeakMap = new WeakMap();
        uniqueId.totalObjectCount = 0;
      }
      let objectWeakMap = uniqueId.objectWeakMap;
      let constructorWeakMap = uniqueId.constructorWeakMap;
      if (!objectWeakMap.has(obj)) {
        const objConstructor = obj.constructor || obj.__proto__ || Object;
        // Increment the object count
        const objIndex = (constructorWeakMap.get(objConstructor) || 0) + 1;
        constructorWeakMap.set(objConstructor, objIndex);
        const objUniqueId = objIndex + "-" + ++uniqueId.totalObjectCount;
        objectWeakMap.set(obj, objUniqueId);
      }
      return objectWeakMap.get(obj);
    }

    // args[0] is a string where the "%[number]" block will be replaced by the args[number]
    function evaluateSprintf(...args) {
      let str = args[0];
      for (let index = 1; index < args.length; index += 1) {
        str = str.replaceAll("%" + index, args[index]);
      }
      return str;
    }

    // TODO: should be done with String.padLeft
    function padNumber(num, minLength) {
      let strNum = String(num);
      while (strNum.length < minLength) {
        strNum = "0" + strNum;
      }
      return strNum;
    }

    // Returns the english ordinal suffix of a number
    function getOrdinalSuffix(num) {
      let suffixes = ["th", "st", "nd", "rd"];
      let lastDigit = num % 10;
      let isTeen = Math.floor(num / 10) % 10 === 1;
      return !isTeen && suffixes[lastDigit] || suffixes[0];
    }
    function suffixWithOrdinal(num) {
      return num + getOrdinalSuffix(num);
    }

    // Erase the first instance of the value from the given array. In-place, returns the array
    function eraseFirst(array, value) {
      const index = array.indexOf(value);
      if (index >= 0) {
        array.splice(index, 1);
      }
      return array;
    }
    const UNICODE_BOM_CHARACTER = 0xFEFF;
    const NOOP_FUNCTION = () => undefined;

    // Used so that a value or a function can be used anywhere
    // If the value is a function, it will call it at most maxIter (default 32) times
    function resolveFuncValue(value, {
      maxIter = 32,
      args = null,
      allowUnresolved = false
    } = {}) {
      while (maxIter > 0 && isFunction(value)) {
        value = value(...args);
        maxIter -= 1;
      }
      if (!allowUnresolved && maxIter === 0) {
        console.error("Failed to resolve value to a non-function");
      }
      return value;
    }
    class CallModifier {
      wrap(func) {
        throw Error("Implement wrap method");
      }
      call(func) {
        return this.wrap(func)();
      }
      toFunction() {
        return func => this.wrap(func);
      }
    }

    /*
    CallThrottler acts both as a throttler and a debouncer, allowing you to combine both types of functionality.
    Available options:
        - debounce (ms): delays the function call by x ms, each call extending the delay
        - throttle (ms): keeps calls from happening with at most x ms between them. If debounce is also set, will make sure to
        fire a debounced even if over x ms have passed. If equal to CallTimer.ON_ANIMATION_FRAME, means that we want to use
        requestAnimationFrame instead of setTimeout, to execute before next frame redraw()
        - dropThrottled (boolean, default false): any throttled function call is not delayed, but dropped
     */
    class CallThrottler extends CallModifier {
      constructor(options = {}) {
        super();
        this.lastCallTime = 0;
        this.pendingCall = null;
        this.pendingCallArgs = [];
        this.pendingCallExpectedTime = 0;
        this.numCalls = 0;
        this.totalCallDuration = 0;
        Object.assign(this, options);
      }
      isThrottleOnAnimationFrame() {
        return this.throttle === this.constructor.ON_ANIMATION_FRAME;
      }
      clearPendingCall() {
        this.pendingCall = null;
        this.pendingCallArgs = [];
        this.pendingCallExpectedTime = 0;
      }
      cancel() {
        this.pendingCall && this.pendingCall.cancel();
        this.clearPendingCall();
      }
      flush() {
        this.pendingCall && this.pendingCall.flush();
        this.clearPendingCall();
      }

      // API compatibility with cleanup jobs
      cleanup() {
        this.cancel();
      }
      computeExecutionDelay(timeNow) {
        let executionDelay = null;
        if (this.throttle != null) {
          executionDelay = Math.max(this.lastCallTime + this.throttle - timeNow, 0);
        }
        if (this.debounce != null) {
          executionDelay = Math.min(executionDelay != null ? executionDelay : this.debounce, this.debounce);
        }
        return executionDelay;
      }
      replacePendingCall(wrappedFunc, funcCall, funcCallArgs) {
        this.cancel();
        if (this.isThrottleOnAnimationFrame()) {
          const cancelHandler = requestAnimationFrame(funcCall);
          wrappedFunc.cancel = () => cancelAnimationFrame(cancelHandler);
          return;
        }
        const timeNow = Date.now();
        let executionDelay = this.computeExecutionDelay(timeNow);
        if (this.dropThrottled) {
          return executionDelay == 0 && funcCall();
        }
        const cancelHandler = setTimeout(funcCall, executionDelay);
        wrappedFunc.cancel = () => clearTimeout(cancelHandler);
        this.pendingCall = wrappedFunc;
        this.pendingCallArgs = funcCallArgs;
        this.pendingCallExpectedTime = timeNow + executionDelay;
      }
      updatePendingCall(args) {
        this.pendingCallArgs = args;
        if (!this.isThrottleOnAnimationFrame()) {
          const timeNow = Date.now();
          this.pendingCallExpectedTime = timeNow + this.computeExecutionDelay(timeNow);
        }
      }
      wrap(func) {
        const funcCall = () => {
          const timeNow = Date.now();
          // The expected time when the function should be executed next might have been changed
          // Check if that's the case, while allowing a 1ms error for time measurement
          if (!this.isThrottleOnAnimationFrame() && timeNow + 1 < this.pendingCallExpectedTime) {
            this.replacePendingCall(wrappedFunc, funcCall, this.pendingCallArgs);
          } else {
            this.lastCallTime = timeNow;
            this.clearPendingCall();
            func(...this.pendingCallArgs);
          }
        };
        const wrappedFunc = (...args) => {
          // Check if it's our function, and update the arguments and next execution time only
          if (this.pendingCall && func === this.pendingCall.originalFunc) {
            // We only need to update the arguments, and maybe mark that we want to executed later than scheduled
            // It's an optimization to not invoke too many setTimeout/clearTimeout pairs
            return this.updatePendingCall(args);
          }
          return this.replacePendingCall(wrappedFunc, funcCall, args);
        };
        wrappedFunc.originalFunc = func;
        wrappedFunc.cancel = NOOP_FUNCTION;
        wrappedFunc.flush = () => {
          if (wrappedFunc === this.pendingCall) {
            this.cancel();
            wrappedFunc();
          }
        };
        return wrappedFunc;
      }
    }

    // export function benchmarkThrottle(options={}) {
    //     const startTime = performance.now();
    //     const calls = options.calls || 100000;
    //
    //     const throttler = new CallThrottler({throttle: options.throttle || 300, debounce: options.debounce || 100});
    //
    //     const func = options.func || NOOP_FUNCTION;
    //
    //     const wrappedFunc = throttler.wrap(func);
    //
    //     for (let i = 0; i < calls; i += 1) {
    //         wrappedFunc();
    //     }
    //     console.warn("Throttle benchmark:", performance.now() - startTime, "for", calls, "calls");
    // }
    CallThrottler.ON_ANIMATION_FRAME = Symbol();
    CallThrottler.AUTOMATIC = Symbol();

    const defaultToPixelsAttributes = new Set(["border-radius", "border-bottom-left-radius", "border-bottom-right-radius", "border-top-left-radius", "border-top-right-radius", "border-bottom-width", "border-left-width", "border-right-width", "border-top-width", "border-width", "bottom", "font-size", "font-stretch", "height", "layer-grid-char", "layer-grid-char-spacing", "layer-grid-line", "left", "letter-spacing", "line-height", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "max-height", "max-width", "min-height", "min-width", "outline-width", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "right", "size", "top", "width", "word-spacing", "gap"]);

    // Used to map from option key to a DOM attribute name.
    // Can recursively fall back to a base mapping, to allow extending of a parent class
    class DOMAttributesMap {
      constructor(fallbackMapping, allowedAttributesArray = [], allowedPrefixes = []) {
        this.allowedAttributesMap = new Map();
        this.reverseNameMap = new Map();
        this.fallbackMapping = fallbackMapping;
        for (let attribute of allowedAttributesArray) {
          if (!Array.isArray(attribute)) {
            attribute = [attribute];
          }
          this.setAttribute(attribute[0], attribute[1]);
        }
        this.allowedPrefixes = allowedPrefixes;
      }
      setAttribute(key, value) {
        value = value || {};
        value.domName = value.domName || key;
        this.allowedAttributesMap.set(key, value);
        this.reverseNameMap.set(value.domName, key);
      }
      get(key) {
        for (const prefix of this.allowedPrefixes) {
          if (key.startsWith(prefix)) {
            return {
              domName: key
            };
          }
        }
        let value = this.allowedAttributesMap.get(key);
        if (!value && this.fallbackMapping) {
          value = this.fallbackMapping.get(key);
        }
        return value;
      }
      has(key) {
        return this.allowedAttributesMap.has(key) || this.fallbackMapping && this.fallbackMapping.has(key);
      }
      getKeyFromDOMName(key) {
        let value = this.reverseNameMap.get(key);
        if (!value && this.fallbackMapping) {
          value = this.fallbackMapping.getKeyFromDOMName(key);
        }
        return value;
      }
    }

    // A class that can be used to work with a className field as with a Set, while having a toString() usable in the DOM
    // It's used when a UI object has a className attribute, that a string, but we still want it to be modified if we call addClass and removeClass
    // In that case, the string gets converted to a ClassNameSet
    class ClassNameSet extends Set {
      // Can't use classic super in constructor since Set is build-in type and will throw an error
      // TODO: see if could still be made to have this as constructor
      static create(className) {
        let value = new Set(String(className || "").split(" "));
        return setObjectPrototype(value, this);
      }
      toString() {
        return Array.from(this).join(" ");
      }
    }
    class NodeAttributes {
      constructor(obj) {
        Object.assign(this, obj);
        // className and style should be deep copied to be modifiable, the others shallow copied
        if (this.className instanceof ClassNameSet) {
          this.className = ClassNameSet.create(String(this.className));
        }
        if (isPlainObject(this.style)) {
          // Make a copy, since we might modify it later
          this.style = {
            ...this.style
          };
        }
      }

      // Change the attribute & apply it, regardless if it exists in the attribute map (in that case it's whitelisted)
      // TODO: should this use the domName or the reverseName? Still needs work
      setAttribute(key, value, node, attributesMap = this.constructor.defaultAttributesMap) {
        // TODO: might want to find a better way than whitelistAttributes field to do this
        if (!attributesMap.has(key)) {
          this.whitelistedAttributes = this.whitelistedAttributes || {}; // TODO: reconsider the whitelisted attributes
          this.whitelistedAttributes[key] = true;
        }
        this[key] = value;
        if (node) {
          this.applyAttribute(key, node, attributesMap);
        }
      }
      applyStyleToNode(key, value, node) {
        if (typeof value === "function") {
          value = value();
        }
        if (isNumber(value) && value != 0 && defaultToPixelsAttributes.has(dashCase(key))) {
          value = value + "px";
        }
        if (node && node.style[key] !== value) {
          node.style[key] = value;
        }
      }

      // Should the style property have been passed in as a string, save it to the variable that will be applied before the string object.
      ensureNoStringStyle() {
        if (isString(this.style)) {
          this.styleString = this.style; // Keep in a temp value
          delete this.style;
        }
      }
      setStyle(key, value, node) {
        value = resolveFuncValue(value);
        if (!isString(key)) {
          // If the key is not a string, it should be a plain object
          for (const styleKey of Object.keys(key)) {
            this.setStyle(styleKey, key[styleKey], node);
          }
          return;
        }
        if (value === undefined) {
          this.removeStyle(key, node);
          return;
        }
        this.ensureNoStringStyle();
        this.style = this.style || {};
        this.style[key] = value;
        this.applyStyleToNode(key, value, node);
      }
      removeStyle(key, node) {
        if (this.style) {
          delete this.style[key];
        }
        if (node && node.style[key]) {
          delete node.style[key];
        }
      }
      static getClassArray(classes) {
        if (!classes) {
          return [];
        }
        if (Array.isArray(classes)) {
          return classes.map(x => String(x).trim());
        } else {
          return String(classes).trim().split(" ");
        }
      }
      getClassNameSet() {
        if (!(this.className instanceof ClassNameSet)) {
          this.className = ClassNameSet.create(this.className || "");
        }
        return this.className;
      }
      addClass(classes, node) {
        classes = this.constructor.getClassArray(classes);
        for (let cls of classes) {
          this.getClassNameSet().add(cls);
          if (node) {
            node.classList.add(cls);
          }
        }
      }
      removeClass(classes, node) {
        classes = this.constructor.getClassArray(classes);
        for (let cls of classes) {
          this.getClassNameSet().delete(cls);
          if (node) {
            node.classList.remove(cls);
          }
        }
      }
      hasClass(className) {
        return this.getClassNameSet().has(isString(className) ? className : className.className);
      }

      // Apply the attribute only if it's in the attributesMap
      applyAttribute(key, node, attributesMap) {
        let attributeOptions = attributesMap.get(key);
        if (!attributeOptions) {
          if (this.whitelistedAttributes && key in this.whitelistedAttributes) {
            attributeOptions = {
              domName: key
            };
          } else {
            return;
          }
        }
        let value = this[key];
        if (typeof value === "function") {
          value = value();
        }
        if (attributeOptions.noValue) {
          if (value) {
            value = "";
          } else {
            value = undefined;
          }
        }
        if (typeof value !== "undefined") {
          node.setAttribute(attributeOptions.domName, value);
        } else {
          node.removeAttribute(attributeOptions.domName);
        }
      }
      applyClassName(node) {
        if (this.className) {
          const className = String(this.className);
          if (node.className != className) {
            node.className = className;
          }
        } else {
          if (node.className) {
            node.removeAttribute("class");
          }
        }
      }
      apply(node, attributesMap) {
        let addedAttributes = {};
        this.whitelistedAttributes || {};

        // First update existing node attributes and delete old ones
        // TODO: optimize to not run this if the node was freshly created
        let nodeAttributes = node.attributes;
        for (let i = nodeAttributes.length - 1; i >= 0; i--) {
          let attr = nodeAttributes[i];
          let attributeName = attr.name;
          if (attributeName === "style" || attributeName === "class") {
            // TODO: maybe should do work here?
            continue;
          }
          let key = attributesMap.getKeyFromDOMName(attributeName);
          if (this.hasOwnProperty(key)) {
            let value = this[key];
            let attributeOptions = attributesMap.get(key);
            if (attributeOptions && attributeOptions.noValue) {
              if (value) {
                value = "";
              } else {
                value = undefined;
              }
            }
            if (value != null) {
              node.setAttribute(attributeName, value);
              addedAttributes[key] = true;
            } else {
              node.removeAttribute(attributeName);
            }
          } else {
            node.removeAttribute(attributeName);
          }
        }
        // Add new attributes
        for (let key in this) {
          if (addedAttributes[key]) {
            continue;
          }
          this.applyAttribute(key, node, attributesMap);
        }
        this.applyClassName(node);
        node.removeAttribute("style");
        this.ensureNoStringStyle();
        if (this.styleString) {
          node.style = this.styleString;
        }
        if (this.style) {
          for (const key of Object.keys(this.style)) {
            this.applyStyleToNode(key, this.style[key], node);
          }
        }
      }
    }

    // Default node attributes, should be as few of these as possible
    NodeAttributes.defaultAttributesMap = new DOMAttributesMap(null, [["id"], ["action"], ["checked", {
      noValue: true
    }], ["colspan"], ["default"], ["disabled", {
      noValue: true
    }], ["fixed"], ["forAttr", {
      domName: "for"
    }],
    // TODO: have a consistent nomenclature for there!
    ["hidden"], ["href"], ["rel"], ["minHeight"], ["minWidth"], ["role"], ["target"], ["domTitle", {
      domName: "title"
    }],
    // TODO titleAttr?
    ["type"], ["placeholder"], ["src"], ["alt"], ["height"], ["width"], ["tabIndex"], ["data"]
    //["value"], // Value is intentionally disabled
    ], ["data-", "aria-"]);

    function applyDebugFlags(element) {
      if (self.STEM_DEBUG) {
        element.node.stemElement = element;
      }
    }

    class ThemeType {
      constructor(type, value, options) {
        options = options || {};
        if (isString(options)) {
          options = {
            comment: options
          };
        }
        this.type = type;
        this.value = value;
        this.options = options;
      }
    }

    // TODO this should also have a validator here for instance
    function MakeThemeType(type) {
      return (value, options = {}) => new ThemeType(type, value, options);
    }
    const FloatType = MakeThemeType("Float");

    var _Theme;
    class Theme extends Dispatchable {
      // TODO @cleanup CallThrottler syntax is really ugly

      constructor(baseTheme, name, props) {
        super();
        this.classSet = new Set();
        this.styleSheetInstances = new Map();
        // map from StyleSheet class to instance
        this.updateThrottled = new CallThrottler({
          throttle: 50
        }).wrap(() => this.updateStyleSheets());
        this.name = name;
        this.baseTheme = baseTheme;
        this.properties = {
          theme: this,
          ...props
        };
        this.propTypes = {};
        this.props = new Proxy(this.properties, {
          get: (properties, key, receiver) => {
            const rawValue = this.getProperty(key);
            const value = resolveFuncValue(rawValue, {
              args: [this.props]
            });
            if (self.STEM_DEBUG && value === undefined) {
              console.warn("Failed to find theme prop", key);
            }
            return value;
          },
          set: (properties, key, value) => {
            this.setProperties({
              [key]: value
            });
            // TODO this should also update all themes that inherit from us
            return true;
          }
        });
        this.styleSheetSymbol = Symbol(this.name + "StyleSheet");
        window.addEventListener("resize", () => this.updateThrottled());
      }

      // Create a new Theme, based on the current one
      fork(name, extraProps) {
        return new Theme(this, name, extraProps);
      }
      register(cls, styleSheet) {
        cls.theme = this;
        cls[this.styleSheetSymbol] = styleSheet;
        this.classSet.add(cls);
      }
      getStyleSheet(cls) {
        return cls[this.styleSheetSymbol] || this.baseTheme?.getStyleSheet(cls);
      }
      getProperty(key) {
        if (this.properties.hasOwnProperty(key)) {
          // Return nulls as well
          return this.properties[key];
        }
        return this.baseTheme?.getProperty(key);
      }
      setProperties(properties, update = true) {
        for (const [key, value] of Object.entries(properties)) {
          if (value instanceof ThemeType) {
            this.properties[key] = value.value;
            this.propTypes[key] = value;
          } else {
            this.properties[key] = value;
          }
        }
        if (update) {
          this.updateThrottled();
        }
      }
      getAllStyleSheets() {
        let styleSheetSet = new Set(this.styleSheetInstances.values());
        for (const cls of this.classSet.values()) {
          styleSheetSet.add(this.getStyleSheet(cls));
        }
        return Array.from(styleSheetSet).map(styleSheet => styleSheet.getInstance(this));
      }
      getStyleSheetInstance(Cls) {
        let instance = this.styleSheetInstances.get(Cls);
        if (!instance) {
          instance = new Cls({
            theme: this
          });
          this.styleSheetInstances.set(Cls, instance);
        }
        return instance;
      }
      updateStyleSheets() {
        this.dispatch("beforeUpdateStyleSheets");
        for (const styleSheet of this.getAllStyleSheets()) {
          styleSheet.update();
        }
        this.dispatch("afterUpdateStyleSheets");
      }
      static register(cls, styleSheet) {
        return this.Global.register(...arguments);
      }
      static setProperties(properties) {
        this.Global.setProperties(...arguments);
      }
      static get props() {
        return this.Global.props;
      }
    }
    _Theme = Theme;
    Theme.Global = new _Theme(null, "Global");
    function registerStyle(styleClass, theme = Theme.Global) {
      return target => theme.register(target, styleClass);
    }

    const RenderStack = []; //keeps track of objects that are redrawing, to know where to assign refs automatically
    const redrawPerTickRunner = new OncePerTickRunner((obj, event) => obj.node && obj.redraw(event));

    // TODO Maybe get rid of the UI namespace
    const UI$1 = {};
    function cleanChildren(children) {
      return unwrapArray(children, unwrapElementWithFunc);
    }
    class BaseUIElement extends Dispatchable {
      canOverwrite(existingChild) {
        return this.constructor === existingChild.constructor && this.getNodeType() === existingChild.getNodeType();
      }
      applyRef() {
        if (this.options?.ref) {
          let obj = this.options.ref.parent;
          let name = this.options.ref.name ?? this.options.ref.key; // TODO: should be key
          obj[name] = this;
        }

        // We do this here since this is done on every redraw, and we just needed a way to hook into all redraw
        this.cancelEnqueuedRedraw();
      }
      removeRef() {
        if (this.options?.ref) {
          let obj = this.options.ref.parent;
          let name = this.options.ref.name;
          if (obj[name] === this) {
            obj[name] = undefined;
          }
        }
      }

      // Calls a queueMicrotask(() => this.redraw()), but only if one isn't already enqueued
      // The enqueued task will be canceled if a redraw is manually called in the meantime
      enqueueRedraw(event) {
        redrawPerTickRunner.maybeEnqueue(this, event);
      }
      cancelEnqueuedRedraw() {
        redrawPerTickRunner.clear(this);
      }

      // Lifecycle methods, called when the element was first inserted in the DOM, and before it's removed
      onMount() {}
      onUnmount() {}
      destroyNode() {
        this.dispatch("unmount", this);
        this.onUnmount();
        this.cleanup();
        this.removeRef();
        this.node?.remove();
        delete this.node; // Clear for gc
      }
    }
    UI$1.TextElement = class UITextElement extends BaseUIElement {
      constructor(value = "") {
        super();
        if (value && value.hasOwnProperty("value") && isPlainObject(value)) {
          this.value = value.value;
          this.options = value;
        } else {
          this.value = value ?? "";
        }
      }
      mount(parent, nextSibling) {
        this.parent = parent;
        if (!this.node) {
          this.createNode();
          this.applyRef();
        } else {
          this.redraw();
        }
        parent.node.insertBefore(this.node, nextSibling);
        this.onMount();
      }
      getNodeType() {
        return Node.TEXT_NODE;
      }
      copyState(element) {
        this.value = element.value;
        this.options = element.options;
      }
      createNode() {
        this.node = document.createTextNode(this.getValue());
        applyDebugFlags(this);
        return this.node;
      }
      setValue(value) {
        this.value = value != null ? value : "";
        if (this.node) {
          this.redraw();
        }
      }
      getValue() {
        return String(this.value);
      }
      toString() {
        return this.getValue();
      }
      redraw() {
        if (this.node) {
          let newValue = this.getValue();
          // TODO: check if this is best for performance
          if (this.node.nodeValue !== newValue) {
            this.node.nodeValue = newValue;
          }
        }
        this.applyRef();
      }
    };

    // TODO: rename to Element
    class UIElement extends BaseUIElement {
      constructor(options = {}) {
        super();
        this.children = []; // These are the rendered children
        this.options = options; // TODO: this is a hack, to not break all the code that references this.options in setOptions
        this.state = this.getDefaultState(); // TODO @cleanup implement a simpler state pattern, that allows custom state types
        this.setOptions(options); // TODO maybe this actually needs to be removed, since on a copy we don't want the default options of the other object
      }
      getDefaultOptions(options) {}

      // Return our options without the UI specific fields, so they can be passed along
      getCleanedOptions() {
        let options = {
          ...this.options
        };
        delete options.ref;
        delete options.children;
        delete options.key;
        delete options.nodeType;
        return options;
      }
      getDefaultState() {
        return {};
      }
      getPreservedOptions() {}
      setOptions(options) {
        let defaultOptions = this.getDefaultOptions(options);
        if (defaultOptions) {
          options = Object.assign(defaultOptions, options);
        }
        this.options = options;
      }

      // TODO: should probably add a second arg, doRedraw=true - same for setOptions
      updateOptions(options) {
        this.setOptions(Object.assign(this.options, options));
        // TODO: if the old options and the new options are deep equal, we can skip this redraw, right?
        this.redraw();
      }
      setChildren(...args) {
        this.updateOptions({
          children: cleanChildren(args)
        });
      }

      // Used when we want to reuse the current element, with the options from the passed in argument
      // Is only called when element.canOverwrite(this) is true
      copyState(element) {
        let options = element.options;
        let preservedOptions = this.getPreservedOptions();
        if (preservedOptions) {
          options = Object.assign({}, options, preservedOptions);
        }
        this.setOptions(options);
        this.addListenersFromOptions();
      }
      getNodeType() {
        return this.options.nodeType || "div";
      }
      static create(parentNode, options) {
        const uiElement = new this(options);
        uiElement.mount(parentNode, null);
        uiElement.dispatch("mount", uiElement);
        return uiElement;
      }

      // TODO: should be renamed to renderContent
      getGivenChildren() {
        return this.options.children || [];
      }
      render() {
        return this.options.children;
      }
      createNode() {
        this.node = document.createElement(this.getNodeType());
        applyDebugFlags(this);
        return this.node;
      }

      // Abstract, gets called when removing DOM node associated with the
      cleanup() {
        this.runCleanupJobs();
        for (const child of this.children) {
          child.destroyNode();
        }
        this.clearNode();
        super.cleanup();
      }
      overwriteChild(existingChild, newChild) {
        existingChild.copyState(newChild);
        return existingChild;
      }
      getElementKeyMap(elements) {
        if (!elements || !elements.length) {
          return;
        }
        let childrenKeyMap = new Map();
        for (let i = 0; i < elements.length; i += 1) {
          let childKey = elements[i].options && elements[i].options.key || "autokey" + i;
          childrenKeyMap.set(childKey, elements[i]);
        }
        return childrenKeyMap;
      }
      getChildrenToRender() {
        return this.render();
      }
      getExtraContext() {
        const {
          theme
        } = this.options;
        if (theme) {
          return {
            theme
          };
        }
        return null; // cleanObject({theme}, {emptyAsNull: true});
      }
      updateContext(context = this.parent?.context) {
        const extraContext = this.getExtraContext();
        this.context = extraContext ? {
          ...context,
          ...extraContext
        } : context;
      }
      getChildrenForRedraw() {
        RenderStack.push(this);
        let children = cleanChildren(this.getChildrenToRender());
        RenderStack.pop();
        return children;
      }
      redraw() {
        if (!this.node) {
          console.error("Element not yet mounted. Redraw aborted!", this);
          return false;
        }
        this.updateContext();
        let newChildren = this.getChildrenForRedraw();
        if (newChildren === this.children) {
          for (const child of newChildren) {
            child.redraw();
          }
          this.applyNodeAttributes();
          this.applyRef();
          return true;
        }
        let domNode = this.node;
        let childrenKeyMap = this.getElementKeyMap(this.children);
        for (let i = 0; i < newChildren.length; i++) {
          let newChild = newChildren[i];
          let prevChildNode = i > 0 ? newChildren[i - 1].node : null;
          let currentChildNode = prevChildNode ? prevChildNode.nextSibling : domNode.firstChild;

          // Not a UIElement, to be converted to a TextElement probably
          if (!newChild.getNodeType) {
            if (newChild.toUI) {
              newChild = newChild.toUI(this); // TODO move this inside the unwrap logic
            } else {
              newChild = new UI$1.TextElement({
                value: String(newChild)
              });
            }
            newChildren[i] = newChild;
          }
          let newChildKey = newChild.options?.key || "autokey" + i;
          let existingChild = childrenKeyMap && childrenKeyMap.get(newChildKey);
          if (existingChild && newChildren[i].canOverwrite(existingChild)) {
            // We're replacing an existing child element, it might be the very same object
            if (existingChild !== newChildren[i]) {
              newChildren[i] = this.overwriteChild(existingChild, newChildren[i]);
            }
            newChildren[i].redraw();
            if (newChildren[i].node !== currentChildNode) {
              domNode.insertBefore(newChildren[i].node, currentChildNode);
            }
          } else {
            // Getting here means we are not replacing anything, should just render
            newChild.mount(this, currentChildNode);
          }
        }
        if (this.children.length) {
          // Remove children that don't need to be here
          let newChildrenSet = new Set(newChildren);
          for (const currentChild of this.children) {
            if (!newChildrenSet.has(currentChild)) {
              currentChild.destroyNode();
            }
          }
        }
        this.children = newChildren;

        // TODO this end logic is duplicated
        this.applyNodeAttributes();
        this.applyRef();
        return true;
      }

      // TODO This is actually slightly wrong, since we need to reuse the attr object we previously created
      getOptionsAsNodeAttributes() {
        return setObjectPrototype(this.options, NodeAttributes);
      }
      instantiateNodeAttributes() {
        return new NodeAttributes(this.options);
      }
      getNodeAttributes() {
        const attr = this.instantiateNodeAttributes();
        // Add the default class "container" from our style sheet (if there is one)
        const containerClassName = this.styleSheet?.container;
        if (containerClassName) {
          attr.addClass(containerClassName);
        }
        return attr;
      }
      extraNodeAttributes(attr) {}
      applyNodeAttributes() {
        const attr = this.getNodeAttributes();
        this.extraNodeAttributes(attr);
        attr.apply(this.node, this.constructor.domAttributesMap);
      }
      setAttribute(key, value) {
        this.getOptionsAsNodeAttributes().setAttribute(key, value, this.node, this.constructor.domAttributesMap);
      }
      setStyle(key, value) {
        if (typeof key === "object") {
          for (const [styleKey, styleValue] of Array.from(Object.entries(key))) {
            this.setStyle(styleKey, styleValue);
          }
          return;
        }
        this.getOptionsAsNodeAttributes().setStyle(key, value, this.node);
      }
      removeStyle(key) {
        this.getOptionsAsNodeAttributes().removeStyle(key, this.node);
      }
      addClass(className) {
        this.getOptionsAsNodeAttributes().addClass(className, this.node);
      }
      removeClass(className) {
        this.getOptionsAsNodeAttributes().removeClass(className, this.node);
      }
      hasClass(className) {
        return this.getOptionsAsNodeAttributes().hasClass(className);
      }
      toggleClass(className) {
        if (!this.hasClass(className)) {
          this.addClass(className);
        } else {
          this.removeClass(className);
        }
      }
      getTheme() {
        return this.options.theme || this.context?.theme || Theme.Global;
      }
      get styleSheet() {
        let {
          styleSheet
        } = this.options;
        const theme = this.getTheme();
        if (!styleSheet) {
          styleSheet = theme.getStyleSheet(this.constructor);
        }
        return styleSheet?.getInstance(theme);
      }
      get themeProps() {
        return this.options.styleSheet?.themeProps || this.getTheme().props;
      }
      addListenersFromOptions() {
        for (const key in this.options) {
          if (typeof key === "string" && key.startsWith("on") && key.length > 2) {
            const eventType = key.substring(2);
            const addListenerMethodName = "add" + eventType + "Listener";
            const handlerMethodName = "on" + eventType + "Handler";

            // The handlerMethod might have been previously added
            // by a previous call to this function or manually by the user
            if (typeof this[addListenerMethodName] === "function" && !this.hasOwnProperty(handlerMethodName)) {
              this[handlerMethodName] = (...args) => {
                if (this.options[key]) {
                  this.options[key](...args, this);
                }
              };

              // Actually add the listener
              this[addListenerMethodName](this[handlerMethodName]);
            }
          }
        }
      }
      refLink(name) {
        return {
          parent: this,
          name: name
        };
      }
      refLinkArray(arrayName, index) {
        if (!this[arrayName]) {
          this[arrayName] = [];
        }
        return {
          parent: this[arrayName],
          name: index
        };
      }
      bindToNode(node, doRedraw) {
        this.node = node;
        if (doRedraw) {
          this.clearNode();
          this.redraw();
        }
        return this;
      }
      mount(parent, nextSiblingNode) {
        if (!parent.node) {
          parent = new UI$1.Element().bindToNode(parent);
        }
        this.parent = parent;
        if (this.node) {
          parent.insertChildNodeBefore(this, nextSiblingNode);
          this.dispatch("changeParent", this.parent);
          return;
        }
        this.createNode();
        this.redraw();
        parent.insertChildNodeBefore(this, nextSiblingNode);
        this.addListenersFromOptions();
        this.onMount();
      }

      // You need to overwrite the next child manipulation routines if this.options.children !== this.children
      appendChild(child) {
        // TODO: the next check should be done with a decorator
        if (this.children !== this.options.children) {
          throw "Can't properly handle appendChild, you need to implement it for " + this.constructor;
        }
        this.options.children.push(child);
        child.mount(this, null);
        return child;
      }
      insertChild(child, position) {
        if (this.children !== this.options.children) {
          throw "Can't properly handle insertChild, you need to implement it for " + this.constructor;
        }
        position = position || 0;
        this.options.children.splice(position, 0, child);
        const nextChildNode = position + 1 < this.options.children.length ? this.children[position + 1].node : null;
        child.mount(this, nextChildNode);
        return child;
      }
      eraseChild(child, destroy = true) {
        let index = this.options.children.indexOf(child);
        if (index < 0) {
          // child not found
          return null;
        }
        return this.eraseChildAtIndex(index, destroy);
      }
      eraseChildAtIndex(index, destroy = true) {
        if (index < 0 || index >= this.options.children.length) {
          console.error("Erasing child at invalid index ", index, this.options.children.length);
          return;
        }
        if (this.children !== this.options.children) {
          throw "Can't properly handle eraseChild, you need to implement it for " + this.constructor;
        }
        let erasedChild = this.options.children.splice(index, 1)[0];
        if (destroy) {
          erasedChild.destroyNode();
        } else {
          this.node.removeChild(erasedChild.node);
        }
        return erasedChild;
      }
      show() {
        this.removeClass("hidden");
      }
      hide() {
        this.addClass("hidden");
      }
      insertChildNodeBefore(childElement, nextSiblingNode) {
        this.node.insertBefore(childElement.node, nextSiblingNode);
      }

      // TODO: should be renamed emptyNode()
      clearNode() {
        while (this.node && this.node.lastChild) {
          this.node.removeChild(this.node.lastChild);
        }
      }
      isInDocument() {
        return document.body.contains(this.node);
      }

      // TODO: this method also doesn't belong here
      getWidthOrHeight(parameter) {
        let node = this.node;
        if (!node) {
          return 0;
        }
        let value = parseFloat(parameter === "width" ? node.offsetWidth : node.offsetHeight);
        return value || 0;
      }
      getHeight() {
        return this.getWidthOrHeight("height");
      }
      getWidth() {
        return this.getWidthOrHeight("width");
      }
      setHeight(value) {
        this.setStyle("height", suffixNumber(value, "px"));
        this.dispatch("resize");
      }
      setWidth(value) {
        this.setStyle("width", suffixNumber(value, "px"));
        this.dispatch("resize");
      }
      addNodeListener(name, callback, ...args) {
        this.node.addEventListener(name, callback, ...args);
        const handler = {
          remove: () => {
            this.removeNodeListener(name, callback, ...args);
          }
        };
        this.addCleanupJob(handler);
        return handler;
      }
      removeNodeListener(name, callback) {
        this.node.removeEventListener(name, callback);
      }

      // TODO: methods can be automatically generated by addNodeListener(UI.Element, "dblclick", "DoubleClick") for instance
      addClickListener(callback) {
        return this.addNodeListener("click", callback);
      }
      removeClickListener(callback) {
        this.removeNodeListener("click", callback);
      }
      addDoubleClickListener(callback) {
        return this.addNodeListener("dblclick", callback);
      }
      removeDoubleClickListener(callback) {
        this.removeNodeListener("dblclick", callback);
      }
    }
    UI$1.createElement = function (tag, options, ...children) {
      if (!tag) {
        console.error("Create element needs a valid object tag, did you mistype a class name?");
        return;
      }
      options = options || {};
      options.children = cleanChildren(children);
      if (options.ref) {
        if (typeof options.ref === "string") {
          if (RenderStack.length > 0) {
            options.ref = {
              parent: RenderStack[RenderStack.length - 1],
              name: options.ref
            };
          } else {
            throw Error("Failed to automatically link ref, there needs to be an element in the rendering stack");
          }
        }
        if (options.key) {
          console.error("Warning! UI Element cannot have both a key and a ref fieldname. Key will be overriden.\n" + "Are you using the options from another object? Shame!", options);
        }
        options.key = "_ref" + options.ref.name;
      }
      if (options.hasOwnProperty("class")) {
        console.error("Invalid UI Element attribute: class. Did you mean className?");
      }
      if (typeof tag === "string") {
        options.nodeType = tag;
        tag = UIElement;
      }
      return new tag(options);
    };
    UIElement.domAttributesMap = NodeAttributes.defaultAttributesMap;
    UI$1.Element = UIElement;
    UI$1.str = value => new UI$1.TextElement(value);

    // Keep a map for every base class, and for each base class keep a map for each nodeType, to cache classes
    let primitiveMap = new WeakMap();
    UI$1.Primitive = (BaseClass, nodeType) => {
      if (!nodeType) {
        nodeType = BaseClass;
        BaseClass = UI$1.Element;
      }
      let baseClassPrimitiveMap = primitiveMap.get(BaseClass);
      if (!baseClassPrimitiveMap) {
        baseClassPrimitiveMap = new Map();
        primitiveMap.set(BaseClass, baseClassPrimitiveMap);
      }
      let resultClass = baseClassPrimitiveMap.get(nodeType);
      if (resultClass) {
        return resultClass;
      }
      resultClass = class Primitive extends BaseClass {
        getNodeType() {
          return nodeType;
        }
      };
      baseClassPrimitiveMap.set(nodeType, resultClass);
      return resultClass;
    };

    // This is the object that will be used to translate text
    let translationMap = null;

    // Keep a set of all UI Element that need to be updated when the language changes
    // Can't use a weak set here unfortunately because we need iteration
    // That's why we must make sure to remove all nodes from the set when destroying them
    UI$1.TranslationElements = new Set();

    // TODO These Polyfills shouldn't live here
    if (!String.prototype.replaceAll) {
      String.prototype.replaceAll = function (pattern, replacement) {
        if (isString(pattern)) {
          pattern = new RegExp(pattern, "g");
        }
        if (this?.replace) {
          return this.replace(pattern, replacement);
        }
        return this;
      };
    }
    if (!document.startViewTransition) {
      document.startViewTransition = callback => callback();
    }
    UI$1.TranslationTextElement = class TranslationTextElement extends UI$1.TextElement {
      constructor(value) {
        if (arguments.length === 1) {
          super(value);
        } else {
          super("");
          this.setValue(...arguments);
        }
      }
      setValue(value) {
        if (arguments.length > 1) {
          this.value = Array.from(arguments);
        } else {
          this.value = value;
        }
        if (this.node) {
          this.redraw();
        }
      }
      evaluate(strings, ...values) {
        if (!Array.isArray(strings)) {
          strings = translationMap?.get(strings) || strings;
          return evaluateSprintf(strings, ...values);
          // This means strings is a string with the sprintf pattern
        } else {
          // Using template literals https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals
          if (arguments.length !== strings.length) {
            console.error("Invalid arguments to evaluate ", Array.from(arguments));
          }
          let result = strings[0];
          for (let i = 1; i < arguments.length; i++) {
            result += arguments[i];
            result += strings[i];
          }
          return result;
        }
      }
      getValue() {
        let value = this.value;
        if (Array.isArray(this.value)) {
          value = this.evaluate(...value);
        } else {
          value = (translationMap && translationMap.get(value)) ?? value;
        }
        return value;
      }
      toString() {
        return this.getValue();
      }
      redraw() {
        if (!this.node) {
          this.node = this.createNode();
        }
        super.redraw();
      }
      onMount() {
        UI$1.TranslationElements.add(this);
      }
      onUnmount() {
        UI$1.TranslationElements.delete(this);
      }
    };

    // This method is a shorthand notation to create a new translatable text element
    // TODO: should also support being used as a string template
    UI$1.T = str => {
      return new UI$1.TranslationTextElement(str);
    };

    // TODO @mciucu this should be wrapped in a way that previous requests that arrive later don't get processed
    // TODO: should this be done with promises?
    // Function to be called with a translation map
    // The translationMap object needs to implement .get(value) to return the translation for value
    function setTranslationMap(_translationMap) {
      if (translationMap === _translationMap) {
        return;
      }
      translationMap = _translationMap;
      for (let textElement of UI$1.TranslationElements.values()) {
        textElement.redraw();
      }
    }
    let languageStore = null;

    // This function should be called to set the language store to watch for changes
    // The languageStore argumenent needs to implement .getLocale(), addListener("localChange", (language) =>{})
    // The language objects need to implement .buildTranslation(callback), where callback should be called with a translationMap
    function setLanguageStore(_languageStore) {
      languageStore = _languageStore;
      let currentLocale = languageStore.getLocale();
      // If there's a default language already set, build the translation table for it
      if (currentLocale) {
        currentLocale.buildTranslation(setTranslationMap);
      }

      // Add a listener for whenever the language changes
      languageStore.addListener("localeChange", language => {
        language.buildTranslation(setTranslationMap);
      });
    }

    class TranslationKey extends StoreObject {}
    const TranslationKeyStore = new GenericObjectStore("TranslationKey", TranslationKey);
    class TranslationEntry extends StoreObject {
      getLanguage() {
        return Language.get(this.languageId);
      }
      getTranslationKey() {
        return TranslationKeyStore.get(this.translationKeyId);
      }
    }
    const TranslationEntryStore = new GenericObjectStore("TranslationEntry", TranslationEntry);
    Language.addListener("buildTranslationMap", language => {
      for (let translationEntry of TranslationEntryStore.all()) {
        if (translationEntry.languageId === language.id) {
          language.translationMap.set(translationEntry.getTranslationKey().value, translationEntry.value);
        }
      }
    });

    // TODO @Mihai this was written originally in 2016, pretty old and crappy
    class WebsocketStreamHandler extends Dispatcher {
      constructor(websocketSubscriber, streamName, options = {}) {
        super();
        this.websocketSubscriber = websocketSubscriber;
        this.streamName = streamName;
        this.options = options;
        this.bytesReceived = 0;
        this.isIndexed = false;
        this.lastMessageIndex = -1;
        this.messageBuffer = new Map();
        this.missedPackets = 0;
        this.resetStatus();
      }
      sendSubscribe() {
        const websocketSubscriber = this.websocketSubscriber;
        this.clearResubscribeTimeout();
        this.status = this.constructor.SUBSCRIBING;
        if (this.isIndexed) {
          websocketSubscriber.sendResubscribe(this.streamName, this.getLastIndex());
        } else {
          websocketSubscriber.sendSubscribe(this.streamName);
        }
        this.subscribeTryCount++;
        const timeoutDuration = websocketSubscriber.calcRetryTimeout(this.subscribeTryCount);
        this.resendSubscribeTimeout = setTimeout(() => {
          console.log("WebsocketSubscriber: stream subscribe timeout for #" + this.streamName + " reached! Trying to resubscribe again!");
          this.sendSubscribe();
        }, timeoutDuration);
      }
      clearResubscribeTimeout() {
        if (this.resendSubscribeTimeout) {
          clearTimeout(this.resendSubscribeTimeout);
          this.resendSubscribeTimeout = undefined;
        }
      }
      setStatusSubscribed() {
        this.clearResubscribeTimeout();
        this.status = this.constructor.SUBSCRIBED;
      }
      resetStatus() {
        this.clearResubscribeTimeout();
        this.status = this.constructor.NONE;
        this.subscribeTryCount = 0;
      }
      processPacket(packet) {
        this.bytesReceived += packet.length;
        let type, payload;
        if (packet[0] === "{") {
          type = "v";
          payload = packet;
        } else {
          let firstSpace = packet.indexOf(" ");
          if (firstSpace > 0) {
            type = packet.substr(0, firstSpace).trim();
            payload = packet.substr(firstSpace + 1).trim();
          } else {
            console.error("WebsocketStreamHandler: Could not process stream packet: " + packet);
            return;
          }
        }
        if (type === "i") {
          this.processIndexedPacket(payload);
        } else if (type === "v") {
          this.processVanillaPacket(payload);
        } else {
          console.error("WebsocketStreamHandler: invalid packet type " + type);
        }
      }
      processIndexedMessage(index, message) {
        this.isIndexed = true;
        if (this.lastMessageIndex === -1) {
          this.lastMessageIndex = index;
          this.processVanillaPacket(message);
        } else if (this.lastMessageIndex + 1 === index) {
          this.lastMessageIndex = index;
          this.processVanillaPacket(message);
          ++index;
          while (this.messageBuffer.has(index)) {
            message = this.messageBuffer.get(index);
            this.messageBuffer.delete(index);
            this.lastMessageIndex = index;
            this.processVanillaPacket(message);
            ++index;
          }
        } else {
          this.messageBuffer.set(index, message);
        }
      }
      processMissedPacket(packet) {
        this.processIndexedMessage(parseInt(packet), WebsocketStreamHandler.MISSING_MESSAGE);
      }
      processVanillaPacket(packet) {
        if (packet == WebsocketStreamHandler.MISSING_MESSAGE) {
          this.missedPackets++;
        }
        if (!this.options.rawMessage) {
          try {
            packet = JSON.parse(packet);
          } catch (exception) {
            if (!this.options.parseMayFail) {
              console.error("WebsocketStreamHandler: Failed to parse ", packet, " on stream ", this.streamName, " Exception:", exception.message);
              return;
            }
          }
        }
        this.dispatch(packet);
      }
      processIndexedPacket(packet) {
        let firstSpace = packet.indexOf(" ");
        let message, index;
        if (firstSpace > 0) {
          index = parseInt(packet.substr(0, firstSpace).trim());
          message = packet.substr(firstSpace + 1).trim();
        } else {
          console.error("WebsocketStreamHandler: Could not process indexed stream packet: " + packet);
          return;
        }
        this.processIndexedMessage(index, message);
      }
      haveIndex() {
        return this.isIndexed;
      }
      getLastIndex() {
        return this.lastMessageIndex;
      }
    }
    WebsocketStreamHandler.NONE = Symbol();
    WebsocketStreamHandler.SUBSCRIBING = Symbol();
    WebsocketStreamHandler.SUBSCRIBED = Symbol();
    WebsocketStreamHandler.UNSUBSCRIBED = Symbol();
    WebsocketStreamHandler.MISSING_MESSAGE = "INVALID_MESSAGE_MISSING_FROM_ROLLING_WINDOW";

    const DEFAULT_HEARTBEAT_MESSAGE = "-heartbeat-city-";

    var _WebsocketSubscriber;
    function splitPayload(str) {
      const delimitedIndex = str.indexOf(" ");
      if (delimitedIndex <= 0) {
        return [str, null];
      }
      return [str.substring(0, delimitedIndex), str.substring(delimitedIndex + 1).trim()];
    }

    // TODO cleanup & simplify
    class WebsocketSubscriber extends Dispatchable {
      constructor(urls) {
        super();
        this.streamHandlers = new Map();
        this.attemptedConnect = false;
        this.connectionStatus = WebsocketSubscriber.ConnectionStatus.NONE;
        this.websocket = null;
        this.failedReconnectAttempts = 0;
        this.numConnectionAttempts = 0;
        this.retryDefaultTimeout = 3000;
        this.retryMaxTimeout = 30000;
        this.heartbeatMessage = DEFAULT_HEARTBEAT_MESSAGE;
        this.urls = toArray(urls);
        //TODO: should probably try to connect right now?
      }
      setConnectionStatus(connectionStatus) {
        this.connectionStatus = connectionStatus;
        this.dispatch("connectionStatus", connectionStatus);
      }
      getNextUrl() {
        const currentURLIndex = this.numConnectionAttempts++ % this.urls.length;
        return this.urls[currentURLIndex];
      }
      connect() {
        const url = this.getNextUrl();
        this.setConnectionStatus(WebsocketSubscriber.ConnectionStatus.CONNECTING);
        try {
          console.log("WebsocketSubscriber: Connecting to " + url + " ...");
          this.websocket = new WebSocket(url);
          this.websocket.onopen = () => this.onWebsocketOpen();
          this.websocket.onmessage = event => this.onWebsocketMessage(event);
          this.websocket.onerror = event => this.onWebsocketError(event);
          this.websocket.onclose = event => this.onWebsocketClose(event);
        } catch (e) {
          this.tryReconnect();
          console.error("WebsocketSubscriber: Failed to connect to ", url, "\nError: ", e.message);
        }
      }
      calcRetryTimeout(numFailedAttempts) {
        return Math.min(this.retryDefaultTimeout * numFailedAttempts, this.retryMaxTimeout);
      }
      tryReconnect() {
        const reconnectWait = this.calcRetryTimeout(this.failedReconnectAttempts);
        this.failedReconnectAttempts++;
        if (!this.reconnectTimeout) {
          this.reconnectTimeout = setTimeout(() => {
            this.reconnectTimeout = null;
            console.log("WebsocketSubscriber: Trying to reconnect websocket connection");
            this.connect();
          }, reconnectWait);
        }
      }
      subscribe(streamName) {
        // TODO: make sure to not explicitly support streams with spaces in the name
        console.log("WebsocketSubscriber: Subscribing to stream ", streamName);
        if (!this.attemptedConnect) {
          this.connect();
          this.attemptedConnect = true;
        }
        if (this.streamHandlers.has(streamName)) {
          console.warning("WebsocketSubscriber: Already subscribed to stream ", streamName);
          return;
        }
        let streamHandler = new WebsocketStreamHandler(this, streamName);
        this.streamHandlers.set(streamName, streamHandler);

        // Check if the websocket connection is open, to see if we can send the subscription now
        if (this.isOpen()) {
          this.sendSubscribe(streamName);
        }
        return streamHandler;
      }
      isOpen() {
        return this.websocket?.readyState === 1;
      }
      sendSubscribe(streamName) {
        if (this.isOpen()) {
          this.send("s " + streamName);
        }
      }
      sendResubscribe(streamName, index) {
        if (this.isOpen(streamName)) {
          this.send("r " + index + " " + streamName);
        }
      }
      resubscribe() {
        // Iterate over all streams and resubscribe to them
        for (let streamHandler of this.streamHandlers.values()) {
          streamHandler.sendSubscribe();
        }
      }
      onStreamSubscribe(streamName) {
        const streamHandler = this.getStreamHandler(streamName);
        if (!streamHandler) {
          console.error("WebsocketSubscriber: received subscribe success response for unrequested stream ", streamName);
          return;
        }
        console.log("WebsocketSubscriber: Successfully subscribed to stream", streamName);
        streamHandler.setStatusSubscribed();
      }
      onWebsocketOpen() {
        this.previousFailedReconnectAttempts = this.failedReconnectAttempts;
        this.failedReconnectAttempts = 0;
        console.log("WebsocketSubscriber: Websocket connection established!");
        this.reset();
        this.setConnectionStatus(WebsocketSubscriber.ConnectionStatus.CONNECTED);
        this.resubscribe();
      }
      handleMessageWithoutListeners(streamName, message) {
        console.error("No handler for websocket stream", streamName);
      }
      handleServerError(payload) {
        console.error("Websocket error:", payload);
        const [errorType, details] = splitPayload(payload);
        if (errorType === "invalidSubscription") {
          // Stop trying to resubscribe to a stream that's been rejected by the server
          const streamName = details;
          const streamHandler = this.getStreamHandler(streamName);
          if (streamHandler) {
            // TODO: set permission denied explicitly?
            streamHandler.clearResubscribeTimeout();
          }
        }
      }
      handleStreamMessage(payload) {
        const [streamName, message] = splitPayload(payload);
        if (message == null) {
          console.error("Could not process stream packet", payload);
          return;
        }
        const streamHandler = this.streamHandlers.get(streamName);
        if (!streamHandler) {
          this.handleMessageWithoutListeners(streamName, message);
          return;
        }
        streamHandler.processPacket(message);
      }
      handleServerClose(payload) {
        this.failedReconnectAttempts = this.previousFailedReconnectAttempts;
        console.error("WebsocketSubscriber: server fatal error close: ", payload);
        this.onWebsocketError(payload);
      }
      onWebsocketMessage(event) {
        const {
          data
        } = event;
        if (data === this.heartbeatMessage) {
          // TODO: keep track of the last heartbeat timestamp
          return;
        }
        const [type, payload] = splitPayload(data);
        if (type === "e" || type === "error") {
          // error
          this.handleServerError(payload);
        } else if (type === "s") {
          // subscribed
          this.onStreamSubscribe(payload);
        } else if (type === "m") {
          // stream message
          this.handleStreamMessage(payload);
        } else if (type === "c") {
          // command
          this.dispatch("serverCommand", payload);
        } else if (type == "close") {
          this.handleServerClose(payload);
        } else {
          console.error("WebsocketSubscriber: Can't process " + event.data);
        }
      }
      reset() {
        this.setConnectionStatus(WebsocketSubscriber.ConnectionStatus.DISCONNECTED);
        for (const streamHandler of this.streamHandlers.values()) {
          streamHandler.resetStatus();
        }
      }
      onWebsocketError(event) {
        console.error("WebsocketSubscriber: Websocket connection is broken!");
        this.reset();
        this.tryReconnect();
      }
      onWebsocketClose(event) {
        console.log("WebsocketSubscriber: Connection closed!");
        this.reset();
        this.tryReconnect();
      }
      send(message) {
        // TODO: if the websocket is not open, enqueue WebsocketSubscriber message to be sent on open or just fail?
        this.websocket.send(message);
      }
      getStreamHandler(streamName) {
        let streamHandler = this.streamHandlers.get(streamName);
        if (!streamHandler) {
          streamHandler = this.subscribe(streamName);
        }
        return streamHandler;
      }

      // this should be pretty much the only external function
      addStreamListener(streamName, callback) {
        let streamHandler = this.getStreamHandler(streamName);
        if (streamHandler.callbackExists(callback)) {
          return;
        }
        streamHandler.addListener(callback);
      }
      removeStreamListener(streamName, callback) {
        let streamHandler = this.streamHandlers.get(streamName);
        if (streamHandler) {
          streamHandler.removeListener(callback);
        }
      }
      static addListener(streamName, callback) {
        return this.Global.addStreamListener(streamName, callback);
      }
    }
    _WebsocketSubscriber = WebsocketSubscriber;
    WebsocketSubscriber.ConnectionStatus = {
      NONE: 0,
      CONNECTING: 1,
      CONNECTED: 2,
      DISCONNECTED: 3
    };
    // TODO sync globally cleaner
    WebsocketSubscriber.Global = self.WEBSOCKET_URL ? new _WebsocketSubscriber(self.WEBSOCKET_URL) : null;

    // Tries to be a more flexible implementation of fetch()
    // Still work in progress


    // Parse the headers from an xhr object, to return a native Headers object
    function parseHeaders(xhr) {
      const rawHeader = xhr.getAllResponseHeaders() || "";
      const rawHeaderLines = rawHeader.split(/\r?\n/);
      let headers = new Headers();
      for (let line of rawHeaderLines) {
        let parts = line.split(":");
        let key = parts.shift().trim();
        if (key) {
          let value = parts.join(":").trim();
          headers.append(key, value);
        }
      }
      return headers;
    }

    // Creates a new URLSearchParams object from a plain object
    // Fields that are arrays are spread
    function getURLSearchParams(data, arrayKeySuffix = "[]") {
      if (!isPlainObject(data)) {
        return data;
      }
      let urlSearchParams = new URLSearchParams();
      for (const key of Object.keys(data)) {
        let value = data[key];
        if (Array.isArray(value)) {
          for (let instance of value) {
            urlSearchParams.append(key + arrayKeySuffix, instance);
          }
        } else {
          urlSearchParams.set(key, value);
        }
      }
      return urlSearchParams;
    }

    // Appends search parameters from an object to a given URL or Request, and returns the new URL
    function composeURL(url, urlSearchParams) {
      if (url.url) {
        url = url.url;
      }
      // TODO: also extract the preexisting arguments in the url
      if (urlSearchParams) {
        url += "?" + urlSearchParams;
      }
      return url;
    }
    class XHRPromise {
      constructor(request, options = {}) {
        request = new Request(request, options);
        let xhr = new XMLHttpRequest();
        this.options = options;
        this.request = request;
        this.xhr = xhr;
        this.promise = new Promise((resolve, reject) => {
          this.promiseResolve = resolve;
          this.promiseReject = reject;
          xhr.onload = () => {
            let headers = this.getResponseHeaders();
            let body = xhr.response || xhr.responseText;
            let responseInit = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: headers,
              url: xhr.responseURL || headers.get("X-Request-URL")
            };
            let response = new Response(body, responseInit);
            // In case dataType is "arrayBuffer", "blob", "formData", "json", "text"
            // Response has methods to return these as promises
            if (typeof response[options.dataType] === "function") {
              response = response[options.dataType]();
              // TODO: should whitelist dataType to json, blob
              response.then(data => {
                this.resolve(data);
              }, err => {
                this.reject(err);
              });
            } else {
              this.resolve(response);
            }
          };

          // TODO: also dispatch all arguments here on errors
          xhr.onerror = () => {
            this.reject(new TypeError("Network error"));
          };

          // TODO: need to have an options to pass setting to xhr (like timeout value)
          xhr.ontimeout = () => {
            this.reject(new TypeError("Network timeout"));
          };
          xhr.open(request.method, request.url, true);
          const {
            onUploadProgress,
            onDownloadProgress
          } = this.options;
          if (onUploadProgress) {
            xhr.upload.onprogress = onUploadProgress;
          }
          if (onDownloadProgress) {
            xhr.onprogress = onDownloadProgress;
          }
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          }

          // TODO: come back to this
          xhr.responseType = "blob";
          let isApplicationTypeJson = false;
          request.headers.forEach((value, name) => {
            if (options.body instanceof FormData && name.toLowerCase() === "content-type") {
              return;
            }
            // check if the request in JSON object based on headers
            if (value === "application/json" && name.toLowerCase() === "content-type") {
              isApplicationTypeJson = true;
            }
            xhr.setRequestHeader(name, value);
          });
          // TODO: there's no need to send anything on a GET or HEAD
          if (options.body instanceof FormData) {
            this.send(options.body);
          } else if (isApplicationTypeJson) {
            // if the request has a JSON body, convert object body to JSON and sent it.
            this.send(JSON.stringify(options.body));
          } else {
            request.blob().then(blob => {
              // The blob can be a FormData when we're polyfilling the Request class
              const body = blob instanceof FormData || blob.size ? blob : null;
              this.send(body);
            });
          }
        });
      }
      getResponseHeaders() {
        return parseHeaders(this.xhr);
      }
      send(body) {
        this.getXHR().send(body);
      }
      getPostprocessors() {
        return this.options.postprocessors || fetch.defaultPostprocessors;
      }
      getErrorPostprocessors() {
        return this.options.errorPostprocessors || fetch.defaultErrorPostprocessors;
      }
      resolve(payload) {
        for (const postprocessor of this.getPostprocessors()) {
          try {
            payload = postprocessor(payload, this) || payload;
          } catch (exception) {
            this.reject(exception);
            return;
          }
        }
        if (this.options.onSuccess) {
          this.options.onSuccess(...arguments);
        } else {
          this.promiseResolve(...arguments);
        }
        if (this.options.onComplete) {
          this.options.onComplete();
        }
      }
      reject(error) {
        for (const postprocessor of this.getErrorPostprocessors()) {
          error = postprocessor(error) || error;
        }
        if (this.options.onError) {
          this.options.onError(...arguments);
        } else {
          if (this._chained) {
            this.promiseReject(...arguments);
          } else {
            if (this.options.errorHandler) {
              this.options.errorHandler(...arguments);
            } else {
              console.error("Unhandled fetch error", ...arguments);
            }
          }
        }
        if (this.options.onComplete) {
          this.options.onComplete();
        }
      }

      // TODO: next 2 functions should throw an exception if you have onSuccess/onError
      then(onResolve, onReject) {
        this._chained = true;
        onReject = onReject || this.options.errorHandler;
        return this.getPromise().then(onResolve, onReject);
      }
      catch() {
        this._chained = true;
        return this.getPromise().catch(...arguments);
      }
      getXHR() {
        return this.xhr;
      }
      getPromise() {
        return this.promise;
      }
      getRequest() {
        return this.request;
      }
      abort() {
        this.getXHR().abort();
      }
      addXHRListener(name, callback) {
        this.getXHR().addEventListener(...arguments);
      }
      addProgressListener(callback) {
        this.addXHRListener("progress", ...arguments);
      }
    }

    // TODO: this offers only partial compatibility with $.ajax, remove
    function jQueryCompatibilityPreprocessor(options) {
      if (options.type) {
        options.method = options.type.toUpperCase();
      }
      if (options.contentType) {
        options.headers.set("Content-Type", options.contentType);
      }
      options.headers.set("X-Requested-With", "XMLHttpRequest");
      if (isPlainObject(options.data)) {
        let method = options.method.toUpperCase();
        if (method === "GET" || method === "HEAD") {
          options.urlParams = options.urlParams || options.data;
          if (options.cache === false) {
            options.urlParams = getURLSearchParams(options.urlParams, options.arraySearchParamSuffix);
            options.urlParams.set("_", Date.now());
          }
        } else {
          let formData = new FormData();
          for (const key of Object.keys(options.data)) {
            const value = options.data[key];
            if (Array.isArray(value)) {
              for (const arrayValue of value) {
                formData.append(key + "[]", arrayValue);
              }
            } else {
              formData.append(key, value);
            }
          }
          options.body = formData;
        }
      } else {
        options.body = options.body || options.data;
      }
      return options;
    }
    // Can either be called with
    // - 1 argument: (Request)
    // - 2 arguments: (url/Request, options)
    function fetch(input, ...args) {
      // In case we're being passed in a single plain object (not Request), assume it has a url field
      if (isPlainObject(input)) {
        return fetch(input.url, ...arguments);
      }
      let options = Object.assign({}, ...args);

      // Ensure that there's a .headers field for preprocessors
      options.headers = new Headers(options.headers || {});
      const preprocessors = options.preprocessors || fetch.defaultPreprocessors || [];
      for (const preprocessor of preprocessors) {
        options = preprocessor(options, input) || options;
      }
      options.onSuccess = options.onSuccess || options.success;
      options.onError = options.onError || options.error;
      options.onComplete = options.onComplete || options.complete;
      if (typeof options.cache === "boolean") {
        options.cache = options.cache ? "force-cache" : "reload";
        // TODO: cache still isn't fully done
      }
      options.method = options.method || "GET";
      // If there are any url search parameters, update the url from the urlParams or urlSearchParams fields
      // These fields can be plain objects (jQuery style) or can be URLSearchParams objects
      const urlParams = options.urlParams || options.urlSearchParams;
      if (urlParams) {
        // Change the URL of the request to add a query
        const urlSearchParams = getURLSearchParams(urlParams, options.arraySearchParamSuffix);
        if (input instanceof Request) {
          input = new Request(composeURL(input.url, urlSearchParams), input);
        } else {
          input = new Request(composeURL(input, urlSearchParams), {});
        }
      }
      return new XHRPromise(input, options);
    }
    fetch.defaultPreprocessors = [];
    fetch.defaultPostprocessors = [];
    fetch.defaultErrorPostprocessors = [];
    fetch.polyfill = true;

    class AjaxHandler {
      constructor(ajaxHandler, errorHandler = null) {
        if (this.constructor._baseAjax === null) {
          this.constructor._baseAjax = this;
        } else if (arguments.length === 0) {
          ajaxHandler = this.constructor._baseAjax;
        }
        this.parentHandler = ajaxHandler;
        this.preprocessors = ajaxHandler ? [] : Array.from(fetch.defaultPreprocessors);
        this.postprocessors = ajaxHandler ? [] : Array.from(fetch.defaultPostprocessors);
        this.errorPostprocessors = ajaxHandler ? [] : Array.from(fetch.defaultErrorPostprocessors);
        this.errorHandler = errorHandler;
      }
      fetch(request, ...args) {
        if (!request) {
          console.error("Missing request for fetch");
          return;
        }
        let baseOptions = {
          preprocessors: this.getPreprocessors(),
          postprocessors: this.getPostprocessors(),
          errorPostprocessors: this.getErrorPostprocessors(),
          errorHandler: this.getErrorHandler()
        };

        // Request may be a plain object or a url, not going to duplicate code from fetch
        for (const key of Object.keys(baseOptions)) {
          if (request[key]) {
            delete baseOptions[key];
          }
        }
        return fetch(request, baseOptions, ...args);
      }
      request() {
        return this.fetch(...arguments);
      }

      // Feel free to modify the post and get methods for your needs
      get(url, options) {
        return this.fetch(...arguments, {
          method: "GET"
        });
      }
      getJSON(url, data, ...args) {
        return this.get(url, {
          dataType: "json",
          data: data
        }, ...args);
      }
      post(url, options) {
        return this.fetch(...arguments, {
          method: "POST"
        });
      }
      postJSON(url, data, ...args) {
        return this.post(url, {
          dataType: "json",
          data: data
        }, ...args);
      }
      addPreprocessor(preprocessor) {
        this.preprocessors.push(preprocessor);
      }
      getPreprocessors() {
        const inherited = this.parentHandler && this.parentHandler.getPreprocessors() || [];
        return [...this.preprocessors, ...inherited];
      }
      addPostprocessor(postprocessor) {
        this.postprocessors.push(postprocessor);
      }
      getPostprocessors() {
        const inherited = this.parentHandler && this.parentHandler.getPostprocessors() || [];
        return [...inherited, ...this.postprocessors];
      }
      addErrorPostprocessor(postprocessor) {
        this.errorPostprocessors.push(postprocessor);
      }
      getErrorPostprocessors() {
        const inherited = this.parentHandler && this.parentHandler.getErrorPostprocessors() || [];
        return [...inherited, ...this.errorPostprocessors];
      }
      getErrorHandler() {
        return this.errorHandler || this.parentHandler && this.parentHandler.getErrorHandler();
      }
    }
    AjaxHandler._baseAjax = null;
    class FixedURLAjaxHandler extends AjaxHandler {
      constructor(url, ajaxHandler = Ajax, errorHandler = null) {
        super(ajaxHandler, errorHandler);
        this.url = url;
      }
      get(options) {
        return super.get(this.url, ...arguments);
      }
      getJSON(data) {
        return super.getJSON(this.url, data);
      }
      post(options) {
        return super.post(this.url, ...arguments);
      }
      postJSON(data) {
        return super.postJSON(this.url, data);
      }
    }
    const Ajax = new AjaxHandler();

    // TODO: this file should be called StoreExtenders

    // TODO This should be an async method
    const AjaxFetchMixin = BaseStoreClass => class AjaxFetchMixin extends BaseStoreClass {
      fetch(id, successCallback, errorCallback, forceFetch = false) {
        if (!forceFetch) {
          let obj = this.get(id);
          if (obj) {
            successCallback(obj);
            return;
          }
        }
        if (!this.fetchJobs) {
          this.fetchJobs = [];
        }
        this.fetchJobs.push({
          id: id,
          success: successCallback,
          error: errorCallback
        });
        if (!this.fetchTimeout) {
          this.fetchTimeout = setTimeout(() => {
            this.executeAjaxFetch();
          }, this.fetchTimeoutDuration);
        }
      }
      getFetchRequestData(ids, fetchJobs) {
        return {
          ids: ids
        };
      }
      getFetchRequestObject(ids, fetchJobs) {
        let requestData = this.getFetchRequestData(ids, fetchJobs);

        // TODO: options.fetchURL should also support a function(ids, fetchJobs), do it when needed
        return {
          url: this.fetchURL,
          type: this.fetchType || "GET",
          dataType: "json",
          data: requestData,
          cache: false,
          success: data => {
            GlobalState$1.load(data);
            for (let fetchJob of fetchJobs) {
              let obj = this.get(fetchJob.id);
              if (obj) {
                fetchJob.success(obj);
              } else {
                console.error("Failed to fetch object ", fetchJob.id, " of type ", this.objectType);
                if (fetchJob.error) {
                  fetchJob.error();
                }
              }
            }
          },
          error: error => {
            console.error("Failed to fetch objects of type ", this.objectType, ":\n", error);
            for (let fetchJob of fetchJobs) {
              if (fetchJob.error) {
                fetchJob.error(error);
              }
            }
          }
        };
      }

      //returns an array of ajax requests that have to be executed
      getFetchRequests(fetchJobs) {
        let idFetchJobs = new Map();
        for (let fetchJob of fetchJobs) {
          let objectId = fetchJob.id;
          if (!idFetchJobs.has(objectId)) {
            idFetchJobs.set(objectId, new Array());
          }
          idFetchJobs.get(objectId).push(fetchJob);
        }
        let maxChunkSize = this.maxFetchObjectCount || 256;
        let idChunks = splitInChunks(Array.from(idFetchJobs.keys()), maxChunkSize);
        let fetchJobsChunks = splitInChunks(Array.from(idFetchJobs.values()), maxChunkSize);
        let requests = [];
        for (let i = 0; i < idChunks.length; i += 1) {
          requests.push(this.getFetchRequestObject(idChunks[i], unwrapArray(fetchJobsChunks[i])));
        }
        return requests;
      }
      executeAjaxFetch() {
        let fetchJobs = this.fetchJobs;
        this.fetchJobs = null;
        let requests = this.getFetchRequests(fetchJobs);
        for (let requestObject of requests) {
          Ajax.fetch(requestObject);
        }
        clearTimeout(this.fetchTimeout);
        this.fetchTimeout = null;
      }
    };
    const VirtualStoreObjectMixin = BaseStoreObjectClass => class VirtualStoreObjectMixin extends BaseStoreObjectClass {
      hasTemporaryId() {
        return (typeof this.id === "string" || this.id instanceof String) && this.id.startsWith("temp-");
      }

      // Meant for updating temporary objects that need to exist before being properly created
      updateId(newId) {
        if (this.id == newId) {
          return;
        }
        let oldId = this.id;
        if (!this.hasTemporaryId()) {
          console.error("This is only meant to replace temporary ids!");
        }
        this.id = newId;
        this.dispatch("updateId", {
          oldId: oldId
        });
      }
    };

    // TODO: there's still a bug in this class when not properly matching virtual obj sometimes I think
    const VirtualStoreMixin = BaseStoreClass => class VirtualStoreMixin extends BaseStoreClass {
      static generateVirtualId() {
        if (!this.virtualIdCounter) {
          this.virtualIdCounter = 0;
        }
        this.virtualIdCounter += 1;
        return this.virtualIdCounter;
      }
      generateVirtualId() {
        return this.constructor.generateVirtualId();
      }

      // TODO: we probably shouldn't have getVirtualObject take in an event
      getVirtualObject(event) {
        return this.objects.get("temp-" + event.virtualId);
      }
      applyUpdateObjectId(object, id) {
        if (object.id === id) {
          return;
        }
        let oldId = object.id;
        object.updateId(id);
        this.objects.delete(oldId);
        this.addObject(object.id, object);
        this.dispatch("updateObjectId", object, oldId);
      }
      applyCreateOrUpdateEvent(event, sendDispatch = true) {
        if (event.virtualId) {
          let existingVirtualObject = this.getVirtualObject(event);
          if (existingVirtualObject) {
            this.applyUpdateObjectId(existingVirtualObject, event.objectId);
          }
        }
        return super.applyCreateOrUpdateEvent(...arguments);
      }
    };

    class Country extends StoreObject {
      toString() {
        return this.name;
      }
      getIsoCode() {
        return this.isoCode;
      }
      getEmojiName() {
        return "flag_" + this.getIsoCode().toLowerCase();
      }
    }
    const ALL_COUNTRIES_PLACEHOLDER = name => ({
      id: 0,
      name: "",
      toString: () => name || "All Countries"
    });
    const NO_COUNTRY_PLACEHOLDER = name => ({
      id: -1,
      name: "",
      toString: () => name || "None"
    });
    const COUNTRY_COMPARATOR = (a, b) => {
      if (a.name > b.name) {
        return 1;
      }
      return -1;
    };
    class CountryStoreClass extends GenericObjectStore {
      allWithNone(noneName = "None") {
        return [NO_COUNTRY_PLACEHOLDER(noneName), ...this.all().sort(COUNTRY_COMPARATOR)];
      }
      getCountriesFromIds(countriesIds, allCountries = true) {
        let countries = [];
        for (let countryId of countriesIds) {
          countries.push(CountryStore.get(countryId));
        }
        let result = countries.sort(COUNTRY_COMPARATOR);
        if (allCountries) {
          result.unshift(ALL_COUNTRIES_PLACEHOLDER());
        }
        return result;
      }
    }
    const CountryStore = new CountryStoreClass("country", Country);

    class User extends StoreObject {
      constructor(obj) {
        super(obj);
        this.taskSummaries = new Map();
      }
      getName() {}
      getCustomSetting(key, defaultValue) {
        let keyChain = key.split(":");
        let currentDict = this.customSettings;
        for (let key of keyChain) {
          if (key in currentDict) {
            currentDict = currentDict[key];
          } else {
            return defaultValue;
          }
        }
        return currentDict;
      }
      getParsedCustomSetting(key, defaultValue) {
        return JSON.parse(this.getCustomSetting(key, defaultValue));
      }
      setCustomSetting(key, value) {
        let keyChain = key.split(":");
        let lastKey = keyChain.pop();
        if (!this.customSettings) {
          this.customSettings = {};
        }
        let currentDict = this.customSettings;
        for (let key of keyChain) {
          if (!(key in currentDict)) {
            currentDict[key] = {};
          }
          currentDict = currentDict[key];
        }
        currentDict[lastKey] = value;
        let event = {
          key: key,
          rawValue: value,
          origin: "set"
        };
        try {
          event.value = JSON.parse(value);
        } catch (e) {
          event.value = value;
        }
        this.dispatch("updateCustomSetting", event);
      }
      saveCustomSetting(key, value) {
        if (this.id != USER.id) {
          console.error("Invalid user");
          return;
        }
        this.dispatch("updateCustomSetting", {
          key: key,
          value: value,
          origin: "save"
        });
        let request = {
          customSettingsKey: key,
          customSettingsValue: value
        };
        if (!this.timeouts) {
          this.timeouts = new Map();
        }
        if (this.timeouts.has(key)) {
          clearTimeout(this.timeouts.get(key));
        }
        this.timeouts.set(key, setTimeout(() => {
          Ajax.postJSON("/accounts/profile_changed/", request).then(() => {}, () => {});
        }));
      }
      applyEvent(event) {
        if (event.type === "setCustomSetting") {
          console.log("Updated custom settings: ", event);
          this.setCustomSetting(event["data"].key, event["data"].value);
        } else {
          super.applyEvent(event);
        }
      }
      getCodeFontSize() {
        return this.getParsedCustomSetting("workspace:codeFontSize", 14);
      }
      getFileFontSize() {
        return this.getParsedCustomSetting("workspace:fileFontSize", 14);
      }
      getTabSize() {
        return this.getParsedCustomSetting("workspace:tabSize", 4);
      }
      getShowLineNumber() {
        return this.getParsedCustomSetting("workspace:showLineNumber", true);
      }
      getShowPrintMargin() {
        return this.getParsedCustomSetting("workspace:showPrintMargin", false);
      }
      getPrintMarginSize() {
        return this.getParsedCustomSetting("workspace:printMarginSize", 80);
      }
      getBasicAutocompletionStatus() {
        return this.getParsedCustomSetting("workspace:enableBasicAutocompletion", true);
      }
      getLiveAutocompletionStatus() {
        return this.getParsedCustomSetting("workspace:enableLiveAutocompletion", true);
      }
      getSnippetsStatus() {
        return this.getParsedCustomSetting("workspace:enableSnippets", false);
      }
      getShowTagsInArchive(archiveId) {
        return this.getParsedCustomSetting("archive:showTags-" + archiveId, false);
      }
    }
    class UserStoreClass extends GenericObjectStore {
      constructor() {
        super("user", User);
      }
      getCurrentUser() {
        return USER;
      }
    }
    const UserStore = new UserStoreClass();
    class PublicUser extends StoreObject {
      getDisplayHandle() {
        let name;
        if (this.displayName) {
          name = this.name || this.username;
        } else {
          name = this.username || this.name;
        }
        return name || "user-" + this.id;
      }
      getProfileUrl() {
        if (this.username) {
          return "/user/" + this.username;
        } else {
          return "/userid/" + this.id;
        }
      }
      getRating() {
        return this.rating;
      }
      getCountry() {
        return CountryStore.get(this.countryId);
      }
    }
    class PublicUserStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      constructor() {
        super("publicuser", PublicUser, {
          fetchTimeoutDuration: 20,
          maxFetchObjectCount: 512,
          fetchURL: "/accounts/public_user_profiles/"
        });
      }
      getCountries() {
        let countryIds = new Set();
        const users = this.all();
        for (let user of users) {
          if (user && user.countryId && !countryIds.has(user.countryId)) {
            countryIds.add(user.countryId);
          }
        }
        return CountryStore.getCountriesFromIds(countryIds);
      }
    }
    const PublicUserStore = new PublicUserStoreClass();
    window.USER = Object.assign({
      id: 0,
      customSettings: {}
    }, window.USER || {});
    window.USER = UserStore.create(window.USER);
    class UserNotification extends StoreObject {
      getUser() {
        return UserStore.get(this.userId);
      }
      isRead() {
        return this.id <= this.getUser().lastReadNotificationId;
      }
    }
    const UserNotificationStore = new GenericObjectStore("UserNotification", UserNotification, {
      dependencies: ["user"]
    });

    class Tag extends StoreObject {
      toString() {
        let result = this.name;
        let parent = this.getParent();
        if (parent) {
          result = parent + " - " + result;
        }
        return result;
      }
      getParent() {
        return TagStore.get(this.parentId);
      }
      getDepth() {
        let depth = -1;
        let tag = this;
        while (tag) {
          tag = tag.getParent();
          depth += 1;
        }
        return depth;
      }
    }
    let TagStore = new GenericObjectStore("tag", Tag);
    TagStore.getTagByName = function (name) {
      if (!this._caseSensitiveCache) {
        this._caseSensitiveCache = new Map();
      }
      if (this._caseSensitiveCache.has(name)) {
        return this._caseSensitiveCache.get(name);
      }
      for (let tag of this.all()) {
        if (tag.name === name) {
          this._caseSensitiveCache.set(name, tag);
          return tag;
        }
      }
      return null;
    };
    TagStore.getTagByNameInsensitive = function (name) {
      let lowerCaseName = name.toLocaleLowerCase();
      if (!this._caseInsensitiveCache) {
        this._caseInsensitiveCache = new Map();
      }
      if (this._caseInsensitiveCache.has(lowerCaseName)) {
        return this._caseInsensitiveCache.get(lowerCaseName);
      }
      for (let tag of this.all()) {
        if (tag.name.toLocaleLowerCase() === lowerCaseName) {
          this._caseInsensitiveCache.set(name, tag);
          return tag;
        }
      }
      return null;
    };

    const extraLanguageAttributes = [[1, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "g++ 13.2.0",
      comment: "Compiled with `g++ -static -O2 -lm -Wall -Wno-unused-result -std=c++2b -DCS_ACADEMY -DONLINE_JUDGE`.\nBoost 1.74.0 is available.",
      alternativeExtensions: ["h", "hpp"]
    }],
    // Plain C
    [13, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "gcc 13.2.0",
      comment: "Compiled with `gcc -O2 -lm -Wall -Wno-unused-result -DCS_ACADEMY -DONLINE_JUDGE`"
    }], [2, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "OpenJDK Java 21",
      comment: "Run with `java -Xmx4g -Xss256m -DONLINE_JUDGE -DCS_ACADEMY Main`"
    }], [4, {
      enforcedTemplateComment: '"""\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n"""\n\n',
      comment: "Comes with `numpy` and `scipy` modules",
      compiler: "Python 3.11.5"
    }],
    // Pypy3
    [29, {
      compiler: "Python 3.9.17, PyPy 7.3.12"
    }], [3, {
      enforcedTemplateComment: '"""\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n"""\n\n',
      compiler: "Python 2.7.18"
    }], [10, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n# \n# However, you can still submit any custom code.\n\n',
      compiler: "Ruby 3.1.2p20"
    }], [11, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n# \n# However, you can still submit any custom code.\n\n',
      compiler: "Perl 5.36.0"
    }], [5, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "Mono 6.8.0.105",
      comment: "Compiled with `mcs -define:ONLINE_JUDGE -define:CS_ACADEMY`"
    }], [14, {
      enforcedTemplateComment: '/*\n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "gcc 13.2.0",
      comment: "Compiled with `gcc -DCS_ACADEMY -DONLINE_JUDGE -I 'gnustep-config --variable=GNUSTEP_SYSTEM_HEADERS' -L 'gnustep-config --variable=GNUSTEP_SYSTEM_LIBRARIES' -lgnustep-base -fconstant-string-class=NSConstantString -D_NATIVE_OBJC_EXCEPTIONS -Wl,--no-as-needed -lgnustep-base -lobjc`"
    }], [26, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "Swift 5.0.2"
    }], [25, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "Go 1.19.2"
    }], [17, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "Node 20.5.1"
    }], [31, {
      compiler: "rustc 1.71.1"
    }], [30, {
      compiler: "kotlinc-jvm 1.4.10 (JRE 21+35-Ubuntu-1)"
    }], [32, {
      compiler: "julia 1.5.3"
    }], [8, {
      enforcedTemplateComment: '! ATTENTION!\n! This task does not have an enforced\n! template in this language!\n! \n! However, you can still submit any custom code.\n\n',
      compiler: "GNU Fortran 13.2.0",
      comment: "Compiled with `gfortran -ffree-form`"
    }], [9, {
      enforcedTemplateComment: '--[=====[\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n--]=====]\n\n',
      compiler: "Lua 5.2.4"
    }], [12, {
      enforcedTemplateComment: '/*\n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "PHP 8.0.8"
    }], [15, {
      enforcedTemplateComment: '"\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n"\n\n',
      compiler: "GNU Smalltalk 3.2.5"
    }], [16, {
      enforcedTemplateComment: '(*\n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n *)\n\n',
      compiler: "OCaml 4.11.1"
    }], [18, {
      enforcedTemplateComment: '*> ATTENTION!\n*> This task does not have an enforced\n*> template in this language!\n*> \n*> However, you can still submit any custom code.\n\n',
      compiler: "GnuCOBOL 4.0",
      comment: "Compiled with `cobc -free -x`"
    }], [19, {
      enforcedTemplateComment: '-- ATTENTION!\n-- This task does not have an enforced\n-- template in this language!\n--\n-- However, you can still submit any custom code.\n\n',
      compiler: "GNATMAKE 10.3.0"
    }], [21, {
      enforcedTemplateComment: ';; ATTENTION!\n;; This task does not have an enforced\n;; template in this language!\n;; \n;; However, you can still submit any custom code.\n\n',
      compiler: "SBCL 2.1.1"
    }], [27, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "Scala 2.11.12",
      comment: "Ran with `scala -J-Xmx4g -J-Xss256m -DONLINE_JUDGE -DCS_ACADEMY Main`"
    }], [23, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n# \n# However, you can still submit any custom code.\n\n',
      compiler: "TCL Shell 8.6.6"
    }], [24, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "GNU Octave 6.2.0"
    }], [20, {
      enforcedTemplateComment: '{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n}\n\n',
      compiler: "Free Pascal 3.2.0",
      comment: "Compiled with `fpc -O2 -Sgic -viwn -Tlinux -dONLINE_JUDGE -dCS_ACADEMY -XS`",
      disabled: true
    }], [6, {
      enforcedTemplateComment: '{-\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n-}\n\n',
      compiler: "GHC 8.8.4",
      disabled: true
    }], [7, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n#\n# However, you can still submit any custom code.\n\n',
      compiler: "Bash 5.2.15",
      disabled: true
    }], [22, {
      enforcedTemplateComment: '% ATTENTION!\n% This task does not have an enforced\n% template in this language!\n% \n% However, you can still submit any custom code.\n\n',
      compiler: "Erlang/OTP 23 [erts-11.1.8]",
      disabled: true
    }]];
    let index = 1;
    let extraLanguageAttributesMap = {};
    for (const [key, value] of extraLanguageAttributes) {
      extraLanguageAttributesMap[key] = value;
      extraLanguageAttributesMap[key].ordinal = index++;
    }
    class ProgrammingLanguageObject extends StoreObject {
      constructor(obj) {
        super(obj);
        Object.assign(this, extraLanguageAttributesMap[this.id] || {});
        this.ordinal = (this.ordinal || 999) * 10000 + this.id;
      }
      getDefaultSource() {
        let user = UserStore.getCurrentUser();
        if (user) {
          return user.getCustomSetting("workspace:programmingLanguage:" + this.id + ":defaultSource", this.defaultSource);
        }
        return this.defaultSource;
      }
      // This is appended to the beginning of the code for languages which
      // do not have a template in an enforced template task

      getDefaultTemplateComment() {
        return this.enforcedTemplateComment;
      }
      getExtension() {
        return this.extension;
      }
      toString() {
        return this.name;
      }
    }
    class ProgrammingLanguageStoreClass extends Store("ProgrammingLanguage", ProgrammingLanguageObject) {
      all() {
        if (!this.cachedAll) {
          let objects = Array.from(super.all()).filter(pl => !pl.disabled);
          objects.sort((a, b) => a.ordinal - b.ordinal);
          this.cachedAll = objects;
        }
        return this.cachedAll;
      }
      getLanguageForFileName(fileName) {
        const parts = fileName.split(".");
        if (parts.length >= 2) {
          // Trying to get the language by languageId
          const nameWithoutExtension = parts[0];
          // 4 is the length of "Main". If that ever changes...Forta Steaua
          const languageId = parseInt(nameWithoutExtension.substring(4));
          const language = ProgrammingLanguage.get(languageId);
          if (language) {
            return language;
          }
        }
        const extension = parts.length >= 2 ? parts.pop() : parts[0];
        for (let programmingLanguage of ProgrammingLanguage.objects.values()) {
          if (programmingLanguage.extension === extension || programmingLanguage.hasOwnProperty("alternativeExtensions") && programmingLanguage.alternativeExtensions.indexOf(extension) !== -1) {
            return programmingLanguage;
          }
        }
        console.error("Can't get a programming language for fileName: ", fileName);
        return {
          aceMode: "text"
        };
      }
      getDefaultLanguage() {
        let programmingLanguageId = 1; // C++
        const user = UserStore.getCurrentUser();
        if (user) {
          programmingLanguageId = user.getParsedCustomSetting("workspace:preferredProgrammingLanguage", programmingLanguageId);
        }
        return ProgrammingLanguage.get(programmingLanguageId);
      }
    }
    const ProgrammingLanguage = new ProgrammingLanguageStoreClass();

    class TermDefinitionObject extends StoreObject {}
    const TermDefinition = MakeStore("TermDefinition", TermDefinitionObject);
    TermDefinition.getDefinition = function (term) {
      return this.find(definition => definition.term === term);
    };

    class AceSettingObject extends StoreObject {
      toString() {
        return this.name;
      }
    }
    const AceTheme = new GenericObjectStore("AceTheme", AceSettingObject);
    AceTheme.getDefaultTheme = function () {
      let aceThemeId = 1; // Dawn
      let user = UserStore.getCurrentUser();
      if (user) {
        aceThemeId = user.getParsedCustomSetting("workspace:aceTheme", aceThemeId);
      }
      return AceTheme.get(aceThemeId);
    };
    const AceKeyboardHandler = new GenericObjectStore("AceEditorKeyboardHandler", AceSettingObject);
    AceKeyboardHandler.getDefaultKeyboardHandler = function () {
      let aceKeyboardHandlerId = 1; // ace
      let user = UserStore.getCurrentUser();
      if (user) {
        aceKeyboardHandlerId = user.getParsedCustomSetting("workspace:aceKeyboardHandler", aceKeyboardHandlerId);
      }
      return AceKeyboardHandler.get(aceKeyboardHandlerId);
    };

    class DifficultyObject extends StoreObject {
      toString() {
        return this.name;
      }
    }
    const Difficulty = new GenericObjectStore("difficulty", DifficultyObject);
    Difficulty.getDefaultDifficulty = function () {
      return Difficulty.get(2);
    };
    Difficulty.importState([{
      id: -1,
      name: "TUTORIAL",
      color: "#00dd00"
    }, {
      id: 1,
      name: "EASY",
      color: "green"
    }, {
      id: 2,
      name: "MEDIUM",
      color: "orange"
    }, {
      id: 3,
      name: "HARD",
      color: "red"
    }, {
      id: 4,
      name: "HARDEST",
      color: "#aa0000"
    }]);
    Object.assign(Difficulty, {
      EASY: Difficulty.get(1),
      MEDIUM: Difficulty.get(2),
      HARD: Difficulty.get(3),
      HARDEST: Difficulty.get(4),
      TUTORIAL: Difficulty.get(-1)
    });

    class ContestScoring extends StoreObject {
      static get PARTIAL_SCORING() {
        return ContestScoringStore.get(1);
      }
      static get ACM() {
        return ContestScoringStore.get(2);
      }
      static get CSA() {
        return ContestScoringStore.get(3);
      }
      toString() {
        return this.name;
      }
    }
    const ContestScoringStore = new GenericObjectStore("ContestScoring", ContestScoring);

    class SocialApp extends StoreObject {
      getClientId() {
        return this.clientId;
      }
    }
    class SocialAppStoreClass extends GenericObjectStore {
      constructor() {
        super("SocialApp", SocialApp);
      }
      getSocialApps() {
        return this.all();
      }
      getSocialAppByName(name) {
        return this.all().find(socialApp => socialApp.name === name);
      }
    }
    const SocialAppStore = new SocialAppStoreClass();

    document.STEM_DEBUG = true;
    let startTime = performance.now();

    // GlobalState initialization
    GlobalState$1.applyEventWrapper = (...args) => GlobalState$1.applyEvent(...args);
    GlobalState$1.registerStream = function (streamName) {
      WebsocketSubscriber.addListener(streamName, GlobalState$1.applyEventWrapper);
    };
    GlobalState$1.importState(self.PUBLIC_STATE); // Set from PublicState.js

    //Register on the global event stream
    GlobalState$1.registerStream("global-events");
    if (USER.id) {
      //Register on the user event stream
      GlobalState$1.registerStream("user-" + USER.id + "-events");
    }

    // CSASettings initialization
    class CSASettingsClass extends SingletonStore {
      constructor() {
        super("CSASettings");
      }
    }
    new CSASettingsClass();

    // Load ISO 3 language codes
    Object.assign(Language, {
      ENGLISH: Language.getLanguageForCode("eng"),
      ROMANIAN: Language.getLanguageForCode("ro") || Language.getLanguageForCode("rom"),
      BULGARIAN: Language.getLanguageForCode("bg"),
      UKRAINIAN: Language.getLanguageForCode("ukr") || Language.getLanguageForCode("uk"),
      RUSSIAN: Language.getLanguageForCode("rus"),
      MANDARIN: Language.getLanguageForCode("cmn"),
      JAPANESE: Language.getLanguageForCode("jpn"),
      ARABIC: Language.getLanguageForCode("ara"),
      SPANISH: Language.getLanguageForCode("spa"),
      FRENCH: Language.getLanguageForCode("fra"),
      GERMAN: Language.getLanguageForCode("deu"),
      ITALIAN: Language.getLanguageForCode("it"),
      POLISH: Language.getLanguageForCode("pol"),
      DUTCH: Language.getLanguageForCode("nld"),
      HUNGARIAN: Language.getLanguageForCode("hu")
    });
    Language.setLocale(Language.get(USER.localeLanguageId) || Language.ENGLISH);
    setLanguageStore(Language);
    console.log("CSAState took", (performance.now() - startTime).toFixed(2), "ms at", performance.now().toFixed(2), "ms.");

    // TODO This should probably be something else
    function isSepi() {
      return self.ENV_NAME === "sepi";
    }

    // TODO: this file is in dire need of a rewrite
    class StringStream {
      constructor(string, options) {
        this.string = string;
        this.pointer = 0;
      }
      done() {
        return this.pointer >= this.string.length;
      }
      advance(steps = 1) {
        this.pointer += steps;
      }
      char() {
        let ch = this.string.charAt(this.pointer);
        this.pointer += 1;
        return ch;
      }
      whitespace(whitespaceChar = /\s/) {
        let whitespaceStart = this.pointer;
        while (!this.done() && whitespaceChar.test(this.at(0))) {
          this.pointer += 1;
        }

        // Return the actual whitespace in case it is needed
        return this.string.substring(whitespaceStart, this.pointer);
      }

      // Gets first encountered non-whitespace substring
      word(validChars = /\S/, skipWhitespace = true) {
        if (skipWhitespace) {
          this.whitespace();
        }
        let wordStart = this.pointer;
        while (!this.done() && validChars.test(this.at(0))) {
          this.pointer += 1;
        }
        return this.string.substring(wordStart, this.pointer);
      }
      number(skipWhitespace = true) {
        if (skipWhitespace) {
          this.whitespace();
        }
        let nanString = "NaN";
        if (this.startsWith(nanString)) {
          this.advance(nanString.length);
          return NaN;
        }
        let sign = "+";
        if (this.at(0) === "-" || this.at(0) === "+") {
          sign = this.char();
        }
        let infinityString = "Infinity";
        if (this.startsWith(infinityString)) {
          this.advance(infinityString.length);
          return sign === "+" ? Infinity : -Infinity;
        }
        let isDigit = char => {
          return char >= "0" || char <= "9";
        };
        if (this.at(0) === "0" && (this.at(1) === "X" || this.at(1) === "x")) {
          // hexadecimal number
          this.advance(2);
          let isHexDigit = char => {
            return isDigit(char) || char >= "A" && char <= "F" || char >= "a" && char <= "f";
          };
          let numberStart = this.pointer;
          while (!this.done() && isHexDigit(this.at(0))) {
            this.pointer += 1;
          }
          return parseInt(sign + this.string.substring(numberStart), 16);
        }
        let numberStart = this.pointer;
        while (!this.done() && isDigit(this.at(1))) {
          this.pointer += 1;
          if (this.peek === ".") {
            this.advance(1);
            while (!this.done() && isDigit(this.at(1))) {
              this.pointer += 1;
            }
            break;
          }
        }
        return parseFloat(sign + this.string.substring(numberStart, this.pointer));
      }

      // Gets everything up to delimiter, usually end of line, limited to maxLength
      line(delimiter = /\r*\n/, maxLength = Infinity) {
        if (delimiter instanceof RegExp) {
          // Treat regex differently. It will probably be slower.
          let str = this.string.substring(this.pointer);
          let delimiterMatch = str.match(delimiter);
          let delimiterIndex, delimiterLength;
          if (delimiterMatch === null) {
            // End of string encountered
            delimiterIndex = str.length;
            delimiterLength = 0;
          } else {
            delimiterIndex = delimiterMatch.index;
            delimiterLength = delimiterMatch[0].length;
          }
          if (delimiterIndex >= maxLength) {
            this.pointer += maxLength;
            return str.substring(0, maxLength);
          }
          this.advance(delimiterIndex + delimiterLength);
          return str.substring(0, delimiterIndex);
        }
        let delimiterIndex = this.string.indexOf(delimiter, this.pointer);
        if (delimiterIndex === -1) {
          delimiterIndex = this.string.length;
        }
        if (delimiterIndex - this.pointer > maxLength) {
          let result = this.string.substring(this.pointer, this.pointer + maxLength);
          this.advance(maxLength);
          return result;
        }
        let result = this.string.substring(this.pointer, delimiterIndex);
        this.pointer = delimiterIndex + delimiter.length;
        return result;
      }

      // The following methods have no side effects

      // Access char at offset position, relative to current pointer
      at(index) {
        return this.string.charAt(this.pointer + index);
      }
      peek(length = 1) {
        return this.string.substring(this.pointer, this.pointer + length);
      }
      startsWith(prefix) {
        if (prefix instanceof RegExp) {
          // we modify the regex to only check for the beginning of the string
          prefix = new RegExp("^" + prefix.toString().slice(1, -1));
          return prefix.test(this.string.substring(this.pointer));
        }
        return this.peek(prefix.length) === prefix;
      }

      // Returns first position of match
      search(pattern) {
        let position;
        if (pattern instanceof RegExp) {
          position = this.string.substring(this.pointer).search(pattern);
        } else {
          position = this.string.indexOf(pattern, this.pointer) - this.pointer;
        }
        return position < 0 ? -1 : position;
      }
      clone() {
        let newStream = new this.constructor(this.string);
        newStream.pointer = this.pointer;
        return newStream;
      }
    }
    function kmp(input) {
      if (input.length === 0) {
        return [];
      }
      let prefix = [0];
      let prefixLength = 0;
      for (let i = 1; i < input.length; i += 1) {
        while (prefixLength > 0 && input[i] !== input[prefixLength]) {
          prefixLength = prefix[prefixLength];
        }
        if (input[i] === input[prefixLength]) {
          prefixLength += 1;
        }
        prefix.push(prefixLength);
      }
      return prefix;
    }
    class ModifierAutomation {
      // build automaton from string
      constructor(options) {
        this.options = options;
        this.steps = 0;
        this.startNode = {
          value: null,
          startNode: true
        };
        this.node = this.startNode;
        let lastNode = this.startNode;
        let char = options.pattern.charAt(0);
        let startPatternNode = {
          value: char,
          startNode: true
        };
        let patternPrefix = kmp(options.pattern);
        let patternNode = [startPatternNode];
        if (options.leftWhitespace) {
          // We don't want to match if the first char is not preceeded by whitespace
          let whitespaceNode = {
            value: " ",
            whitespaceNode: true
          };
          whitespaceNode.next = input => {
            if (input === char) return startPatternNode;
            return /\s/.test(input) ? whitespaceNode : this.startNode;
          };
          lastNode.next = input => {
            return /\s/.test(input) ? whitespaceNode : this.startNode;
          };
          this.node = whitespaceNode;
        } else {
          lastNode.next = input => {
            return input === char ? startPatternNode : this.startNode;
          };
        }
        lastNode = startPatternNode;
        for (let i = 1; i < options.pattern.length; i += 1) {
          let char = options.pattern[i];
          let newNode = {
            value: char
          };
          patternNode.push(newNode);
          let backNode = patternPrefix[i - 1] === 0 ? this.startNode : patternNode[patternPrefix[i - 1] - 1];
          lastNode.next = input => {
            if (input === char) {
              return newNode;
            }
            return backNode.next(input);
          };
          lastNode = newNode;
        }
        lastNode.patternLastNode = true;
        if (options.captureContent) {
          this.capture = [];
          let captureNode = {
            value: "",
            captureNode: true
          };

          // We treat the first character separately in order to support empty capture
          let char = options.endPattern.charAt(0);
          let endCaptureNode = {
            value: char
          };
          let endPatternPrefix = kmp(options.endPattern);
          let endPatternNodes = [endCaptureNode];
          lastNode.next = captureNode.next = input => {
            return input === char ? endCaptureNode : captureNode;
          };
          lastNode = endCaptureNode;
          for (let i = 1; i < options.endPattern.length; i += 1) {
            let char = options.endPattern[i];
            let newNode = {
              value: char
            };
            endPatternNodes.push(newNode);
            let backNode = endPatternPrefix[i - 1] === 0 ? captureNode : endPatternNodes[endPatternPrefix[i - 1] - 1];
            lastNode.next = input => {
              if (input === char) {
                return newNode;
              }
              return backNode.next(input);
            };
            lastNode = newNode;
          }
          lastNode.endPatternLastNode = true;
        }
        lastNode.endNode = true;
        lastNode.next = input => {
          return this.startNode.next(input);
        };
      }
      nextState(input) {
        this.steps += 1;
        this.node = this.node.next(input);
        if (this.node.startNode) {
          this.steps = 0;
          delete this.patternStep;
          delete this.endPatternStep;
        }
        if (this.node.patternLastNode) {
          this.patternStep = this.steps - this.options.pattern.length + 1;
        }
        if (this.node.endPatternLastNode) {
          // TODO(@all): Shouldn't it be this.options.endPattern.length instead of this.options.pattern.length?
          this.endPatternStep = this.steps - this.options.pattern.length + 1;
        }
        return this.node;
      }
      done() {
        return this.node.endNode;
      }
    }
    let Modifier$1 = class Modifier {
      constructor(options) {}
      modify(currentArray, originalString) {
        let matcher = new ModifierAutomation({
          pattern: this.pattern,
          captureContent: this.captureContent,
          // TODO: some elements should not wrap
          endPattern: this.endPattern,
          leftWhitespace: this.leftWhitespace
        });
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let newArray = [];
        for (let i = 0; i < originalString.length; i += 1) {
          let char = originalString[i];
          if (i >= currentElement.end) {
            newArray.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }
          if (currentElement.isJSX) {
            matcher.nextState("\\" + char); // prevent char from advancing automata
            continue;
          }
          matcher.nextState(char);
          if (matcher.done()) {
            let modifierStart = i - (matcher.steps - matcher.patternStep);
            let modifierEnd = i - (matcher.steps - matcher.endPatternStep) + this.endPattern.length;
            let modifierCapture = [];
            while (newArray.length > 0 && modifierStart <= newArray[newArray.length - 1].start) {
              let element = newArray.pop();
              modifierCapture.push(element);
            }
            if (newArray.length > 0 && modifierStart < newArray[newArray.length - 1].end) {
              let element = newArray.pop();
              newArray.push({
                isString: true,
                start: element.start,
                end: modifierStart
              });
              modifierCapture.push({
                isString: true,
                start: modifierStart,
                end: element.end
              });
            }
            if (currentElement.start < modifierStart) {
              newArray.push({
                isString: true,
                start: currentElement.start,
                end: modifierStart
              });
            }
            modifierCapture.reverse();

            // this is the end of the capture
            modifierCapture.push({
              isString: true,
              start: Math.max(currentElement.start, modifierStart),
              end: modifierEnd
            });
            newArray.push({
              content: this.wrap(this.processChildren(modifierCapture, originalString)),
              start: modifierStart,
              end: modifierEnd
            });

            // We split the current element to in two(one will be captured, one replaces the current element
            currentElement = {
              isString: true,
              start: modifierEnd,
              end: currentElement.end
            };
          }
        }
        if (currentElement.start < originalString.length) {
          newArray.push(currentElement);
        }
        return newArray;
      }
      processChildren(capture, originalString) {
        return capture.map(element => {
          return this.processChild(element, originalString);
        });
      }
      processChild(element, originalString) {
        if (element.isDummy) {
          return "";
        }
        if (element.isString) {
          return originalString.substring(element.start, element.end);
        } else {
          return element.content;
        }
      }
    };
    function InlineModifierMixin(BaseModifierClass) {
      return class InlineModifier extends BaseModifierClass {
        constructor(options) {
          super(options);
          this.captureContent = true;
        }
        wrap(content) {
          if (content.length > 0) {
            content[0] = content[0].substring(content[0].indexOf(this.pattern) + this.pattern.length);
            let lastElement = content.pop();
            lastElement = lastElement.substring(0, lastElement.lastIndexOf(this.endPattern));
            content.push(lastElement);
            return {
              tag: this.tag,
              children: content
            };
          }
        }
      };
    }
    function LineStartModifierMixin(BaseModifierClass) {
      return class LineStartModifier extends BaseModifierClass {
        constructor(options) {
          super(options);
          this.groupConsecutive = false;
        }
        isValidElement(element) {
          return element.content && element.content.tag === "p" && element.content.children.length > 0 && !element.content.children[0].tag &&
          // child is text string
          element.content.children[0].startsWith(this.pattern);
        }
        modify(currentArray, originalString) {
          let newArray = [];
          for (let i = 0; i < currentArray.length; i += 1) {
            let element = currentArray[i];
            if (this.isValidElement(element)) {
              if (this.groupConsecutive) {
                let elements = [];
                let start, end;
                start = currentArray[i].start;
                while (i < currentArray.length && this.isValidElement(currentArray[i])) {
                  elements.push(this.wrapItem(currentArray[i].content.children));
                  i += 1;
                }
                // we make sure no elements are skipped
                i -= 1;
                end = currentArray[i].end;
                newArray.push({
                  start: start,
                  end: end,
                  content: this.wrap(elements)
                });
              } else {
                // We use object assign here to keep the start and end properties. (Maybe along with others)
                let newElement = Object.assign({}, element, {
                  content: this.wrap(element.content.children)
                });
                newArray.push(newElement);
              }
            } else {
              newArray.push(element);
            }
          }
          return newArray;
        }
        wrapItem(content) {
          let firstChild = content[0];
          let patternIndex = firstChild.indexOf(this.pattern);
          let patternEnd = patternIndex + this.pattern.length;
          content[0] = firstChild.substring(patternEnd);
          return {
            tag: this.itemTag,
            children: content
          };
        }
        wrap(content) {
          return {
            tag: this.tag,
            children: content
          };
        }
      };
    }
    function RawContentModifierMixin(BaseModifierClass) {
      return class RawContentModifier extends BaseModifierClass {
        processChildren(children, originalString) {
          if (children.length === 0) {
            return [];
          }
          return [originalString.substring(children[0].start, children[children.length - 1].end)];
        }
      };
    }
    class BlockCodeModifier extends Modifier$1 {
      constructor(options) {
        super(options);
        this.pattern = "```";
        this.endPattern = "\n```";
        this.leftWhitespace = true;
        this.captureContent = true;
      }
      processChildren(capture, originalString) {
        this.codeOptions = null;
        if (capture.length > 0) {
          let codeBlock = originalString.substring(capture[0].start, capture[capture.length - 1].end);
          codeBlock = codeBlock.substring(codeBlock.indexOf(this.pattern) + this.pattern.length);
          codeBlock = codeBlock.substring(0, codeBlock.lastIndexOf(this.endPattern));
          let firstLineEnd = codeBlock.indexOf("\n") + 1;
          let firstLine = codeBlock.substring(0, firstLineEnd).trim();
          codeBlock = codeBlock.substring(firstLineEnd);
          if (firstLine.length > 0) {
            this.codeOptions = {};
            let lineStream = new StringStream(firstLine);
            this.codeOptions.aceMode = lineStream.word();
            Object.assign(this.codeOptions, MarkupParser.parseOptions(lineStream));
          }
          return codeBlock;
        }
        return "";
      }
      getElement(content) {
        return {
          tag: this.constructor.tag || "pre",
          children: [content]
        };
      }
      wrap(content, options) {
        let codeHighlighter = this.getElement(content);

        // TODO: this code should not be here
        let codeOptions = {
          aceMode: "c_cpp",
          maxLines: 32
        };
        if (this.codeOptions) {
          Object.assign(codeOptions, this.codeOptions);
          delete this.codeOptions;
        }
        Object.assign(codeOptions, codeHighlighter);
        return codeOptions;
      }
    }
    class HeaderModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.pattern = "#";
      }
      wrap(content) {
        let firstChild = content[0];
        let hashtagIndex = firstChild.indexOf("#");
        let hashtagEnd = hashtagIndex + 1;
        let headerLevel = 1;
        let nextChar = firstChild.charAt(hashtagEnd);
        if (nextChar >= "1" && nextChar <= "6") {
          headerLevel = parseInt(nextChar);
          hashtagEnd += 1;
        } else if (nextChar === "#") {
          while (headerLevel < 6 && firstChild.charAt(hashtagEnd) === "#") {
            headerLevel += 1;
            hashtagEnd += 1;
          }
        }
        content[0] = firstChild.substring(hashtagEnd);
        return {
          tag: "h" + headerLevel,
          children: content
        };
      }
    }
    class HorizontalRuleModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.pattern = "---";
      }
      wrap(content) {
        return {
          tag: "hr"
        };
      }
    }
    class UnorderedListModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.tag = "ul";
        this.itemTag = "li";
        this.pattern = "- ";
        this.groupConsecutive = true;
      }
    }
    class OrderedListModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.tag = "ol";
        this.itemTag = "li";
        this.pattern = "1. ";
        this.groupConsecutive = true;
      }
    }
    class ParagraphModifier extends Modifier$1 {
      modify(currentArray, originalString) {
        let newArray = [];
        let capturedContent = [];
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let lineStart = 0;
        for (let i = 0; i < originalString.length; i += 1) {
          if (i >= currentElement.end) {
            capturedContent.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }
          if (currentElement.isJSX) {
            continue;
          }
          if (originalString[i] === "\n") {
            if (currentElement.start < i) {
              capturedContent.push({
                isString: true,
                start: currentElement.start,
                end: i
              });
            }
            newArray.push({
              content: this.wrap(this.processChildren(capturedContent, originalString)),
              start: lineStart,
              end: i + 1
            });
            capturedContent = [];
            lineStart = i + 1;
            if (originalString[i + 1] === "\n") {
              let start, end;
              start = i;
              while (i + 1 < originalString.length && originalString[i + 1] === "\n") {
                i += 1;
              }
              end = i + 1;
              newArray.push({
                content: {
                  tag: "br"
                },
                start: start,
                end: end
              });
              lineStart = i + 1;
            }
            currentElement = {
              isString: true,
              start: lineStart,
              end: currentElement.end
            };
          }
        }
        if (currentElement.start < originalString.length) {
          capturedContent.push(currentElement);
        }
        if (capturedContent.length > 0) {
          newArray.push({
            content: this.wrap(this.processChildren(capturedContent, originalString)),
            start: lineStart,
            end: originalString.length
          });
        }
        return newArray;
      }
      wrap(capture) {
        return {
          tag: "p",
          children: capture
        };
      }
    }
    class StrongModifier extends InlineModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.leftWhitespace = true;
        this.pattern = "*";
        this.endPattern = "*";
        this.tag = "strong";
      }
    }
    class ItalicModifier extends InlineModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.leftWhitespace = true;
        this.pattern = "/";
        this.endPattern = "/";
        this.tag = "em";
      }
    }
    class InlineCodeModifier extends RawContentModifierMixin(InlineModifierMixin(Modifier$1)) {
      constructor(options) {
        super(options);
        this.pattern = "`";
        this.endPattern = "`";
        this.tag = "code";
      }
      processChildren(children, originalString) {
        if (children.length === 0) {
          return [];
        }
        return [originalString.substring(children[0].start, children[children.length - 1].end)];
      }
    }
    class InlineVarModifier extends RawContentModifierMixin(InlineModifierMixin(Modifier$1)) {
      constructor(options) {
        super(options);
        this.pattern = "$";
        this.endPattern = "$";
        this.tag = "var";
      }
    }
    class InlineLatexModifier extends RawContentModifierMixin(InlineModifierMixin(Modifier$1)) {
      constructor(options) {
        super(options);
        this.pattern = "$$";
        this.endPattern = "$$";
        this.tag = "Latex";
      }
    }
    class LinkModifier extends Modifier$1 {
      static isCorrectUrl(str) {
        if (str.startsWith("http://") || str.startsWith("https://")) {
          return true;
        }
      }
      static trimProtocol(str) {
        if (str[4] === 's') {
          return str.substring(8, str.length);
        }
        return str.substring(7, str.length);
      }
      modify(currentArray, originalString) {
        let newArray = [];
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let lineStart = 0;
        let checkAndAddUrl = (start, end) => {
          let substr = originalString.substring(start, end);
          if (this.constructor.isCorrectUrl(substr)) {
            if (currentElement.start < start) {
              newArray.push({
                isString: true,
                start: currentElement.start,
                end: start
              });
            }
            newArray.push({
              isJSX: true,
              content: {
                tag: "a",
                href: substr,
                children: [this.constructor.trimProtocol(substr)],
                target: "_blank"
              },
              start: start,
              end: end
            });
            currentElement = {
              isString: true,
              start: end,
              end: currentElement.end
            };
          }
        };
        for (let i = 0; i < originalString.length; i += 1) {
          if (i >= currentElement.end) {
            newArray.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }
          if (currentElement.isJSX) {
            continue;
          }
          if (/\s/.test(originalString[i])) {
            checkAndAddUrl(lineStart, i);
            lineStart = i + 1;
          }
        }
        if (lineStart < originalString.length) {
          checkAndAddUrl(lineStart, originalString.length);
        }
        if (currentElement.start < originalString.length) {
          newArray.push(currentElement);
        }
        return newArray;
      }
    }
    let MarkupModifier = Modifier$1;
    class MarkupParser {
      constructor(options) {
        options = options || {};
        this.modifiers = options.modifiers || this.constructor.modifiers;
        this.uiElements = options.uiElements || new Map();
      }
      parse(content) {
        if (!content) return [];
        let result = [];
        let arr = this.parseUIElements(content);
        for (let i = this.modifiers.length - 1; i >= 0; i -= 1) {
          let modifier = this.modifiers[i];
          arr = modifier.modify(arr, content);
        }
        for (let el of arr) {
          if (el.isDummy) ; else if (el.isString) {
            result.push(content.substring(el.start, el.end));
          } else {
            result.push(el.content);
          }
        }
        return result;
      }
      parseUIElements(content) {
        let stream = new StringStream(content);
        let result = [];
        let textStart = 0;
        while (!stream.done()) {
          let char = stream.char();
          if (char === "<" && /[a-zA-Z]/.test(stream.at(0))) {
            stream.pointer -= 1; //step back to beginning of ui element
            let elementStart = stream.pointer;
            let uiElement;
            try {
              uiElement = this.parseUIElement(stream);
            } catch (e) {
              // failed to parse jsx element
              continue;
            }
            if (this.uiElements.has(uiElement.tag)) {
              result.push({
                isString: true,
                start: textStart,
                end: elementStart
              });
              result.push({
                content: uiElement,
                isJSX: true,
                start: elementStart,
                end: stream.pointer
              });
              textStart = stream.pointer;
            }
          }
        }
        if (textStart < content.length) {
          result.push({
            isString: true,
            start: textStart,
            end: content.length
          });
        }
        return result;
      }
      parseUIElement(stream, delimiter = /\/?>/) {
        // content should be of type <ClassName option1="string" option2={{jsonObject: true}} />
        // TODO: support nested elements like <ClassName><NestedClass /></ClassName>

        stream.whitespace();
        if (stream.done()) {
          return null;
        }
        if (stream.at(0) !== "<") {
          throw Error("Invalid UIElement declaration.");
        }
        let result = {};
        stream.char(); // skip the '<'

        result.tag = stream.word();
        stream.whitespace();
        Object.assign(result, this.parseOptions(stream, delimiter));
        stream.line(delimiter);
        return result;
      }
      parseOptions(stream, optionsEnd) {
        return this.constructor.parseOptions(stream, optionsEnd);
      }

      // optionsEnd cannot include whitespace or start with '='
      static parseOptions(stream, optionsEnd) {
        let options = {};
        stream.whitespace();
        while (!stream.done()) {
          // argument name is anything that comes before whitespace or '='
          stream.whitespace();
          let validOptionName = /[\w$]/;
          let optionName;
          if (validOptionName.test(stream.at(0))) {
            optionName = stream.word(validOptionName);
          }
          stream.whitespace();
          if (optionsEnd && stream.search(optionsEnd) === 0) {
            options[optionName] = true;
            break;
          }
          if (!optionName) {
            throw Error("Invalid option name");
          }
          if (stream.peek() === "=") {
            stream.char();
            stream.whitespace();
            if (stream.done()) {
              throw Error("No argument given for option: " + optionName);
            }
            if (stream.peek() === '"') {
              // We have a string here
              let optionString = "";
              let foundStringEnd = false;
              stream.char();
              while (!stream.done()) {
                let char = stream.char();
                if (char === '"') {
                  foundStringEnd = true;
                  break;
                }
                optionString += char;
              }
              if (!foundStringEnd) {
                // You did not close that string
                throw Error("Argument string not closed: " + optionString);
              }
              options[optionName] = optionString;
            } else if (stream.peek() === '{') {
              // Once you pop, the fun don't stop
              let bracketCount = 0;
              let validJSON = false;
              let jsonString = "";
              stream.char();
              while (!stream.done()) {
                let char = stream.char();
                if (char === '{') {
                  bracketCount += 1;
                } else if (char === '}') {
                  if (bracketCount > 0) {
                    bracketCount -= 1;
                  } else {
                    // JSON ends here
                    options[optionName] = jsonString.length > 0 ? this.parseJSON5(jsonString) : undefined;
                    validJSON = true;
                    break;
                  }
                }
                jsonString += char;
              }
              if (!validJSON) {
                throw Error("Invalid JSON argument for option: " + optionName + ". Input: " + jsonString);
              }
            } else {
              throw Error("Invalid argument for option: " + optionName + ". Need string or JSON.");
            }
          } else {
            options[optionName] = true;
          }
          stream.whitespace();
        }
        return options;
      }
      parseTextLine(stream) {
        let capturedContent = [];
        let textStart = stream.pointer;
        let contentStart = stream.pointer;
        while (!stream.done()) {
          if (stream.startsWith(/\s+\r*\n/)) {
            // end of line, stop here
            break;
          }
          if (stream.at(0) === "<") {
            capturedContent.push({
              content: stream.string.substring(contentStart, stream.pointer),
              start: contentStart,
              end: stream.pointer
            });
            let uiElementStart = stream.pointer;
            let uiElement = this.parseUIElement(stream, /\/*>/);
            capturedContent.push({
              content: uiElement,
              start: uiElementStart,
              end: stream.pointer
            });
            contentStart = stream.pointer;
            continue;
          }
          let char = stream.char();
          if (char === "\\") {
            // escape next character
            char += stream.char();
          }
        }
        let remainingContent = stream.string.substring(textStart, stream.pointer);
        if (remainingContent.length > 0) {
          capturedContent.push(remainingContent);
        }
        stream.line(); // delete line endings

        return capturedContent;
      }
    }
    MarkupParser.modifiers = [new BlockCodeModifier(), new HeaderModifier(), new HorizontalRuleModifier(), new UnorderedListModifier(), new OrderedListModifier(), new ParagraphModifier(), new InlineCodeModifier(), new InlineLatexModifier(), new InlineVarModifier(), new StrongModifier(), new ItalicModifier(), new LinkModifier()];

    // json5.js
    // This file is based directly off of Douglas Crockford's json_parse.js:
    // https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js
    MarkupParser.parseJSON5 = function () {
      // This is a function that can parse a JSON5 text, producing a JavaScript
      // data structure. It is a simple, recursive descent parser. It does not use
      // eval or regular expressions, so it can be used as a model for implementing
      // a JSON5 parser in other languages.

      // We are defining the function inside of another function to avoid creating
      // global variables.

      let at,
        // The index of the current character
        lineNumber,
        // The current line number
        columnNumber,
        // The current column number
        ch; // The current character
      let escapee = {
        "'": "'",
        '"': '"',
        '\\': '\\',
        '/': '/',
        '\n': '',
        // Replace escaped newlines in strings w/ empty string
        b: '\b',
        f: '\f',
        n: '\n',
        r: '\r',
        t: '\t'
      };
      let text;
      let renderChar = chr => {
        return chr === '' ? 'EOF' : "'" + chr + "'";
      };
      let error = m => {
        // Call error when something is wrong.

        let error = new SyntaxError();
        // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
        error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
        error.at = at;
        // These two property names have been chosen to agree with the ones in Gecko, the only popular
        // environment which seems to supply this info on JSON.parse
        error.lineNumber = lineNumber;
        error.columnNumber = columnNumber;
        throw error;
      };
      let next = c => {
        // If a c parameter is provided, verify that it matches the current character.

        if (c && c !== ch) {
          error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
        }

        // Get the next character. When there are no more characters,
        // return the empty string.

        ch = text.charAt(at);
        at++;
        columnNumber++;
        if (ch === '\n' || ch === '\r' && peek() !== '\n') {
          lineNumber++;
          columnNumber = 0;
        }
        return ch;
      };
      let peek = () => {
        // Get the next character without consuming it or
        // assigning it to the ch varaible.

        return text.charAt(at);
      };
      let identifier = () => {
        // Parse an identifier. Normally, reserved words are disallowed here, but we
        // only use this for unquoted object keys, where reserved words are allowed,
        // so we don't check for those here. References:
        // - http://es5.github.com/#x7.6
        // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
        // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
        // TODO Identifiers can have Unicode "letters" in them; add support for those.
        let key = ch;

        // Identifiers must start with a letter, _ or $.
        if (ch !== '_' && ch !== '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {
          error("Bad identifier as unquoted key");
        }

        // Subsequent characters can contain digits.
        while (next() && (ch === '_' || ch === '$' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')) {
          key += ch;
        }
        return key;
      };
      let number = () => {
        // Parse a number value.
        var number,
          sign = '',
          string = '',
          base = 10;
        if (ch === '-' || ch === '+') {
          sign = ch;
          next(ch);
        }

        // support for Infinity (could tweak to allow other words):
        if (ch === 'I') {
          number = word();
          if (typeof number !== 'number' || isNaN(number)) {
            error('Unexpected word for number');
          }
          return sign === '-' ? -number : number;
        }

        // support for NaN
        if (ch === 'N') {
          number = word();
          if (!isNaN(number)) {
            error('expected word to be NaN');
          }
          // ignore sign as -NaN also is NaN
          return number;
        }
        if (ch === '0') {
          string += ch;
          next();
          if (ch === 'x' || ch === 'X') {
            string += ch;
            next();
            base = 16;
          } else if (ch >= '0' && ch <= '9') {
            error('Octal literal');
          }
        }
        switch (base) {
          case 10:
            while (ch >= '0' && ch <= '9') {
              string += ch;
              next();
            }
            if (ch === '.') {
              string += '.';
              while (next() && ch >= '0' && ch <= '9') {
                string += ch;
              }
            }
            if (ch === 'e' || ch === 'E') {
              string += ch;
              next();
              if (ch === '-' || ch === '+') {
                string += ch;
                next();
              }
              while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
              }
            }
            break;
          case 16:
            while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
              string += ch;
              next();
            }
            break;
        }
        if (sign === '-') {
          number = -string;
        } else {
          number = +string;
        }
        if (!isFinite(number)) {
          error("Bad number");
        } else {
          return number;
        }
      };
      let string = () => {
        // Parse a string value.
        let hex,
          i,
          string = '',
          uffff;
        let delim; // double quote or single quote

        // When parsing for string values, we must look for ' or " and \ characters.

        if (ch === '"' || ch === "'") {
          delim = ch;
          while (next()) {
            if (ch === delim) {
              next();
              return string;
            } else if (ch === '\\') {
              next();
              if (ch === 'u') {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string += String.fromCharCode(uffff);
              } else if (ch === '\r') {
                if (peek() === '\n') {
                  next();
                }
              } else if (typeof escapee[ch] === 'string') {
                string += escapee[ch];
              } else {
                break;
              }
            } else if (ch === '\n') {
              // unescaped newlines are invalid; see:
              // https://github.com/aseemk/json5/issues/24
              // TODO this feels special-cased; are there other
              // invalid unescaped chars?
              break;
            } else {
              string += ch;
            }
          }
        }
        error("Bad string");
      };
      let inlineComment = () => {
        // Skip an inline comment, assuming this is one. The current character should
        // be the second / character in the // pair that begins this inline comment.
        // To finish the inline comment, we look for a newline or the end of the text.

        if (ch !== '/') {
          error("Not an inline comment");
        }
        do {
          next();
          if (ch === '\n' || ch === '\r') {
            next();
            return;
          }
        } while (ch);
      };
      let blockComment = () => {
        // Skip a block comment, assuming this is one. The current character should be
        // the * character in the /* pair that begins this block comment.
        // To finish the block comment, we look for an ending */ pair of characters,
        // but we also watch for the end of text before the comment is terminated.

        if (ch !== '*') {
          error("Not a block comment");
        }
        do {
          next();
          while (ch === '*') {
            next('*');
            if (ch === '/') {
              next('/');
              return;
            }
          }
        } while (ch);
        error("Unterminated block comment");
      };
      let comment = () => {
        // Skip a comment, whether inline or block-level, assuming this is one.
        // Comments always begin with a / character.

        if (ch !== '/') {
          error("Not a comment");
        }
        next('/');
        if (ch === '/') {
          inlineComment();
        } else if (ch === '*') {
          blockComment();
        } else {
          error("Unrecognized comment");
        }
      };
      let white = () => {
        // Skip whitespace and comments.
        // Note that we're detecting comments by only a single / character.
        // This works since regular expressions are not valid JSON(5), but this will
        // break if there are other valid values that begin with a / character!

        while (ch) {
          if (ch === '/') {
            comment();
          } else if (/\s/.test(ch)) {
            next();
          } else {
            return;
          }
        }
      };
      let word = () => {
        // true, false, or null.

        switch (ch) {
          case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
          case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
          case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
          case 'I':
            next('I');
            next('n');
            next('f');
            next('i');
            next('n');
            next('i');
            next('t');
            next('y');
            return Infinity;
          case 'N':
            next('N');
            next('a');
            next('N');
            return NaN;
        }
        error("Unexpected " + renderChar(ch));
      };
      let value;
      let array = () => {
        // Parse an array value.
        let array = [];
        if (ch === '[') {
          next('[');
          white();
          while (ch) {
            if (ch === ']') {
              next(']');
              return array; // Potentially empty array
            }
            // ES5 allows omitting elements in arrays, e.g. [,] and
            // [,null]. We don't allow this in JSON5.
            if (ch === ',') {
              error("Missing array element");
            } else {
              array.push(value());
            }
            white();
            // If there's no comma after this value, this needs to
            // be the end of the array.
            if (ch !== ',') {
              next(']');
              return array;
            }
            next(',');
            white();
          }
        }
        error("Bad array");
      };
      let object = () => {
        // Parse an object value.

        var key,
          object = {};
        if (ch === '{') {
          next('{');
          white();
          while (ch) {
            if (ch === '}') {
              next('}');
              return object; // Potentially empty object
            }

            // Keys can be unquoted. If they are, they need to be
            // valid JS identifiers.
            if (ch === '"' || ch === "'") {
              key = string();
            } else {
              key = identifier();
            }
            white();
            next(':');
            object[key] = value();
            white();
            // If there's no comma after this pair, this needs to be
            // the end of the object.
            if (ch !== ',') {
              next('}');
              return object;
            }
            next(',');
            white();
          }
        }
        error("Bad object");
      };
      value = () => {
        // Parse a JSON value. It could be an object, an array, a string, a number,
        // or a word.

        white();
        switch (ch) {
          case '{':
            return object();
          case '[':
            return array();
          case '"':
          case "'":
            return string();
          case '-':
          case '+':
          case '.':
            return number();
          default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
      };

      // Return the json_parse function. It will have access to all of the above
      // functions and variables.

      return function (source, reviver) {
        var result;
        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }

        // If there is a reviver function, we recursively walk the new structure,
        // passing each name/value pair to the reviver function for possible
        // transformation, starting with a temporary root object that holds the result
        // in an empty key. If there is not a reviver function, we simply return the
        // result.

        return typeof reviver === 'function' ? function walk(holder, key) {
          var k,
            v,
            value = holder[key];
          if (value && typeof value === 'object') {
            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = walk(value, k);
                if (v !== undefined) {
                  value[k] = v;
                } else {
                  delete value[k];
                }
              }
            }
          }
          return reviver.call(holder, key, value);
        }({
          '': result
        }, '') : result;
      };
    }();

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
      });
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      if ('value' in desc || desc.initializer) {
        desc.writable = true;
      }
      desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
      }, desc);
      if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
      }
      if (desc.initializer === void 0) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }

    // TODO: should this be actually better done throught the dynamic CSS API, without doing through the DOM?
    // So far it's actually better like this, since we want to edit the classes inline
    class StyleInstance extends UI$1.TextElement {
      constructor(options) {
        super(options);
        this.setOptions(options);
      }
      setOptions(options) {
        this.options = options;
        this.options.attributes = this.options.attributes || {};
        this.attributes = new Map();
        for (let key in this.options.attributes) {
          this.attributes.set(key, this.options.attributes[key]);
        }
      }
      getValue() {
        let str = this.options.selector + "{";
        for (let [key, value] of this.attributes) {
          if (typeof value === "function") {
            value = value();
          }
          // Ignore keys with null or undefined value
          if (value == null) {
            continue;
          }
          key = dashCase(key);

          // If it's a size property, and the value is a number, assume it's in pixels
          if (isNumber(value) && value != 0 && defaultToPixelsAttributes.has(key)) {
            value = value + "px";
          }

          // TODO: if key starts with vendor-, replace it with the browser specific one (and the plain one)
          const buildKeyValue = (key, value) => key + ":" + value + ";";
          if (Array.isArray(value)) {
            for (const v of value) {
              str += buildKeyValue(key, v);
            }
          } else {
            str += buildKeyValue(key, value);
          }
        }
        return str + "}";
      }
      copyState(element) {
        this.setOptions(element.options);
      }
      setAttribute(name, value) {
        this.attributes.set(name, value);
        this.redraw();
      }
      deleteAttribute(name) {
        this.attributes.delete(name);
        this.redraw();
      }
    }
    class StyleElement extends UI$1.Primitive("style") {
      getNodeAttributes() {
        // TODO: allow custom style attributes (media, scoped, etc)
        const attr = new NodeAttributes({});
        if (this.options.name) {
          attr.setAttribute("name", this.options.name);
        }
        return attr;
      }
    }
    const ALLOWED_SELECTOR_STARTS = new Set([":", ">", " ", "+", "~", "[", "."]);

    // TODO: figure out how to work with animation frames, this only creates a wrapper class
    class DynamicStyleElement extends StyleElement {
      toString() {
        return this.getClassName();
      }

      // Overwrite valueOf, so when using the + operator should seamlessly concatenate to create a valid className
      valueOf() {
        return " " + this.getClassName() + " ";
      }

      // TODO: use a cached decorator here
      getClassName() {
        if (this.className) {
          return this.className;
        }
        self.styleInstanceCounter = (self.styleInstanceCounter || 0) + 1;
        this.className = (this.options.name || "autocls") + "-" + self.styleInstanceCounter;
        return this.className;
      }
      getSelector() {
        return this.options.selectorName || "." + this.getClassName();
      }

      // A cyclic dependency in the style object will cause an infinite loop here
      getStyleInstances(selector, style) {
        const result = [],
          ownStyle = {};
        let haveOwnStyle = false;
        for (const key in style) {
          const value = style[key];
          if (value == null) {
            continue;
          }
          const isProperValue = isString(value) || isNumber(value) || isFunction(value) || Array.isArray(value);
          if (isProperValue) {
            ownStyle[key] = value;
            haveOwnStyle = true;
          } else {
            // Check that this actually is a valid subselector
            const firstChar = String(key).charAt(0);
            if (!ALLOWED_SELECTOR_STARTS.has(firstChar)) {
              console.error(`First character of your selector is invalid. The key is "${key}"`);
              continue;
            }
            // TODO: maybe optimize for waste here?
            const subStyle = this.getStyleInstances(selector + key, value);
            result.push(...subStyle);
          }
        }
        if (haveOwnStyle) {
          result.unshift(new StyleInstance({
            selector: selector,
            key: selector,
            attributes: ownStyle
          }));
        }
        return result;
      }
      render() {
        let style = this.options.style || {};
        if (typeof style === "function") {
          style = style();
        }
        if (style.selectorName) {
          this.options.selectorName = style.selectorName;
          delete style.selectorName;
        }
        return this.getStyleInstances(this.getSelector(), style);
      }
      setStyle(key, value) {
        this.options.style[key] = value;
        this.children[0].setAttribute(key, value);
      }
      setSubStyle(selector, key, value) {
        throw Error("Implement me!");
      }
      getStyleObject() {
        return this.options.style;
      }
    }
    class KeyframeElement extends StyleElement {
      toString() {
        return this.getKeyframeName();
      }
      getKeyframeName() {
        if (this.keyframeName) {
          return this.keyframeName;
        }
        self.styleInstanceCounter = (self.styleInstanceCounter || 0) + 1;
        this.keyframeName = (this.options.name || "autokeyframe") + "-" + self.styleInstanceCounter;
        return this.keyframeName;
      }
      getValue(style) {
        let str = "{";
        for (let key in style) {
          let value = style[key];
          if (typeof value === "function") {
            value = value();
          }
          if (value == null) {
            continue;
          }
          str += dashCase(key) + ":" + value + ";";
        }
        return str + "}";
      }
      getKeyframeInstance(keyframe) {
        let result = "{";
        for (let key in keyframe) {
          let value = keyframe[key];
          result += key + " " + this.getValue(value);
        }
        return result + "}";
      }
      render() {
        return "@keyframes " + this.getKeyframeName() + this.getKeyframeInstance(this.options.keyframe || {});
      }
    }

    function isDescriptor(desc) {
      if (!desc || !desc.hasOwnProperty) {
        return false;
      }
      const keys = ['value', 'initializer', 'get', 'set'];
      for (let key of keys) {
        if (desc.hasOwnProperty(key)) {
          return true;
        }
      }
      return false;
    }
    function decorate(handleDescriptor, entryArgs) {
      if (isDescriptor(entryArgs[entryArgs.length - 1])) {
        return handleDescriptor(...entryArgs, []);
      } else {
        return function () {
          return handleDescriptor(...arguments, entryArgs);
        };
      }
    }
    function createDefaultSetter(key) {
      return function set(newValue) {
        Object.defineProperty(this, key, {
          configurable: true,
          writable: true,
          // IS enumerable when reassigned by the outside word
          enumerable: true,
          value: newValue
        });
        return newValue;
      };
    }

    function handleDescriptor(target, key, descriptor) {
      const {
        configurable,
        enumerable,
        initializer,
        value
      } = descriptor;
      // The "key" property is constructed with accessor descriptor (getter / setter),
      // but the first time the getter is used, the property is reconstructed with data descriptor.
      return {
        configurable,
        enumerable,
        get() {
          // This happens if someone accesses the property directly on the prototype
          if (this === target) {
            return;
          }
          const ret = initializer ? initializer.call(this) : value;

          // Overwrite the getter & setter combo with the plain field on first assignment.
          Object.defineProperty(this, key, {
            configurable,
            enumerable,
            writable: true,
            value: ret
          });
          return ret;
        },
        set: createDefaultSetter(key)
      };
    }
    function lazyInit(...args) {
      return decorate(handleDescriptor, args);
    }

    function evaluateStyleRuleObject(target, initializer, value, options) {
      let result = initializer ? initializer.call(target) : value;
      if (typeof result === "function") {
        result = result();
      }
      if (Array.isArray(result)) {
        result = Object.assign({}, ...result);
      }
      return result;
    }
    function getStyleRuleKey(key) {
      return "__style__" + key;
    }
    function getKeyframesRuleKey(key) {
      return "__keyframes__" + key;
    }
    const PREFERRED_CLASS_NAME_KEY = Symbol("PreferredClassName");
    function getPreferredClassName(cls, key, descriptor) {
      if (key !== "container") {
        return key;
      }
      let className = cls.constructor.name;
      if (className.endsWith("Style")) {
        className = className.substr(0, className.length - 5);
      }
      className = className.replaceAll("$", ""); // Fix minify mangling
      return className + "-container";
    }

    // TODO: this function can be made a lot more generic, to wrap plain object initializer with inheritance support
    function styleRuleWithOptions() {
      let options = Object.assign({}, ...arguments); //Simpler notation?
      // TODO: Remove this if you don't think it's appropiate, I thought a warning would do no harm
      if (!options.targetMethodName) {
        console.error("WARNING: targetMethodName not specified in the options (default is \"css\")");
      }
      let targetMethodName = options.targetMethodName || "css";
      function styleRuleDecorator(target, key, descriptor) {
        const {
          initializer,
          value
        } = descriptor;
        descriptor.objInitializer = function () {
          let style = evaluateStyleRuleObject(this, initializer, value);
          if (options.selector) {
            style["selectorName"] = options.selector;
          }
          if (options.inherit) {
            // Get the value we set in the prototype of the parent class
            let parentDesc = Object.getPrototypeOf(target)[getStyleRuleKey(key)];
            if (!parentDesc) {
              console.error("You're trying to inherit a rule that isn't implemented in the parent: " + key);
            }
            let parentStyle = evaluateStyleRuleObject(this, parentDesc.objInitializer, parentDesc.value);
            style = deepCopy({}, parentStyle, style);
          }
          style[PREFERRED_CLASS_NAME_KEY] = getPreferredClassName(target, key);
          return style;
        };

        // Change the prototype of this object to be able to access the old descriptor/value
        target[options.getKey(key)] = Object.assign({}, descriptor);
        descriptor.initializer = function () {
          let style = descriptor.objInitializer.call(this);
          return this[targetMethodName](style);
        };
        delete descriptor.value;
        return lazyInit(target, key, descriptor);
      }
      return styleRuleDecorator;
    }

    // TODO: Second argument is mostly useless (implied from targetMethodName)
    const styleRule = styleRuleWithOptions({
      targetMethodName: "css",
      getKey: getStyleRuleKey,
      inherit: false
    });
    const styleRuleInherit = styleRuleWithOptions({
      targetMethodName: "css",
      getKey: getStyleRuleKey,
      inherit: true
    });
    function styleRuleCustom(options) {
      return styleRuleWithOptions(Object.assign({
        targetMethodName: "css",
        getKey: getStyleRuleKey,
        inherit: false
      }, options));
    }
    const keyframesRule = styleRuleWithOptions({
      targetMethodName: "keyframes",
      getKey: getKeyframesRuleKey,
      inherit: false
    });

    // TODO: This is currently not working (I think)
    styleRuleWithOptions({
      targetMethodName: "keyframes",
      getKey: getKeyframesRuleKey,
      inherit: true
    });

    // Class meant to group multiple classes inside a single <style> element, for convenience
    // TODO: pattern should be more robust, to be able to only update classes
    class StyleSheet extends Dispatchable {
      constructor(options = {}) {
        super();
        this.options = {
          ...this.getDefaultOptions(options),
          ...options
        };
        this.elements = new Set();
        const {
          delayedMount
        } = this.options;
        if (!delayedMount) {
          this.ensureMounted();
        }
        this.themeProps = this.options.theme.props;
      }
      getDefaultOptions(options) {
        const theme = options.theme || Theme.Global;
        return {
          parent: document.head,
          theme,
          name: options.name || this.constructor.getElementName(theme) // call only if needed
        };
      }
      ensureMounted() {
        if (this.styleElement) {
          return;
        }
        const styleElementOptions = {
          children: [],
          name: this.options.name
        };
        this.styleElement = StyleElement.create(this.options.parent, styleElementOptions);
      }
      static getInstance(theme = this.theme || Theme.Global) {
        return theme.getStyleSheetInstance(this);
      }

      // Just to have the same pattern as objects or not
      getInstance() {
        return this;
      }

      // Generate an instance, and also make sure to instantiate all style elements
      static initialize() {
        const styleSheet = this.getInstance();
        for (const key in this.prototype) {
          // Just hit the getter to instantiate the style
          if (!styleSheet[key]) {
            console.log("This is here to prevent a bundling optimization bug");
          }
        }
      }
      static getElementName(theme) {
        this.elementNameCounter = (this.elementNameCounter || 0) + 1;
        let name = this.name;
        if (theme !== Theme.Global) {
          name += "-" + theme.name;
        }
        name = name.replaceAll("$", ""); // Fix minify mangling
        if (this.elementNameCounter > 1) {
          name += "-" + this.elementNameCounter;
        }
        return name;
      }
      ensureFirstUpdate() {
        if (this._firstUpdate) {
          return;
        }
        this._firstUpdate = true;
        this.ensureMounted();
        // Call all listeners before update for the very first time, to update any possible variables
        this.dispatch("beforeUpdate", this);
      }
      css(style) {
        this.ensureFirstUpdate();
        if (arguments.length > 1) {
          style = Object.assign({}, ...arguments);
        }
        let elementOptions = {
          style: style
        };
        if (style[PREFERRED_CLASS_NAME_KEY]) {
          elementOptions.name = style[PREFERRED_CLASS_NAME_KEY];
        }
        let element = new DynamicStyleElement(elementOptions);
        this.elements.add(element);
        let styleInstances = element.render();
        for (let styleInstance of styleInstances) {
          this.styleElement.appendChild(styleInstance);
        }
        return element;
      }
      keyframes(keyframes) {
        this.ensureFirstUpdate();
        // This is not really necessarily as I don't believe it will ever be used
        if (arguments.length > 1) {
          keyframes = Object.assign({}, ...arguments);
        }
        let element = new KeyframeElement({
          keyframe: keyframes
        });
        this.elements.add(element);
        this.styleElement.appendChild(element);
        return element;
      }
      addBeforeUpdateListener(callback) {
        return this.addListener("beforeUpdate", callback);
      }
      update() {
        if (!this._firstUpdate) {
          return;
        }
        this.dispatch("beforeUpdate", this);
        for (const key of Object.keys(this)) {
          if (this[key] instanceof DynamicStyleElement) {
            const desc = this["__style__" + key];
            const func = desc && desc.objInitializer;
            if (func) {
              this[key].options.style = func.call(this);
            }
          }
        }
        let children = [];
        for (let value of this.elements) {
          if (value instanceof StyleElement) {
            let styleElements = value.render();
            children.push(...styleElements);
          }
        }
        this.styleElement.options.children = children;
        this.styleElement.redraw();
      }
    }

    const COLORS_BY_NAME = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };

    /*
     * This class contains methods for operating with colors. Its objects are kept in hsva format with normalized
     * attributes (each attribute has value between 0 and 1 inclusive), and can be converted from/to rgba.
     */
    let Color$1 = class Color {
      constructor(color) {
        if (color) {
          this.setColor(color);
        }
      }
      setColor(color) {
        this.color = this.constructor.parseColor(color);
      }
      getColor() {
        let rgba = Color.parseColor(this);
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3]})`;
      }

      /*
       * @param color A color string of the types: native name, hex3, hex6, rgb, rgba, hsl, hsla
       *              or a Color object, or a hsla color array
       */
      static parseColor(color) {
        if (color instanceof Color) {
          return color.color;
        } else if (color instanceof Array) {
          // Add the alpha parameter at the end
          if (color.length === 3) {
            color.push(1);
          }
          return color;
        }
        color = color.trim().toLowerCase();

        // Check if color is given by name
        if (COLORS_BY_NAME.hasOwnProperty(color)) {
          color = COLORS_BY_NAME[color];
        }
        let values = [];

        // Check for hex3 (e.g. "#f00")
        let hex3 = color.match(/^#([0-9a-f]{3})$/i);
        if (hex3) {
          values = [parseInt(hex3[1].charAt(0), 16) * 0x11, parseInt(hex3[1].charAt(1), 16) * 0x11, parseInt(hex3[1].charAt(2), 16) * 0x11, 1];
        }

        // Check for hex6 (e.g. "#ff0000")
        let hex6 = color.match(/^#([0-9a-f]{6})$/i);
        if (hex6) {
          values = [parseInt(hex6[1].substr(0, 2), 16), parseInt(hex6[1].substr(2, 2), 16), parseInt(hex6[1].substr(4, 2), 16), 1];
        }

        // Check for rgba (e.g. "rgba(255, 0, 0, 0.5)")
        let rgba = color.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+\.?\d*)\s*\)$/i);
        if (rgba) {
          values = [parseInt(rgba[1]), parseInt(rgba[2]), parseInt(rgba[3]), parseFloat(rgba[4])];
        }

        // Check for rgb (e.g. "rgb(255, 0, 0)")
        let rgb = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
        if (rgb) {
          values = [parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3]), 1];
        }
        return values;
      }

      // TODO: this should be implemented as a factory that generates an interpolator object, that just takes in a t
      static interpolate(firstColor, secondColor, t = 0.5) {
        let firstColorArray = Color.parseColor(firstColor);
        let secondColorArray = Color.parseColor(secondColor);
        return Color.convertToRgba([parseInt(firstColorArray[0] * (1 - t) + secondColorArray[0] * t), parseInt(firstColorArray[1] * (1 - t) + secondColorArray[1] * t), parseInt(firstColorArray[2] * (1 - t) + secondColorArray[2] * t), parseFloat(firstColorArray[3] * (1 - t) + secondColorArray[3] * t)]);
      }
      static addOpacity(color, opacity) {
        let colorArray = Color.parseColor(color);
        return Color.convertToRgba([parseInt(colorArray[0]), parseInt(colorArray[1]), parseInt(colorArray[2]), opacity]);
      }
      static convertToRgba(rgba) {
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3]})`;
      }
      static isLight(color) {
        let values = Color.parseColor(color);
        return values[0] * 0.3 + values[1] * 0.59 + values[2] * 0.11 > 188;
      }
      static isWhite(color) {
        let values = Color.parseColor(color);
        return values[0] === 255 && values[1] === 255 && values[2] === 255 && values[3] === 1;
      }
      static isBlack(color) {
        let values = Color.parseColor(color);
        return values[0] === 0 && values[1] === 0 && values[2] === 0 && values[3] === 1;
      }
    };
    function lighten(color, amount) {
      if (amount >= 0) {
        return Color$1.interpolate(color, "#fff", amount);
      } else {
        return darken(color, -amount);
      }
    }
    function darken(color, amount) {
      if (amount >= 0) {
        let rgba = Color$1.parseColor(Color$1.interpolate(color, "#000", amount));
        for (let i = 0; i < 3; i += 1) {
          let root = Math.pow(255 - rgba[i], 0.7);
          rgba[i] = parseInt(rgba[i] - root * amount);
          if (rgba[i] < 0) {
            rgba[i] = 0;
          }
        }
        return Color$1.convertToRgba(rgba);
      } else {
        return lighten(color, -amount);
      }
    }
    const COLOR_MATCHER_REGEXP = new RegExp(`(#[0-9a-f]{6}|#[0-9a-f]{3}|rgba\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d*\\.?\\d*\\s*\\)|rgb\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*\\))|${Object.keys(COLORS_BY_NAME).sort((a, b) => b.length - a.length).join("|")}`, "gi");
    function saturateColor(color, saturate) {
      const rgba = Color$1.parseColor(color);
      const rgb = rgba.slice(0, 3);
      const maxValueIndex = rgb.findIndex(x => x === Math.max(...rgb));
      const minValueIndex = rgb.findIndex((x, i) => x === Math.min(...rgb) && i !== maxValueIndex);
      const midValueIndex = 3 - minValueIndex - maxValueIndex;
      const lightness = (rgb[maxValueIndex] + rgb[minValueIndex]) / 2 / 255;
      const grayValue = lightness * 255;
      const saturationRange = Math.round(Math.min(255 - grayValue, grayValue));
      const saturateSign = saturate > 0 ? 1 : -1;
      const saturateValue = Math.abs(saturate);
      const maxChange = saturate > 0 ? Math.min(255 - rgb[maxValueIndex], Math.max(saturate * 30, rgb[minValueIndex])) : grayValue - rgb[minValueIndex];
      const changeAmount = Math.min(saturationRange * saturateValue, maxChange);
      const highDiff = grayValue - rgb[maxValueIndex];
      const midDiff = grayValue - rgb[midValueIndex];
      let midValueRatio;
      if (highDiff === 0) {
        midValueRatio = 1;
      } else {
        midValueRatio = midDiff / highDiff;
      }
      rgb[minValueIndex] -= saturateSign * changeAmount;
      rgb[maxValueIndex] += saturateSign * changeAmount;
      rgb[midValueIndex] = grayValue + (rgb[maxValueIndex] - grayValue) * midValueRatio;
      return Color$1.convertToRgba([...rgb.map(x => Math.min(255, Math.max(0, Math.round(x)))), rgba[3]]);
    }
    function enhanceColor(color, amount, saturate) {
      let enhancedColor;
      if (Color$1.isLight(color)) {
        enhancedColor = darken(color, amount);
      } else {
        enhancedColor = lighten(color, amount);
      }
      return saturateColor(enhancedColor, saturate);
    }

    // gamma: [-1,1], saturate: [-1,1] (you can also try bigger values, seems to be working fine, heh)
    function enhance(colorContainingString, gamma, saturate = 0) {
      return colorContainingString.replace(COLOR_MATCHER_REGEXP, color => enhanceColor(color, gamma, saturate));
    }
    function buildColors(color, dark = true) {
      let colors = [];
      let darkenPercents;
      if (!dark) {
        darkenPercents = [0.1, 0, -0.2, -0.3, -0.35, -0.2, -1];
      } else if (Color$1.isLight(color)) {
        darkenPercents = [0.05, 0, 0.05, 0.1, 0.15, 0.3, 0.8];
      } else {
        darkenPercents = [-0.3, 0, 0.1, 0.2, 0.23, 0.1, -1];
      }
      for (let i = 0; i < darkenPercents.length; i += 1) {
        colors.push(darken(color, darkenPercents[i]));
      }
      return colors;
    }
    class ColorGenerator {
      static getPersistentColor(uniqueId) {
        if (uniqueId < this.FIRST_COLORS.length) {
          return this.FIRST_COLORS[uniqueId];
        }
        if (!this.cache.has(uniqueId)) {
          this.cache.set(uniqueId, this.getRandomColor());
        }
        return this.cache.get(uniqueId);
      }
      static getRandomColor() {
        const allowed = "3456789ABC";
        let color = "#";
        for (let i = 0; i < 6; i += 1) {
          color += allowed.charAt(parseInt(Math.random() * allowed.length));
        }
        return color;
      }
    }
    ColorGenerator.FIRST_COLORS = ["#337ab7", "#5cb85c", "#f0ad4e", "#5bc0de", "#d9534f"];
    ColorGenerator.cache = new Map();

    // Primitive utils for wrapping browser info

    function isTouchDevice() {
      return !!("createTouch" in window.document || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || "ontouchstart" in window);
    }
    function isMobileDevice() {
      const mobileDevices = ["Android", "webOS", "iPad", "iPhone", "iPod", "BlackBerry", "Windows Phone"];
      for (let device of mobileDevices) {
        if (navigator.userAgent.indexOf(device) !== -1) {
          return true;
        }
      }
      return false;
    }
    function isLandscape() {
      if (window.orientation && (window.orientation === -90 || window.orientation === 90)) {
        return true;
      }
      if (!isMobileDevice()) {
        return window.innerWidth > window.innerHeight;
      }
      const width = isMobileDevice() && window.screen?.width || window.innerWidth;
      const height = isMobileDevice() && window.screen?.height || window.innerHeight;
      return width > height || height < 380;
    }
    function getEventTouchIdentifier(event) {
      return Math.min(...[...event.touches].map(touch => touch.identifier));
    }
    function getEventTouch(event) {
      const identifier = getEventTouchIdentifier(event);
      return [...event.touches].find(touch => touch.identifier === identifier);
    }
    function getEventCoord(event, axis, reference = "client") {
      let coordName = reference + axis;
      if (event[coordName]) {
        return event[coordName];
      }
      if (event.touches) {
        return getEventTouch(event)[coordName];
      }
      if (event.originalEvent) {
        return getEventCoord(event.originalEvent, axis, reference);
      }
      console.warn("Couldn't find coordinates for event. Maybe wrong reference point? (client/page/screen)");
    }
    function getEventX(event, reference = "client") {
      return getEventCoord(event, "X", reference);
    }
    function getEventY(event, reference = "client") {
      return getEventCoord(event, "Y", reference);
    }
    function getBrowser() {
      // TODO: should try to use navigator
      if (!!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {
        return "Opera";
      }
      if (typeof InstallTrigger !== 'undefined') {
        return "Firefox";
      }
      if (Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {
        return "Safari";
      }
      if (document.documentMode) {
        return "Internet Explorer";
      }
      if (window.StyleMedia) {
        return "Edge";
      }
      if (window.chrome && window.chrome.webstore) {
        return "Chrome";
      }
      return "Unknown";
    }
    const supportsEventCache = new Map();
    function supportsEvent(eventName) {
      if (!supportsEventCache.has(eventName)) {
        var element = document.createElement("div");
        let onEventName = "on" + eventName;
        var isSupported = (onEventName in element);
        if (!isSupported) {
          element.setAttribute(onEventName, "return;");
          isSupported = typeof element[onEventName] === "function";
        }
        element = null;
        supportsEventCache.set(eventName, isSupported);
      }
      return supportsEventCache.get(eventName);
    }

    // This object is deprecated, use the functions in this file directly instead.
    const Device = {
      isTouchDevice,
      isMobileDevice,
      isLandscape,
      getEventTouchIdentifier,
      getEventTouch,
      getEventCoord,
      getEventX,
      getEventY,
      getBrowser,
      supportsEvent
    };

    const Orientation$1 = {
      HORIZONTAL: 1,
      VERTICAL: 2
    };
    const Direction = {
      UP: "up",
      LEFT: "left",
      DOWN: "down",
      RIGHT: "right"
    };
    const Level = {
      INFO: "info",
      PRIMARY: "primary",
      SECONDARY: "secondary",
      SUCCESS: "success",
      WARNING: "warning",
      DANGER: "error",
      ERROR: "error"
    };
    const Size = {
      NONE: null,
      EXTRA_SMALL: "xs",
      SMALL: "sm",
      LARGE: "lg",
      EXTRA_LARGE: "xl"
    };
    const VoteStatus = {
      NONE: null,
      LIKE: 1,
      DISLIKE: 0
    };
    const ActionStatus = {
      INITIAL: 1,
      RUNNING: 2,
      SUCCESS: 3,
      FAILED: 4
    };

    var _class2$12, _descriptor8$n, _descriptor9$i, _class3$o, _descriptor10$e, _descriptor11$c, _descriptor12$a, _descriptor13$9, _descriptor14$9, _class4$d, _descriptor15$8, _descriptor16$8, _descriptor17$8;

    // TODO: export these properly, don't use a namespace here

    function getTextColor(backgroundColor) {
      return enhance(backgroundColor, 1);
    }
    Theme.setProperties({
      // TODO use _COLOR as a suffix
      COLOR_BACKGROUND: "#fff",
      COLOR_BACKGROUND_ALTERNATIVE: "#eee",
      COLOR_BACKGROUND_BODY: "#f8f8f8",
      COLOR_FOREGROUND_BODY: "#f2f2f2",
      COLOR_BACKGROUND_BADGE: "#777",
      COLOR_PRIMARY: "#337ab7",
      COLOR_SECONDARY: "#358ba4",
      COLOR_SUCCESS: "#5cb85c",
      COLOR_INFO: "#5bc0de",
      COLOR_WARNING: "#f0ad4e",
      COLOR_DANGER: "#d9534f",
      COLOR_LINK: "#337ab7",
      FONT_SIZE_EXTRA_SMALL: 10,
      FONT_SIZE_SMALL: 12,
      FONT_SIZE_DEFAULT: 14,
      FONT_SIZE_LARGE: 17,
      FONT_SIZE_EXTRA_LARGE: 21,
      FONT_WEIGHT_DEFAULT: 400,
      FONT_WEIGHT_BOLD: 700,
      GENERAL_LINE_HEIGHT: "1.5",
      BASE_DISABLED_OPACITY: FloatType(0.6),
      DEFAULT_TRANSITION_DURATION_MS: 250,
      DEFAULT_TRANSITION: props => props.DEFAULT_TRANSITION_DURATION_MS + "ms ease",
      BASE_BORDER_RADIUS: 0,
      BASE_BOX_SHADOW: "0px 0px 10px rgb(160, 162, 168)",
      BASE_BORDER_WIDTH: 0,
      BASE_BORDER_STYLE: "solid",
      BASE_BORDER_COLOR: "#ddd",
      BUTTON_PADDING: "6px 12px",
      BUTTON_BORDER_RADIUS: props => props.BASE_BORDER_RADIUS,
      BUTTON_COLOR: props => props.COLOR_BACKGROUND,
      BUTTON_FONT_WEIGHT: props => props.FONT_WEIGHT_DEFAULT,
      TOGGLE_COLOR: "#086472",
      TOGGLE_BACKGROUND: "#D2E2E5",
      TOGGLE_PILL_SIZE: 20,
      TOGGLE_DISABLED_BACKGROUND: "#78AAB2",
      TOGGLE_SHADOW: "0 1px 1px 0 rgba(0,0,0,.14), 0 2px 1px -1px rgba(0,0,0,.12), 0 1px 3px 0 rgba(0,0,0,.2)",
      CARD_HEADER_BACKGROUND_COLOR: "#ccc",
      CARD_HEADER_TEXT_COLOR: "#222",
      CARD_HEADER_HEIGHT: "",
      CARD_PANEL_HEADER_HEIGHT: 30,
      CARD_PANEL_HEADER_HEIGHT_LARGE: 40,
      CARD_PANEL_HEADING_PADDING: 10,
      CARD_PANEL_HEADING_PADDING_LARGE: 20,
      CARD_PANEL_TEXT_TRANSFORM: "inherit",
      DARK_BOX_SHADOW: "0px 0px 10px rgba(0, 0, 0, .6)",
      ROW_LIST_ROW_HEIGHT: 30,
      ROW_LIST_ROW_HEIGHT_LARGE: 40,
      ROW_LIST_ROW_PADDING: 10,
      ROW_LIST_ROW_PADDING_LARGE: 20,
      ROW_LIST_ROW_BORDER_WIDTH: 1,
      FONT_FAMILY_SANS_SERIF: "Lato, 'Segoe UI', 'Lucida Sans Unicode', 'Helvetica Neue', Helvetica, Arial, sans-serif",
      FONT_FAMILY_SERIF: "serif",
      FONT_FAMILY_MONOSPACE: "'Source Code Pro', Menlo, Monaco, Consolas, 'Courier New', monospace",
      FONT_FAMILY_DEFAULT: props => props.FONT_FAMILY_SANS_SERIF,
      NAV_MANAGER_NAVBAR_HEIGHT: 50,
      NAV_MANAGER_BOX_SHADOW_NAVBAR: "0px 0px 10px rgb(0, 0, 0)",
      NAV_MANAGER_BOX_SHADOW_SIDE_PANEL: "0px 0px 10px #202e3e",
      MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP: 0,
      MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE: 0,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_DESKTOP: 0,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_MOBILE: 0,
      FLAT_TAB_AREA_LINE_HEIGHT: 30,
      FLAT_TAB_AREA_PADDING_SIDES: 10,
      FLAT_TAB_AREA_UNDERLINE_HEIGHT: 3,
      INPUT_BACKGROUND: "#fff",
      INPUT_BORDER_COLOR: "#E5EAE9",
      INPUT_BORDER_RADIUS: 4
    }, false);
    class BasicLevelSizeStyleSheet extends StyleSheet {
      Level(level) {
        if (!level) {
          return null;
        }
        if (this[level]) {
          return this[level];
        }
        for (let type of Object.keys(Level)) {
          if (level == Level[type]) {
            return this[type];
          }
        }
      }
      Size(size) {
        if (!size) {
          return null;
        }
        for (let type of Object.keys(Size)) {
          if (size == Size[type]) {
            return this[type];
          }
        }
      }
    }
    const BasicLevelStyleSheet = colorToStyleFunction => {
      var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      return _class = class BasicLevelStyleClass extends BasicLevelSizeStyleSheet {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "BASE", _descriptor, this);
          _initializerDefineProperty(this, "PRIMARY", _descriptor2, this);
          _initializerDefineProperty(this, "SECONDARY", _descriptor3, this);
          _initializerDefineProperty(this, "SUCCESS", _descriptor4, this);
          _initializerDefineProperty(this, "INFO", _descriptor5, this);
          _initializerDefineProperty(this, "WARNING", _descriptor6, this);
          _initializerDefineProperty(this, "DANGER", _descriptor7, this);
        }
        colorStyleRule(color, textColor) {
          return colorToStyleFunction(color, textColor || getTextColor(color));
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "BASE", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_BACKGROUND);
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "PRIMARY", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_PRIMARY);
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "SECONDARY", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_SECONDARY);
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "SUCCESS", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_SUCCESS);
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "INFO", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_INFO);
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "WARNING", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_WARNING);
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, "DANGER", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_DANGER);
        }
      })), _class;
    };
    let FlexContainerStyle = (_class2$12 = class FlexContainerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "HORIZONTAL", _descriptor8$n, this);
        _initializerDefineProperty(this, "VERTICAL", _descriptor9$i, this);
      }
      Orientation(orientation) {
        for (let type of Object.keys(Orientation$1)) {
          if (orientation == Orientation$1[type]) {
            return this[type];
          }
        }
      }
    }, (_descriptor8$n = _applyDecoratedDescriptor(_class2$12.prototype, "HORIZONTAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          ">*": {
            marginLeft: 20,
            flex: "1"
          },
          ">:first-child": {
            marginLeft: 0
          }
        };
      }
    }), _descriptor9$i = _applyDecoratedDescriptor(_class2$12.prototype, "VERTICAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column",
          ">*": {
            marginTop: 20,
            flex: "1"
          },
          ">:first-child": {
            marginTop: 0
          }
        };
      }
    })), _class2$12);
    let ContainerStyle = (_class3$o = class ContainerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor10$e, this);
        _initializerDefineProperty(this, "SMALL", _descriptor11$c, this);
        _initializerDefineProperty(this, "MEDIUM", _descriptor12$a, this);
        _initializerDefineProperty(this, "LARGE", _descriptor13$9, this);
        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor14$9, this);
      }
      getSizeStyle(mobilePixels, desktopPercent) {
        return {
          margin: Device.isMobileDevice() ? `0 ${mobilePixels}px` : `0% ${desktopPercent}%`
        };
      }
      Size(size) {
        for (let type of Object.keys(Size)) {
          if (size == Size[type]) {
            return this[type];
          }
        }
      }
    }, (_descriptor10$e = _applyDecoratedDescriptor(_class3$o.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(6, 15);
      }
    }), _descriptor11$c = _applyDecoratedDescriptor(_class3$o.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(4, 10);
      }
    }), _descriptor12$a = _applyDecoratedDescriptor(_class3$o.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(4, 6);
      }
    }), _descriptor13$9 = _applyDecoratedDescriptor(_class3$o.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(2, 3);
      }
    }), _descriptor14$9 = _applyDecoratedDescriptor(_class3$o.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(2, 1);
      }
    })), _class3$o);
    let StyleUtils = (_class4$d = class StyleUtils extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.extraTop = () => this.themeProps[Device.isMobileDevice() ? "MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE" : "MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP"];
        _initializerDefineProperty(this, "fullHeight", _descriptor15$8, this);
        _initializerDefineProperty(this, "hidden", _descriptor16$8, this);
        // Use this class for content that has no space between it and the navbar.
        _initializerDefineProperty(this, "fullContainer", _descriptor17$8, this);
      }
    }, (_descriptor15$8 = _applyDecoratedDescriptor(_class4$d.prototype, "fullHeight", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%"
        };
      }
    }), _descriptor16$8 = _applyDecoratedDescriptor(_class4$d.prototype, "hidden", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "none"
        };
      }
    }), _descriptor17$8 = _applyDecoratedDescriptor(_class4$d.prototype, "fullContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: () => "calc(100% + " + this.extraTop() + "px)",
          marginTop: () => -this.extraTop()
        };
      }
    })), _class4$d); // TODO simplify this
    const GlobalStyle = StyleUtils.getInstance();
    GlobalStyle.FlexContainer = FlexContainerStyle.getInstance();
    GlobalStyle.Container = ContainerStyle.getInstance();
    GlobalStyle.Utils = StyleUtils.getInstance();

    class Switcher extends UI$1.Element {
      constructor(options) {
        super(options);
        this.childMap = new WeakMap();
        this.numRedraws = 0;
      }
      getPreferredActive() {
        const {
          children
        } = this.options;
        for (const child of children) {
          if (child.options.active) {
            return child;
          }
        }
        return children[0] || this.activeChild;
      }
      getDefaultOptions() {
        return {
          fullHeight: false,
          preserveScroll: true
        };
      }
      extraNodeAttributes(attr) {
        if (this.options.fullHeight) {
          attr.addClass(GlobalStyle.Utils.fullHeight);
        }
      }
      copyState(element) {
        let options = Object.assign({}, element.options, {
          children: this.overwriteChildren(this.options.children || [], element.options.children || [])
        });

        // TODO @Mihai use the logic from UIElement.copyState
        this.setOptions(options);
        this.activeChild = this.getPreferredActive();
      }
      render() {
        return this.activeChild || this.options.children[0];
      }
      overwriteChildren(existingChildren, newChildren) {
        let keyMap = this.getElementKeyMap(existingChildren) || new Map();
        for (let i = 0; i < newChildren.length; i += 1) {
          let newChild = newChildren[i];
          let newChildKey = newChild.options && newChild.options.key || "autokey" + i;
          let existingChild = keyMap.get(newChildKey);
          if (existingChild === newChild) {
            continue;
          }
          const wasActive = existingChild === this.activeChild;
          if (existingChild && newChild.canOverwrite(existingChild)) {
            newChildren[i] = newChild = this.overwriteChild(existingChild, newChild);
          }
          if (wasActive) {
            newChild.options.active = true;
          }
        }
        return newChildren;
      }
      redraw() {
        this.numRedraws += 1;

        //basic things for our current node
        this.applyNodeAttributes();
        this.applyRef();

        // This render may be required to update this.options.children
        RenderStack.push(this);
        this.render();
        RenderStack.pop();
        if (this.options.children.length == 0) {
          return;
        }
        const activeChild = this.activeChild || this.options.children[0];
        for (let child of this.options.children) {
          if (child === activeChild) {
            continue;
          }
          if (this.options.lazyRender) {
            this.getChildProperties(child).isUpToDate = false;
            child.applyRef();
          } else {
            this.updateChild(child);
          }
        }
        this.updateActiveChild(activeChild);
      }
      getChildProperties(child) {
        if (!this.childMap.has(child)) {
          this.childMap.set(child, {
            isMounted: !!child.node,
            redrawIndex: -1
          });
        }
        return this.childMap.get(child);
      }
      updateChild(child) {
        if (this.getChildProperties(child).redrawIndex < this.numRedraws) {
          if (!child.node) {
            child.mount(this);
          } else {
            child.redraw();
          }
          this.getChildProperties(child).redrawIndex = this.numRedraws;
        }
      }
      appendChild(child, doMount = false) {
        this.options.children.push(child);
        if (doMount) {
          child.mount(this);
        }
        if (this.options.children.length == 1) {
          this.setActive(child);
        }
        return child;
      }
      getActive() {
        return this.activeChild;
      }
      insertChildNodeBefore(child, nextSibling) {
        let childProperties = this.getChildProperties(child);
        childProperties.isMounted = true;
        childProperties.redrawIndex = this.numRedraws;
      }
      updateActiveChild(element) {
        // Removing and reinserting the same node is inefficient, so
        // just update the internal state of the switcher instead.
        if (element && element.node === this.node.firstChild) {
          this.updateChild(element);
          this.children[0] = this.activeChild = element;
          return;
        }
        while (this.node.firstChild) {
          //TODO: would be useful here to be able to access the matching UI Element
          this.node.removeChild(this.node.firstChild);
        }
        if (!element) {
          this.activeChild = null;
          return;
        }
        this.updateChild(element);
        this.node.appendChild(element.node);
        this.children[0] = this.activeChild = element;
      }
      deactivateChild(child) {
        child.dispatch("hide");
        child.dispatch("setActive", false);
        if (this.options.preserveScroll) {
          this.getChildProperties(child).scrollTop = this.node.scrollTop;
        }
      }
      activateChild(child) {
        child.dispatch("setActive", true);
        child.dispatch("show");
        if (this.options.preserveScroll) {
          this.node.scrollTop = this.getChildProperties(child).scrollTop || 0;
        }
      }
      setActive(element) {
        if (this.activeChild === element) {
          return;
        }
        if (this.activeChild) {
          this.deactivateChild(this.activeChild);
        }
        this.updateActiveChild(element);
        if (this.activeChild) {
          this.activateChild(this.activeChild);
        }
      }
      hasChild(element) {
        return this.childMap.has(element);
      }
      onMount() {
        this.addListener("shouldRedrawChild", event => {
          if (event.child.isInDocument()) {
            event.child.redraw();
          } else {
            this.getChildProperties(event.child).isUpToDate = false;
          }
        });
      }
    }

    class PageTitleManager {
      static getPrefix() {
        return this.prefix;
      }
      static setPrefix(prefix) {
        this.prefix = prefix;
        this.updatePageTitle();
      }
      static setDefaultTitle(defaultTitle) {
        this.defaultTitle = defaultTitle;
      }
      static getTitle() {
        return this.title || this.defaultTitle;
      }
      static setTitle(title) {
        this.title = title;
        this.updatePageTitle();
      }
      static getFullPageTitle() {
        return unwrapArray([this.getPrefix(), this.getTitle()]).join(" - ");
      }
      static updatePageTitle() {
        document.title = this.getFullPageTitle();
      }
      static setIcon() {
        throw Error("Not implemented yet!");
      }
    }
    PageTitleManager.title = null;
    PageTitleManager.defaultTitle = "Website";
    PageTitleManager.prefix = null;

    class Router extends Switcher {
      // Return a historic page, depth = 0 current, depth = 1 previous, etc
      static getHistoricPath(depth) {
        depth = Math.abs(depth); // So negatives also work
        const index = this.localHistory.length - 1 - depth;
        if (index < 0) {
          return null;
        }
        const url = this.localHistory[index];

        // TODO @cleanup this should use new URL(url), only keeping Denis's shit code to not break anything
        return url.split("?")[0].split("#")[0];
      }
      static getCurrentPath() {
        let path = "";
        if (this.useLocalHistory && this.localHistory.length) {
          // We do this to get rid of query params or hash params
          path = this.getHistoricPath(0);
        } else {
          path = location.pathname;
        }
        return path;
      }
      static parseURL(path = location.pathname) {
        if (!Array.isArray(path)) {
          path = path.split("/");
        }
        return path.filter(str => str != "");
      }
      static joinQueryParams(queryParams = {}) {
        return Object.keys(queryParams).map(param => `${encodeURIComponent(param)}=${encodeURIComponent(queryParams[param])}`).join("&");
      }
      static formatURL(url) {
        if (Array.isArray(url)) {
          url = url.length ? "/" + url.join("/") : "/";
        }
        if (isString(url) && url[0] !== "/") {
          url = "/" + url;
        }
        return url;
      }
      static changeURL(url, options = {
        queryParams: {},
        state: {},
        replaceHistory: false,
        forceElementUpdate: false,
        keepSearchParams: false
      }) {
        url = this.formatURL(url);
        if (options.queryParams && Object.keys(options.queryParams).length > 0) {
          const queryString = this.joinQueryParams(options.queryParams);
          url = `${url}?${queryString}`;
        } else if (options.keepSearchParams) {
          url += location.search;
        }
        if (url === window.location.pathname && !options.forceElementUpdate) {
          // We're already here
          return;
        }
        options.state = options.state || {};
        const historyArgs = [options.state, PageTitleManager.getTitle(), url];
        if (this.useLocalHistory) {
          if (options.replaceHistory) {
            this.localHistory.pop();
          }
          if (this.localHistory.length === 0 || this.localHistory[this.localHistory.length - 1] != url) {
            this.localHistory.push(url);
          }
        } else {
          if (options.replaceHistory) {
            window.history.replaceState(...historyArgs);
          } else {
            window.history.pushState(...historyArgs);
          }
        }
        this.updateURL();
      }
      static onPopState() {
        this.changeURL(this.parseURL(this.getCurrentPath()), {
          replaceHistory: true,
          forceElementUpdate: true,
          keepSearchParams: true
        });
        Dispatcher.Global.dispatch("externalURLChange");
      }
      static back() {
        if (this.useLocalHistory) {
          this.localHistory.pop();
          this.onPopState();
        } else {
          window.history.back();
        }
      }
      static updateURL() {
        this.Global.setURL(this.parseURL(this.getCurrentPath()));
      }
      static setGlobalRouter(router) {
        this.Global = router;
        window.onpopstate = () => {
          this.onPopState();
        };
        if (this.globalSetURL) {
          this.Global.setURL = this.globalSetURL;
        }
        this.updateURL();
      }
      clearCache() {
        this.getRoutes().clearCache();
      }

      // TODO: should be named getRootRoute() :)
      getRoutes() {
        return this.options.routes;
      }
      getPageNotFound() {
        const element = UI$1.createElement("h1", {
          children: ["Can't find url, make sure you typed it correctly"]
        });
        element.pageTitle = "Page not found";
        return element;
      }
      getPageToRender(urlParts) {
        const result = this.getRoutes().getPage(urlParts);
        if (result === false) {
          return this.getPageNotFound();
        }
        if (Array.isArray(result)) {
          this.constructor.changeURL(...result);
          return null;
        }
        return result;
      }
      deactivateChild(child) {
        super.deactivateChild(child);
        if (child.options.doNotCache) {
          child.destroyNode();
        }
      }
      setURL(urlParts) {
        urlParts = unwrapArray(urlParts);
        const page = this.getPageToRender(urlParts);
        if (!page) return;
        const activePage = this.getActive();
        if (activePage !== page) {
          activePage?.dispatch("urlExit");
          this.setActive(page);
          page.dispatch("urlEnter");
        } else {
          page.dispatch("urlReload");
        }
        if (page.pageTitle) {
          PageTitleManager.setTitle(page.pageTitle);
        }
        this.dispatchChange(urlParts, page, activePage);
      }
      onMount() {
        if (!Router.Global) {
          this.constructor.setGlobalRouter(this);
        }
      }
    }
    // TODO: This works bad with query params. Fix it!
    Router.localHistory = [];
    // If we want the router to not alter the window history, use this instead.
    Router.useLocalHistory = false;
    class Route {
      getDefaultOptions() {
        return {
          beforeEnter: null,
          cachePage: true
        };
      }
      constructor(expr, pageGenerator, subroutes = [], options = {}) {
        this.cachedPages = new Map();
        this.expr = expr instanceof Array ? expr : [expr];
        this.pageGenerator = pageGenerator;
        this.subroutes = unwrapArray(subroutes);
        if (typeof options === "string") {
          options = {
            title: options
          };
        }
        this.options = {
          ...this.getDefaultOptions(),
          ...options
        };
        this.cachedPages = new Map();
      }
      clearCache() {
        this.cachedPages.clear();
        for (const subroute of this.subroutes) {
          if (subroute.clearCache) {
            subroute.clearCache();
          }
        }
      }
      matches(urlParts) {
        if (urlParts.length < this.expr.length) {
          return null;
        }
        let args = [];
        for (let i = 0; i < this.expr.length; i += 1) {
          const isArg = this.expr[i] === this.constructor.ARG_KEY;
          if (urlParts[i] != this.expr[i] && !isArg) {
            return null;
          }
          if (isArg) {
            args.push(urlParts[i]);
          }
        }
        return {
          args: args,
          urlParts: urlParts.slice(this.expr.length)
        };
      }
      getPageTitle() {
        return this.options.title;
      }
      getPageGuard() {
        return this.options.beforeEnter;
      }
      generatePage(pageGenerator, ...argsArray) {
        if (!pageGenerator) {
          return null;
        }
        const serializedArgs = argsArray.toString();
        if (!this.cachedPages.has(serializedArgs)) {
          const args = unwrapArray(argsArray);
          const generatorArgs = {
            args,
            argsArray,
            doNotCache: this.options.doNotCache
          };
          const page = pageGenerator.prototype instanceof UI$1.Element ? new pageGenerator(generatorArgs) : pageGenerator(generatorArgs);
          if (page && !page.pageTitle) {
            const myPageTitle = this.getPageTitle();
            if (myPageTitle) {
              page.pageTitle = this.getPageTitle();
            }
          }
          if (this.options.doNotCache) {
            return page;
          }
          this.cachedPages.set(serializedArgs, page);
        }
        return this.cachedPages.get(serializedArgs);
      }
      matchesOwnNode(urlParts) {
        return urlParts.length === 0;
      }
      executeGuard() {
        const pageGuard = this.getPageGuard();
        if (!pageGuard) {
          return null;
        }
        return pageGuard(this.getSnapshot());
      }
      getPage(urlParts, router, ...argsArray) {
        let match;
        let matchingRoute = this.matchesOwnNode(urlParts) ? this : null;
        if (!matchingRoute) {
          for (const subroute of this.subroutes) {
            match = subroute.matches(urlParts);
            if (!match) {
              continue;
            }
            if (match.args.length) {
              argsArray.push(match.args);
            }
            matchingRoute = subroute;
            break;
          }
        }
        if (!matchingRoute) {
          return false;
        }
        const guardResult = this.executeGuard();
        if (!guardResult) {
          return matchingRoute === this ? this.generatePage(this.pageGenerator, ...argsArray) : matchingRoute.getPage(match.urlParts, router, ...argsArray);
        }
        if (Array.isArray(guardResult)) {
          return guardResult;
        }
        return this.generatePage(guardResult, ...argsArray);
      }
      getSnapshot() {
        return {
          expr: this.expr,
          url: window.location.href,
          path: `${window.location.pathname}${window.location.search}`,
          params: new URLSearchParams(window.location.search)
        };
      }
    }
    Route.ARG_KEY = "%s";
    class TerminalRoute extends Route {
      constructor(expr, pageGenerator, options = {}) {
        super(expr, pageGenerator, [], options);
        this.timeout = null;
      }
      matchesOwnNode(urlParts) {
        return true;
      }
      getPage(urlParts, router) {
        const page = super.getPage(...arguments);
        // TODO: why is this in a setTimeout?
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          if (page?.setURL) {
            page.setURL(urlParts);
          }
        });
        return page;
      }
    }

    var _class$1$, _descriptor$11, _dec$1j, _class2$11;
    function sanitizeUrlFromOptions(options, key) {
      const rawURL = options[key];
      if (!rawURL || !rawURL.includes(":")) {
        return options;
      }
      const invalidateUrl = () => {
        console.error("Invalid URL", rawURL);
        options[key] = "";
        options.value = options.label = options.alt = "[Invalid URL]";
      };
      try {
        const url = new URL(rawURL);
        if (["http:", "https:", "mailto:", "tel:"].indexOf(url.protocol) === -1) {
          invalidateUrl();
        }
      } catch (e) {
        invalidateUrl();
      }
      return options;
    }
    let LinkStyle = (_class$1$ = class LinkStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$11, this);
      }
    }, (_descriptor$11 = _applyDecoratedDescriptor(_class$1$.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer"
        };
      }
    })), _class$1$);
    let Link = (_dec$1j = registerStyle(LinkStyle), _dec$1j(_class2$11 = class Link extends UI$1.Primitive("a") {
      getDefaultOptions() {
        return {
          newTab: false
        };
      }
      setOptions(options) {
        options = sanitizeUrlFromOptions(options, "href");
        super.setOptions(options);
        if (this.options.newTab) {
          this.options.target = "_blank";
        }
        return options;
      }
      render() {
        const {
          value,
          label
        } = this.options;
        return value || label || super.render();
      }
      changeRouteInternal() {
        // TODO Only if Router.Global exists?
        Router.changeURL(trimLocalUrl(this.options.href));
      }
      onMount() {
        this.addClickListener(event => {
          const {
            href,
            newTab,
            target
          } = this.options;
          const specialKeyPressed = event.shiftKey || event.ctrlKey || event.metaKey;
          const unroutable = !href || !isLocalUrl(href);
          if (specialKeyPressed || unroutable || newTab || target && target !== "_self") {
            // Leave it to the browser
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          this.changeRouteInternal();
        });
      }
    }) || _class2$11);

    class IFrame extends UI$1.Primitive("iframe") {}
    IFrame.domAttributesMap = new DOMAttributesMap(UI$1.Element.domAttributesMap, [["allow"], ["allowfullscreen", {
      noValue: true
    }], ["allowpaymentrequest", {
      noValue: true
    }], ["csp"], ["loading"], ["name"], ["referrerpolicy"], ["sandbox"], ["src"], ["srcdoc"], ["align"], ["frameborder"], ["longdesc"], ["marginheight"], ["marginwidth"], ["scrolling"], ["mozbrowser"]]);

    class Image extends UI$1.Primitive("img") {
      setOptions(options) {
        return super.setOptions(sanitizeUrlFromOptions(options, "src"));
      }
      addLoadListener(callback) {
        return this.addNodeListener("load", callback);
      }
    }

    // TODO: this file existed to hold generic classes in a period of fast prototyping, has a lot of old code

    // A very simple class, all this does is implement the `getTitle()` method
    // TODO Just deprecate this class?
    class Panel extends UI$1.Element {
      getTitle() {
        return this.options.title;
      }
    }

    function enqueueIfNotLoaded(target, key, descriptor) {
      const method = descriptor.value;
      return Object.assign({}, descriptor, {
        value: function () {
          if (this.isLoaded()) {
            return method.call(this, ...arguments);
          } else {
            this.enqueueMethodCall(method, arguments);
            return null;
          }
        }
      });
    }
    const EnqueueableMethodMixin = BaseClass => class EnqueueableMethodClass extends BaseClass {
      isLoaded() {
        throw Error("Not implemented!");
      }
      enqueueMethodCall(method, args) {
        this.methodCallQueue = this.methodCallQueue || [];
        this.methodCallQueue.push([method, args]);
      }
      resolveQueuedMethods() {
        if (!this.isLoaded()) {
          throw Error("Cannot process scheduled jobs, element not loaded");
        }
        for (let methodCall of this.methodCallQueue || []) {
          methodCall[0].call(this, ...methodCall[1]);
        }
        delete this.methodCallQueue;
      }
    };

    class ScriptResolver extends Dispatchable {
      constructor(scriptPath) {
        super();
        this.loaded = false;
        this.jobs = [];
        // TODO: should be more thought out
        let scriptElement = document.createElement("script");
        scriptElement.async = true;
        scriptElement.src = scriptPath;
        scriptElement.onload = () => this.onLoad();
        // TODO: what about error?
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
      }
      onLoad() {
        this.loaded = true;
        for (let i = 0; i < this.jobs.length; i += 1) {
          this.jobs[i](this);
        }
        this.jobs = [];
      }
      resolve(callback) {
        if (this.loaded) {
          callback(this);
          return;
        }
        this.jobs.push(callback);
      }
    }
    let scriptResolveMap = new Map();
    async function ensureSingle(script) {
      let scriptResolver = scriptResolveMap.get(script);
      if (!scriptResolver) {
        scriptResolver = new ScriptResolver(script);
        scriptResolveMap.set(script, scriptResolver);
      }
      return new Promise(function (resolve, reject) {
        scriptResolver.resolve(resolve, reject);
      });
    }
    async function ensure(scripts, callback) {
      scripts = toArray(scripts);
      let promises = scripts.map(script => ensureSingle(script));
      return Promise.all(promises).then(function () {
        if (callback) {
          callback(...arguments);
        }
      });
    }

    var _class$1_, _CodeEditor, _class2$10, _descriptor$10, _dec$1i, _class3$n;
    let CodeEditor = (_class$1_ = (_CodeEditor = class CodeEditor extends EnqueueableMethodMixin(UI$1.Element) {
      static requireAce(callback) {
        throw Error("You need to implement requireAce");
      }
      isLoaded() {
        return !!this.getAce();
      }
      setOptions(options) {
        let defaultOptions = {
          aceMode: "text",
          readOnly: false,
          aceTheme: "dawn",
          aceKeyboardHandler: "ace",
          fontSize: 14,
          tabSize: 4,
          showLineNumber: true,
          showPrintMargin: false,
          printMarginSize: 80
        };
        options = Object.assign(defaultOptions, options);
        if (options.aceMode) {
          options.aceMode = options.aceMode.toLowerCase();
        }
        if (options.aceMode === "cpp" || options.aceMode === "c") {
          options.aceMode = "c_cpp";
        }
        super.setOptions(options);
        if (this.getAce()) {
          this.applyAceOptions();
        }
      }
      redraw() {
        if (this.getAce()) {
          this.aceResize();
          this.applyRef();
          return;
        }
        super.redraw();
      }
      whenLoaded(callback) {
        if (this.isLoaded()) {
          callback();
        } else {
          this.addListenerOnce("aceReady", callback);
        }
      }
      onMount() {
        // Sometimes when the parent div resizes the ace editor doesn't fully update.
        this.addListener("resize", () => {
          this.aceResize();
        });
        this.addListener("change", () => {
          this.aceResize();
        });
        if (!window.ace) {
          this.constructor.requireAce(() => {
            this.onDelayedMount();
          });
          return;
        }
        this.onDelayedMount();
      }
      onDelayedMount() {
        this.ace = window.ace.edit(this.node);

        // Removes some warnings
        this.getAce().$blockScrolling = Infinity;
        this.resolveQueuedMethods();
        this.applyAceOptions();

        //#voodoo was here to automatically redraw when unhiding
        //This Ace event listener might be useful in the future
        this.getAce().renderer.$textLayer.addEventListener("changeCharacterSize", event => {
          this.aceResize();
        });
        this.dispatch("aceReady");
      }
      onUnmount() {
        this.getAce().destroy();
      }
      getAce() {
        return this.ace;
      }
      getValue() {
        return this.getAce().getValue();
      }
      applyAceOptions() {
        // TODO maybe only this should be with enqueueIfNotLoaded
        this.setAceMode(this.options.aceMode);
        this.setAceKeyboardHandler(this.options.aceKeyboardHandler);
        this.setAceTheme(this.options.aceTheme);
        this.setAceFontSize(this.options.fontSize);
        this.setAceTabSize(this.options.tabSize);
        this.setAceLineNumberVisible(this.options.showLineNumber);
        this.setAcePrintMarginVisible(this.options.showPrintMargin);
        this.setAcePrintMarginSize(this.options.printMarginSize);
        this.setReadOnly(this.options.readOnly);
        this.setUseWrapMode(this.options.lineWrapping || false);
        if (this.options.numLines) {
          this.options.maxLines = this.options.minLines = this.options.numLines;
        }
        if (this.options.maxLines) {
          this.setAceOptions({
            maxLines: this.options.maxLines
          });
        }
        if (this.options.minLines) {
          this.setAceOptions({
            minLines: this.options.minLines
          });
        }
        if (this.options.value) {
          this.setValue(this.options.value, -1);
        }
        if (this.options.hasOwnProperty("enableBasicAutocompletion") || this.options.hasOwnProperty("enableLiveAutocompletion")) {
          const {
            langToolsSrc
          } = this.constructor;
          if (!langToolsSrc) {
            console.warn("Autocompletion requires setting 'langToolSrc' in CodeEditor");
          } else {
            ensure([langToolsSrc], () => {
              this.setBasicAutocompletion(this.options.enableBasicAutocompletion);
              this.setLiveAutocompletion(this.options.enableLiveAutocompletion);
              this.setSnippets(this.options.enableSnippets);
            });
          }
        }
      }
      aceResize() {
        this.getAce().resize();
      }
      setValue(sourceCode, fakeUserChange) {
        // We need to wrap the ace call in these flags so any event listeners can know if this change
        // was done by us or by the user
        this.apiChange = !fakeUserChange;
        this.getAce().setValue(sourceCode, -1);
        this.apiChange = false;
      }
      setAceOptions(options) {
        this.getAce().setOptions(options);
      }

      // TODO: should this be setEditable?
      setReadOnly(value) {
        this.getAce().setReadOnly(value);
      }
      setAceMode(aceMode) {
        if (aceMode.hasOwnProperty("aceMode")) {
          aceMode = aceMode.aceMode;
        }
        this.getAce().getSession().setMode("ace/mode/" + aceMode);
      }
      getAceKeyboardHandler() {
        return this.getAce().$keybindingId;
      }
      setAceKeyboardHandler(keyboardHandler) {
        if (keyboardHandler.hasOwnProperty("aceName")) {
          keyboardHandler = keyboardHandler.aceName;
        }
        this.getAce().setKeyboardHandler("ace/keyboard/" + keyboardHandler);
      }
      getAceMode() {
        return this.getAce().getSession().getMode();
      }
      setAceTheme(theme) {
        if (theme.hasOwnProperty("aceName")) {
          theme = theme.aceName;
        }
        this.getAce().setTheme("ace/theme/" + theme);
      }
      getAceTheme() {
        return this.getAce().getTheme();
      }
      setAceFontSize(fontSize) {
        this.getAce().setOptions({
          fontSize: fontSize + "px"
        });
      }
      getAceFontSize() {
        return this.getAce().getFontSize();
      }
      setAceTabSize(tabSize) {
        this.getAce().setOptions({
          tabSize: tabSize
        });
      }
      getAceTabSize() {
        return this.getAce().getOption("tabSize");
      }
      setAceLineNumberVisible(value) {
        this.getAce().renderer.setShowGutter(value);
      }
      getAceLineNumberVisible() {
        return this.getAce().renderer.getShowGutter();
      }
      setAcePrintMarginVisible(value) {
        this.getAce().setShowPrintMargin(value);
      }
      getAcePrintMarginVisible() {
        return this.getAce().getShowPrintMargin();
      }
      setAcePrintMarginSize(printMarginSize) {
        this.getAce().setPrintMarginColumn(printMarginSize);
      }
      getAcePrintMarginSize() {
        return this.getAce().getPrintMarginColumn();
      }
      setBasicAutocompletion(value) {
        this.getAce().setOptions({
          enableBasicAutocompletion: value
        });
      }
      setLiveAutocompletion(value) {
        this.getAce().setOptions({
          enableLiveAutocompletion: value
        });
      }
      setSnippets(value) {
        this.getAce().setOptions({
          enableSnippets: value
        });
      }
      setAnnotations(annotations) {
        this.getAce().getSession().setAnnotations(annotations);
      }
      setUseWrapMode(value) {
        this.getAce().getSession().setUseWrapMode(value);
      }
      setIndentedSoftWrap(value) {
        this.getAce().setOption("indentedSoftWrap", value);
      }
      blockScroll() {
        this.getAce().$blockScrolling = Infinity;
      }
      setFoldStyle(foldStyle) {
        this.getAce().getSession().setFoldStyle(foldStyle);
      }
      setHighlightActiveLine(value) {
        this.getAce().setHighlightActiveLine(value);
      }
      setHighlightGutterLine(value) {
        this.getAce().setHighlightGutterLine(value);
      }
      setShowGutter(value) {
        this.getAce().renderer.setShowGutter(value);
      }
      getScrollTop() {
        return this.getAce().getSession().getScrollTop();
      }
      setScrollTop(value) {
        this.getAce().getSession().setScrollTop(value);
      }
      addMarker(startLine, startCol, endLine, endCol, ...args) {
        const Range = this.constructor.AceRange;
        return this.getAce().getSession().addMarker(new Range(startLine, startCol, endLine, endCol), ...args);
      }
      removeMarker(marker) {
        this.getAce().getSession().removeMarker(marker);
      }
      getRendererLineHeight() {
        return this.getAce().renderer.lineHeight;
      }
      getTextRange(startLine, startCol, endLine, endCol) {
        const Range = this.constructor.AceRange;
        return this.getAce().getSession().doc.getTextRange(new Range(startLine, startCol, endLine, endCol));
      }
      setTextRange(startLine, startCol, endLine, endCol, text) {
        const Range = this.constructor.AceRange;
        this.getAce().getSession().replace(new Range(startLine, startCol, endLine, endCol), text);
      }
      removeLine(line) {
        const Range = this.constructor.AceRange;
        this.getAce().getSession().getDocument().remove(new Range(line, 0, line + 1, 0));
      }
      insertAtLine(line, str) {
        let column = this.getAce().session.getLine(line - 1).length;
        this.getAce().gotoLine(line, column);
        this.insert(str);
      }
      replaceLine(line, str) {
        const Range = this.constructor.AceRange;
        this.getAce().getSession().getDocument().replace(new Range(line, 0, line + 1, 0), str);
      }
      addAceSessionEventListener(event, callback) {
        this.getAce().getSession().addEventListener(event, callback);
      }
      addAceSessionChangeListener(callback) {
        this.addAceSessionEventListener("change", callback);
      }
      addAceChangeListener(callback) {
        this.getAce().on("change", callback);
      }
      addChangeListener(callback) {
        this.getAce().getSession().addEventListener("change", callback);
      }
      addAceEventListener() {
        this.getAce().addEventListener(...arguments);
      }
      focus() {
        this.getAce().focus();
      }
      gotoEnd() {
        let editor = this.getAce();
        let editorRow = editor.session.getLength() - 1;
        let editorColumn = editor.session.getLine(editorRow).length;
        editor.gotoLine(editorRow + 1, editorColumn);
      }
      setUndoManager(undoManager) {
        this.getAce().getSession().setUndoManager(undoManager);
      }
      setAceRendererOption(key, value) {
        this.getAce().renderer.setOption(key, value);
      }

      // Inserts the text at the current cursor position
      insert(text) {
        this.getAce().insert(text);
      }

      // Appends the text at the end of the document
      append(text) {
        var lastRow = this.getAce().getSession().getLength() - 1;
        if (lastRow < 0) {
          lastRow = 0;
        }
        var lastRowLength = this.getAce().getSession().getLine(lastRow).length;
        var scrolledToBottom = this.getAce().isRowFullyVisible(lastRow);
        // console.log("Scroll to bottom ", scrolledToBottom);
        this.getAce().getSession().insert({
          row: lastRow,
          column: lastRowLength
        }, text);
        this.aceResize();
        if (scrolledToBottom) {
          // TODO: Include scroll lock option!
          // TODO: See if scrolling to bottom can be done better
          // TODO: for some reason the scroll bar height is not being updated, this needs to be fixed
          this.getAce().scrollToLine(this.getAce().getSession().getLength() - 1, true, true, function () {});
        }
      }
      copyTextToClipboard() {
        this.getAce().selectAll();
        this.getAce().focus();
        document.execCommand("copy");
      }
    }, _CodeEditor.langToolsSrc = null, _CodeEditor), (_applyDecoratedDescriptor(_class$1_.prototype, "applyAceOptions", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "applyAceOptions"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "aceResize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "aceResize"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setValue", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setValue"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceOptions", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceOptions"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setReadOnly", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setReadOnly"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceMode", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceMode"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceKeyboardHandler", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceKeyboardHandler"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceTheme", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceTheme"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceFontSize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceFontSize"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceTabSize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceTabSize"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceLineNumberVisible", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceLineNumberVisible"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAcePrintMarginVisible", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAcePrintMarginVisible"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAcePrintMarginSize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAcePrintMarginSize"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setBasicAutocompletion", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setBasicAutocompletion"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setLiveAutocompletion", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setLiveAutocompletion"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setSnippets", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setSnippets"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAnnotations", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAnnotations"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setUseWrapMode", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setUseWrapMode"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setIndentedSoftWrap", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setIndentedSoftWrap"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "blockScroll", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "blockScroll"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setFoldStyle", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setFoldStyle"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setHighlightActiveLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setHighlightActiveLine"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setHighlightGutterLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setHighlightGutterLine"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setShowGutter", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setShowGutter"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setScrollTop", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setScrollTop"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "addMarker", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "addMarker"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "removeMarker", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "removeMarker"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setTextRange", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setTextRange"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "removeLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "removeLine"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "insertAtLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "insertAtLine"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "replaceLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "replaceLine"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "addAceSessionEventListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "addAceSessionEventListener"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "addAceSessionChangeListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "addAceSessionChangeListener"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "addAceChangeListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "addAceChangeListener"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "addChangeListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "addChangeListener"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "addAceEventListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "addAceEventListener"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "focus", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "focus"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "gotoEnd", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "gotoEnd"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setUndoManager", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setUndoManager"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "setAceRendererOption", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "setAceRendererOption"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "insert", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "insert"), _class$1_.prototype), _applyDecoratedDescriptor(_class$1_.prototype, "append", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1_.prototype, "append"), _class$1_.prototype)), _class$1_);
    let StaticCodeHighlighterStyle = (_class2$10 = class StaticCodeHighlighterStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "hideActive", _descriptor$10, this);
      }
    }, (_descriptor$10 = _applyDecoratedDescriptor(_class2$10.prototype, "hideActive", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          " .ace_gutter-active-line": {
            display: "none"
          },
          " .ace_active-line": {
            display: "none"
          },
          " .ace_cursor": {
            display: "none"
          }
        };
      }
    })), _class2$10);
    let StaticCodeHighlighter = (_dec$1i = registerStyle(StaticCodeHighlighterStyle), _dec$1i(_class3$n = class StaticCodeHighlighter extends CodeEditor {
      setOptions(options) {
        options = Object.assign({
          fontSize: 13,
          readOnly: true,
          lineWrapping: true
        }, options);
        super.setOptions(options);
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.hideActive);
      }
    }) || _class3$n);

    // Class that for every markup tag returns the UI class to instantiate for that element
    class MarkupClassMap {
      constructor(fallback, extraClasses = []) {
        this.classMap = new Map();
        this.fallback = fallback;
        for (const extraClass of extraClasses) {
          this.addClass(extraClass[0], extraClass[1]);
        }
      }
      addClass(className, classObject) {
        this.classMap.set(className, classObject);
      }
      registerDependencies(dependencies) {
        for (let dependency of dependencies) {
          if (dependency?.registerMarkup) {
            dependency.registerMarkup(this);
          }
        }
      }
      static addClass(className, classObject) {
        this.GLOBAL.addClass(className, classObject);
      }
      getClass(className) {
        let classObject = this.classMap.get(className);
        if (!classObject && this.fallback) {
          classObject = this.fallback.getClass(className);
        }
        return classObject;
      }
      get(className) {
        return this.getClass(className);
      }
      has(className) {
        return this.getClass(className);
      }
    }
    MarkupClassMap.GLOBAL = new MarkupClassMap();
    class MarkupRenderer extends Panel {
      setOptions(options) {
        if (!options.classMap) {
          options.classMap = new MarkupClassMap(MarkupClassMap.GLOBAL);
        }
        if (!options.parser) {
          options.parser = new MarkupParser({
            uiElements: options.classMap
          });
        }
        super.setOptions(options);
        this.setValue(this.options.value || "");
        if (this.options.classMap) {
          this.classMap = this.options.classMap;
        }
      }
      setValue(value) {
        if (typeof value === "string") {
          this.options.rawValue = value;
          try {
            value = this.options.parser.parse(value);
          } catch (e) {
            console.error("Can't parse ", value, e);
            value = {
              tag: "span",
              children: [value]
            };
          }
        }
        this.options.value = value;
      }
      reparse() {
        if (this.options.rawValue) {
          this.setValue(this.options.rawValue);
        }
      }
      registerDependencies(dependencies) {
        if (dependencies.length > 0) {
          this.classMap.registerDependencies(dependencies);
          this.reparse();
        }
      }
      addClass(className, classObject) {
        this.classMap.addClass(className, classObject);
      }
      getClass(className) {
        return this.classMap.getClass(className);
      }
      getValue() {
        return this.options.value;
      }
      convertToUI(value) {
        if (value instanceof UI$1.TextElement || value instanceof UI$1.Element) {
          // TODO: investigate this!
          return value;
        }
        if (typeof value === "string") {
          return new UI$1.TextElement(value);
        }
        if (Array.isArray(value)) {
          return value.map(x => this.convertToUI(x));
        }
        if (value.children) {
          value.children = this.convertToUI(value.children);
        }
        let classObject = this.getClass(value.tag) || value.tag;

        // TODO: maybe just copy to another object, not delete?
        //delete value.tag;
        return UI$1.createElement(classObject, value, ...(value.children || []));
      }
      render() {
        return this.convertToUI(this.getValue());
      }
    }
    MarkupClassMap.addClass("CodeSnippet", StaticCodeHighlighter);
    const SafeUriEnhancer = (BaseClass, attribute) => class SafeUriClass extends BaseClass {
      setOptions(options) {
        if (options[attribute] && !this.constructor.isSafeUri(options[attribute])) {
          options = Object.assign({}, options, {
            [attribute]: undefined
          });
        }
        return super.setOptions(options);
      }
      static isSafeUri(uri) {
        return uri.indexOf(":") === -1 || uri.startsWith("http:") || uri.startsWith("https:") || uri.startsWith("mailto:");
      }
    };
    MarkupClassMap.addClass("Link", SafeUriEnhancer(Link, "href"));
    MarkupClassMap.addClass("Image", SafeUriEnhancer(Image, "src"));

    var _class$1Z, _descriptor$$, _descriptor2$T, _descriptor3$L, _descriptor4$F, _descriptor5$B, _descriptor6$v, _dec$1h, _class2$$, _class3$m, _descriptor7$q, _descriptor8$m, _descriptor9$h, _descriptor10$d, _descriptor11$b, _descriptor12$9, _dec2$s, _class4$c;
    function DefaultMakeIcon(icon, options = {}) {
      if (isFunction(icon)) {
        return icon(options);
      }
      if (icon instanceof UI$1.Element) {
        return icon;
      }
      const iconOptions = {
        ...options
      };
      iconOptions.className = (iconOptions.className || "") + " fa fa-" + icon;
      return UI$1.createElement("span", iconOptions);
    }
    let MakeIconFunc = DefaultMakeIcon;

    // Change the icon function
    function SetMakeIcon(func) {
      MakeIconFunc = func;
    }
    function MakeIcon() {
      return MakeIconFunc(...arguments);
    }
    class SimpleStyledElement extends UI$1.Element {
      getLevel() {
        return this.options.level || this.parent && this.parent.getLevel && this.parent.getLevel();
      }
      setLevel(level) {
        this.updateOptions({
          level
        });
      }
      getSize() {
        return this.options.size || this.parent && this.parent.getSize && this.parent.getSize();
      }
      setSize(size) {
        this.updateOptions({
          size
        });
      }
    }
    class IconableInterface extends SimpleStyledElement {
      render() {
        return [this.beforeChildren(), this.getLabel(), super.render()];
      }
      getLabel() {
        return this.options.label;
      }
      setLabel(label) {
        this.updateOptions({
          label
        });
      }
      setIcon(icon) {
        this.updateOptions({
          icon
        });
      }
      getIcon() {
        const {
          icon
        } = this.options;
        return icon && MakeIcon(icon);
      }
      beforeChildren() {
        return this.getIcon();
      }
    }

    // TODO: move this to another file
    let labelColorToStyle = color => {
      const colors = buildColors(color);
      let darker = {
        backgroundColor: colors[2],
        color: colors[6],
        textDecoration: "none"
      };
      let regular = {
        backgroundColor: colors[1],
        borderColor: colors[5],
        color: colors[6]
      };
      return Object.assign({}, regular, {
        ":hover": darker,
        ":hover:disabled": regular,
        ":focus": darker,
        ":active": darker
      });
    };
    let LabelStyle = (_class$1Z = class LabelStyle extends BasicLevelStyleSheet(labelColorToStyle) {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$$, this);
        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor2$T, this);
        _initializerDefineProperty(this, "SMALL", _descriptor3$L, this);
        _initializerDefineProperty(this, "MEDIUM", _descriptor4$F, this);
        _initializerDefineProperty(this, "LARGE", _descriptor5$B, this);
        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor6$v, this);
      }
    }, (_descriptor$$ = _applyDecoratedDescriptor(_class$1Z.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 12,
          fontWeight: "bold",
          border: "0.1em solid transparent",
          padding: "0.07em 0.4em",
          borderRadius: "0.3em",
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "bottom",
          lineHeight: 4 / 3 + "",
          display: "inline-block",
          touchAction: "manipulation",
          ":disabled": {
            opacity: "0.7",
            cursor: "not-allowed"
          },
          ...this.colorStyleRule(this.themeProps.COLOR_BACKGROUND_BADGE)
        };
      }
    }), _descriptor2$T = _applyDecoratedDescriptor(_class$1Z.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 10,
          padding: "0.05em 0.2em",
          borderWidth: "0.05em"
        };
      }
    }), _descriptor3$L = _applyDecoratedDescriptor(_class$1Z.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 10
        };
      }
    }), _descriptor4$F = _applyDecoratedDescriptor(_class$1Z.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor5$B = _applyDecoratedDescriptor(_class$1Z.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 14
        };
      }
    }), _descriptor6$v = _applyDecoratedDescriptor(_class$1Z.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          padding: "0.05em 0.2em"
        };
      }
    })), _class$1Z);
    let Label = (_dec$1h = registerStyle(LabelStyle), _dec$1h(_class2$$ = class Label extends UI$1.Primitive(IconableInterface, "span") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.Size(this.getSize()));
        attr.addClass(this.styleSheet.Level(this.getLevel()));
      }
    }) || _class2$$);
    let badgeColorToStyle = color => {
      const colors = buildColors(color);
      return {
        backgroundColor: colors[1],
        borderColor: colors[5],
        color: colors[6]
      };
    };
    let BadgeStyle = (_class3$m = class BadgeStyle extends BasicLevelStyleSheet(badgeColorToStyle) {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor7$q, this);
        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor8$m, this);
        _initializerDefineProperty(this, "SMALL", _descriptor9$h, this);
        _initializerDefineProperty(this, "MEDIUM", _descriptor10$d, this);
        _initializerDefineProperty(this, "LARGE", _descriptor11$b, this);
        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor12$9, this);
      }
    }, (_descriptor7$q = _applyDecoratedDescriptor(_class3$m.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          padding: "0.25em 0.55em",
          fontWeight: "700",
          lineHeight: "1",
          color: "#fff",
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          backgroundColor: "#777",
          borderRadius: "0.8em",
          fontSize: 12,
          ...this.colorStyleRule(this.themeProps.COLOR_BACKGROUND_BADGE)
        };
      }
    }), _descriptor8$m = _applyDecoratedDescriptor(_class3$m.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "10px",
          padding: "0.1em 0.2em"
        };
      }
    }), _descriptor9$h = _applyDecoratedDescriptor(_class3$m.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "10px"
        };
      }
    }), _descriptor10$d = _applyDecoratedDescriptor(_class3$m.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor11$b = _applyDecoratedDescriptor(_class3$m.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor12$9 = _applyDecoratedDescriptor(_class3$m.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "17px",
          padding: "0.1em 0.2em"
        };
      }
    })), _class3$m);
    let Badge = (_dec2$s = registerStyle(BadgeStyle), _dec2$s(_class4$c = class Badge extends UI$1.Primitive(IconableInterface, "span") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.Size(this.getSize()));
        attr.addClass(this.styleSheet.Level(this.getLevel()));
      }
    }) || _class4$c);

    var _class$1Y, _descriptor$_, _descriptor2$S, _descriptor3$K, _descriptor4$E, _descriptor5$A, _class2$_, _descriptor6$u, _descriptor7$p, _class3$l, _descriptor8$l;
    const buttonColorToStyle = color => {
      const colors = buildColors(color);
      const darker1 = {
        backgroundColor: colors[2]
      };
      const darker2 = {
        backgroundColor: colors[3]
      };
      const darker3 = {
        backgroundColor: colors[4]
      };
      const regular = {
        backgroundColor: colors[1],
        borderColor: colors[5],
        color: colors[6]
      };
      return {
        ...regular,
        ":hover": darker1,
        ":hover:disabled": {
          ...regular
        },
        ":focus": darker1,
        ":active": darker2,
        ":hover:active": darker3,
        ":focus:active": darker3,
        ".active": darker3
      };
    };
    let ButtonStyle = (_class$1Y = class ButtonStyle extends BasicLevelStyleSheet(buttonColorToStyle) {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$_, this);
        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor2$S, this);
        _initializerDefineProperty(this, "SMALL", _descriptor3$K, this);
        _initializerDefineProperty(this, "LARGE", _descriptor4$E, this);
        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor5$A, this);
      }
      getLevel(level) {
        return super.getLevel(level) || this.INFO;
      }
    }, (_descriptor$_ = _applyDecoratedDescriptor(_class$1Y.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          outline: 0,
          border: "1px solid",
          padding: this.themeProps.BUTTON_PADDING,
          borderRadius: this.themeProps.BUTTON_BORDER_RADIUS,
          fontFamily: "inherit",
          fontSize: this.themeProps.FONT_SIZE_DEFAULT,
          fontWeight: this.themeProps.BUTTON_FONT_WEIGHT,
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          touchAction: "manipulation",
          userSelect: "none",
          cursor: "pointer",
          ":disabled": {
            opacity: 0.7,
            cursor: "not-allowed"
          },
          ...this.colorStyleRule(this.themeProps.BUTTON_COLOR)
        };
      }
    }), _descriptor2$S = _applyDecoratedDescriptor(_class$1Y.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_EXTRA_SMALL,
          padding: "0.2em 0.4em",
          borderWidth: "0.05em"
        };
      }
    }), _descriptor3$K = _applyDecoratedDescriptor(_class$1Y.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_SMALL
        };
      }
    }), _descriptor4$E = _applyDecoratedDescriptor(_class$1Y.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_LARGE
        };
      }
    }), _descriptor5$A = _applyDecoratedDescriptor(_class$1Y.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_EXTRA_LARGE,
          padding: "0.2em 0.4em"
        };
      }
    })), _class$1Y);
    let ButtonGroupStyle = (_class2$_ = class ButtonGroupStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "HORIZONTAL", _descriptor6$u, this);
        _initializerDefineProperty(this, "VERTICAL", _descriptor7$p, this);
      }
      Orientation(orientation) {
        for (let type of Object.keys(Orientation$1)) {
          if (orientation === Orientation$1[type]) {
            return this[type];
          }
        }
      }
    }, (_descriptor6$u = _applyDecoratedDescriptor(_class2$_.prototype, "HORIZONTAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          pointerEvents: "none",
          ">*": {
            "margin-left": "5px",
            "display": "inline-block",
            pointerEvents: "initial"
          },
          ">:first-child": {
            "margin-left": "0px"
          }
        };
      }
    }), _descriptor7$p = _applyDecoratedDescriptor(_class2$_.prototype, "VERTICAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          pointerEvents: "none",
          ">*": {
            "margin-top": "5px",
            "display": "block",
            pointerEvents: "initial"
          },
          ">:first-child": {
            "margin-top": "0px"
          }
        };
      }
    })), _class2$_);
    let RadioButtonGroupStyle = (_class3$l = class RadioButtonGroupStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor8$l, this);
      }
    }, (_descriptor8$l = _applyDecoratedDescriptor(_class3$l.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          pointerEvents: "none",
          ">*": {
            pointerEvents: "initial",
            borderRadius: 0,
            margin: 0
          },
          ">:last-child": {
            borderTopRightRadius: "0.3em",
            borderBottomRightRadius: "0.3em"
          },
          ">:first-child": {
            borderTopLeftRadius: "0.3em",
            borderBottomLeftRadius: "0.3em"
          }
        };
      }
    })), _class3$l);

    var _dec$1g, _class$1X;
    let Button$1 = (_dec$1g = registerStyle(ButtonStyle), _dec$1g(_class$1X = class Button extends UI$1.Primitive(IconableInterface, "button") {
      extraNodeAttributes(attr) {
        const {
          styleSheet
        } = this;
        // TODO Maybe StyleSheet should have a method onElementRedraw(attr, element), that just adds container by default
        attr.addClass(styleSheet.Size(this.getSize()));
        attr.addClass(styleSheet.Level(this.getLevel()));
      }
      disable() {
        this.setEnabled(false);
      }
      enable() {
        this.setEnabled(true);
      }
      setEnabled(enabled) {
        this.updateOptions({
          disabled: !enabled
        });
      }
    }) || _class$1X);

    // TODO: this whole file is mosly here to not break compatibility with pre-Stem code, need refactoring
    var EPS = 1e-6;

    // Check if a value is equal to zero. Use epsilon check.
    var isZero = function (val, epsilon = EPS) {
      return Math.abs(val) < epsilon;
    };
    var equal = function (val1, val2, epsilon = EPS) {
      return isZero(val1 - val2, epsilon);
    };

    // Compute square of a number
    var sqr = function (x) {
      return x * x;
    };

    // Compute the distance between 2 points
    var distance = function (p1, p2) {
      return Math.sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y));
    };
    var signedDistancePointLine = function (point, line) {
      return (line.a * point.x + line.b * point.y + line.c) / Math.sqrt(sqr(line.a) + sqr(line.b));
    };
    var distancePointLine = function (point, line) {
      return Math.abs(signedDistancePointLine(point, line));
    };
    var pointOnSegment = function (point, segmentStart, segmentEnd, epsilon) {
      epsilon = epsilon || EPS;
      return Math.abs(distance(point, segmentStart) + distance(point, segmentEnd) - distance(segmentStart, segmentEnd)) <= epsilon;
    };
    var perpendicularFoot = function (point, line) {
      var distance = (line.a * point.x + line.b * point.y + line.c) / (sqr(line.a) + sqr(line.b));
      return {
        x: point.x - line.a * distance,
        y: point.y - line.b * distance
      };
    };
    var lineEquation = function (A, B) {
      return {
        a: B.y - A.y,
        b: A.x - B.x,
        c: A.y * B.x - A.x * B.y
      };
    };

    // TODO: lots of these should be methods of the point class, not global functions
    var crossProduct = function (p1, p2, p0) {
      p0 = p0 || {
        x: 0,
        y: 0
      };
      return (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);
    };
    var rotatePoint = function (point, orig, angle) {
      // TODO: WTF, default argument value in the middle of argument list?
      orig = orig || {
        x: 0,
        y: 0
      };
      return {
        x: Math.cos(angle) * (point.x - orig.x) - Math.sin(angle) * (point.y - orig.y) + orig.x,
        y: Math.sin(angle) * (point.x - orig.x) + Math.cos(angle) * (point.y - orig.y) + orig.y
      };
    };
    var polarToCartesian = function (angle, radius, orig) {
      orig = orig || {
        x: 0,
        y: 0
      };
      return {
        x: radius * Math.cos(angle) + orig.x,
        y: radius * Math.sin(angle) + orig.y
      };
    };
    var vectorLength = function (vector) {
      return distance({
        x: 0,
        y: 0
      }, vector);
    };
    var normalizeVector = function (vector) {
      let len = vectorLength(vector);
      if (Math.abs(len) < EPS) {
        return {
          x: 0,
          y: 0
        };
      }
      return {
        x: vector.x / len,
        y: vector.y / len
      };
    };
    var scaleVector = function (vector, scalar) {
      return {
        x: vector.x * scalar,
        y: vector.y * scalar
      };
    };
    var addVectors = function (vector1, vector2) {
      return {
        x: vector1.x + vector2.x,
        y: vector1.y + vector2.y
      };
    };
    var subtractVectors = function (vector1, vector2) {
      return {
        x: vector1.x - vector2.x,
        y: vector1.y - vector2.y
      };
    };
    var interpolationValue = function (interpolationArray, X) {
      var Y = 0;
      var aux;
      var i;
      var j;
      for (i = 0; i < interpolationArray.length; i += 1) {
        if (interpolationArray.x === X) {
          return interpolationArray.y;
        }
      }
      for (i = 0; i < interpolationArray.length; i += 1) {
        aux = interpolationArray[i].y;
        for (j = 0; j < interpolationArray.length; j += 1) {
          if (i !== j) {
            aux = aux * (X - interpolationArray[j].x) / (interpolationArray[i].x - interpolationArray[j].x);
          }
        }
        Y += aux;
      }
      return Y;
    };

    let Transition$1 = class Transition {
      constructor(options) {
        this.func = options.func;
        this.context = options.context;
        this.duration = options.duration || 0;
        this.startTime = options.startTime || 0;
        this.dependsOn = options.dependsOn || [];
        this.speedFactor = 1;
      }
      toString() {
        return "{\n" + "   context: " + this.context + "\n" + "   duration: " + this.duration + "\n" + "   startTime: " + this.startTime + "\n" + "   dependsOn: " + this.dependsOn + "\n" + "   func: " + this.func.toString() + "\n" + "}\n";
      }
      hasDependencyOn(t) {
        for (let transition of this.dependsOn) {
          if (transition === t) {
            return true;
          }
        }
        return false;
      }
      canAdvance() {
        for (let i = 0; i < this.dependsOn.length; i += 1) {
          if (!this.dependsOn[i].isStopped()) {
            return false;
          }
        }
        return true;
      }
      getFraction(now = Date.now()) {
        return Math.min((now - this.startTime) / this.getLength(), 1);
      }
      start(now = Date.now()) {
        if (this.stopped) {
          delete this.stopped;
        }
        this.setStartTime(now);
        let functionWrapper = () => {
          if (this.stopped) {
            return;
          }
          if (!this.pauseTime) {
            this.nextStep();
          }
          requestAnimationFrame(functionWrapper);
        };
        requestAnimationFrame(functionWrapper);
        return this;
      }
      getLength() {
        return this.getEndTime() - this.startTime;
      }
      setStartTime(time) {
        this.startTime = time;
        return this;
      }
      setSpeedFactor(speedFactor, now = Date.now()) {
        let ratio = speedFactor / this.speedFactor;
        this.startTime = (this.startTime - now) / ratio + now;
        if (this.pauseTime) {
          this.pauseTime = (this.pauseTime - now) / ratio + now;
        }
        this.speedFactor = speedFactor;
        return this;
      }
      pause(now = Date.now()) {
        if (!this.pauseTime) {
          this.pauseTime = now;
        }
        return this;
      }
      resume(now = Date.now()) {
        if (this.pauseTime) {
          this.startTime += now - this.pauseTime;
          this.pauseTime = 0;
        }
        return this;
      }
      forceStart() {
        this.restart();
        this.func(0.0, this.context);
        return this;
      }
      forceFinish() {
        this.func(1.0, this.context);
        this.stop();
        return this;
      }
      stop() {
        this.stopped = true;
      }
      restart() {
        delete this.stopped;
        return this;
      }
      isStopped() {
        return this.stopped === true;
      }
      nextStep(now = Date.now()) {
        // Return if transition is stopped
        if (this.isStopped()) {
          return this;
        }
        this.lastT = this.getFraction(now);
        // Return if transitions not started yet
        if (this.lastT < 0) {
          return this;
        }
        // Call the animation function
        this.func(this.lastT, this.context);
        // Stop the animation if it's the last step
        if (this.lastT === 1) {
          this.stop();
        }
        return this;
      }
      getEndTime() {
        return this.startTime + this.duration / this.speedFactor;
      }
    };
    class Modifier extends Transition$1 {
      constructor(options) {
        super(options);
        this.reverseFunc = options.reverseFunc;
        this.context = options.context;
      }

      // WTF, so basically JSON.stringify??
      toString() {
        return "{\n" + "   context: " + this.context + "\n" + "   duration: " + this.duration + "\n" + "   startTime: " + this.startTime + "\n" + "   dependsOn: " + this.dependsOn + "\n" + "   func: " + this.func.toString() + "\n" + "   reverseFunc: " + this.reverseFunc.toString() + "\n" + "}\n";
      }
      forceStart() {
        this.restart();
        this.reverseFunc(this.context);
        return this;
      }
      forceFinish() {
        this.func(this.context);
        this.stop();
        return this;
      }
      nextStep(now = Date.now()) {
        if (this.isStopped()) {
          return this;
        }
        if (now >= this.startTime) {
          this.func(this.context);
          this.stop();
        }
        return this;
      }
      getEndTime() {
        return this.startTime;
      }
    }
    class TransitionList {
      constructor(startTime = 0) {
        this.startTime = startTime;
        this.speedFactor = 1;
        this.transitions = [];
        this.dependsOn = [];
      }
      toString() {
        return "{\n" + "   context: " + this.context + "\n" + "   duration: " + this.duration + "\n" + "   startTime: " + this.startTime + "\n" + "   dependsOn: " + this.dependsOn + "\n" + "   transitions: [" + (this.transitions.length ? this.transitions[0].toString() : "") + " ...]\n" + "}\n";
      }
      add(transition, forceFinish = true) {
        for (let i = 0; i < transition.dependsOn.length; i += 1) {
          if (transition.dependsOn[i].getEndTime() > transition.startTime) {
            console.error(transition.toString() + "\ndepends on\n" + transition.dependsOn[i].toString() + "\n" + "which ends after its start!");
          }
        }
        if (forceFinish) {
          transition.forceFinish();
        }
        this.transitions.push(transition);
        return this;
      }
      push(transition, forceFinish = true) {
        transition.setStartTime(this.getLength());
        for (let i = 0; i < transition.dependsOn.length; i += 1) {
          if (transition.dependsOn[i].getEndTime() > transition.startTime) {
            console.error(transition.toString() + "\ndepends on\n" + transition.dependsOn[i].toString() + "\n" + "which ends after its start!");
          }
        }
        if (forceFinish) {
          transition.forceFinish();
        }
        this.transitions.push(transition);
        return this;
      }
      getFraction(now = Date.now()) {
        return Math.min((now - this.startTime) / this.getLength(), 1);
      }
      setStartTime(startTime) {
        let timeDelta = startTime - this.startTime;
        this.startTime = startTime;
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          transition.setStartTime(transition.startTime + timeDelta);
        }
      }
      start(now = Date.now()) {
        if (this.stopped) {
          delete this.stopped;
        }
        this.setStartTime(now);
        let functionWrapper = () => {
          if (this.stopped) {
            return;
          }
          if (!this.pauseTime) {
            this.nextStep();
          }
          requestAnimationFrame(functionWrapper);
        };
        requestAnimationFrame(functionWrapper);
        return this;
      }
      stop() {
        this.stopped = true;
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          transition.stop();
        }
      }
      isStopped() {
        return this.stopped === true;
      }
      pause(now = Date.now()) {
        if (!this.pauseTime) {
          this.pauseTime = now;
          for (let i = 0; i < this.transitions.length; i += 1) {
            this.transitions[i].pause(now);
          }
        }
        return this;
      }
      resume(now = Date.now()) {
        if (this.pauseTime) {
          this.startTime += now - this.pauseTime;
          for (let i = 0; i < this.transitions.length; i += 1) {
            this.transitions[i].resume(now);
          }
          this.pauseTime = 0;
        }
        return this;
      }
      nextStep() {
        // Return if transition list is stopped
        if (this.isStopped()) {
          return;
        }
        if (this.onNewFrame) {
          this.onNewFrame(this.getFraction());
        }
        let finished = true;
        let stk = [];
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          if (!transition.isStopped()) {
            if (transition.canAdvance()) {
              transition.nextStep();
              while (stk.length !== 0 && this.transitions[stk[stk.length - 1]].canAdvance()) {
                this.transitions[stk[stk.length - 1]].nextStep();
                stk.pop();
              }
            } else {
              stk.push(i);
            }
            finished = false;
          }
        }
        if (finished) {
          this.stop();
        }
        return this;
      }
      setSpeedFactor(speedFactor, now = Date.now()) {
        let ratio = speedFactor / this.speedFactor;
        this.startTime = (this.startTime - now) / ratio + now;
        if (this.pauseTime) {
          this.pauseTime = (this.pauseTime - now) / ratio + now;
        }
        this.speedFactor = speedFactor;
        for (let i = 0; i < this.transitions.length; i += 1) {
          this.transitions[i].setSpeedFactor(speedFactor, now);
        }
        return this;
      }
      restart() {
        delete this.stopped;
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          transition.restart();
        }
        this.sortByEndTime();
        return this;
      }
      getLength() {
        return this.getEndTime() - this.startTime;
      }
      getEndTime() {
        let endTime = 0;
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transitionEndTime = this.transitions[i].getEndTime();
          if (transitionEndTime > endTime) {
            endTime = transitionEndTime;
          }
        }
        return endTime;
      }
      hasDependencyOn(t) {
        for (let transition in this.dependsOn) {
          if (transition === t) {
            return true;
          }
        }
        return false;
      }
      canAdvance() {
        for (let i = 0; i < this.dependsOn.length; i += 1) {
          if (!this.dependsOn[i].isStopped()) {
            return false;
          }
        }
        return true;
      }
      sortByStartTime() {
        // TODO: this comparator should be global
        this.transitions.sort((a, b) => {
          if (!equal(a.startTime, b.startTime, 0.001)) {
            return b.startTime - a.startTime;
          }
          //not a hack, works in all conflict cases
          if (!equal(a.getEndTime(), b.getEndTime(), 0.001)) {
            return b.getEndTime() - a.getEndTime();
          }
          if (a.hasDependencyOn(b)) {
            return 1;
          }
          if (b.hasDependencyOn(a)) {
            return -1;
          }
          return 0;
        });
      }
      sortByEndTime() {
        this.transitions.sort((a, b) => {
          if (!equal(a.getEndTime(), b.getEndTime(), 0.001)) {
            return a.getEndTime() - b.getEndTime();
          }
          //not a hack, works in all conflict cases
          if (!equal(a.startTime, b.startTime, 0.001)) {
            return a.startTime - b.startTime;
          }
          if (a.hasDependencyOn(b)) {
            return -1;
          }
          if (b.hasDependencyOn(a)) {
            return 1;
          }
          return 0;
        });
      }
      forceStart(now = Date.now()) {
        this.sortByStartTime();
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          if (transition.startTime <= now) {
            transition.forceStart(now);
          }
        }
        return this;
      }
      forceFinish(now = Date.now(), startTime = -1) {
        this.sortByEndTime();
        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          if (transition.getEndTime() >= startTime) {
            if (transition instanceof TransitionList) {
              transition.forceFinish(now, startTime);
            } else {
              if (typeof now === "undefined" || transition.getEndTime() < now) {
                transition.forceFinish();
              }
            }
          }
        }
        return this;
      }
      startAtPercent(startPercent, now = Date.now()) {
        cancelAnimationFrame(this.animationFrameId);
        this.restart();
        // TODO(@wefgef): Buggy
        let paused = this.pauseTime;
        if (paused) {
          this.resume();
        }
        this.forceStart(now);
        this.setStartTime(now - startPercent * this.getLength());
        this.forceFinish(now);
        // TODO(@wefgef): Huge hack to deal with force transition
        this.nextStep();
        this.nextStep();
        if (paused) {
          this.pause();
        }
        let functionWrapper = () => {
          if (this.isStopped()) {
            return;
          }
          if (!this.pauseTime) {
            this.nextStep();
          }
          this.animationFrameId = requestAnimationFrame(functionWrapper);
        };
        this.animationFrameId = requestAnimationFrame(functionWrapper);
      }
    }

    function getOffset(node) {
      if (node instanceof UI$1.Element) {
        node = node.node;
      }
      if (!node) {
        return {
          left: 0,
          top: 0
        };
      }
      let nodePosition = node.style && node.style.position;
      let left = 0;
      let top = 0;
      while (node) {
        let nodeStyle = node.style || {};
        if (nodePosition === "absolute" && nodeStyle.position === "relative") {
          return {
            left: left,
            top: top
          };
        }
        left += node.offsetLeft;
        top += node.offsetTop;
        node = node.offsetParent;
      }
      return {
        left: left,
        top: top
      };
    }
    function getComputedStyle(node, attribute) {
      if (node instanceof UI$1.Element) {
        node = node.node;
      }
      let computedStyle = window.getComputedStyle(node, null);
      return attribute ? computedStyle.getPropertyValue(attribute) : computedStyle;
    }
    function changeParent(element, newParent) {
      const currentParent = element.parent;
      currentParent.eraseChild(element, false);
      newParent.appendChild(element);
    }

    var _class$1W, _descriptor$Z, _descriptor2$R, _descriptor3$J;
    let InputStyle = (_class$1W = class InputStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "inputElement", _descriptor$Z, this);
        _initializerDefineProperty(this, "checkboxInput", _descriptor2$R, this);
        _initializerDefineProperty(this, "select", _descriptor3$J, this);
      }
    }, (_descriptor$Z = _applyDecoratedDescriptor(_class$1W.prototype, "inputElement", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "border-color ease-in-out .15s, box-shadow ease-in-out .15s",
          padding: "0.4em 0.54em",
          background: this.themeProps.INPUT_BACKGROUND,
          border: () => "1px solid " + this.themeProps.INPUT_BORDER_COLOR,
          borderRadius: this.themeProps.INPUT_BORDER_RADIUS,
          height: this.themeProps.INPUT_DEFAULT_HEIGHT,
          ":focus": {
            outline: "0",
            borderColor: "#66afe9"
          }
        };
      }
    }), _descriptor2$R = _applyDecoratedDescriptor(_class$1W.prototype, "checkboxInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block"
        };
      }
    }), _descriptor3$J = _applyDecoratedDescriptor(_class$1W.prototype, "select", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    })), _class$1W);

    class TokenFormatter {
      constructor(tokens) {
        this.tokenMap = new Map();
        for (const [token, formatter] of tokens) {
          this.tokenMap.set(token, formatter);
        }
      }

      // TODO This is very old code, meh
      splitToTokens(str) {
        // TODO: "[HH]HH" will be split to ["HH", "HH"], so the escape does not solve the problem
        let tokens = [];
        let lastIsLetter = null;
        let escapeByCurlyBracket = false;
        let escapeBySquareBracket = false;
        for (let i = 0; i < str.length; i++) {
          let charCode = str.charCodeAt(i);
          if (charCode === 125 && escapeByCurlyBracket) {
            // '}' ending the escape
            escapeByCurlyBracket = false;
            lastIsLetter = null;
          } else if (charCode === 93 && escapeBySquareBracket) {
            // ']' ending the escape
            escapeBySquareBracket = false;
            lastIsLetter = null;
          } else if (escapeByCurlyBracket || escapeBySquareBracket) {
            // The character is escaped no matter what it is
            tokens[tokens.length - 1] += str[i];
          } else if (charCode === 123) {
            // '{' starts a new escape
            escapeByCurlyBracket = true;
            tokens.push("");
          } else if (charCode === 91) {
            // '[' starts a new escape
            escapeBySquareBracket = true;
            tokens.push("");
          } else {
            let isLetter = 65 <= charCode && charCode <= 90 || 97 <= charCode && charCode <= 122;
            if (isLetter === lastIsLetter) {
              tokens[tokens.length - 1] += str[i];
            } else {
              tokens.push(str[i]);
            }
            lastIsLetter = isLetter;
          }
        }
        if (escapeByCurlyBracket || escapeBySquareBracket) {
          console.warn("Unfinished escaped sequence!");
        }
        return tokens;
      }
      evalToken(value, token) {
        let func = this.tokenMap.get(token);
        if (!func) {
          return token;
        }
        return func(value);
      }
      format(value, str) {
        let tokens = this.splitToTokens(str);
        tokens = tokens.map(token => this.evalToken(value, token));
        return tokens.join("");
      }
    }

    class TimeUnit {
      constructor(name, baseUnit, multiplier, options = {}) {
        this.name = name;
        this.pluralName = name + "s";
        this.baseUnit = baseUnit;
        this.multiplier = multiplier;
        this.milliseconds = (baseUnit?.getMilliseconds() || 1) * multiplier;
        this.variableMultiplier = options.variableMultiplier || false;
        this.variableDuration = this.variableMultiplier || baseUnit && baseUnit.isVariable();
        let methodSuffix = name === "year" ? "FullYear" : name === "day" ? "Date" : capitalize(name);
        this.getterName = "get" + methodSuffix;
        this.setterName = "set" + methodSuffix;
        if (!Date.prototype[this.getterName] && Date.prototype[this.getterName + "s"]) {
          this.getterName += "s";
          this.setterName += "s";
        }
      }
      static toTimeUnit(timeUnit) {
        if (timeUnit instanceof TimeUnit) {
          return timeUnit;
        }
        return this.CANONICAL[timeUnit];
      }
      valueOf() {
        return this.milliseconds;
      }
      getName() {
        return this.name;
      }
      getPluralName() {
        return this.pluralName;
      }
      getFrequencyName() {
        if (this.name.toLowerCase() === "day") {
          return "daily";
        }
        return this.name + "ly";
      }
      formatCount(numTimeUnits, omitCountOnSingular) {
        if (numTimeUnits != 1) {
          return numTimeUnits + " " + this.getPluralName();
        } else {
          if (omitCountOnSingular) {
            return this.getName();
          } else {
            return numTimeUnits + " " + this.getName();
          }
        }
      }
      getMilliseconds() {
        return this.milliseconds;
      }
      isVariable() {
        return this.variableDuration;
      }
      hasVariableMultiplier() {
        return this.variableMultiplier;
      }
      getDateValue(date) {
        return date[this.getterName]();
      }
      setDateValue(date, value) {
        return date[this.setterName](value);
      }
    }
    TimeUnit.CANONICAL = {};
    TimeUnit.ALL = [];
    TimeUnit.FIXED_DURATION = [];
    TimeUnit.VARIABLE_DURATION = [];
    TimeUnit.MILLISECOND = new TimeUnit("millisecond", null, 1);
    TimeUnit.SECOND = new TimeUnit("second", TimeUnit.MILLISECOND, 1000);
    TimeUnit.MINUTE = new TimeUnit("minute", TimeUnit.SECOND, 60);
    TimeUnit.HOUR = new TimeUnit("hour", TimeUnit.MINUTE, 60);
    TimeUnit.DAY = new TimeUnit("day", TimeUnit.HOUR, 24, {
      variableMultiplier: true
    });
    TimeUnit.WEEK = new TimeUnit("week", TimeUnit.DAY, 7);
    TimeUnit.MONTH = new TimeUnit("month", TimeUnit.DAY, 30, {
      variableMultiplier: true
    });
    TimeUnit.QUARTER = new TimeUnit("quarter", TimeUnit.MONTH, 3);
    TimeUnit.TRIMESTER = new TimeUnit("trimester", TimeUnit.MONTH, 4);
    TimeUnit.SEMESTER = new TimeUnit("semester", TimeUnit.MONTH, 6);
    TimeUnit.YEAR = new TimeUnit("year", TimeUnit.DAY, 365, {
      variableMultiplier: true
    });
    TimeUnit.DAY.dateMethodSuffix = "Date";
    TimeUnit.MONTH.dateMethodSuffix = "Month";
    TimeUnit.YEAR.dateMethodSuffix = "FullYear";
    class Duration {
      constructor(duration) {
        if (duration instanceof Date) {
          throw new Error("Can't automatically transform Date to Duration, use date.getTime() if you really want to");
        }
        if (isNumber(duration)) {
          this.milliseconds = duration;
          return;
        }
        if (duration instanceof Duration) {
          Object.assign(this, duration);
          return;
        }
        if (duration instanceof TimeUnit) {
          this.relativeDuration = duration.isVariable();
          if (this.relativeDuration) {
            this[duration.name] = 1;
          } else {
            this.milliseconds = duration.getMilliseconds();
          }
          return;
        }
        if (isPlainObject(duration)) {
          this.milliseconds = 0;
          for (const key of Object.keys(duration)) {
            let timeUnit = TimeUnit.CANONICAL[key];
            if (!timeUnit) {
              throw Error("Unknown time unit:", key);
            }
            // TODO: throw an error if can't parse these values
            if (timeUnit.isVariable()) {
              this[key] = parseInt(duration[key]);
              this.relativeDuration = true;
            } else {
              this.milliseconds += parseFloat(duration[key]) * timeUnit.milliseconds;
            }
          }
          return;
        }
        if (arguments.length > 0) {
          throw Error("Invalid Duration arguments: ", ...arguments);
        }
        this.milliseconds = 0;
      }
      static toDuration(duration) {
        if (duration instanceof Duration) {
          return duration;
        }
        return new this(duration);
      }
      static optionally(value) {
        return value != null ? this.toDuration(value) : value;
      }
      increment(duration) {
        duration = this.constructor.toDuration(duration);
        for (const key in duration) {
          if (!(key in TimeUnit.CANONICAL)) {
            continue;
          }
          if (this.hasOwnProperty(key)) {
            this[key] += duration[key];
          } else {
            this[key] = duration[key];
          }
        }
        return this;
      }

      // TODO really decide if we want all these to modify the object or not
      add(duration) {
        return this.clone().increment(duration);
      }
      subtract(duration) {
        duration = this.constructor.toDuration(duration).negate();
        return this.add(duration);
      }

      // Returns true if was defined terms of absolute primitives (anything less than a day)
      isAbsolute() {
        return !this.isVariable();
      }
      isVariable() {
        return this.relativeDuration;
      }
      negate() {
        let duration = new Duration(this);
        for (const key in duration) {
          if (key in TimeUnit.CANONICAL) {
            duration[key] = -duration[key];
          }
        }
        return duration;
      }

      // Returns a new Duration with a positive length
      abs() {
        return new Duration(Math.abs(+this));
      }
      clone() {
        return new Duration(this);
      }

      // The primitive value
      valueOf() {
        return this.milliseconds;
      }
      toNanoseconds() {
        return Math.floor(+this * 1e6);
      }

      // TODO: for all these units, should have a way to get the float and int value
      // TODO use methods that use TimeUnit
      toMilliseconds() {
        return Math.floor(+this);
      }
      getMilliseconds() {
        return this.toMilliseconds() % 1000;
      }
      toSeconds() {
        return Math.floor(+this / 1000);
      }
      getSeconds() {
        return this.toSeconds() % 60;
      }
      toMinutes() {
        return Math.floor(+this / (1000 * 60));
      }
      getMinutes() {
        return this.toMinutes() % 60;
      }
      toHours() {
        return Math.floor(+this / (1000 * 60 * 60));
      }
      getHours() {
        return this.toHours() % 24;
      }
      toDays() {
        return Math.floor(+this / (1000 * 60 * 60 * 24));
      }
      toMonths() {
        return Math.floor(+this / (1000 * 60 * 60 * 24 * 30));
      }
      toYears() {
        return Math.floor(+this / (1000 * 60 * 60 * 24 * 365));
      }
      toTimeUnit(timeUnit) {
        return Math.floor(+this / timeUnit.getMilliseconds());
      }

      // Split the duration in absolute value into component parts
      // Will skip zero parts
      // TODO this doesn't yet handle cases with variable length fields
      splitInParts(maxParts, minTimeUnit) {
        let duration = this.abs();
        let timeUnit = TimeUnit.YEAR;
        let parts = [];
        let numPartsIncludingSkipped = 0; // Use a separate counter to include skipped zero entries
        while (true) {
          const numWholeTimeUnits = duration.toTimeUnit(timeUnit);
          if (numWholeTimeUnits) {
            duration = duration.subtract(numWholeTimeUnits * timeUnit);
            parts.push({
              numUnits: numWholeTimeUnits,
              timeUnit
            });
          }
          if (parts.length > 0) {
            numPartsIncludingSkipped += 1;
            if (numPartsIncludingSkipped >= maxParts) {
              break;
            }
          }
          const nextUnit = timeUnit.baseUnit;
          // Either stop at milliseconds or when we're too low
          // Don't modify timeUnit just we have it in the response
          if (nextUnit == null || minTimeUnit && nextUnit < minTimeUnit) {
            break;
          }
          timeUnit = nextUnit;
        }
        return {
          parts,
          timeUnit,
          duration
        };
      }

      // If you pass in a string like "hh:mm:ss", this will trigger a special case
      format({
        maxEntries = 2,
        locale = null,
        separator = ", ",
        raw = false
      } = {}) {
        if (isString(arguments[0])) {
          const pattern = String(arguments[0]).toLowerCase();
          return this.constructor.formatter.format(this, pattern);
        }
        const {
          parts
        } = this.splitInParts(maxEntries);
        return parts.map(part => part.timeUnit.formatCount(part.numUnits)).join(separator);
      }
      toString(...args) {
        return this.format(...args);
      }
    }
    Duration.formatter = new TokenFormatter([["h", date => date.getHours()], ["hh", date => padNumber(date.getHours(), 2)], ["m", date => date.getMinutes()], ["mm", date => padNumber(date.getMinutes(), 2)], ["s", date => date.getSeconds()], ["ss", date => padNumber(date.getSeconds(), 2)], ["ts", date => Math.floor(date.getMilliseconds() / 100)], ["hs", date => padNumber(Math.floor(date.getMilliseconds() / 10), 2)], ["ms", date => padNumber(date.getMilliseconds(), 3)]]);
    function addCanonicalTimeUnit(key, timeUnit) {
      TimeUnit.ALL.push(timeUnit);
      if (timeUnit.isVariable()) {
        TimeUnit.VARIABLE_DURATION.push(timeUnit);
      } else {
        TimeUnit.FIXED_DURATION.push(timeUnit);
      }
      TimeUnit.CANONICAL[timeUnit.name] = timeUnit;
      if (timeUnit.pluralName) {
        TimeUnit.CANONICAL[timeUnit.pluralName] = timeUnit;
      }
      const timeUnitsName = timeUnit.pluralName;

      // TODO: not sure about this anymore
      Duration[key] = new Duration({
        [timeUnitsName]: 1
      });
    }
    function addCanonicalTimeUnits() {
      for (const key in TimeUnit) {
        const timeUnit = TimeUnit[key];
        if (timeUnit instanceof TimeUnit) {
          addCanonicalTimeUnit(key, timeUnit);
        }
      }
    }
    addCanonicalTimeUnits();

    // By default, StemDate will guess if the value is in milliseconds or seconds.
    // Any value less than this is interpreted as a unix time in seconds
    // If you want to go around this behavior, you can use the static method .fromUnixMilliseconds()
    // To disable, set this value to 0
    let MAX_AUTO_UNIX_TIME = Math.pow(2, 32); // Either ~Feb 2106 in unix seconds or ~Feb 1970 in unix milliseconds

    let DEFAULT_DATE_FORMAT = "ISO";
    const BaseDate = self.Date;
    class StemDate extends BaseDate {
      // This is only to let the IDE know that this class can receive arguments.
      constructor(...args) {
        super(...args);
        if (args.length === 1 && isNumber(args[0]) && this.valueOf() < MAX_AUTO_UNIX_TIME) {
          this.setTime(this.valueOf() * 1000);
        }
      }
      static create(value) {
        return new this(value);
      }

      // Return a StemDate from the object, else return value if falsy
      static optionally(value) {
        return value != null ? this.create(value) : value;
      }
      static toDate(date) {
        if (date instanceof StemDate) {
          return date;
        } else {
          return new this(date);
        }
      }

      // Contract change: Date.now() returns a time in milliseconds, while we return an actual date
      static now() {
        return new this(BaseDate.now());
      }
      toBaseString() {
        return super.toString();
      }
      toString() {
        if (isString(DEFAULT_DATE_FORMAT)) {
          return this.format(DEFAULT_DATE_FORMAT);
        }
        return DEFAULT_DATE_FORMAT(this);
      }
      static fromUnixMilliseconds(unixMilliseconds) {
        return this.create(new BaseDate(unixMilliseconds));
      }
      static fromUnixSeconds(unixSeconds) {
        return this.fromUnixMilliseconds(unixSeconds * 1000);
      }

      // You don't usually need to call this in most cases, constructor uses MAX_AUX_UNIX_TIME
      static unix(unixTime) {
        return this.fromUnixSeconds(unixTime);
      }

      // Creates a Date object from an instance of DOMHighResTimeStamp, returned by performance.now() for instance
      static fromHighResTimestamp(highResTimestamp) {
        return this.fromUnixMilliseconds(highResTimestamp + self.performance.timing.navigationStart);
      }
      set(date) {
        date = this.constructor.toDate(date);
        this.setTime(date.getTime());
        return this;
      }
      clone() {
        return new this.constructor(this.getTime());
      }
      toUnix() {
        return this.getTime() / 1000;
      }
      unix() {
        return Math.floor(this.toUnix());
      }
      isBefore(date) {
        return this.getTime() < StemDate.toDate(date).getTime();
      }
      equals(date) {
        return this.getTime() === StemDate.toDate(date).getTime();
      }
      get(timeUnit) {
        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        return timeUnit.getDateValue(this);
      }
      isSame(date, timeUnit) {
        if (!timeUnit) {
          return this.equals(date);
        }
        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        date = this.constructor.toDate(date);
        let diff = this.diff(date);
        if (diff >= 2 * timeUnit) {
          // If the distance between the two dates is more than 2 standard lengths of the time unit
          // This would be wrong if you would have time unit that can sometimes last more than twice their canonical duration
          // Works correctly for all implemented time units
          return false;
        }
        return this.get(timeUnit) == date.get(timeUnit);
      }
      isAfter(date) {
        return this.getTime() > StemDate.toDate(date).getTime();
      }
      isSameOrBefore(date) {
        return this.isBefore(date) || this.equals(date);
      }
      isSameOrAfter(date) {
        return this.isAfter(date) || this.equals(date);
      }
      isBetween(a, b) {
        return this.isSameOrAfter(a) && this.isSameOrBefore(b);
      }
      getWeekDay() {
        return this.getDay();
      }
      addUnit(timeUnit, count = 1) {
        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        count = parseInt(count);
        if (!timeUnit.isVariable()) {
          this.setTime(this.getTime() + timeUnit.getMilliseconds() * count);
          return this;
        }
        while (!timeUnit.dateMethodSuffix) {
          count *= timeUnit.multiplier;
          timeUnit = timeUnit.baseUnit;
        }
        const dateMethodSuffix = timeUnit.dateMethodSuffix;
        const currentValue = this["get" + dateMethodSuffix]();
        this["set" + dateMethodSuffix](currentValue + count);
        return this;
      }
      static min() {
        // TODO: simplify and remove code duplication
        let result = this.constructor.toDate(arguments[0]);
        for (let index = 1; index < arguments.length; index++) {
          let candidate = this.constructor.toDate(arguments[index]);
          if (candidate.isBefore(result)) {
            result = candidate;
          }
        }
        return result;
      }
      static max() {
        let result = this.constructor.toDate(arguments[0]);
        for (let index = 1; index < arguments.length; index++) {
          let candidate = this.constructor.toDate(arguments[index]);
          if (candidate.isAfter(result)) {
            result = candidate;
          }
        }
        return result;
      }

      // Assign the given date if current value if greater than it
      capUp(date) {
        date = this.constructor.toDate(date);
        if (this.isAfter(date)) {
          this.set(date);
        }
      }

      // Assign the given date if current value if less than it
      capDown(date) {
        date = this.constructor.toDate(date);
        if (this.isBefore(date)) {
          this.set(date);
        }
      }
      roundDown(timeUnit) {
        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        // TODO: this is wrong for semester, etc, should be different then
        while (timeUnit = timeUnit.baseUnit) {
          timeUnit.setDateValue(this, 0);
        }
        return this;
      }
      roundUp(timeUnit) {
        const roundDown = this.clone().roundDown(timeUnit);
        if (this.equals(roundDown)) {
          return this.set(roundDown);
        }
        this.addUnit(timeUnit);
        return this.roundDown(timeUnit);
      }
      round(timeUnit) {
        let roundUp = this.clone().roundUp(timeUnit);
        let roundDown = this.clone().roundDown(timeUnit);
        // On a tie we round up, as that's where time is flowing towards in our human perception of "reality"
        if (this.diff(roundUp) <= this.diff(roundDown)) {
          this.setTime(roundUp.getTime());
        } else {
          this.setTime(roundDown.getTime());
        }
        return this;
      }

      // TODO @branch have all of these return a new objects and have dates immutable
      add(duration) {
        duration = Duration.toDuration(duration);
        if (duration.isAbsolute()) {
          this.setTime(this.getTime() + duration.toMilliseconds());
          return this;
        }
        for (const key in duration) {
          const timeUnit = TimeUnit.CANONICAL[key];
          if (timeUnit) {
            this.addUnit(timeUnit, duration[key]);
          }
        }
        return this;
      }
      subtract(duration) {
        duration = Duration.toDuration(duration).negate();
        return this.add(duration);
      }

      // TODO deprecate this
      diffDuration(date) {
        return new Duration(this.diff(date));
      }

      // The different in absolute value
      diff(date, inAbsolute = true) {
        date = this.constructor.toDate(date);
        let diffMilliseconds = +this - date;
        if (inAbsolute) {
          diffMilliseconds = Math.abs(diffMilliseconds);
        }
        return new Duration(diffMilliseconds);
      }

      // Just to keep moment compatibility, until we actually implement locales
      locale(loc) {
        return this;
      }
      format(str = DEFAULT_DATE_FORMAT) {
        return this.constructor.formatter.format(this, str);
      }
      static format(date, str) {
        return StemDate.toDate(date).format(str);
      }
      isValid() {
        return super.toString() != "Invalid Date";
      }
      utc() {
        // Temp hack
        return this.constructor.fromUnixMilliseconds(+this + this.getTimezoneOffset() * 60 * 1000);
      }
      isLeapYear() {
        let year = this.getFullYear();
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
      }
      daysInMonth() {
        // The 0th day of the next months is actually the last day in the current month
        let lastDayInMonth = new BaseDate(this.getFullYear(), this.getMonth() + 1, 0);
        return lastDayInMonth.getDate();
      }
      getDaysCountPerMonth(index) {
        const months = [31, 28 + this.isLeapYear(), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        return months[index];
      }
      getDayInYear() {
        const month = this.getMonth();
        let totalDays = 0;
        for (let i = 0; i < month; i += 1) {
          totalDays += this.getDaysCountPerMonth(i);
        }
        return totalDays + this.getDate() - 1;
      }
      getWeekInYear() {
        return (this.getDayInYear() - this.getWeekDay()) / 7;
      }
      getStartOfDay() {
        return new StemDate(this.getFullYear(), this.getMonth(), this.getDate());
      }
      getEndOfDay() {
        return this.getStartOfDay().add(TimeUnit.DAY).subtract(TimeUnit.MILLISECOND);
      }
      getStartOfMonth() {
        return new StemDate(this.getFullYear(), this.getMonth(), 1);
      }
      getEndOfMonth() {
        return this.getStartOfMonth().add(TimeUnit.MONTH).subtract(TimeUnit.MILLISECOND);
      }
      getStartOfYear() {
        return new StemDate(this.getFullYear(), 0, 1);
      }
      getEndOfYear() {
        return this.getStartOfYear().add(TimeUnit.YEAR).subtract(TimeUnit.MILLISECOND);
      }
    }

    // TODO Maybe rename these
    const miniWeekDays = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
    const shortWeekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const longWeekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const longMonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    StemDate.formatter = new TokenFormatter([["ISO", date => date.toISOString()], ["Y", date => date.getFullYear()], ["YY", date => padNumber(date.getFullYear() % 100, 2)], ["YYYY", date => date.getFullYear()], ["M", date => date.getMonth() + 1], ["MM", date => padNumber(date.getMonth() + 1, 2)], ["MMM", date => shortMonthNames[date.getMonth()]], ["MMMM", date => longMonthNames[date.getMonth()]], ["D", date => date.getDate()], ["Do", date => suffixWithOrdinal(date.getDate())], ["DD", date => padNumber(date.getDate(), 2)], ["d", date => date.getWeekDay()], ["do", date => suffixWithOrdinal(date.getWeekDay())], ["dd", date => miniWeekDays[date.getWeekDay()]], ["ddd", date => shortWeekDays[date.getWeekDay()]], ["dddd", date => longWeekdays[date.getWeekDay()]], ["H", date => date.getHours()], ["HH", date => padNumber(date.getHours(), 2)], ["h", date => date.getHours() % 12 ? date.getHours() % 12 : 12], ["hh", date => padNumber(date.getHours() % 12 ? date.getHours() % 12 : 12, 2)], ["m", date => date.getMinutes()], ["mm", date => padNumber(date.getMinutes(), 2)], ["s", date => date.getSeconds()], ["ss", date => padNumber(date.getSeconds(), 2)], ["S", date => Math.floor(date.getMilliseconds() / 100)], ["SS", date => padNumber(Math.floor(date.getMilliseconds() / 10), 2)], ["SSS", date => padNumber(date.getMilliseconds(), 3)], ["ms", date => padNumber(date.getMilliseconds(), 3)], ["aa", date => date.getHours() > 12 ? "pm" : "am"], ["AA", date => date.getHours() > 12 ? "PM" : "AM"], ["LL", date => date.format("MMMM Do, YYYY")]]);

    var _dec$1f, _class$1V;

    // TODO rename to BaseInputElement
    // TODO handle the setOptions - initialValue lifecycle
    let InputableElement = (_dec$1f = registerStyle(InputStyle), _dec$1f(_class$1V = class InputableElement extends UI$1.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.inputElement);
      }
      isEqual(valueA, valueB) {
        return valueA === valueB;
      }
      setOptions(options) {
        const oldInitialValue = this.options.initialValue;
        super.setOptions(options);
        const {
          initialValue
        } = this.options;
        if (oldInitialValue == null && initialValue == null) {
          return;
        }
        // TODO @branch reimplement to be like Denis's code
        if (this.node && !this.isEqual(initialValue, oldInitialValue)) {
          this.setValue(initialValue);
        }
      }
      focus() {
        this.node.focus();
      }
      blur() {
        this.node.blur();
      }
      onMount() {
        const {
          initialValue
        } = this.options;
        if (initialValue) {
          this.setValue(initialValue);
        }
      }
      addChangeListener(callback) {
        const callbackWrapper = () => {
          callback(this.getValue(), this);
        };
        return new CleanupJobs([this.addNodeListener("change", callbackWrapper), this.addNodeListener("input", callbackWrapper)]);
      }
      addInputListener(callback) {
        return this.addNodeListener("input", callback);
      }
    }) || _class$1V);
    class Input extends UI$1.Primitive(InputableElement, "input") {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setAttribute("type", this.getInputType() || this.options.type);
      }
      getRawValue() {
        return this.node.value;
      }
      getValue() {
        return this.getRawValue().trim();
      }
      setValue(newValue) {
        if (newValue != null) {
          this.node.value = newValue;
        } else {
          this.node.removeAttribute("value");
        }
      }
      setOptions(options) {
        const oldInitialValue = this.options.initialValue;
        const oldValue = this.options.value;
        super.setOptions(options);
        if (!this.node) {
          return;
        }
        const {
          initialValue,
          value
        } = this.options;
        if (initialValue && initialValue !== oldInitialValue) {
          this.setValue(initialValue);
        }
        if (value && value !== oldValue) {
          this.setValue(value);
        }
      }
      getInputType() {
        // Must be overloaded
        return null;
      }
      addKeyUpListener(callback) {
        this.addNodeListener("keyup", callback);
      }
      onMount() {
        // TODO Fix value and initialValue logic
        this.setValue(this.options.value || this.options.initialValue);
      }
    }
    Input.domAttributesMap = new DOMAttributesMap(UI$1.Element.domAttributesMap, [["autocomplete"], ["autofocus", {
      noValue: true
    }], ["formaction"], ["maxLength", {
      domName: "maxlength"
    }], ["minLength", {
      domName: "minlength"
    }], ["name"], ["placeholder"], ["readonly"], ["required"], ["value"], ["pattern"], ["type"]]);
    class SubmitInput extends Input {
      getInputType() {
        return "submit";
      }
    }
    SubmitInput.domAttributesMap = new DOMAttributesMap(Input.domAttributesMap, [["formenctype"], ["formmethod"], ["formnovalidate"], ["formtarget"]]);
    class TextInput extends Input {
      getInputType() {
        return "text";
      }
    }
    class NumberInput extends Input {
      getInputType() {
        return "number";
      }
      getValue() {
        const value = super.getValue();
        return value ? parseFloat(value) : null;
      }
    }
    NumberInput.domAttributesMap = new DOMAttributesMap(Input.domAttributesMap, [["min"], ["max"], ["step"]]);
    class EmailInput extends Input {
      getInputType() {
        return "email";
      }
      isValid() {
        const value = this.getValue();
        // Default regex pattern is RFC 5322 Format
        const regex = new RegExp(this.options.pattern || "([!#-'*+/-9=?A-Z^-~-]+(\.[!#-'*+/-9=?A-Z^-~-]+)*|\"\(\[\]!#-[^-~ \t]|(\\[\t -~]))+\")@([!#-'*+/-9=?A-Z^-~-]+(\.[!#-'*+/-9=?A-Z^-~-]+)*|\[[\t -Z^-~]*])");
        return regex.test(value);
      }
    }
    class PasswordInput extends Input {
      getInputType() {
        return "password";
      }
    }
    class FileInput extends Input {
      getInputType() {
        return "file";
      }
      getFiles() {
        return this.node.files;
      }
      getTotalSize() {
        let totalSize = 0;
        for (const file of this.getFiles()) {
          totalSize += file.size;
        }
        return totalSize;
      }
      getFile() {
        // TODO: this is valid only if multipleFiles is false
        return this.getFiles()[0];
      }
      getAsFormData() {
        let formData = new FormData();
        for (let file of this.getFiles()) {
          formData.append(file.name, file);
        }
        return formData;
      }
      clear() {
        this.node.value = null;
      }
    }
    FileInput.domAttributesMap = new DOMAttributesMap(Input.domAttributesMap, [["multipleFiles", {
      domName: "multiple",
      noValue: true
    }], ["fileTypes", {
      domName: "accept"
    }]]);
    class RawCheckboxInput extends Input {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.checkboxInput);
      }
      getInputType() {
        return "checkbox";
      }
      getValue() {
        return this.node.checked;
      }
      setValue(newValue, indeterminate) {
        this.node.checked = newValue;
        if (indeterminate != null) {
          this.setIndeterminate(indeterminate);
        }
      }
      setIndeterminate(value) {
        this.options.indeterminate = value;
        this.node && (this.node.indeterminate = value);
      }
      getIndeterminate() {
        return this.options.indeterminate;
      }

      // TODO @branch fix this
      render() {
        super.render();
        if (this.options.noStupid) {
          // Temp hack
          return;
        }
        if (this.options.value != this.getValue() || this.getIndeterminate() != this.node?.indeterminate) {
          this.setValue(this.options.value, this.options.indeterminate);
        }
      }
    }
    RawCheckboxInput.domAttributesMap = new DOMAttributesMap(Input.domAttributesMap, [["checked", {
      noValue: true
    }]]);
    class RadioInput extends RawCheckboxInput {
      getInputType() {
        return "radio";
      }
      getValue() {
        return this.node.checked;
      }
      setValue(newValue) {
        this.node.checked = newValue;
      }
    }
    RadioInput.domAttributesMap = new DOMAttributesMap(RawCheckboxInput.domAttributesMap, [["name"]]);
    class TextArea extends UI$1.Primitive(InputableElement, "textarea") {
      applyNodeAttributes() {
        super.applyNodeAttributes();
        this.node.readOnly = this.options.readOnly || false;
      }
      setReadOnly(value) {
        this.options.readOnly = value;
        this.node.readOnly = value;
      }
      getValue() {
        return this.node.value;
      }
      redraw() {
        super.redraw();
        if (this.options.hasOwnProperty("value")) {
          this.node.value = this.options.value + "";
        }
      }
      setValue(value) {
        this.options.value = value;
        this.node.value = value;
      }
      addKeyUpListener(callback) {
        this.addNodeListener("keyup", callback);
      }
    }

    // TODO this element is inconsistent with the rest. Properly fix the initialValue pattern
    class Select extends UI$1.Primitive(InputableElement, "select") {
      render() {
        this.givenOptions = this.options.options || [];
        let selectOptions = [];
        for (let i = 0; i < this.givenOptions.length; i += 1) {
          let options = {
            key: i
          };
          if (this.givenOptions[i] == this.options.selected) {
            options.selected = true;
          }
          selectOptions.push(UI$1.createElement("option", options, this.serializeEntry(this.givenOptions[i])));
        }
        return selectOptions;
      }
      serializeEntry(obj) {
        const formatter = this.options.formatter || this.options.serializer;
        if (formatter) {
          return formatter(obj);
        } else {
          return obj.toString();
        }
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.select);
      }
      get() {
        let selectedIndex = this.getIndex();
        return this.givenOptions[selectedIndex];
      }
      getValue() {
        return this.get();
      }
      set(value) {
        for (let i = 0; i < this.givenOptions.length; i++) {
          if (this.givenOptions[i] === value) {
            this.setIndex(i);
            return;
          }
        }
        console.error("Can't set the select option ", value, "\nAvailable options: ", this.givenOptions);
      }
      setValue(value) {
        this.set(value);
      }
      getIndex() {
        return this.node.selectedIndex;
      }
      setIndex(index) {
        this.node.selectedIndex = index;
        this.options.selected = this.givenOptions[index];
      }
      redraw() {
        super.redraw();
        if (this.options.selected) {
          this.set(this.options.selected);
        }
      }
    }

    var _class$1U, _descriptor$Y, _descriptor2$Q, _descriptor3$I, _descriptor4$D, _descriptor5$z, _descriptor6$t;
    let FormStyle = (_class$1U = class FormStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "form", _descriptor$Y, this);
        _initializerDefineProperty(this, "formGroup", _descriptor2$Q, this);
        _initializerDefineProperty(this, "formField", _descriptor3$I, this);
        _initializerDefineProperty(this, "sameLine", _descriptor4$D, this);
        this.separatedLineInputStyle = {
          marginRight: "0.5em",
          width: "100%",
          height: "2.4em"
        };
        _initializerDefineProperty(this, "separatedLine", _descriptor5$z, this);
        _initializerDefineProperty(this, "hasError", _descriptor6$t, this);
      }
    }, (_descriptor$Y = _applyDecoratedDescriptor(_class$1U.prototype, "form", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0 auto"
        };
      }
    }), _descriptor2$Q = _applyDecoratedDescriptor(_class$1U.prototype, "formGroup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "10px"
        };
      }
    }), _descriptor3$I = _applyDecoratedDescriptor(_class$1U.prototype, "formField", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">label": {
            width: "100%"
          },
          display: "block",
          padding: "6px 0px",
          lineHeight: "1.42857143",
          color: "#555",
          maxWidth: "600px",
          margin: "0 auto",
          "[disabled]": {
            opacity: "1",
            cursor: "not-allowed"
          },
          "[readonly]": {
            opacity: "1"
          }
        };
      }
    }), _descriptor4$D = _applyDecoratedDescriptor(_class$1U.prototype, "sameLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">label>*:nth-child(1)": {
            display: "inline-block",
            textAlign: "right",
            paddingRight: "1em",
            width: "30%",
            verticalAlign: "middle"
          },
          ">label>*:nth-child(2)": {
            display: "inline-block",
            width: "70%",
            verticalAlign: "middle"
          }
        };
      }
    }), _descriptor5$z = _applyDecoratedDescriptor(_class$1U.prototype, "separatedLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "6px 10px",
          ">label>*:nth-child(1)": {
            verticalAlign: "sub"
          },
          ">label>input": this.separatedLineInputStyle,
          ">label>select": this.separatedLineInputStyle,
          ">label>textarea": this.separatedLineInputStyle,
          ">label>input[type='checkbox']": {
            marginLeft: "10px",
            verticalAlign: "middle"
          }
        };
      }
    }), _descriptor6$t = _applyDecoratedDescriptor(_class$1U.prototype, "hasError", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#a94442"
        };
      }
    })), _class$1U);

    var _dec$1e, _class$1T, _dec2$r, _class2$Z;
    let Form = (_dec$1e = registerStyle(FormStyle), _dec$1e(_class$1T = class Form extends UI$1.Primitive("form") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.form);
      }
      onMount() {
        // Form elements by default refresh the page when a button inside them is clicked, so we prevent that.
        this.addNodeListener("submit", event => event.preventDefault());
      }
    }) || _class$1T);
    let FormGroup = (_dec2$r = registerStyle(FormStyle), _dec2$r(_class2$Z = class FormGroup extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.formGroup);
      }
      setError(errorMessage) {
        this.errorField.node.textContent = errorMessage;
        this.addClass(this.styleSheet.hasError);
      }
      removeError() {
        this.errorField.node.textContent = "";
        this.removeClass(this.styleSheet.hasError);
      }
      getErrorField() {
        return UI$1.createElement("span", {
          ref: "errorField",
          style: {
            float: "right"
          }
        });
      }
      getChildrenToRender() {
        return [this.render(), this.getErrorField()];
      }
    }) || _class2$Z);
    class FormField extends FormGroup {
      inline() {
        return !(this.options.inline === false || this.parent && this.parent.options && this.parent.options.inline === false);
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.formField);
        if (this.inline()) {
          attr.addClass(this.styleSheet.sameLine);
        } else {
          attr.addClass(this.styleSheet.separatedLine);
        }
      }
      getLabel() {
        if (this.options.label) {
          return UI$1.createElement("strong", null, this.options.label);
        }
        return null;
      }
      render() {
        if (this.options.contentFirst) {
          return [UI$1.createElement("label", null, [super.render(), this.getLabel()])];
        } else {
          return [UI$1.createElement("label", null, [this.getLabel(), super.render()])];
        }
      }
    }

    // Setting these attributes as styles in mozilla has no effect.
    // To maintain compatibility between moz and webkit, whenever
    // one of these attributes is set as a style, it is also set as a
    // node attribute.
    const MozStyleElements = new Set(["width", "height", "rx", "ry", "cx", "cy", "x", "y"]);
    class SVGNodeAttributes extends NodeAttributes {
      fixMozAttributes(node) {
        if (this.hasOwnProperty("style")) {
          for (let attributeName of MozStyleElements.values()) {
            if (this.style.hasOwnProperty(attributeName) && !this.hasOwnProperty(attributeName)) {
              this.setAttribute(attributeName, this.style[attributeName], node);
            }
          }
        }
      }
      setStyle(attributeName, value, node) {
        super.setStyle(attributeName, value, node);
        if (MozStyleElements.has(attributeName)) {
          this.setAttribute(attributeName, value, node);
        }
      }

      // SVG elements have a different API for setting the className than regular DOM nodes
      applyClassName(node) {
        if (this.className) {
          const className = String(this.className);
          node.setAttribute("class", className);
        } else {
          node.removeAttribute("class");
        }
      }
      apply(node, attributesMap) {
        this.transform = this.transform || this.translate;
        super.apply(node, attributesMap);
        this.fixMozAttributes(node);
      }
    }

    let SVG = {};

    // TODO Simplify this class
    SVG.Element = class SVGElement extends UI$1.Element {
      createNode() {
        this.node = document.createElementNS("http://www.w3.org/2000/svg", this.getNodeType());
        applyDebugFlags(this);
        return this.node;
      }
      getScreenCoordinatedForPoint(point) {
        const node = this.node;
        // TODO: this is a good argument to always keep a reference to the Stem element in the nodes
        const svgNode = node.ownerSVGElement || node;
        if (svgNode.createSVGPoint) {
          // Using native SVG transformations
          // See https://msdn.microsoft.com/en-us/library/hh535760(v=vs.85).aspx
          let svgPoint = svgNode.createSVGPoint();
          svgPoint.x = point.x;
          svgPoint.y = point.y;
          return svgPoint.matrixTransform(node.getScreenCTM().inverse());
        }
        const rect = this.getBoundingClientRect();
        return {
          x: point.x - rect.left - node.clientLeft,
          y: point.y - rect.top - node.clientTop
        };
      }
      getMouseCoordinatesForEvent(event = window.event) {
        return this.getScreenCoordinatedForPoint({
          x: Device.getEventX(event),
          y: Device.getEventY(event)
        });
      }
      saveState() {
        let state = {};
        state.options = Object.assign({}, this.options);
        return state;
      }
      setState(state) {
        this.setOptions(state.options);
      }

      // TODO @cleanup deprecate
      getOptionsAsNodeAttributes() {
        return setObjectPrototype(this.options, SVGNodeAttributes);
      }
      instantiateNodeAttributes() {
        return new SVGNodeAttributes(this.options);
      }
      translate(x = 0, y = 0) {
        this.options.translate = "translate(" + x + "," + y + ")";
      }

      //TODO(@all) : getBoundingClientRect is unreliable, reimplement it.
      getBoundingClientRect() {
        let element = this.node;
        let x = 0;
        let y = 0;
        while (element && element !== document.body) {
          x -= element.scrollLeft;
          y -= element.scrollTop;
          element = element.offsetParent || element.parentNode;
        }
        if (element) {
          x -= element.scrollLeft;
          y -= element.scrollTop;
        }
        let pos = this.node.getBoundingClientRect();
        return {
          top: pos.top - y,
          left: pos.left - x,
          width: pos.width,
          bottom: pos.bottom - y,
          height: pos.height,
          right: pos.right - x
        };
      }
      getBBox() {
        return this.node.getBBox();
      }
      getHeight() {
        return this.getBoundingClientRect().height;
      }
      getWidth() {
        return this.getBoundingClientRect().width;
      }
      toFront() {
        const parentNode = this.node && this.node.parentElement;
        if (parentNode) {
          parentNode.removeChild(this.node);
          parentNode.appendChild(this.node);
        }
      }
      toBack() {}
      setOpacity(newOpacity) {
        this.options.opacity = newOpacity;
        if (this.node) {
          this.node.setAttribute("opacity", newOpacity);
        }
      }
      setColor(color) {
        this.options.color = color;
        if (this.node) {
          this.node.setAttribute("stroke", color);
          this.node.setAttribute("fill", color);
        }
      }
      remove() {}
      getSvg() {
        return this.parent.getSvg();
      }
    };
    SVG.Element.domAttributesMap = new DOMAttributesMap(UI$1.Element.domAttributesMap, [["fill"], ["height"], ["opacity"], ["stroke"], ["strokeWidth", {
      domName: "stroke-width"
    }], ["clipPath", {
      domName: "clip-path"
    }], ["transform"], ["width"], ["cx"], ["cy"], ["rx"], ["ry"], ["x"], ["y"], ["x1"], ["y1"], ["x2"], ["y2"], ["offset"], ["stopColor", {
      domName: "stop-color"
    }], ["strokeDasharray", {
      domName: "stroke-dasharray"
    }], ["strokeLinecap", {
      domName: "stroke-linecap"
    }], ["viewBox", {
      domName: "viewBox"
    }]]);

    SVG.Text = class SVGText extends SVG.Element {
      getNodeType() {
        return "text";
      }
      getDefaultOptions() {
        return {
          text: "",
          fontSize: "15px",
          color: "black",
          dy: "0.35em",
          textAnchor: "middle",
          selectable: false
        };
      }
      extraNodeAttributes(attr) {
        // TODO: For some reason, still selectable in mozilla...
        if (!this.options.selectable) {
          attr.setStyle("-webkit-user-select", "none");
          attr.setStyle("-khtml-user-select", "none");
          attr.setStyle("-moz-user-select", "none");
          attr.setStyle("-ms-user-select", "none");
          attr.setStyle("user-select", "none");
        }
      }
      render() {
        return [UI$1.createElement(UI$1.TextElement, {
          ref: "textElement",
          value: this.options.text + ""
        })];
      }
      getX() {
        return this.options.x;
      }
      setX(x) {
        this.options.x = x;
        this.node.setAttribute("x", this.options.x);
      }
      getY() {
        return this.options.y;
      }
      setY(y) {
        this.options.y = y;
        this.node.setAttribute("y", this.options.y);
      }
      setText(text) {
        this.options.text = text;
        this.textElement.setValue(text + "");
      }
      getText() {
        return this.options.text;
      }
      setPosition(x, y) {
        this.setX(x);
        this.setY(y);
      }
      getColor() {
        return this.options.color;
      }
      setColor(color, fillOnly = false) {
        this.options.color = color;
        if (this.node) {
          this.node.setAttribute("fill", color);
          if (!fillOnly) {
            this.node.setAttribute("stroke", color);
          }
        }
      }
    };
    SVG.Text.domAttributesMap = new DOMAttributesMap(SVG.Element.domAttributesMap, [["dx"], ["dy"], ["fontFamily", {
      domName: "font-family"
    }], ["fontSize", {
      domName: "font-size"
    }], ["textAnchor", {
      domName: "text-anchor"
    }]]);

    SVG.SVGRoot = class SVGRoot extends SVG.Element {
      getNodeType() {
        return "svg";
      }
      getSvg() {
        return this;
      }
    };
    SVG.RawSVG = class RawSVG extends SVG.SVGRoot {
      redraw() {
        super.redraw();
        this.node.innerHTML = this.options.innerHTML;
      }
    };
    SVG.Group = class SVGGroup extends SVG.Element {
      getNodeType() {
        return "g";
      }
      setColor(color) {
        for (let i = 0; i < this.children.length; i += 1) {
          this.children[i].setColor(color);
        }
      }
    };
    SVG.Defs = class SVGDefs extends SVG.Element {
      getNodeType() {
        return "defs";
      }
    };
    SVG.ClipPath = class ClipPath extends SVG.Element {
      getNodeType() {
        return "clipPath";
      }
    };
    SVG.Path = class SVGPath extends SVG.Element {
      getNodeType() {
        return "path";
      }
      getDefaultOptions() {
        return {
          d: ""
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getPath());
        return attr;
      }
      getPath() {
        return this.options.d;
      }
      setPath(newPath) {
        this.options.d = newPath;
        this.node.setAttribute("d", this.options.d);
      }
      getLength() {
        return this.node.getTotalLength();
      }
      getPointAtLength(len) {
        return this.node.getPointAtLength(len);
      }
      getPointAtLengthWithAngle(len) {
        let totalLength = this.getLength();
        let epsilon;
        if (totalLength <= 1) {
          epsilon = totalLength / 1000;
        } else {
          epsilon = Math.min(totalLength / 1000, Math.log(totalLength), 1);
        }
        let p1 = this.getPointAtLength(len);
        let p2 = this.getPointAtLength(Math.min(len + epsilon, totalLength));
        let p3 = this.getPointAtLength(Math.max(len - epsilon, 0));
        return {
          x: p1.x,
          y: p1.y,
          alpha: 180 * Math.atan2(p3.y - p2.y, p3.x - p2.x) / Math.PI
        };
      }
    };
    SVG.Circle = class SVGCircle extends SVG.Element {
      getNodeType() {
        return "circle";
      }
      getDefaultOptions() {
        return {
          radius: 0,
          center: {
            x: 0,
            y: 0
          }
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("r", this.options.radius);
        attr.setAttribute("cx", this.options.center.x);
        attr.setAttribute("cy", this.options.center.y);
        return attr;
      }
      getRadius() {
        return this.options.radius;
      }
      setRadius(radius) {
        this.options.radius = radius;
        this.setAttribute("r", radius);
      }
      setCenter(x, y) {
        this.options.center.x = x;
        this.options.center.y = y;
        this.setAttribute("cx", x);
        this.setAttribute("cy", y);
      }
      getCenter() {
        return this.options.center;
      }
      toPath() {
        let r = this.options.radius;
        let cx = this.options.center.x;
        let cy = this.options.center.y;
        let pathString = "M" + (cx - r) + " " + cy +
        // Starting point is W
        "a" + r + " " + r + " 0 0 1 " + r + " " + -r +
        // Move to N
        "a" + r + " " + r + " 0 0 1 " + r + " " + r +
        // Move to E
        "a" + r + " " + r + " 0 0 1 " + -r + " " + r +
        // Move to S
        "a" + r + " " + r + " 0 0 1 " + -r + " " + -r; // Finally, move back to W
        return new SVG.Path({
          d: pathString
        });
      }
    };
    SVG.Stop = class SVGStop extends SVG.Element {
      getNodeType() {
        return "stop";
      }
    };
    SVG.RadialGradient = class SVGRadialGradient extends SVG.Element {
      getNodeType() {
        return "radialGradient";
      }
    };
    SVG.LinearGradient = class SVGLinearGradient extends SVG.Element {
      getNodeType() {
        return "linearGradient";
      }
    };

    //TODO Complete this class
    SVG.Ellipse = class SVGEllipse extends SVG.Element {
      getNodeType() {
        return "ellipse";
      }
    };
    SVG.CircleArc = class SVGCircleArc extends SVG.Path {
      getPath() {
        let startAngle = this.options.startAngle;
        let endAngle = this.options.endAngle;
        let radius = this.options.radius;
        let center = this.options.center;
        var angleDiff = endAngle - startAngle + (endAngle < startAngle ? 2 * Math.PI : 0);
        var startPoint = polarToCartesian(startAngle, radius, center);
        var endPoint = polarToCartesian(endAngle, radius, center);
        var sweepFlag;
        var largeArcFlag;

        // Set largeArcFlag and sweepFlag
        if (angleDiff <= Math.PI) {
          largeArcFlag = 0;
          if (crossProduct(startPoint, endPoint, center) <= 0) {
            sweepFlag = 0;
          } else {
            sweepFlag = 1;
          }
        } else {
          largeArcFlag = 1;
          if (crossProduct(startPoint, endPoint, center) <= 0) {
            sweepFlag = 1;
          } else {
            sweepFlag = 0;
          }
        }
        return "M " + startPoint.x + " " + startPoint.y + " A " + radius + " " + radius + " 0 " + largeArcFlag + " " + sweepFlag + " " + endPoint.x + " " + endPoint.y;
      }
    };
    SVG.Rect = class SVGRect extends SVG.Element {
      getNodeType() {
        return "rect";
      }
      getX() {
        return this.options.x;
      }
      setX(x) {
        this.options.x = x;
        this.node.setAttribute("x", this.options.x);
      }
      getY() {
        return this.options.y;
      }
      setY(y) {
        this.options.y = y;
        this.node.setAttribute("y", this.options.y);
      }
      getWidth() {
        return this.options.width;
      }
      setWidth(width) {
        this.options.width = width;
        this.node.setAttribute("width", this.options.width);
      }
      getHeight() {
        return this.options.height;
      }
      setHeight(height) {
        this.options.height = height;
        this.node.setAttribute("height", this.options.height);
      }
    };
    SVG.Line = class SVGLine extends SVG.Element {
      getNodeType() {
        return "line";
      }
      getDefaultOptions() {
        return {
          fill: "black",
          stroke: "black"
        };
      }

      //TODO(@all): Make the getters for x1, y1, x2, y2

      setLine(x1, y1, x2, y2) {
        this.options.x1 = x1;
        this.options.y1 = y1;
        this.options.x2 = x2;
        this.options.y2 = y2;
        this.setAttribute("x1", x1);
        this.setAttribute("y1", y1);
        this.setAttribute("x2", x2);
        this.setAttribute("y2", y2);
      }
    };
    SVG.Polygon = class Polygon extends SVG.Path {
      getDefaultOptions() {
        return {
          points: []
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getPolygonPath());
        return attr;
      }
      getPolygonPath() {
        let pathString = "";
        for (let i = 0; i < this.options.points.length; ++i) {
          if (i == 0) {
            pathString += "M ";
          } else {
            pathString += "L ";
          }
          pathString += this.options.points[i].x + " " + this.options.points[i].y + " ";
        }
        pathString += "Z";
        return pathString;
      }
      setPoints(points) {
        this.options.points = points;
        this.setPath(this.getPolygonPath());
      }
    };

    SVG.AnimatedSVG = class AnimatedSVG extends SVG.SVGRoot {
      onMount() {
        if (this.options.transition) {
          this.options.transition.setStartTime(Date.now());
          let animationWrapper = () => {
            if (this.options.transition.isStopped()) {
              if (this.options.repeat) {
                this.options.transition.setStartTime(Date.now());
                this.options.transition.restart();
                requestAnimationFrame(animationWrapper);
              }
              return;
            }
            if (!this.options.transition.pauseTime) {
              this.options.transition.nextStep();
            }
            requestAnimationFrame(animationWrapper);
          };
          requestAnimationFrame(animationWrapper);
        }
      }
    };
    SVG.Element.prototype.blinkTransition = function (options) {
      let config = {
        duration: 2000,
        times: 2,
        firstColor: "grey",
        secondColor: "black",
        executeLastStep: true,
        startTime: 0,
        dependsOn: []
      };
      Object.assign(config, options);
      return new Transition$1({
        func: (t, context) => {
          if (t > 1 - context.interval && !context.executeLastStep) {
            this.setColor(context.firstColor);
          } else {
            this.setColor(Math.floor((1 - t) / context.interval) % 2 === 1 ? context.firstColor : context.secondColor);
          }
        },
        context: {
          firstColor: config.firstColor,
          secondColor: config.secondColor,
          interval: 1 / (2 * config.times),
          executeLastStep: config.executeLastStep
        },
        duration: config.duration,
        startTime: config.startTime,
        dependsOn: config.dependsOn
      });
    };
    SVG.Element.prototype.changeOpacityTransition = function (opacity, duration, dependsOn = [], startTime = 0) {
      if (!this.options.hasOwnProperty("opacity")) {
        this.options.opacity = 1;
      }
      return new Transition$1({
        func: (t, context) => {
          this.setOpacity((1 - t) * context.opacity + t * opacity);
        },
        context: {
          opacity: this.options.opacity
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };
    SVG.Element.prototype.changeColorTransition = function (color, duration, dependsOn = [], startTime = 0) {
      return new Transition$1({
        func: (t, context) => {
          this.setColor(Color$1.interpolate(context.color, color, t));
        },
        context: {
          color: this.getColor()
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };
    SVG.Text.prototype.moveTransition = function (coords, duration, dependsOn = [], startTime = 0) {
      return new Transition$1({
        func: (t, context) => {
          this.setPosition((1 - t) * context.x + t * coords.x, (1 - t) * context.y + t * coords.y);
        },
        context: {
          x: this.options.x,
          y: this.options.y
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };
    SVG.Text.prototype.changeFillTransition = function (color, duration, dependsOn = [], startTime = 0) {
      return new Transition$1({
        func: (t, context) => {
          this.setColor(Color$1.interpolate(context.color, color, t), true);
        },
        context: {
          color: this.getColor()
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };

    var _class$1S, _descriptor$X, _descriptor2$P, _descriptor3$H, _descriptor4$C, _descriptor5$y, _descriptor6$s, _descriptor7$o, _descriptor8$k, _descriptor9$g, _dec$1d, _class2$Y;
    let progressBarColorToStyle = color => {
      let colors = buildColors(color);
      return {
        backgroundColor: colors[1]
      };
    };
    let ProgressBarStyle = (_class$1S = class ProgressBarStyle extends BasicLevelStyleSheet(progressBarColorToStyle) {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$X, this);
        _initializerDefineProperty(this, "bar", _descriptor2$P, this);
        _initializerDefineProperty(this, "striped", _descriptor3$H, this);
        _initializerDefineProperty(this, "active", _descriptor4$C, this);
        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor5$y, this);
        _initializerDefineProperty(this, "SMALL", _descriptor6$s, this);
        _initializerDefineProperty(this, "MEDIUM", _descriptor7$o, this);
        _initializerDefineProperty(this, "LARGE", _descriptor8$k, this);
        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor9$g, this);
      }
    }, (_descriptor$X = _applyDecoratedDescriptor(_class$1S.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 20,
          marginBottom: 20,
          overflow: "hidden",
          backgroundColor: "#f5f5f5",
          borderRadius: 4,
          boxShadow: "inset 0 1px 2px rgba(0, 0, 0, .1)"
        };
      }
    }), _descriptor2$P = _applyDecoratedDescriptor(_class$1S.prototype, "bar", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "left",
          width: "0",
          height: "100%",
          lineHeight: "20px",
          color: "#fff",
          textAlign: "center",
          backgroundColor: "#337ab7",
          boxShadow: "inset 0 -1px 0 rgba(0, 0, 0, .15)",
          transition: "width .25s ease",
          fontColor: "#ffffff",
          fontSize: 12,
          ...this.colorStyleRule(this.themeProps.COLOR_PRIMARY)
        };
      }
    }), _descriptor3$H = _applyDecoratedDescriptor(_class$1S.prototype, "striped", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundImage: "linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent)",
          backgroundSize: "40px 40px"
        };
      }
    }), _descriptor4$C = _applyDecoratedDescriptor(_class$1S.prototype, "active", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          animation: "progress-bar-stripes 2s linear infinite"
        };
      }
    }), _descriptor5$y = _applyDecoratedDescriptor(_class$1S.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "8px"
        };
      }
    }), _descriptor6$s = _applyDecoratedDescriptor(_class$1S.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "10px"
        };
      }
    }), _descriptor7$o = _applyDecoratedDescriptor(_class$1S.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor8$k = _applyDecoratedDescriptor(_class$1S.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor9$g = _applyDecoratedDescriptor(_class$1S.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "17px",
          padding: "0.1em 0.2em"
        };
      }
    })), _class$1S);
    let ProgressBar = (_dec$1d = registerStyle(ProgressBarStyle), _dec$1d(_class2$Y = class ProgressBar extends SimpleStyledElement {
      render() {
        let valueInPercent = (this.options.value || 0) * 100;
        let orientation = Orientation$1.HORIZONTAL;
        if (this.options.hasOwnProperty("orientation")) {
          orientation = this.options.orientation;
        }
        let barStyle;
        if (orientation === Orientation$1.HORIZONTAL) {
          barStyle = {
            width: valueInPercent + "%",
            height: this.options.height + "px"
          };
        } else {
          barStyle = {
            height: valueInPercent + "%",
            width: "5px"
          };
        }
        let barOptions = {
          className: this.styleSheet.bar,
          style: barStyle
        };
        if (this.options.disableTransition) {
          Object.assign(barOptions.style, {
            transition: "none"
          });
        }
        if (this.options.level) {
          barOptions.className += " " + this.styleSheet.Level(this.getLevel());
        }
        if (this.options.striped) {
          barOptions.className += " " + this.styleSheet.striped;
        }
        if (this.options.active) {
          barOptions.className += " " + this.styleSheet.active;
        }
        if (this.options.color) {
          barOptions.style.backgroundColor = this.options.color;
        }
        return UI$1.createElement("div", barOptions, UI$1.createElement("span", null, this.options.label));
      }
      set(value) {
        if (value < 0) value = 0;else if (value > 1) value = 1;
        this.options.value = value;
        this.redraw();
      }
    }) || _class2$Y);

    var _class$1R, _descriptor$W, _descriptor2$O, _descriptor3$G, _descriptor4$B, _descriptor5$x, _descriptor6$r, _descriptor7$n;
    let HorizontalOverflowStyle = (_class$1R = class HorizontalOverflowStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.baseColor = () => this.themeProps.COLOR_PRIMARY;
        this.arrowColor = () => enhance(this.baseColor(), .8);
        this.arrowBackground = () => this.baseColor();
        this.arrowHoverColor = () => enhance(this.baseColor(), 1);
        this.arrowHoverBackground = () => enhance(this.baseColor(), -.3);
        this.transitionTime = .15;
        this.arrow = {
          zIndex: "1",
          alignItems: "center",
          padding: ".3em",
          fontSize: "150% !important",
          height: "100%",
          position: "absolute",
          cursor: "pointer",
          top: 0,
          color: () => this.arrowColor(),
          backgroundColor: () => this.arrowBackground(),
          ":hover": {
            color: () => this.arrowHoverColor(),
            backgroundColor: () => this.arrowHoverBackground()
          }
        };
        _initializerDefineProperty(this, "leftArrow", _descriptor$W, this);
        _initializerDefineProperty(this, "rightArrow", _descriptor2$O, this);
        _initializerDefineProperty(this, "horizontalOverflow", _descriptor3$G, this);
        _initializerDefineProperty(this, "childrenContainer", _descriptor4$B, this);
        _initializerDefineProperty(this, "swipeAnimation", _descriptor5$x, this);
        _initializerDefineProperty(this, "hiddenArrow", _descriptor6$r, this);
        _initializerDefineProperty(this, "pusherContainer", _descriptor7$n, this);
      }
    }, (_descriptor$W = _applyDecoratedDescriptor(_class$1R.prototype, "leftArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({}, this.arrow, {
          left: 0,
          borderRight: () => "2px solid " + this.arrowHoverBackground()
        });
      }
    }), _descriptor2$O = _applyDecoratedDescriptor(_class$1R.prototype, "rightArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({}, this.arrow, {
          right: 0,
          borderLeft: () => "2px solid " + this.arrowHoverBackground()
        });
      }
    }), _descriptor3$G = _applyDecoratedDescriptor(_class$1R.prototype, "horizontalOverflow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          width: "100%",
          ">:first-child": {
            display: "flex"
          },
          ">:last-child": {
            display: "flex"
          }
        };
      }
    }), _descriptor4$B = _applyDecoratedDescriptor(_class$1R.prototype, "childrenContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          overflow: Device.isMobileDevice() ? "auto" : "hidden",
          display: "flex"
        };
      }
    }), _descriptor5$x = _applyDecoratedDescriptor(_class$1R.prototype, "swipeAnimation", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "margin-left " + this.transitionTime + "s ease"
        };
      }
    }), _descriptor6$r = _applyDecoratedDescriptor(_class$1R.prototype, "hiddenArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "none !important"
        };
      }
    }), _descriptor7$n = _applyDecoratedDescriptor(_class$1R.prototype, "pusherContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: Device.isMobileDevice() ? "auto" : "hidden",
          position: "relative",
          display: "flex",
          width: "100%"
        };
      }
    })), _class$1R);

    var _class$1Q, _descriptor$V, _descriptor2$N, _descriptor3$F, _descriptor4$A, _descriptor5$w, _class2$X, _descriptor6$q, _descriptor7$m, _descriptor8$j, _class3$k, _descriptor9$f, _descriptor10$c, _descriptor11$a, _class4$b, _descriptor12$8, _descriptor13$8, _descriptor14$8, _descriptor15$7, _descriptor16$7, _descriptor17$7;
    let BaseTabAreaStyle = (_class$1Q = class BaseTabAreaStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "tab", _descriptor$V, this);
        _initializerDefineProperty(this, "activeTab", _descriptor2$N, this);
        _initializerDefineProperty(this, "nav", _descriptor3$F, this);
        _initializerDefineProperty(this, "switcher", _descriptor4$A, this);
        _initializerDefineProperty(this, "tabArea", _descriptor5$w, this);
      }
    }, (_descriptor$V = _applyDecoratedDescriptor(_class$1Q.prototype, "tab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          userSelect: "none",
          display: "inline-block",
          position: "relative"
        };
      }
    }), _descriptor2$N = _applyDecoratedDescriptor(_class$1Q.prototype, "activeTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor3$F = _applyDecoratedDescriptor(_class$1Q.prototype, "nav", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          listStyle: "none"
        };
      }
    }), _descriptor4$A = _applyDecoratedDescriptor(_class$1Q.prototype, "switcher", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          overflow: "auto"
        };
      }
    }), _descriptor5$w = _applyDecoratedDescriptor(_class$1Q.prototype, "tabArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column"
        };
      }
    })), _class$1Q);
    let DefaultTabAreaStyle = (_class2$X = class DefaultTabAreaStyle extends BaseTabAreaStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "tab", _descriptor6$q, this);
        _initializerDefineProperty(this, "activeTab", _descriptor7$m, this);
        _initializerDefineProperty(this, "nav", _descriptor8$j, this);
      }
    }, (_descriptor6$q = _applyDecoratedDescriptor(_class2$X.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "-1px",
          textDecoration: "none !important",
          marginRight: "2px",
          lineHeight: "1.42857143",
          border: "1px solid transparent",
          borderRadius: "4px 4px 0 0",
          padding: "8px",
          paddingLeft: "10px",
          paddingRight: "10px",
          ":hover": {
            cursor: "pointer",
            backgroundColor: "#eee",
            color: "#555",
            border: "1px solid #ddd",
            borderBottomColor: "transparent"
          }
        };
      }
    }), _descriptor7$m = _applyDecoratedDescriptor(_class2$X.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#555 !important",
          cursor: "default !important",
          backgroundColor: "#fff !important",
          border: "1px solid #ddd !important",
          borderBottomColor: "transparent !important"
        };
      }
    }), _descriptor8$j = _applyDecoratedDescriptor(_class2$X.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "1px solid #ddd",
          paddingLeft: "0",
          marginBottom: "0"
        };
      }
    })), _class2$X);
    let MinimalistTabAreaStyle = (_class3$k = class MinimalistTabAreaStyle extends BaseTabAreaStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "tab", _descriptor9$f, this);
        _initializerDefineProperty(this, "activeTab", _descriptor10$c, this);
        _initializerDefineProperty(this, "nav", _descriptor11$a, this);
      }
    }, (_descriptor9$f = _applyDecoratedDescriptor(_class3$k.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textDecoration: "none !important",
          lineHeight: "1.42857143",
          paddingTop: "6px",
          paddingLeft: "8px",
          paddingRight: "8px",
          paddingBottom: "4px",
          color: "#666",
          borderBottom: "2px solid transparent",
          ":hover": {
            cursor: "pointer",
            color: "rgba(51,122,183,1)"
          }
        };
      }
    }), _descriptor10$c = _applyDecoratedDescriptor(_class3$k.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontWeight: "bold",
          color: "rgba(51,122,183,1)",
          cursor: "default !important",
          borderBottom: "2px solid rgba(51,122,183,1) !important"
        };
      }
    }), _descriptor11$a = _applyDecoratedDescriptor(_class3$k.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          borderBottom: "1px solid #aaa"
        };
      }
    })), _class3$k);
    let FlatTabAreaStyle = (_class4$b = class FlatTabAreaStyle extends BaseTabAreaStyle {
      constructor(...args) {
        super(...args);
        this.transitionTime = 0.3;
        _initializerDefineProperty(this, "tab", _descriptor12$8, this);
        _initializerDefineProperty(this, "activeTab", _descriptor13$8, this);
        _initializerDefineProperty(this, "nav", _descriptor14$8, this);
        _initializerDefineProperty(this, "activeBar", _descriptor15$7, this);
        _initializerDefineProperty(this, "activeBarAnimated", _descriptor16$7, this);
        _initializerDefineProperty(this, "activeOnRender", _descriptor17$7, this);
      }
    }, (_descriptor12$8 = _applyDecoratedDescriptor(_class4$b.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textDecoration: "none !important",
          padding: () => this.themeProps.FLAT_TAB_AREA_PADDING_SIDES,
          paddingBottom: () => this.themeProps.FLAT_TAB_AREA_PADDING_SIDES - this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT,
          borderBottom: () => this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT + "px solid rgba(0,0,0,0)",
          letterSpacing: "0.5px",
          color: () => enhance(this.themeProps.COLOR_FOREGROUND_BODY, 0.4) + "!important",
          fontWeight: "bold",
          ":hover": {
            cursor: "pointer",
            color: () => enhance(this.themeProps.COLOR_FOREGROUND_BODY, 0.6) + "!important"
          },
          ...this.themeProps.FLAT_TAB_AREA_TAB_STYLE
        };
      }
    }), _descriptor13$8 = _applyDecoratedDescriptor(_class4$b.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: () => enhance(this.themeProps.COLOR_FOREGROUND_BODY, 0.8) + "!important",
          cursor: "default !important"
        };
      }
    }), _descriptor14$8 = _applyDecoratedDescriptor(_class4$b.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          whiteSpace: "nowrap",
          position: "relative",
          paddingTop: "4px",
          backgroundColor: () => this.themeProps.COLOR_FOREGROUND_BODY
        };
      }
    }), _descriptor15$7 = _applyDecoratedDescriptor(_class4$b.prototype, "activeBar", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT,
          backgroundColor: () => this.themeProps.COLOR_PRIMARY,
          position: "absolute",
          left: 0,
          bottom: 0
        };
      }
    }), _descriptor16$7 = _applyDecoratedDescriptor(_class4$b.prototype, "activeBarAnimated", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: `${this.transitionTime}s width, ${this.transitionTime}s left`
        };
      }
    }), _descriptor17$7 = _applyDecoratedDescriptor(_class4$b.prototype, "activeOnRender", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingBottom: () => this.themeProps.FLAT_TAB_AREA_PADDING_SIDES - this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT,
          borderBottom: () => this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT + "px solid " + this.themeProps.COLOR_PRIMARY + " !important"
        };
      }
    })), _class4$b);
    class FlatTabAreaHorizontalOverflowStyle extends HorizontalOverflowStyle {
      constructor(...args) {
        super(...args);
        this.baseColor = () => this.themeProps.COLOR_FOREGROUND_BODY;
        this.arrowColor = () => enhance(this.baseColor(), 0.4);
        this.arrowBackground = () => this.baseColor();
        this.arrowHoverColor = () => enhance(this.baseColor(), 0.8);
        this.arrowHoverBackground = () => enhance(this.baseColor(), 0.1);
      }
    }

    var _dec$1c, _class$1P;
    class BasicTabTitle extends Link {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.tab);
        if (this.options.active) {
          attr.addClass(this.styleSheet.activeTab);
        }
      }
      getDefaultOptions() {
        return {
          newTab: false
        };
      }
      canOverwrite(existingElement) {
        // Disable reusing with different panels, since we want to attach listeners to the panel
        return super.canOverwrite(existingElement) && this.options.panel === existingElement.options.panel;
      }
      setActive(active) {
        this.options.active = active;
        this.redraw();
        if (active) {
          this.options.activeTabDispatcher.setActive(this.getPanel(), () => {
            this.setActive(false);
          });
        }
      }
      getPanel() {
        return this.options.panel;
      }
      getTitle() {
        if (this.options.title) {
          return this.options.title;
        }
        let panel = this.getPanel();
        if (typeof panel.getTitle === "function") {
          return panel.getTitle();
        }
        return panel.options.title;
      }
      render() {
        return [this.getTitle()];
      }
      onMount() {
        super.onMount();
        if (this.options.active) {
          this.setActive(true);
        }
        this.addClickListener(() => {
          this.setActive(true);
        });
        if (this.options.panel && this.options.panel.addListener) {
          this.attachListener(this.options.panel, "show", () => {
            this.setActive(true);
          });
        }
      }
    }
    class TabTitleArea extends UI$1.Element {}
    let TabArea = (_dec$1c = registerStyle(DefaultTabAreaStyle), _dec$1c(_class$1P = class TabArea extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.activeTabDispatcher = new SingleActiveElementDispatcher();
      }
      getDefaultOptions() {
        return {
          autoActive: true,
          // means the first Tab will be automatically selected
          // lazyRender: true, // TODO: should be true by default
          panelClass: null,
          // Custom css class can be added to panels
          titleAreaClass: null // Custom css class can be added to title area
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.tabArea);
      }
      createTabPanel(panel) {
        let tab = UI$1.createElement(BasicTabTitle, {
          panel: panel,
          activeTabDispatcher: this.activeTabDispatcher,
          active: panel.options.active,
          href: panel.options.tabHref,
          styleSheet: this.styleSheet
        });
        return [tab, panel];
      }
      appendChild(panel, doMount) {
        let [tabTitle, tabPanel] = this.createTabPanel(panel);
        this.options.children.push(panel);
        this.titleArea.appendChild(tabTitle);
        this.switcher.appendChild(tabPanel, doMount || !this.options.lazyRender);
      }
      getTitleArea(tabTitles) {
        let titleAreaClass = this.styleSheet.nav;
        if (this.options.titleAreaClass) {
          titleAreaClass += " " + this.options.titleAreaClass;
        }
        return UI$1.createElement(TabTitleArea, {
          ref: "titleArea",
          className: titleAreaClass
        }, tabTitles);
      }
      getSwitcher(tabPanels) {
        let switcherClass = this.styleSheet.switcher;
        if (this.options.panelClass) {
          switcherClass += " " + this.options.panelClass;
        }
        return UI$1.createElement(Switcher, {
          className: switcherClass,
          ref: "switcher",
          lazyRender: this.options.lazyRender
        }, tabPanels);
      }
      getChildrenToRender() {
        let tabTitles = [];
        let tabPanels = [];
        let activeTab;
        let givenChildren = unwrapArray(this.render());
        if (this.switcher) {
          // In order to keep track of the active tab we'll use the switcher's logic
          // This also reuses the children
          this.switcher.overwriteChildren(this.switcher.options.children || [], givenChildren);
        }
        for (const panel of givenChildren) {
          let [tabTitle, tabPanel] = this.createTabPanel(panel);
          const tabPanelKey = tabPanel.options && tabPanel.options.key;
          const activePanelKey = this.activePanel && this.activePanel.options && this.activePanel.options.key;
          if (this.activePanel === tabPanel || tabPanelKey != null && tabPanelKey === activePanelKey) {
            activeTab = tabTitle;
          }
          tabTitles.push(tabTitle);
          tabPanels.push(tabPanel);
        }
        if (!activeTab) {
          for (const tabTitle of tabTitles) {
            if (tabTitle.options.active) {
              activeTab = tabTitle;
            }
          }
        } else {
          for (let i = 0; i < tabPanels.length; i += 1) {
            const tabTitle = tabTitles[i];
            const tabPanel = tabPanels[i];
            if (tabTitle.options.active) {
              tabTitle.options.active = false;
            }
            if (tabPanel.options.active) {
              tabPanel.options.active = false;
            }
            if (activeTab === tabTitle) {
              tabPanel.options.active = true;
              tabTitle.options.active = true;
            }
          }
        }
        if (this.options.autoActive && !activeTab && tabTitles.length > 0) {
          tabTitles[0].options.active = true;
        }
        return [this.getTitleArea(tabTitles), this.getSwitcher(tabPanels)];
      }
      setActive(panel) {
        this.activeTabDispatcher.setActive(panel);
      }
      getActive() {
        return this.activeTabDispatcher.getActive();
      }
      onSetActive(panel) {
        this.switcher.setActive(panel);
        this.activePanel = panel;
      }
      onMount() {
        this.attachListener(this.activeTabDispatcher, panel => {
          this.onSetActive(panel);
        });
        this.addListener("resize", () => {
          this.switcher.dispatch("resize");
        });
      }
    }) || _class$1P);

    // Contains classes to abstract some generic Font Awesome usecases.
    class FAIcon extends UI$1.Primitive("i") {
      getIcon() {
        return this.options.icon;
      }
      extraNodeAttributes(attr) {
        attr.addClass("fa");
        attr.addClass("fa-" + this.getIcon());
        if (this.options.size) {
          attr.addClass("fa-" + this.options.size);
        }
      }
      setIcon(icon) {
        this.options.icon = icon;
        this.redraw();
      }
    }
    class FACollapseIcon extends FAIcon {
      getIcon() {
        if (this.options.collapsed) {
          return "angle-right";
        } else {
          return "angle-down";
        }
      }
      setCollapsed(collapsed) {
        this.options.collapsed = collapsed;
        this.redraw();
      }
      toggleCollapsed() {
        this.setCollapsed(!this.options.collapsed);
      }
    }
    class FASortIcon extends FAIcon {
      getIcon() {
        if (this.options.direction === Direction.UP) {
          return "sort-asc";
        } else if (this.options.direction === Direction.DOWN) {
          return "sort-desc";
        } else {
          return "sort";
        }
      }
    }

    var _dec$1b, _class$1O;
    let HorizontalOverflow = (_dec$1b = registerStyle(HorizontalOverflowStyle), _dec$1b(_class$1O = class HorizontalOverflow extends UI$1.Element {
      getDefaultOptions() {
        return {
          swipePercent: .5
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.horizontalOverflow);
      }
      getChildrenToRender() {
        return [UI$1.createElement(FAIcon, {
          ref: "leftArrow",
          icon: "chevron-left",
          className: `${this.styleSheet.leftArrow} ${this.styleSheet.hiddenArrow}`
        }), UI$1.createElement("div", {
          ref: "childrenContainer",
          className: this.styleSheet.childrenContainer
        }, UI$1.createElement("div", {
          ref: "swipeHelperChild"
        }), UI$1.createElement("div", {
          ref: "pusherContainer",
          className: this.styleSheet.pusherContainer
        }, this.render())), UI$1.createElement(FAIcon, {
          ref: "rightArrow",
          icon: "chevron-right",
          className: `${this.styleSheet.rightArrow} ${this.styleSheet.hiddenArrow}`
        })];
      }
      appendChild(...args) {
        this.pusherContainer.appendChild(...args);
      }
      eraseChild(...args) {
        this.pusherContainer.eraseChild(...args);
      }
      checkForOverflow() {
        const children = this.pusherContainer.children;
        if (!children.length) {
          return;
        }
        let shouldOverflowRight = false;
        let shouldOverflowLeft = false;
        const elementRect = this.node.getBoundingClientRect();
        for (let child of children) {
          const childRect = child.node.getBoundingClientRect();
          shouldOverflowRight |= elementRect.left + elementRect.width < childRect.left + childRect.width - 1;
          shouldOverflowLeft |= elementRect.left > childRect.left;
        }
        const leftArrowHidden = !this.leftArrow.getWidth();
        if (shouldOverflowLeft && leftArrowHidden) {
          this.leftArrow.removeClass(this.styleSheet.hiddenArrow);
        } else if (!shouldOverflowLeft && !leftArrowHidden) {
          this.leftArrow.addClass(this.styleSheet.hiddenArrow);
        }
        const rightArrowHidden = !this.rightArrow.getWidth();
        if (shouldOverflowRight && rightArrowHidden) {
          this.rightArrow.removeClass(this.styleSheet.hiddenArrow);
        } else if (!shouldOverflowRight && !rightArrowHidden) {
          this.rightArrow.addClass(this.styleSheet.hiddenArrow);
        }
      }
      scrollContent(amount) {
        let scrollLeft;
        const containerNode = this.pusherContainer.node;
        if (amount < 0) {
          scrollLeft = Math.max(0, containerNode.scrollLeft + amount * this.getWidth());
        } else {
          scrollLeft = Math.min(containerNode.scrollWidth - this.getWidth(), containerNode.scrollLeft + amount * this.getWidth());
        }
        if (amount < 0) {
          this.swipeHelperChild.setStyle("marginLeft", scrollLeft - containerNode.scrollLeft);
          containerNode.scrollLeft = scrollLeft;
        }
        this.pusherContainer.setWidth("fit-content");
        this.swipeHelperChild.addClass(this.styleSheet.swipeAnimation);
        if (amount < 0) {
          this.swipeHelperChild.setStyle("marginLeft", 0);
        } else {
          this.swipeHelperChild.setStyle("marginLeft", containerNode.scrollLeft - scrollLeft);
        }
        setTimeout(() => {
          this.pusherContainer.setWidth("100%");
          this.swipeHelperChild.removeClass(this.styleSheet.swipeAnimation);
          containerNode.scrollLeft = scrollLeft;
          this.swipeHelperChild.setStyle("marginLeft", 0);
          this.checkForOverflow();
        }, this.styleSheet.transitionTime * 1000);
      }
      scrollContentLeft() {
        this.scrollContent(-this.options.swipePercent);
      }
      scrollContentRight() {
        this.scrollContent(this.options.swipePercent);
      }

      // This method should be overwritten, and it is called whenever the position of the elements is changed.
      handleEventAndHandlePositionChange(callback) {
        callback();
      }
      onMount() {
        this.pusherContainer.addNodeListener("scroll", () => this.handleEventAndHandlePositionChange(() => this.checkForOverflow()));
        this.addListener("resize", () => this.handleEventAndHandlePositionChange(() => this.checkForOverflow()));
        this.rightArrow.addClickListener(() => this.handleEventAndHandlePositionChange(() => this.scrollContentRight()));
        this.leftArrow.addClickListener(() => this.handleEventAndHandlePositionChange(() => this.scrollContentLeft()));

        // TODO: Create a resizeable-aware UI Element to be extended by this class and manage these listeners.
        this.attachEventListener(window, "resize", () => this.handleEventAndHandlePositionChange(() => this.checkForOverflow()));
        setTimeout(() => this.checkForOverflow());
      }
    }) || _class$1O);

    var _dec$1a, _class$1N;
    class FlatTabTitle extends BasicTabTitle {
      setActive(active) {
        super.setActive(active);
        if (active) {
          this.options.activeTabTitleDispatcher.setActive(this, () => {
            this.setActive(false);
          });
        }
      }
    }

    // This class displays a bottom bar on the active tab, and when changing tabs it also moves the bottom bar.
    class FlatTabTitleArea extends TabTitleArea {
      constructor(...args) {
        super(...args);
        this.barLeft = 0;
        // Active bar left and width must be cached so the redraw is done seamlessly.
        this.barWidth = 0;
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.nav);
      }
      getChildrenToRender() {
        for (const child of this.render()) {
          if (child.options.active) {
            child.addClass(this.styleSheet.activeOnRender);
          }
        }
        return [UI$1.createElement(HorizontalOverflow, {
          ref: "horizontalOverflow",
          styleSheet: FlatTabAreaHorizontalOverflowStyle
        }, this.render(), UI$1.createElement("div", {
          ref: "bar",
          className: this.styleSheet.activeBar,
          style: {
            left: this.barLeft,
            width: this.barWidth
          }
        }))];
      }
      setActiveBar(activeTab) {
        let barLeft = 0;
        let barWidth = 0;
        for (const tab of unwrapArray(this.render())) {
          const tabWidth = tab.getWidth();
          if (tab === activeTab) {
            barWidth = tabWidth;
            break;
          }
          barLeft += tabWidth;
        }
        this.bar.setStyle({
          left: barLeft,
          width: barWidth
        });
        this.barLeft = barLeft;
        this.barWidth = barWidth;
      }
      setActive(activeTab) {
        if (this.activeTab) {
          // Remove the border from the active tab and "prepare" the bar on the current active tab.
          this.setActiveBar(this.activeTab);
          this.activeTab.removeClass(this.styleSheet.activeOnRender);
        }

        // Animate the bar.
        setTimeout(() => {
          this.bar.addClass(this.styleSheet.activeBarAnimated);
          this.setActiveBar(activeTab);
        });
        setTimeout(() => {
          // Sometimes, another tab has been clicked between the start and end of an animation, so remove the
          // active class on that tab, just in case.
          if (this.activeTab) {
            this.activeTab.removeClass(this.styleSheet.activeOnRender);
          }
          // Add the active class on the current tab.
          activeTab.addClass(this.styleSheet.activeOnRender);
          // Restore the bar to its "unused" state.
          this.bar.removeClass(this.styleSheet.activeBarAnimated);
          this.bar.setWidth(0);
          // Update the active tab.
          this.activeTab = activeTab;
        }, this.styleSheet.transitionTime * 1000);
      }
      onMount() {
        super.onMount();
        for (const child of this.options.children) {
          if (child.options.active) {
            this.setActive(child);
          }
        }
        this.attachListener(this.options.activeTabTitleDispatcher, tab => this.setActive(tab));
        this.addListener("resize", () => this.horizontalOverflow.dispatch("resize"));
      }
    }
    let FlatTabArea = (_dec$1a = registerStyle(FlatTabAreaStyle), _dec$1a(_class$1N = class FlatTabArea extends TabArea {
      constructor(...args) {
        super(...args);
        this.activeTabTitleDispatcher = new SingleActiveElementDispatcher();
      }
      getTitleArea(tabTitles) {
        return UI$1.createElement(FlatTabTitleArea, {
          ref: "titleArea",
          styleSheet: this.styleSheet,
          activeTabTitleDispatcher: this.activeTabTitleDispatcher,
          className: this.options.titleAreaClass || ""
        }, tabTitles);
      }
      createTabPanel(panel) {
        let tab = UI$1.createElement(FlatTabTitle, {
          panel: panel,
          activeTabDispatcher: this.activeTabDispatcher,
          activeTabTitleDispatcher: this.activeTabTitleDispatcher,
          active: panel.options.active,
          href: panel.options.tabHref,
          styleSheet: this.styleSheet
        });
        return [tab, panel];
      }
    }) || _class$1N);

    var _dec$19, _class$1M, _dec2$q, _class2$W;
    let ButtonGroup = (_dec$19 = registerStyle(ButtonGroupStyle), _dec$19(_class$1M = class ButtonGroup extends SimpleStyledElement {
      getDefaultOptions() {
        return {
          orientation: Orientation$1.HORIZONTAL
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.Orientation(this.options.orientation));
      }
    }) || _class$1M);
    let RadioButtonGroup = (_dec2$q = registerStyle(RadioButtonGroupStyle), _dec2$q(_class2$W = class RadioButtonGroup extends SimpleStyledElement {
      setOptions(options) {
        super.setOptions(options);
        this.index = this.options.index || 0;
      }
      render() {
        this.buttons = this.options.givenOptions.map((option, index) => UI$1.createElement(Button$1, {
          key: index,
          onClick: () => this.setIndex(index),
          size: this.getSize(),
          label: option.toString(),
          level: this.getLevel(),
          className: this.index === index ? "active" : ""
        }));
        return this.buttons;
      }
      getIndex() {
        return this.index;
      }
      getValue() {
        return this.options.givenOptions[this.index];
      }
      setIndex(index) {
        this.dispatch("setIndex", {
          index: index,
          oldIndex: this.index,
          value: this.options.givenOptions[index],
          oldValue: this.options.givenOptions[this.index]
        });
        this.buttons[this.index].removeClass("active");
        this.index = index;
        this.buttons[this.index].addClass("active");
      }
    }) || _class2$W);

    class StateButton extends Button$1 {
      setOptions(options) {
        options.state = this.options && this.options.state || options.state || ActionStatus.INITIAL;
        super.setOptions(options);
        this.options.statusOptions = this.options.statusOptions || [];
        for (let i = 0; i < 4; i += 1) {
          if (typeof this.options.statusOptions[i] === "string") {
            let statusLabel = this.options.statusOptions[i];
            this.options.statusOptions[i] = {
              label: statusLabel,
              faIcon: ""
            };
          }
        }
      }
      setState(status) {
        this.options.state = status;
        if (status === ActionStatus.INITIAL) {
          this.enable();
        } else if (status === ActionStatus.RUNNING) {
          this.disable();
        } else ;
        this.redraw();
      }
      render() {
        let stateOptions = this.options.statusOptions[this.options.state - 1];
        this.options.label = stateOptions.label;
        this.options.faIcon = stateOptions.faIcon;
        return super.render();
      }
    }

    class AjaxButton extends StateButton {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions() || {}, {
          resetToDefaultTimeout: 1000
        });
      }
      getAjaxHandler() {
        return this.options.ajaxHandler || Ajax;
      }
      setAjaxHandler(ajaxHandler) {
        this.options.ajaxHandler = ajaxHandler;
      }
      clearResetTimeout() {
        if (this.stateResetTimeout) {
          clearTimeout(this.stateResetTimeout);
          delete this.stateResetTimeout;
        }
      }
      scheduleStateReset() {
        this.clearResetTimeout();
        this.stateResetTimeout = setTimeout(() => {
          this.setState(ActionStatus.INITIAL);
          this.clearResetTimeout();
        }, this.resetToDefaultTimeout);
      }
      ajax(methodName, ...args) {
        this.setState(ActionStatus.RUNNING);
        let ajaxPromise = this.getAjaxHandler()[methodName](...args);
        ajaxPromise.getPromise().then(data => {
          this.setState(ActionStatus.SUCCESS);
          this.scheduleStateReset();
        }, error => {
          this.setState(ActionStatus.FAILED);
          this.scheduleStateReset();
        });
        return ajaxPromise;
      }
      ajaxCall(data) {
        return this.ajax("fetch", data);
      }
    }
    for (const methodName of ["fetch", "request", "get", "post", "getJSON", "postJSON"]) {
      AjaxButton.prototype[methodName] = function (...args) {
        return this.ajax(methodName, ...args);
      };
    }

    var _class$1L, _descriptor$U, _descriptor2$M, _descriptor3$E, _descriptor4$z, _descriptor5$v, _dec$18, _class2$V;
    function cardPanelColorToStyle(color) {
      let colors = buildColors(color);
      return {
        borderColor: colors[4]
      };
    }
    let CardPanelStyle = (_class$1L = class CardPanelStyle extends BasicLevelStyleSheet(cardPanelColorToStyle) {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "heading", _descriptor$U, this);
        _initializerDefineProperty(this, "LARGE", _descriptor2$M, this);
        _initializerDefineProperty(this, "body", _descriptor3$E, this);
        _initializerDefineProperty(this, "container", _descriptor4$z, this);
        _initializerDefineProperty(this, "centered", _descriptor5$v, this);
      }
    }, (_descriptor$U = _applyDecoratedDescriptor(_class$1L.prototype, "heading", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          alignItems: "center",
          width: "100%",
          flexDirection: "row",
          padding: "5px",
          minHeight: this.themeProps.CARD_PANEL_HEADER_HEIGHT,
          textTransform: this.themeProps.CARD_PANEL_TEXT_TRANSFORM,
          paddingLeft: this.themeProps.CARD_PANEL_HEADING_PADDING,
          paddingRight: this.themeProps.CARD_PANEL_HEADING_PADDING,
          ...cardPanelHeaderColorToStyle(this.themeProps.COLOR_BACKGROUND)
        };
      }
    }), _descriptor2$M = _applyDecoratedDescriptor(_class$1L.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minHeight: this.themeProps.CARD_PANEL_HEADER_HEIGHT_LARGE,
          paddingLeft: this.themeProps.CARD_PANEL_HEADING_PADDING_LARGE,
          paddingRight: this.themeProps.CARD_PANEL_HEADING_PADDING_LARGE
        };
      }
    }), _descriptor3$E = _applyDecoratedDescriptor(_class$1L.prototype, "body", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor4$z = _applyDecoratedDescriptor(_class$1L.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [{
          borderWidth: this.themeProps.BASE_BORDER_WIDTH,
          borderRadius: this.themeProps.BASE_BORDER_RADIUS,
          boxShadow: this.themeProps.BASE_BOX_SHADOW,
          borderStyle: this.themeProps.BASE_BORDER_STYLE,
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        }, cardPanelColorToStyle(this.themeProps.COLOR_BACKGROUND)];
      }
    }), _descriptor5$v = _applyDecoratedDescriptor(_class$1L.prototype, "centered", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          justifyContent: "center"
        };
      }
    })), _class$1L);
    function cardPanelHeaderColorToStyle(color) {
      let colors = buildColors(color);
      return {
        color: colors[6],
        backgroundColor: colors[1],
        borderBottomColor: colors[4]
      };
    }
    const CardPanelHeaderStyle = BasicLevelStyleSheet(cardPanelHeaderColorToStyle);
    let CardPanel = (_dec$18 = registerStyle(CardPanelStyle), _dec$18(_class2$V = class CardPanel extends SimpleStyledElement {
      getTitle() {
        return this.options.title;
      }
      getHeaderStyleSheet() {
        return CardPanelHeaderStyle.getInstance();
      }
      getDefaultOptions() {
        return {
          headingCentered: true,
          bodyCentered: false,
          level: Level.PRIMARY
        };
      }
      getHeadingClasses() {
        const {
          styleSheet
        } = this;
        const {
          headingCentered
        } = this.options;
        const headingLevel = this.getHeaderStyleSheet().Level(this.getLevel());
        let headingClasses = styleSheet.heading;
        if (headingLevel) {
          headingClasses = headingClasses + headingLevel;
        }
        if (this.getSize()) {
          headingClasses = headingClasses + styleSheet.Size(this.getSize());
        }
        if (headingCentered) {
          headingClasses = headingClasses + styleSheet.centered;
        }
        return headingClasses;
      }
      getBodyClasses() {
        const {
          styleSheet
        } = this;
        const {
          bodyCentered
        } = this.options;
        let bodyClasses = styleSheet.body;
        if (bodyCentered) {
          bodyClasses = bodyClasses + styleSheet.centered;
        }
        return bodyClasses;
      }
      getChildrenToRender() {
        const headingClasses = this.getHeadingClasses();
        const bodyClasses = this.getBodyClasses();
        return [UI$1.createElement("div", {
          ref: "panelTitle",
          className: headingClasses
        }, this.getTitle()), UI$1.createElement("div", {
          ref: "panelBody",
          className: bodyClasses,
          style: this.options.bodyStyle
        }, this.render())];
      }
    }) || _class2$V);

    var _class$1K, _descriptor$T, _descriptor2$L, _descriptor3$D, _descriptor4$y, _descriptor5$u, _dec$17, _class2$U;
    let RowListStyle = (_class$1K = class RowListStyle extends BasicLevelSizeStyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$T, this);
        _initializerDefineProperty(this, "rowListEntry", _descriptor2$L, this);
        _initializerDefineProperty(this, "LARGE", _descriptor3$D, this);
        _initializerDefineProperty(this, "alternativeColorsOddRow", _descriptor4$y, this);
        _initializerDefineProperty(this, "noAlternativeColors", _descriptor5$u, this);
      }
    }, (_descriptor$T = _applyDecoratedDescriptor(_class$1K.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor2$L = _applyDecoratedDescriptor(_class$1K.prototype, "rowListEntry", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          alignItems: "center",
          width: "100%",
          minHeight: this.themeProps.ROW_LIST_ROW_HEIGHT,
          paddingLeft: this.themeProps.ROW_LIST_ROW_PADDING,
          paddingRight: this.themeProps.ROW_LIST_ROW_PADDING,
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        };
      }
    }), _descriptor3$D = _applyDecoratedDescriptor(_class$1K.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minHeight: this.themeProps.ROW_LIST_ROW_HEIGHT_LARGE,
          paddingLeft: this.themeProps.ROW_LIST_ROW_PADDING_LARGE,
          paddingRight: this.themeProps.ROW_LIST_ROW_PADDING_LARGE
        };
      }
    }), _descriptor4$y = _applyDecoratedDescriptor(_class$1K.prototype, "alternativeColorsOddRow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
        };
      }
    }), _descriptor5$u = _applyDecoratedDescriptor(_class$1K.prototype, "noAlternativeColors", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderTopWidth: this.themeProps.ROW_LIST_ROW_BORDER_WIDTH,
          borderTopStyle: this.themeProps.BASE_BORDER_STYLE,
          borderTopColor: this.themeProps.BASE_BORDER_COLOR
        };
      }
    })), _class$1K); //TODO @cleanup just delete this?
    let RowList = (_dec$17 = registerStyle(RowListStyle), _dec$17(_class2$U = class RowList extends SimpleStyledElement {
      getDefaultOptions(options) {
        return {
          alternateColors: true
        };
      }
      getRowClasses(index) {
        let rowClasses = this.styleSheet.rowListEntry;
        if (this.getSize()) {
          rowClasses = rowClasses + this.styleSheet.Size(this.getSize());
        }
        const {
          alternateColors
        } = this.options;
        if (alternateColors && index % 2 === 1) {
          rowClasses = rowClasses + this.styleSheet.alternativeColorsOddRow;
        } else if (!alternateColors && index > 0) {
          rowClasses = rowClasses + this.styleSheet.noAlternativeColors;
        }
        return rowClasses;
      }
      render() {
        const {
          rows,
          rowParser
        } = this.options;
        return rows.map((row, index) => {
          return UI$1.createElement("div", {
            className: this.getRowClasses(index)
          }, rowParser(row));
        });
      }
    }) || _class2$U);

    var _class$1J, _descriptor$S, _descriptor2$K, _descriptor3$C, _descriptor4$x, _descriptor5$t, _class2$T, _descriptor6$p, _descriptor7$l, _descriptor8$i, _descriptor9$e;
    let CollapsibleStyle = (_class$1J = class CollapsibleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.transitionDuration = 0.4;
        // TODO @theme use this.themeProps.DEFAULT_TRANSITION_DURATION_MS
        _initializerDefineProperty(this, "collapsing", _descriptor$S, this);
        _initializerDefineProperty(this, "collapsed", _descriptor2$K, this);
        _initializerDefineProperty(this, "toggleButton", _descriptor3$C, this);
        _initializerDefineProperty(this, "toggleIcon", _descriptor4$x, this);
        _initializerDefineProperty(this, "toggleIconCollapsed", _descriptor5$t, this);
      }
    }, (_descriptor$S = _applyDecoratedDescriptor(_class$1J.prototype, "collapsing", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "0",
          transitionTimingFunction: "ease",
          transitionDuration: `${this.transitionDuration}s`,
          transitionProperty: "margin-top",
          transitionDelay: "-0.15s"
        };
      }
    }), _descriptor2$K = _applyDecoratedDescriptor(_class$1J.prototype, "collapsed", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "-100% !important",
          transitionDelay: "0s !important"
        };
      }
    }), _descriptor3$C = _applyDecoratedDescriptor(_class$1J.prototype, "toggleButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer"
        };
      }
    }), _descriptor4$x = _applyDecoratedDescriptor(_class$1J.prototype, "toggleIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "0.3s ease",
          display: "inline-block"
        };
      }
    }), _descriptor5$t = _applyDecoratedDescriptor(_class$1J.prototype, "toggleIconCollapsed", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transform: "rotate(-90deg) !important"
        };
      }
    })), _class$1J);
    let CollapsiblePanelStyle = (_class2$T = class CollapsiblePanelStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor6$p, this);
        _initializerDefineProperty(this, "heading", _descriptor7$l, this);
        _initializerDefineProperty(this, "title", _descriptor8$i, this);
        _initializerDefineProperty(this, "content", _descriptor9$e, this);
      }
    }, (_descriptor6$p = _applyDecoratedDescriptor(_class2$T.prototype, "container", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxShadow: null,
          borderWidth: 1,
          borderColor: "#ccc !important",
          borderRadius: this.themeProps.BUTTON_BORDER_RADIUS
        };
      }
    }), _descriptor7$l = _applyDecoratedDescriptor(_class2$T.prototype, "heading", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 10,
          cursor: "pointer",
          fontSize: 16,
          ...(this.themeProps.CARD_HEADER_HEIGHT ? {
            display: "flex",
            alignItems: "center"
          } : {}),
          height: this.themeProps.CARD_HEADER_HEIGHT,
          color: this.themeProps.CARD_HEADER_TEXT_COLOR,
          backgroundColor: this.themeProps.CARD_HEADER_BACKGROUND_COLOR,
          ":hover": {
            backgroundColor: enhance(this.themeProps.CARD_HEADER_BACKGROUND_COLOR, 0.1)
          }
        };
      }
    }), _descriptor8$i = _applyDecoratedDescriptor(_class2$T.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 4
        };
      }
    }), _descriptor9$e = _applyDecoratedDescriptor(_class2$T.prototype, "content", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 8
        };
      }
    })), _class2$T);

    class BaseInputElement extends UI$1.Element {
      getValue() {
        return this.value;
      }

      // TODO This should be an options object, not a list of bools
      setValue(value, dispatchChange = true, doRedraw = true) {
        if (this.isEqual(this.value, value)) {
          return;
        }
        this.value = value;
        if (doRedraw && this.node) {
          this.redraw();
        }
        if (dispatchChange) {
          this.dispatchChange(value);
        }
      }
      isEqual(valueA, valueB) {
        return valueA === valueB;
      }
      setOptions(options) {
        const oldInitialValue = this.options.initialValue;
        super.setOptions(options);
        const {
          initialValue
        } = this.options;
        if (this.value === undefined || !this.node || !this.isEqual(initialValue, oldInitialValue)) {
          this.setValue(initialValue, false, false);
        }
        if (this.options.hasOwnProperty("value")) {
          this.setValue(this.options.value);
        }
      }
      focus() {
        this.node.focus();
      }
      blur() {
        this.node.blur();
      }
    }

    var _class$1I, _descriptor$R, _descriptor2$J, _descriptor3$B, _dec$16, _class2$S;
    let SimpleCollapsibleStyle = (_class$1I = class SimpleCollapsibleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$R, this);
        _initializerDefineProperty(this, "iconCollapsed", _descriptor2$J, this);
        _initializerDefineProperty(this, "collapsed", _descriptor3$B, this);
      }
    }, (_descriptor$R = _applyDecoratedDescriptor(_class$1I.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "all 0.3s ease",
          display: "inline-block"
        };
      }
    }), _descriptor2$J = _applyDecoratedDescriptor(_class$1I.prototype, "iconCollapsed", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transform: "rotate(-90deg) !important"
        };
      }
    }), _descriptor3$B = _applyDecoratedDescriptor(_class$1I.prototype, "collapsed", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // transition: "all 0.3s ease",
          transform: "scaleY(0)",
          maxHeight: 0
        };
      }
    })), _class$1I); // If value is true, it means we're collapsed
    (_dec$16 = registerStyle(SimpleCollapsibleStyle), _dec$16(_class2$S = class CollapsibleControllerInput extends BaseInputElement {
      getTarget() {
        const {
          target
        } = this.options;
        return isFunction(target) ? target() : target;
      }
      expand() {
        this.setValue(false);
        const panel = this.getTarget();
        if (!panel) {
          return;
        }
        const {
          styleSheet
        } = this;
        panel.removeClass(styleSheet.collapsed);
        this.removeClass(styleSheet.iconCollapsed);
      }
      collapse() {
        this.setValue(true);
        const panel = this.getTarget();
        if (!panel) {
          return;
        }
        const {
          styleSheet
        } = this;
        panel.addClass(styleSheet.collapsed);
        // // TODO(@mihai): Implement a pattern for this
        // panel.addNodeListener("transitionend", () => {
        //     if (this.getValue()) {
        //         panel.addClass(GlobalStyle.hidden);
        //     }
        // });

        this.addClass(styleSheet.iconCollapsed);
      }
      toggle() {
        if (this.getValue()) {
          this.expand();
        } else {
          this.collapse();
        }
      }
      applyCollapsedState() {
        if (this.getValue()) {
          this.collapse();
        } else {
          this.expand();
        }
      }
      render() {
        return MakeIcon("chevron-down");
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          this.toggle();
        });
      }
    }) || _class2$S);
    function CollapsibleMixin(BaseClass, CollapsibleClass = CollapsibleStyle) {
      class CollapsibleElement extends BaseClass {
        getDefaultOptions() {
          return {
            collapsed: true
          };
        }
        getCollapsibleStyleSheet() {
          return this.options.collapsibleStyleSheet || this.constructor.collapsibleStyleSheet;
        }
        getToggleIcon() {
          const collapsibleStyle = this.getCollapsibleStyleSheet();
          let iconClassName = collapsibleStyle.toggleIcon;
          if (this.options.collapsed) {
            iconClassName += collapsibleStyle.toggleIconCollapsed;
          }
          return UI$1.createElement("div", {
            ref: "toggleIcon",
            className: iconClassName
          }, MakeIcon("chevron-down"));
        }
        expand(panel = this.contentArea) {
          const collapsibleStyle = this.getCollapsibleStyleSheet();
          this.options.collapsed = false;
          panel.removeClass(GlobalStyle.hidden);
          panel.addClass(collapsibleStyle.collapsing);
          setTimeout(() => {
            panel.removeClass(collapsibleStyle.collapsed);
          }, 100); // TODO @branch take this from this.themeProps

          this.toggleIcon?.removeClass(this.getCollapsibleStyleSheet().toggleIconCollapsed);
        }
        collapse(panel = this.contentArea) {
          const collapsibleStyle = this.getCollapsibleStyleSheet();
          this.options.collapsed = true;
          panel.addClass(collapsibleStyle.collapsing);
          panel.addClass(collapsibleStyle.collapsed);
          // TODO(@mihai): Implement a pattern for this
          panel.addNodeListener("transitionend", () => {
            if (this.options.collapsed) {
              panel.addClass(GlobalStyle.hidden);
            }
          });
          this.toggleIcon?.addClass(this.getCollapsibleStyleSheet().toggleIconCollapsed);
        }
        toggle() {
          if (this.options.collapsed) {
            this.expand();
          } else {
            this.collapse();
          }
        }
      }
      CollapsibleElement.collapsibleStyleSheet = CollapsibleClass.getInstance();
      return CollapsibleElement;
    }

    var _dec$15, _class$1H;
    let CollapsiblePanel = (_dec$15 = registerStyle(CollapsiblePanelStyle), _dec$15(_class$1H = class CollapsiblePanel extends CollapsibleMixin(CardPanel) {
      getPreservedOptions() {
        return {
          collapsed: this.options.collapsed // TODO: rename to defaultCollapsed?
        };
      }
      getChildrenToRender() {
        let contentClassName = this.styleSheet.content;
        if (this.options.collapsed) {
          contentClassName += GlobalStyle.hidden;
        }
        return [UI$1.createElement("div", {
          onClick: () => this.toggle(),
          className: this.styleSheet.heading
        }, this.getToggleIcon(), UI$1.createElement("span", {
          className: this.styleSheet.title
        }, this.getTitle())), UI$1.createElement("div", {
          style: {
            overflow: "hidden"
          }
        }, UI$1.createElement("div", {
          ref: "contentArea",
          className: contentClassName
        }, this.render()))];
      }
    }) || _class$1H);

    var _class$1G, _descriptor$Q, _descriptor2$I, _class2$R, _descriptor3$A, _descriptor4$w, _descriptor5$s, _descriptor6$o, _descriptor7$k;
    let FloatingWindowStyle = (_class$1G = class FloatingWindowStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "hiddenAnimated", _descriptor$Q, this);
        _initializerDefineProperty(this, "visibleAnimated", _descriptor2$I, this);
      }
    }, (_descriptor$Q = _applyDecoratedDescriptor(_class$1G.prototype, "hiddenAnimated", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden",
          opacity: "0",
          transition: "opacity 0.1s linear"
        };
      }
    }), _descriptor2$I = _applyDecoratedDescriptor(_class$1G.prototype, "visibleAnimated", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "visible",
          opacity: "1",
          transition: "opacity 0.1s linear"
        };
      }
    })), _class$1G);
    let ModalStyle = (_class2$R = class ModalStyle extends FloatingWindowStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor3$A, this);
        _initializerDefineProperty(this, "background", _descriptor4$w, this);
        _initializerDefineProperty(this, "header", _descriptor5$s, this);
        _initializerDefineProperty(this, "body", _descriptor6$o, this);
        _initializerDefineProperty(this, "footer", _descriptor7$k, this);
      }
    }, (_descriptor3$A = _applyDecoratedDescriptor(_class2$R.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "fixed",
          top: "0px",
          left: "0px",
          right: "0px",
          bottom: "0px",
          width: "100%",
          height: "100%",
          zIndex: "9999"
        };
      }
    }), _descriptor4$w = _applyDecoratedDescriptor(_class2$R.prototype, "background", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "fixed",
          width: "100%",
          height: "100%",
          background: "rgba(0,0,0,0.5)"
        };
      }
    }), _descriptor5$s = _applyDecoratedDescriptor(_class2$R.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "15px",
          borderBottom: "1px solid #e5e5e5"
        };
      }
    }), _descriptor6$o = _applyDecoratedDescriptor(_class2$R.prototype, "body", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          padding: "15px"
        };
      }
    }), _descriptor7$k = _applyDecoratedDescriptor(_class2$R.prototype, "footer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "15px",
          textAlign: "right",
          borderTop: "1px solid #e5e5e5"
        };
      }
    })), _class2$R);

    var _dec$14, _class$1F;
    let FloatingWindow = (_dec$14 = registerStyle(FloatingWindowStyle), _dec$14(_class$1F = class FloatingWindow extends UI$1.Element {
      getDefaultOptions() {
        return {
          transitionTime: 0,
          style: {
            zIndex: 2016
          }
        };
      }
      fadeOut() {
        this.removeClass(this.styleSheet.visibleAnimated);
        this.addClass(this.styleSheet.hiddenAnimated);
      }
      fadeIn() {
        this.removeClass(this.styleSheet.hiddenAnimated);
        this.addClass(this.styleSheet.visibleAnimated);
      }
      show() {
        // TODO: refactor this to use this.parent and UI.Element appendChild
        if (!this.isInDocument()) {
          this.parentNode.appendChild(this.node);
          this.redraw();
          setTimeout(() => {
            this.fadeIn();
          }, 0);
        }
      }
      setParentNode(parentNode) {
        this.options.parentNode = parentNode;
      }
      get parentNode() {
        if (!this.options.parentNode) {
          if (this.parent) {
            if (this.parent instanceof HTMLElement) {
              this.options.parentNode = this.parent;
            } else {
              this.options.parentNode = this.parent.node;
            }
          } else {
            this.options.parentNode = document.body;
          }
        }
        return this.options.parentNode;
      }
      hide() {
        // TODO: refactor this to use this.parent and UI.Element removeChild
        if (this.isInDocument()) {
          this.fadeOut();
          setTimeout(() => {
            if (this.isInDocument()) {
              this.parentNode.removeChild(this.node);
            }
          }, this.options.transitionTime);
        }
      }
    }) || _class$1F);
    class VolatileFloatingWindow extends FloatingWindow {
      bindWindowListeners() {
        this.hideListener = this.hideListener || (() => {
          this.hide();
        });
        window.addEventListener("click", this.hideListener);
      }
      toggle() {
        if (!this.isInDocument()) {
          this.show();
        } else {
          this.hide();
        }
      }
      show() {
        if (!this.isInDocument()) {
          this.bindWindowListeners();
          super.show();
        }
      }
      hide() {
        if (this.isInDocument()) {
          super.hide();
        }
      }
      onUnmount() {
        super.onUnmount();
        window.removeEventListener("click", this.hideListener);
      }
      onMount() {
        if (!this.options.notVisible) {
          this.bindWindowListeners();
        } else {
          setTimeout(() => {
            this.hide();
          });
        }
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }
    }

    class TemporaryMessageArea extends UI$1.Primitive("span") {
      getDefaultOptions() {
        return {
          margin: 10
        };
      }
      render() {
        return [UI$1.createElement(UI$1.TextElement, {
          ref: "textElement",
          value: this.options.value || ""
        })];
      }
      extraNodeAttributes(attr) {
        attr.setStyle({
          marginLeft: this.options.margin,
          marginRight: this.options.margin
        });
      }
      setValue(value) {
        this.options.value = value;
        this.textElement.setValue(value);
      }
      setColor(color) {
        this.setStyle("color", color);
      }
      showMessage(message, color = "black", displayDuration = 2000) {
        this.setColor(color);
        this.clear();
        this.setValue(message);
        if (displayDuration) {
          this.clearValueTimeout = this.attachTimeout(() => this.clear(), displayDuration);
        }
      }
      clear() {
        this.setValue("");
        if (this.clearValueTimeout) {
          clearTimeout(this.clearValueTimeout);
          this.clearValueTimeout = null;
        }
      }
    }

    var _dec$13, _class$1E;
    let Modal = (_dec$13 = registerStyle(ModalStyle), _dec$13(_class$1E = class Modal extends UI$1.Element {
      getDefaultOptions() {
        return {
          closeButton: true,
          destroyOnHide: true,
          visible: false
        };
      }
      extraNodeAttributes(attr) {
        if (!this.options.visible) {
          attr.addClass("hidden");
        }
      }
      getChildrenToRender() {
        return [UI$1.createElement(Panel, {
          ref: "behindPanel",
          className: this.styleSheet.hiddenAnimated + this.styleSheet.background,
          onClick: () => this.hide()
        }), this.getModalWindow()];
      }
      getModalWindow() {
        let closeButton = null;
        if (this.options.closeButton) {
          // TODO: this should be in a method
          closeButton = UI$1.createElement("div", {
            style: {
              right: "10px",
              zIndex: "10",
              position: "absolute"
            }
          }, UI$1.createElement(Button$1, {
            className: "close",
            size: Size.EXTRA_LARGE,
            style: {
              border: "none"
            },
            label: "\xD7",
            onClick: () => this.hide()
          }));
        }
        return UI$1.createElement(FloatingWindow, {
          ref: "modalWindow",
          style: this.getModalWindowStyle()
        }, closeButton, this.render());
      }
      getModalWindowStyle() {
        if (this.options.fillScreen) {
          this.options.width = "85%";
        }
        // TODO(@Rocky): I don't like this very much, honestly...
        return {
          position: "relative",
          padding: "1%",
          boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
          borderRadius: "10px",
          margin: "60px auto",
          display: this.options.display || "block",
          maxHeight: this.options.maxHeight || "85%",
          left: "0",
          right: "0",
          width: this.options.width || "50%",
          height: this.options.height || "auto",
          background: "white",
          overflow: this.options.overflow || "auto"
        };
      }
      isVisible() {
        return this.options.visible;
      }
      hide() {
        if (!this.isVisible()) {
          return;
        }
        this.options.visible = false;
        this.modalWindow.fadeOut();
        setTimeout(() => {
          this.behindPanel.removeClass(this.styleSheet.visibleAnimated);
          this.behindPanel.addClass(this.styleSheet.hiddenAnimated);
          setTimeout(() => {
            this.addClass("hidden");
            if (this.options.destroyOnHide) {
              this.destroyNode();
            }
          }, this.modalWindow.options.transitionTime || 0);
          this.detachListener(this.closeListenerHandler);
        }, this.modalWindow.options.transitionTime || 0);
        document.body.classList.remove("unscrollable");
      }
      show() {
        this.options.visible = true;
        if (!this.node) {
          this.mount(document.body);
        }
        this.removeClass("hidden");
        setTimeout(() => {
          this.behindPanel.addClass(this.styleSheet.visibleAnimated);
          this.behindPanel.removeClass(this.styleSheet.hiddenAnimated);
          setTimeout(() => {
            this.modalWindow.fadeIn();
          }, this.modalWindow.options.transitionTime);
        }, 0);
        this.closeListenerHandler = this.attachListener(Dispatcher.Global, "closeAllModals", () => {
          this.hide();
        });
        document.body.classList.add("unscrollable");
      }
      static show(options = {}) {
        let modal = new this(options);
        modal.show();
        return modal;
      }
    }) || _class$1E);
    class ActionModal extends Modal {
      getDefaultOptions() {
        return {
          ...super.getDefaultOptions(),
          closeButton: false,
          closeName: "Cancel",
          actionName: "Default Action"
        };
      }
      getActionName() {
        return this.options.actionName;
      }
      getActionLevel() {
        return this.options.level;
      }
      getCloseName() {
        return this.options.closeName;
      }
      render() {
        const {
          styleSheet
        } = this;
        const headerContent = this.getHeader(); // TODO need a rewrite/rename
        const bodyContent = this.getBody();
        const footerContent = this.getFooter();
        return [UI$1.createElement("div", {
          className: styleSheet.header
        }, headerContent), bodyContent && UI$1.createElement("div", {
          className: styleSheet.body
        }, bodyContent), footerContent && UI$1.createElement("div", {
          className: styleSheet.footer
        }, footerContent)];
      }
      getHeader() {
        return UI$1.createElement("h4", null, this.getTitle());
      }
      getTitle() {
        return this.options.title || this.getActionName();
      }
      getBody() {
        return null;
      }

      // If the main action is allowed
      isValid() {
        return true;
      }
      updateActionButtonEnabled() {
        this.actionButton.updateOptions({
          disabled: this.isValid()
        });
      }
      getActionButton() {
        return UI$1.createElement(Button$1, {
          ref: "actionButton",
          level: this.getActionLevel(),
          label: this.getActionName(),
          disabled: !this.isValid(),
          onClick: () => this.action()
        });
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: this.getCloseName(),
          onClick: () => this.hide()
        }), this.getActionButton())];
      }
      action() {}
    }
    const ActionModalButton = ActionModal => class ActionModalButton extends Button$1 {
      getModalOptions() {
        let modalOptions = {
          actionName: this.options.label,
          level: this.options.level
        };
        Object.assign(modalOptions, this.options.modalOptions);
        return modalOptions;
      }
      onMount() {
        this.addClickListener(() => {
          ActionModal.show(this.getModalOptions());
        });
      }
    };
    class ErrorModal extends ActionModal {
      getTitle() {
        return "An Error occurred";
      }
      getBody() {
        return this.options.error.message || this.options.error;
      }
      getFooter() {
        return UI$1.createElement(Button$1, {
          level: Level.DANGER,
          label: "Dismiss",
          onClick: () => this.hide()
        });
      }
    }

    var _class$1D, _descriptor$P;

    // TODO @cleanup this seems to be too complicated
    let GlobalContainerStyle = (_class$1D = class GlobalContainerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$P, this);
      }
    }, (_descriptor$P = _applyDecoratedDescriptor(_class$1D.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => {
            return Device.isMobileDevice() ? `${window.innerHeight}px` : "100vh";
          },
          paddingTop: this.themeProps.NAV_MANAGER_NAVBAR_HEIGHT,
          background: this.themeProps.COLOR_BACKGROUND_BODY,
          width: "100%",
          ">*": {
            height: "100%",
            width: "100%",
            paddingTop: Device.isMobileDevice() ? this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE : this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP,
            paddingBottom: Device.isMobileDevice() ? this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_MOBILE : this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_DESKTOP,
            overflow: Device.isMobileDevice() ? "" : "auto"
          }
        };
      }
    })), _class$1D);

    var _dec$12, _class$1C;
    let GlobalContainer = (_dec$12 = registerStyle(GlobalContainerStyle), _dec$12(_class$1C = class GlobalContainer extends UI$1.Element {
      onMount() {
        if (!Device.isTouchDevice() || !Device.isMobileDevice()) {
          Object.assign(document.body.style, {
            overflow: "hidden"
          });
        }
        GlobalContainer.Global = GlobalContainer.Global || this;
      }
    }) || _class$1C);

    class Divider extends UI$1.Element {
      dragMousedown(event) {}
      dragMousemove(event) {}
      dragMouseup(event) {}
      dividerMousedownFunction(event) {
        this.dragMousedown(event);
        this.parent.dispatch("dividerMousedown", {
          divider: this,
          domEvent: event
        });
        let dragMousemoveFunction = event => {
          this.dragMousemove(event);
          event.preventDefault(); // for touch devices
          this.parent.dispatch("dividerMousemove", event);
        };
        this.parent.addNodeListener("touchmove", dragMousemoveFunction);
        this.parent.addNodeListener("mousemove", dragMousemoveFunction);
        let dragMouseupFunction = event => {
          this.dragMouseup(event);
          this.parent.dispatch("dividerMouseup", event);
          this.parent.removeNodeListener("touchmove", dragMousemoveFunction);
          window.removeEventListener("touchend", dragMouseupFunction);
          this.parent.removeNodeListener("mousemove", dragMousemoveFunction);
          window.removeEventListener("mouseup", dragMouseupFunction);
        };
        window.addEventListener("touchend", dragMouseupFunction);
        window.addEventListener("mouseup", dragMouseupFunction);
      }
      onMount() {
        // TODO: fix this hack when Device.isTouchDevice works
        this.addNodeListener("touchstart", event => {
          this.touchDeviceTriggered = true;
          this.dividerMousedownFunction(event);
        });
        this.addNodeListener("mousedown", event => {
          if (!this.touchDeviceTriggered) {
            this.dividerMousedownFunction(event);
          }
        });
      }
    }

    var _class$1B, _descriptor$O, _class2$Q, _descriptor2$H, _descriptor3$z, _descriptor4$v, _descriptor5$r, _class3$j, _descriptor6$n, _descriptor7$j, _descriptor8$h, _descriptor9$d, _class4$a, _descriptor10$b, _descriptor11$9, _descriptor12$7, _descriptor13$7, _descriptor14$7, _descriptor15$6, _descriptor16$6, _descriptor17$6, _descriptor18$4, _descriptor19$3, _descriptor20$3;
    let DividerStyle = (_class$1B = class DividerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "noTextSelection", _descriptor$O, this);
      }
    }, (_descriptor$O = _applyDecoratedDescriptor(_class$1B.prototype, "noTextSelection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "-webkit-user-select": "none",
          "-moz-user-select": "none",
          "-ms-user-select": "none",
          "-o-user-select": "none",
          userSelect: "none"
        };
      }
    })), _class$1B);
    let AccordionStyle = (_class2$Q = class AccordionStyle extends DividerStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "accordion", _descriptor2$H, this);
        _initializerDefineProperty(this, "grab", _descriptor3$z, this);
        _initializerDefineProperty(this, "grabbing", _descriptor4$v, this);
        _initializerDefineProperty(this, "collapseIcon", _descriptor5$r, this);
      }
    }, (_descriptor2$H = _applyDecoratedDescriptor(_class2$Q.prototype, "accordion", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column",
          ">:nth-of-type(even)": {
            flexGrow: "1",
            flexShrink: "1",
            flexBasis: "auto",
            overflow: "auto",
            position: "relative"
          },
          ">:nth-of-type(odd)": {
            fontSize: "1em",
            textTransform: "uppercase",
            padding: "8px 8px"
          }
        };
      }
    }), _descriptor3$z = _applyDecoratedDescriptor(_class2$Q.prototype, "grab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "grab"
        };
      }
    }), _descriptor4$v = _applyDecoratedDescriptor(_class2$Q.prototype, "grabbing", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "grabbing"
        };
      }
    }), _descriptor5$r = _applyDecoratedDescriptor(_class2$Q.prototype, "collapseIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "0.7em",
          fontSize: "120% !important",
          fontWeight: "900 !important",
          textAlign: "center",
          marginRight: "0.2em"
        };
      }
    })), _class2$Q);
    let SectionDividerStyle = (_class3$j = class SectionDividerStyle extends DividerStyle {
      constructor(...args) {
        super(...args);
        this.barThickness = 2;
        this.barPadding = 3;
        this.dividerColor = () => "#DDD";
        _initializerDefineProperty(this, "horizontalDivider", _descriptor6$n, this);
        _initializerDefineProperty(this, "verticalDivider", _descriptor7$j, this);
        _initializerDefineProperty(this, "horizontalSection", _descriptor8$h, this);
        _initializerDefineProperty(this, "verticalSection", _descriptor9$d, this);
      }
    }, (_descriptor6$n = _applyDecoratedDescriptor(_class3$j.prototype, "horizontalDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          zIndex: "10",
          position: "absolute",
          height: "100%",
          cursor: "col-resize",
          width: this.barThickness + 2 * this.barPadding + "px",
          background: () => this.dividerColor(),
          backgroundClip: "padding-box",
          borderLeft: `${this.barPadding}px solid transparent`,
          borderRight: `${this.barPadding}px solid transparent`,
          marginLeft: `${-this.barThickness / 2 - this.barPadding}px`,
          marginRight: `${-this.barThickness / 2}px`,
          display: "inline-block"
        };
      }
    }), _descriptor7$j = _applyDecoratedDescriptor(_class3$j.prototype, "verticalDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          zIndex: "10",
          position: "absolute",
          cursor: "row-resize",
          width: "100%",
          height: this.barThickness + 2 * this.barPadding + "px",
          background: () => this.dividerColor(),
          backgroundClip: "padding-box",
          borderBottom: `${this.barPadding}px solid transparent`,
          borderTop: `${this.barPadding}px solid transparent`,
          marginBottom: `${-this.barThickness / 2 - this.barPadding}px`,
          marginTop: `${-this.barThickness / 2 - this.barPadding}px`
        };
      }
    }), _descriptor8$h = _applyDecoratedDescriptor(_class3$j.prototype, "horizontalSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          whiteSpace: "nowrap",
          ">*": {
            whiteSpace: "initial",
            verticalAlign: "top",
            paddingLeft: `${this.barThickness / 2 + this.barPadding}px`,
            paddingRight: `${this.barThickness / 2 + this.barPadding}px`
          },
          ">:first-child": {
            paddingLeft: "0"
          },
          ">:last-child": {
            paddingRight: "0"
          },
          ">:nth-of-type(even)": {
            padding: "0"
          },
          ">:nth-of-type(odd)": {
            display: "inline-block"
          }
        };
      }
    }), _descriptor9$d = _applyDecoratedDescriptor(_class3$j.prototype, "verticalSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          ">*": {
            paddingTop: `${this.barThickness / 2 + this.barPadding}px`,
            paddingBottom: `${this.barThickness / 2 + this.barPadding}px`
          },
          ">:first-child": {
            paddingTop: "0"
          },
          ">:last-child": {
            paddingBottom: "0"
          },
          ">:nth-of-type(even)": {
            padding: "0"
          }
        };
      }
    })), _class3$j);
    let TitledDividerStyle = (_class4$a = class TitledDividerStyle extends SectionDividerStyle {
      constructor(...args) {
        super(...args);
        this.barThickness = 16;
        this.barPadding = 1;
        this.transitionTime = 0.3;
        this.dividerStyle = {
          backgroundColor: "white",
          borderColor: "#DDD !important"
        };
        _initializerDefineProperty(this, "horizontalDivider", _descriptor10$b, this);
        _initializerDefineProperty(this, "horizontalDots", _descriptor11$9, this);
        _initializerDefineProperty(this, "verticalDivider", _descriptor12$7, this);
        _initializerDefineProperty(this, "verticalDots", _descriptor13$7, this);
        _initializerDefineProperty(this, "arrowButton", _descriptor14$7, this);
        _initializerDefineProperty(this, "buttonsDisabled", _descriptor15$6, this);
        _initializerDefineProperty(this, "barCollapsePanel", _descriptor16$6, this);
        _initializerDefineProperty(this, "hiddenContent", _descriptor17$6, this);
        _initializerDefineProperty(this, "collapsedBarTitle", _descriptor18$4, this);
        _initializerDefineProperty(this, "animatedSectionDivider", _descriptor19$3, this);
        _initializerDefineProperty(this, "paddingRemoved", _descriptor20$3, this);
      }
    }, (_descriptor10$b = _applyDecoratedDescriptor(_class4$a.prototype, "horizontalDivider", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.dividerStyle, {
          display: "inline-flex",
          alignItems: "center",
          flexDirection: "column",
          ">*": {
            flex: "1",
            display: "flex",
            color: "rgba(0,0,0, .4)"
          },
          ">:first-child": {
            alignItems: "flex-end"
          },
          ">:last-child": {
            alignItems: "flex-start"
          },
          ">:nth-child(2)": {
            flex: ".2",
            alignItems: "center"
          }
        });
      }
    }), _descriptor11$9 = _applyDecoratedDescriptor(_class4$a.prototype, "horizontalDots", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transform: "rotate(90deg) scaleX(5)"
        };
      }
    }), _descriptor12$7 = _applyDecoratedDescriptor(_class4$a.prototype, "verticalDivider", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.dividerStyle, {
          display: "flex",
          alignItems: "center"
        });
      }
    }), _descriptor13$7 = _applyDecoratedDescriptor(_class4$a.prototype, "verticalDots", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          fontSize: "70% !important",
          height: 0,
          textAlign: "center",
          transform: "scaleX(10) translateY(-.4em)"
        };
      }
    }), _descriptor14$7 = _applyDecoratedDescriptor(_class4$a.prototype, "arrowButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "230% !important",
          padding: "1em .2em",
          color: "rgba(0,0,0, .4)",
          cursor: "pointer",
          ":hover": {
            color: "black"
          }
        };
      }
    }), _descriptor15$6 = _applyDecoratedDescriptor(_class4$a.prototype, "buttonsDisabled", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            pointerEvents: "none"
          },
          ">:last-child": {
            pointerEvents: "none"
          }
        };
      }
    }), _descriptor16$6 = _applyDecoratedDescriptor(_class4$a.prototype, "barCollapsePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          ">:first-child": {
            width: "100%",
            height: "100%"
          },
          ">:nth-child(2)": {
            display: "none",
            opacity: "0",
            transition: "opacity " + this.transitionTime + "s ease"
          }
        };
      }
    }), _descriptor17$6 = _applyDecoratedDescriptor(_class4$a.prototype, "hiddenContent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            display: "none"
          },
          ">:nth-child(2)": {
            opacity: "1"
          }
        };
      }
    }), _descriptor18$4 = _applyDecoratedDescriptor(_class4$a.prototype, "collapsedBarTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          borderLeft: "1px solid #ccc",
          borderRight: "1px solid #ccc",
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          backgroundColor: "#fff",
          flexDirection: "column",
          zIndex: 5,
          position: "absolute",
          top: 0,
          left: 0,
          ":hover": {
            backgroundColor: "#f3f3f3"
          },
          ">:nth-child(2)": {
            flex: "1",
            transform: "rotate(90deg)"
          },
          ">:nth-child(2)>:first-child": {
            textTransform: "uppercase",
            fontWeight: "bold",
            fontSize: "130%",
            whiteSpace: "nowrap",
            marginTop: "-.4em",
            transform: "translateY(10%)"
          },
          ">*": {
            display: "flex",
            alignItems: "center"
          },
          ">:first-child": {
            flex: ".5",
            fontSize: "180%"
          },
          ">:last-child": {
            flex: ".5",
            fontSize: "180%"
          }
        };
      }
    }), _descriptor19$3 = _applyDecoratedDescriptor(_class4$a.prototype, "animatedSectionDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            transition: this.transitionTime + "s height ease, " + this.transitionTime + "s width ease"
          }
        };
      }
    }), _descriptor20$3 = _applyDecoratedDescriptor(_class4$a.prototype, "paddingRemoved", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            padding: "0 !important",
            overflow: "hidden"
          },
          ">:nth-of-type(even)": {
            display: "none !important"
          }
        };
      }
    })), _class4$a);

    var _dec$11, _class$1A, _dec2$p, _class2$P;

    // options.orientation is the orientation of the divided elements
    let DividerBar = (_dec$11 = registerStyle(SectionDividerStyle), _dec$11(_class$1A = class DividerBar extends Divider {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          orientation: Orientation$1.HORIZONTAL
        });
      }
      dragMousedown(event) {
        document.body.classList.add(this.styleSheet.noTextSelection);
      }
      dragMouseup(event) {
        document.body.classList.remove(this.styleSheet.noTextSelection);
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        if (this.options.orientation === Orientation$1.VERTICAL) {
          attr.addClass(this.styleSheet.verticalDivider);
        } else {
          attr.addClass(this.styleSheet.horizontalDivider);
        }
      }
    }) || _class$1A);

    /* SectionDivider class should take in:
        - Vertical or horizontal separation
        - All the children it's dividing
        - An option on how to redivide the sizes of the children
     */
    let SectionDivider = (_dec2$p = registerStyle(SectionDividerStyle), _dec2$p(_class2$P = class SectionDivider extends UI$1.Element {
      getDefaultOptions() {
        return Object.assign({
          autoCollapse: false
        }, super.getDefaultOptions());
      }
      constructor(options) {
        super(options);
        this.uncollapsedSizes = new WeakMap();
      }
      getDividerBarClass() {
        return DividerBar;
      }
      extraNodeAttributes(attr) {
        if (this.getOrientation() === Orientation$1.VERTICAL) {
          attr.addClass(this.styleSheet.verticalSection);
        } else {
          attr.addClass(this.styleSheet.horizontalSection);
        }
      }
      getOrientation() {
        return this.options.orientation || Orientation$1.VERTICAL;
      }
      getDimension(element) {
        if (this.getOrientation() === Orientation$1.HORIZONTAL) {
          return element.getWidth();
        } else {
          return element.getHeight();
        }
      }
      setDimension(element, size) {
        if (this.getOrientation() === Orientation$1.HORIZONTAL) {
          element.setWidth(size);
        } else {
          element.setHeight(size);
        }
      }
      getMinDimension(element) {
        if (this.getOrientation() === Orientation$1.HORIZONTAL && element.options.hasOwnProperty("minWidth")) {
          return element.options.minWidth;
        } else if (this.getOrientation() === Orientation$1.VERTICAL && element.options.hasOwnProperty("minHeight")) {
          return element.options.minHeight;
        } else {
          return this.getDimension(this) / this.panels.length / 4;
        }
      }
      getHiddenDivider(index) {
        let divider;
        for (let i = index; i < this.panels.length - 1; i += 1) {
          if (this.dividers[i].hasClass("hidden")) {
            divider = this.dividers[i];
          } else if (!this.dividers[i].hasClass("hidden")) {
            break;
          }
          if (divider && !this.panels[i + 1].hasClass("hidden")) {
            return divider;
          }
        }
        divider = null;
        for (let i = index - 1; i >= 0; i -= 1) {
          if (this.dividers[i].hasClass("hidden")) {
            divider = this.dividers[i];
          } else if (!this.dividers[i].hasClass("hidden")) {
            break;
          }
          if (divider && !this.panels[i].hasClass("hidden")) {
            return divider;
          }
        }
        return null;
      }
      getVisibleDivider(index) {
        for (let i = index; i < this.panels.length - 1; i += 1) {
          if (!this.dividers[i].hasClass("hidden")) {
            return this.dividers[i];
          }
        }
        for (let i = index - 1; i >= 0; i -= 1) {
          if (!this.dividers[i].hasClass("hidden")) {
            return this.dividers[i];
          }
        }
        return null;
      }
      collapseChild(index) {
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let childSize = this.getDimension(child);
        this.uncollapsedSizes.set(child, childSize);
        let unCollapsedCount = -1;
        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }
        let divider = this.getVisibleDivider(index);
        if (divider) {
          divider.hide();
        }
        this.setDimension(child, "0");
        child.hide();
        for (let panel of this.panels) {
          if (this.getDimension(panel) !== 0 && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) + childSize / unCollapsedCount) * 100 / parentSize - 0.5 / this.children.length + "%");
          }
        }
        this.recalculateDimensions();
      }
      expandChild(index) {
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let unCollapsedCount = 1;
        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }
        let divider = this.getHiddenDivider(index);
        if (divider) {
          divider.show();
        }
        child.show();
        let childSize = this.uncollapsedSizes.get(child);
        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) - childSize / (unCollapsedCount - 1)) * 100 / parentSize - this.panels.length / 2 + "%");
          }
        }
        this.setDimension(child, childSize * 100 / parentSize + "%");
        this.recalculateDimensions();
      }
      isCollapsed(child) {
        return !this.getDimension(child);
      }
      toggleChild(index) {
        if (this.isCollapsed(this.panels[index])) {
          this.expandChild(index);
        } else {
          this.collapseChild(index);
        }
      }
      recalculateDimensions() {
        if (!this.isInDocument()) {
          return;
        }
        let parentSize = this.getDimension(this);
        let fixedTotalSize = 0;
        let unfixedTotalSize = 0;
        for (let panel of this.panels) {
          if (panel.options.fixed) {
            fixedTotalSize += this.getDimension(panel);
          } else {
            unfixedTotalSize += this.getDimension(panel);
          }
        }
        let ratio = (parentSize - fixedTotalSize) / parentSize;
        for (let panel of this.panels) {
          if (!panel.options.fixed && !panel.hasClass("hidden")) {
            this.setDimension(panel, this.getDimension(panel) * 100 * ratio / unfixedTotalSize + "%");
          }
        }
      }
      getPreviousUnfixedChild(index) {
        for (let i = index; i >= 0; i -= 1) {
          let panel = this.panels[i];
          if (!panel.hasClass("hidden") && !panel.options.fixed) {
            return panel;
          }
        }
        return null;
      }
      getNextUnfixedChild(index) {
        for (let i = index + 1; i < this.panels.length; i += 1) {
          let panel = this.panels[i];
          if (!panel.hasClass("hidden") && !panel.options.fixed) {
            return panel;
          }
        }
        return null;
      }
      dividerMouseDownFunction(dividerEvent) {
        let previousEvent = dividerEvent.domEvent;
        const index = this.dividers.indexOf(dividerEvent.divider);
        const previousPanel = this.getPreviousUnfixedChild(index);
        const nextPanel = this.getNextUnfixedChild(index);
        if (previousPanel && nextPanel) {
          const parentSize = this.getDimension(this);
          let panelsSize = parentSize;
          for (let panel of this.panels) {
            if (panel.options.fixed) {
              panelsSize -= this.getDimension(panel);
            }
          }
          const deltaFunction = this.getOrientation() === Orientation$1.HORIZONTAL ? event => Device.getEventX(event) : event => Device.getEventY(event);
          const mouseMoveListener = this.addListener("dividerMousemove", event => {
            const delta = deltaFunction(event) - deltaFunction(previousEvent);
            const nextSize = this.getDimension(nextPanel) - delta;
            const previousSize = this.getDimension(previousPanel) + delta;
            if (this.options.autoCollapse) {
              if (delta > 0 && nextPanel.collapsed || delta < 0 && previousPanel.collapsed) {
                return;
              }
              if (delta < 0 && nextPanel.collapsed && this.options.autoCollapse) {
                this.expandChild(index + 1);
                return;
              }
              if (delta > 0 && previousPanel.collapsed) {
                this.expandChild(index);
                return;
              }
              if (nextSize < this.getMinDimension(nextPanel)) {
                this.collapseChild(index + 1);
                return;
              }
              if (previousSize < this.getMinDimension(previousPanel)) {
                this.collapseChild(index);
                return;
              }
            } else {
              if (nextSize < this.getMinDimension(nextPanel) || previousSize < this.getMinDimension(previousPanel)) {
                return;
              }
            }
            this.setDimension(nextPanel, nextSize * 100 / parentSize + "%");
            this.setDimension(previousPanel, previousSize * 100 / parentSize + "%");
            previousEvent = event;
          });
          const mouseUpListener = this.addListener("dividerMouseup", () => {
            if (this.clearListeners) {
              this.clearListeners();
            }
          });
          this.clearListeners = () => {
            mouseMoveListener.remove();
            mouseUpListener.remove();
            this.clearListeners = null;
          };
        }
      }
      onMount() {
        this.addListener("dividerMousedown", dividerEvent => this.dividerMouseDownFunction(dividerEvent));
        setTimeout(() => {
          this.recalculateDimensions();
        });
      }
      getChildrenToRender() {
        const children = [];
        this.dividers = [];
        this.panels = [];
        let leftChildVisible = false;
        const DividerBarClass = this.getDividerBarClass();
        for (let child of unwrapArray(this.render())) {
          if (this.panels.length) {
            let hiddenClass = "hidden";
            if (leftChildVisible && !child.hasClass("hidden")) {
              hiddenClass = "";
            }
            let divider = UI$1.createElement(DividerBarClass, {
              className: hiddenClass,
              orientation: this.getOrientation()
            });
            children.push(divider);
            this.dividers.push(divider);
          }
          leftChildVisible |= !child.hasClass("hidden");
          children.push(child);
          this.panels.push(child);
        }
        return children;
      }
    }) || _class2$P);

    var _dec$10, _class$1z, _dec2$o, _class2$O, _dec3$9, _class3$i;
    let TitledSectionDividerBar = (_dec$10 = registerStyle(TitledDividerStyle), _dec$10(_class$1z = class TitledSectionDividerBar extends DividerBar {
      render() {
        if (this.options.orientation === Orientation$1.VERTICAL) {
          return [UI$1.createElement(FAIcon, {
            icon: "ellipsis-h",
            className: this.styleSheet.verticalDots
          })];
        }
        return [UI$1.createElement("div", null, UI$1.createElement(FAIcon, {
          ref: "rightButton",
          icon: "caret-right",
          className: this.styleSheet.arrowButton
        })), UI$1.createElement("div", null, UI$1.createElement(FAIcon, {
          icon: "bars",
          className: this.styleSheet.horizontalDots
        })), UI$1.createElement("div", null, UI$1.createElement(FAIcon, {
          ref: "leftButton",
          icon: "caret-left",
          className: this.styleSheet.arrowButton
        }))];
      }
      onMount() {
        super.onMount();
        this.leftButton.addNodeListener("mousedown", event => {
          event.stopPropagation();
        });
        this.leftButton.addClickListener(() => {
          this.dispatch("collapsePrevious");
        });
        this.rightButton.addNodeListener("mousedown", event => {
          event.stopPropagation();
        });
        this.rightButton.addClickListener(() => {
          this.dispatch("collapseNext");
        });
      }
    }) || _class$1z);
    let BarCollapsePanel = (_dec2$o = registerStyle(TitledDividerStyle), _dec2$o(_class2$O = class BarCollapsePanel extends UI$1.Element {
      extraNodeAttributes(attr) {
        const panelChild = this.getGivenChildren()[0];
        attr.addClass(this.styleSheet.barCollapsePanel);
        let panelSize = panelChild.options.size;
        if (this.collapsed) {
          attr.addClass(this.styleSheet.hiddenContent);
          panelSize = this.options.collapsedSize;
        }
        if (panelSize) {
          if (this.options.orientation === Orientation$1.VERTICAL) {
            attr.setStyle("height", panelSize);
          } else {
            attr.setStyle("width", panelSize);
          }
        }
        if (this.options.orientation === Orientation$1.VERTICAL) {
          attr.setStyle("width", "100%");
        } else {
          attr.setStyle("height", "100%");
        }
      }
      getChildrenToRender() {
        this.collapsed = this.getGivenChildren()[0].options.collapsed;
        const isFirst = this.parent.panels.indexOf(this) === 0;
        const isLast = this.parent.panels.indexOf(this) === this.parent.panels.length - 1;
        const firstCaret = isLast ? "left" : "right";
        const lastCaret = isFirst ? "right" : "left";
        return [this.render(), UI$1.createElement("div", {
          ref: "collapsedBarTitle",
          style: {
            display: this.collapsed ? "flex" : " none"
          },
          className: this.styleSheet.collapsedBarTitle
        }, UI$1.createElement("div", null, UI$1.createElement(FAIcon, {
          icon: "caret-" + firstCaret
        })), UI$1.createElement("div", {
          className: this.styleSheet.title
        }, UI$1.createElement("div", null, this.options.title)), UI$1.createElement("div", null, UI$1.createElement(FAIcon, {
          icon: "caret-" + lastCaret
        })))];
      }
      toggle() {
        if (this.collapsed) {
          this.collapsed = false;
          this.removeClass(this.styleSheet.hiddenContent);
          this.collapsedBarTitle.setStyle("display", "none");
        } else {
          this.collapsed = true;
          this.collapsedBarTitle.setStyle("display", "flex");
          setTimeout(() => {
            this.addClass(this.styleSheet.hiddenContent);
          }, 100);
        }
      }
      onMount() {
        this.collapsedBarTitle.addClickListener(() => {
          this.dispatch("expand");
        });
        this.addListener("resize", () => {
          for (const child of unwrapArray(this.render())) {
            child.dispatch("resize");
          }
        });
      }
    }) || _class2$O);
    let TitledSectionDivider = (_dec3$9 = registerStyle(TitledDividerStyle), _dec3$9(_class3$i = class TitledSectionDivider extends SectionDivider {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          collapsedSize: 40,
          autoCollapse: true
        });
      }
      getDividerBarClass() {
        return TitledSectionDividerBar;
      }
      setDimension(element, size) {
        if (this.getOrientation() === Orientation$1.HORIZONTAL) {
          element.setWidth(size);
        } else {
          element.setHeight(size);
        }
      }
      collapseChild(index) {
        if (this.clearListeners) {
          this.clearListeners();
        }
        this.addClass(this.styleSheet.paddingRemoved);
        this.addClass(this.styleSheet.animatedSectionDivider);
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let childSize = this.getDimension(child);
        this.uncollapsedSizes.set(child, childSize);
        let unCollapsedCount = -1;
        for (let panel of this.panels) {
          if (!panel.collapsed && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }
        this.setDimension(child, this.options.collapsedSize);
        child.toggle();
        for (let panel of this.panels) {
          if (!panel.collapsed && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) + (childSize - this.options.collapsedSize) / unCollapsedCount) * 100 / parentSize + "%");
          }
        }
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.recalculateDimensions();
        }, this.styleSheet.transitionTime * 1000);
      }
      expandChild(index) {
        this.removeClass(this.styleSheet.paddingRemoved);
        this.addClass(this.styleSheet.animatedSectionDivider);
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let unCollapsedCount = 1;
        for (let panel of this.panels) {
          if (!panel.collapsed && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }
        let childSize = this.uncollapsedSizes.get(child);
        child.toggle();
        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) - (childSize - this.options.collapsedSize) / (unCollapsedCount - 1)) * 100 / parentSize + "%");
          }
        }
        this.setDimension(child, childSize * 100 / parentSize + "%");
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.recalculateDimensions();
        }, this.styleSheet.transitionTime * 1000);
      }
      getChildrenToRender() {
        const children = [];
        this.dividers = [];
        this.panels = [];
        const DividerBarClass = this.getDividerBarClass();
        for (const child of unwrapArray(this.render())) {
          if (child.options.collapsed) {
            this.addClass(this.styleSheet.paddingRemoved);
          }
          if (this.panels.length) {
            let divider = UI$1.createElement(DividerBarClass, {
              orientation: this.getOrientation()
            });
            children.push(divider);
            this.dividers.push(divider);
          }
          const wrappedChild = UI$1.createElement(BarCollapsePanel, {
            orientation: this.options.orientation,
            collapsedSize: this.options.collapsedSize,
            title: child.options.title || "..."
          }, child);
          children.push(wrappedChild);
          this.panels.push(wrappedChild);
        }
        return children;
      }
      onMount() {
        super.onMount();
        for (let i = 0; i < this.panels.length; i += 1) {
          const panel = this.panels[i];
          this.attachListener(panel, "expand", () => {
            this.uncollapsedSizes.set(panel, this.getDimension(this) / this.panels.length);
            this.expandChild(i);
          });
        }
        for (let i = 0; i < this.dividers.length; i += 1) {
          this.attachListener(this.dividers[i], "collapseNext", () => this.collapseChild(i + 1));
          this.attachListener(this.dividers[i], "collapsePrevious", () => this.collapseChild(i));
        }
      }
    }) || _class3$i);

    var _dec$$, _class$1y, _dec2$n, _class2$N;
    let AccordionDivider = (_dec$$ = registerStyle(AccordionStyle), _dec$$(_class$1y = class AccordionDivider extends Divider {
      dragMousedown(event) {
        document.body.classList.add(this.styleSheet.noTextSelection);
        this.addClass(this.styleSheet.grabbing);
      }
      dragMouseup(event) {
        document.body.classList.remove(this.styleSheet.noTextSelection);
        this.removeClass(this.styleSheet.grabbing);
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.grab);
      }
      render() {
        return [UI$1.createElement(FACollapseIcon, {
          ref: "collapseIcon",
          collapsed: false,
          className: this.styleSheet.collapseIcon
        }), this.options.children];
      }
      setCollapsed(value) {
        this.collapseIcon.setCollapsed(value);
      }
      onMount() {
        super.onMount();
        this.addListener("togglePanel", () => {
          this.collapseIcon.toggleCollapsed();
        });
      }
    }) || _class$1y);
    let Accordion = (_dec2$n = registerStyle(AccordionStyle), _dec2$n(_class2$N = class Accordion extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.accordion);
      }
      getChildrenToRender() {
        let children = [];
        this.dividers = [];
        this.panels = [];
        for (let child of unwrapArray(this.render())) {
          let title = child.getTitle ? child.getTitle() : child.options.title ? child.options.title : "";
          let divider = UI$1.createElement(AccordionDivider, null, title);
          this.dividers.push(divider);
          this.panels.push(child);
          children.push(divider);
          children.push(child);
        }
        return children;
      }
      getNextVisibleChild(index) {
        for (let i = index; i < this.panels.length; i += 1) {
          if (!this.panels[i].hasClass("hidden")) {
            return this.panels[i];
          }
        }
        return null;
      }
      getPreviousVisibleChild(index) {
        for (let i = index - 1; i >= 0; i -= 1) {
          if (!this.panels[i].hasClass("hidden")) {
            return this.panels[i];
          }
        }
        return null;
      }
      dividerMousedownFunction(dividerEvent) {
        let dragTriggered, panelsHeight, totalFlex;
        let previousEvent = dividerEvent.domEvent;
        let index = this.dividers.indexOf(dividerEvent.divider);
        let previousPanel = this.getPreviousVisibleChild(index);
        let nextPanel = this.getNextVisibleChild(index);
        panelsHeight = this.getHeight();
        for (let divider of this.dividers) {
          panelsHeight -= divider.getHeight();
        }
        totalFlex = 0;
        for (let panel of this.panels) {
          if (!panel.hasClass("hidden")) {
            totalFlex += parseFloat(getComputedStyle(panel.node, "flex"));
          }
        }
        let mouseMoveListener = this.addListener("dividerMousemove", event => {
          dragTriggered = true;
          if (index != -1 && nextPanel && previousPanel) {
            // Calculate the height to transfer from one panel to another
            let delta = (Device.getEventY(event) - Device.getEventY(previousEvent)) * totalFlex / panelsHeight;
            let nextSize = parseFloat(getComputedStyle(nextPanel.node, "flex"));
            let previousSize = parseFloat(getComputedStyle(previousPanel.node, "flex"));

            // Cap the delta value, to at most zero our panels
            delta = Math.sign(delta) * Math.min(Math.abs(delta), delta > 0 ? nextSize : previousSize);
            nextPanel.setStyle("flex", nextSize - delta);
            previousPanel.setStyle("flex", previousSize + delta);
            previousEvent = event;
            this.dispatch("dragging");
          }
        });
        let mouseUpListener = this.addListener("dividerMouseup", () => {
          if (!dragTriggered) {
            dividerEvent.divider.dispatch("togglePanel");
            this.toggleChild(this.panels[index]);
          }
          mouseMoveListener.remove();
          mouseUpListener.remove();
          this.dispatch("childrenStatusChange");
        });
      }
      toggleChild(child) {
        let totalFlex = 0;
        for (let panel of this.panels) {
          if (!panel.hasClass("hidden")) {
            totalFlex += parseFloat(getComputedStyle(panel.node, "flex"));
          }
        }
        let sign = child.hasClass("hidden") ? 1 : -1;
        totalFlex += sign * parseFloat(getComputedStyle(child, "flex"));
        child.toggleClass("hidden");
        if (totalFlex < 1) {
          for (let panel of this.panels) {
            if (!panel.hasClass("hidden") && parseFloat(getComputedStyle(panel.node, "flex")) < 1) {
              panel.setStyle("flex", 1);
            }
          }
        }
      }
      getChildrenStatus() {
        let childrenStatus = [];
        for (let panel of this.panels) {
          childrenStatus.push({
            flex: getComputedStyle(panel.node, "flex"),
            collapsed: panel.hasClass("hidden")
          });
        }
        return childrenStatus;
      }
      getDefaultChildrenStatus() {
        let childrenStatus = [];
        for (let panel of this.panels) {
          childrenStatus.push({
            flex: 1,
            collapsed: false
          });
        }
        return childrenStatus;
      }
      setChildrenStatus(childrenStatus) {
        for (let i = 0; i < childrenStatus.length; i += 1) {
          this.panels[i].setStyle("flex", childrenStatus[i].flex);
          let collapsed = childrenStatus[i].collapsed;
          if (collapsed) {
            this.panels[i].addClass("hidden");
          } else {
            this.panels[i].removeClass("hidden");
          }
          this.dividers[i].setCollapsed(collapsed);
        }
      }
      onMount() {
        this.addListener("dividerMousedown", dividerEvent => this.dividerMousedownFunction(dividerEvent));
      }
    }) || _class2$N);

    var _class$1x, _descriptor$N, _descriptor2$G, _descriptor3$y, _descriptor4$u, _dec$_, _class2$M;

    // TODO Review CSS
    let CarouselStyle = (_class$1x = class CarouselStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.navigatorHeight = "35px";
        this.hoverColor = "#364251";
        this.transitionTime = "0.3";
        this.textColor = "inherit";
        this.navigatorTransitionTime = "0s";
        _initializerDefineProperty(this, "carousel", _descriptor$N, this);
        _initializerDefineProperty(this, "container", _descriptor2$G, this);
        _initializerDefineProperty(this, "navigator", _descriptor3$y, this);
        _initializerDefineProperty(this, "navigatorIcon", _descriptor4$u, this);
      }
    }, (_descriptor$N = _applyDecoratedDescriptor(_class$1x.prototype, "carousel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: "auto"
        };
      }
    }), _descriptor2$G = _applyDecoratedDescriptor(_class$1x.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          whiteSpace: "nowrap",
          height: "100%",
          ">*": {
            width: "100%",
            height: "100%",
            display: "inline-block",
            verticalAlign: "top"
          },
          ">:first-child": {
            width: "0",
            transition: `margin-left ease ${this.transitionTime}s`
          }
        };
      }
    }), _descriptor3$y = _applyDecoratedDescriptor(_class$1x.prototype, "navigator", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: this.navigatorHeight,
          display: "flex"
        };
      }
    }), _descriptor4$u = _applyDecoratedDescriptor(_class$1x.prototype, "navigatorIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.textColor,
          fontSize: "180% !important",
          textAlign: "center",
          cursor: "pointer",
          flex: "1",
          fontWeight: "900 !important",
          lineHeight: this.navigatorHeight + " !important",
          transition: `background-color ${this.navigatorTransitionTime}`,
          ":hover": {
            backgroundColor: this.hoverColor
          }
        };
      }
    })), _class$1x);
    class CarouselNavigator extends UI$1.Element {
      get styleSheet() {
        return super.styleSheet || this.parent.styleSheet;
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.navigator);
      }
      render() {
        return [UI$1.createElement(FAIcon, {
          icon: "angle-left",
          className: this.styleSheet.navigatorIcon,
          onClick: () => {
            this.parent.dispatch("previousPage");
          }
        }), UI$1.createElement(FAIcon, {
          icon: "angle-right",
          className: this.styleSheet.navigatorIcon,
          onClick: () => {
            this.parent.dispatch("nextPage");
          }
        })];
      }
    }
    let Carousel = (_dec$_ = registerStyle(CarouselStyle), _dec$_(_class2$M = class Carousel extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.carousel);
      }
      appendChild(child, doMount) {
        this.options.children.push(child);
        if (doMount) {
          this.setActive(child);
        }
        child.mount(this, null);
        this.redraw();
      }
      eraseChild(child) {
        if (this.options.children.indexOf(child) === this.options.children.length - 1) {
          this.setActiveIndex(Math.max(this.options.children.length - 2, 0));
        }
        this.options.children.splice(this.options.children.indexOf(child), 1);
        this.redraw();
      }
      render() {
        if (this.activeIndex == null) {
          this.activeIndex = 0;
          for (let i = 0; i < this.options.children.length; i += 1) {
            if (this.options.children[i].options.active) {
              this.activeIndex = i;
              break;
            }
          }
        }
        return [UI$1.createElement(CarouselNavigator, {
          className: this.options.children.length > 1 ? "" : "hidden"
        }), UI$1.createElement("div", {
          className: this.styleSheet.container
        }, UI$1.createElement("div", {
          ref: "pusher",
          style: {
            marginLeft: `${-this.activeIndex * 100}%`
          }
        }), this.options.children)];
      }
      setActive(panel) {
        this.setActiveIndex(this.options.children.indexOf(panel));
      }
      setActiveIndex(index) {
        this.activeIndex = index;
        this.pusher.setStyle("margin-left", `${-index * this.getWidth()}px`);
      }
      getActive() {
        return this.options.children[this.activeIndex];
      }
      onMount() {
        this.addListener("nextPage", () => this.setActiveIndex((this.activeIndex + 1) % this.options.children.length));
        this.addListener("previousPage", () => this.setActiveIndex((this.activeIndex + this.options.children.length - 1) % this.options.children.length));
      }
      getOrientation() {
        return this.options.orientation || Orientation$1.VERTICAL;
      }
    }) || _class2$M);

    var _class$1w, _descriptor$M, _descriptor2$F, _descriptor3$x, _descriptor4$t, _descriptor5$q, _descriptor6$m, _descriptor7$i;
    let RangePanelStyle = (_class$1w = class RangePanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.rowHeight = 52;
        _initializerDefineProperty(this, "default", _descriptor$M, this);
        _initializerDefineProperty(this, "tableContainer", _descriptor2$F, this);
        _initializerDefineProperty(this, "scrollablePanel", _descriptor3$x, this);
        _initializerDefineProperty(this, "fakePanel", _descriptor4$t, this);
        _initializerDefineProperty(this, "footer", _descriptor5$q, this);
        _initializerDefineProperty(this, "jumpToButton", _descriptor6$m, this);
        _initializerDefineProperty(this, "table", _descriptor7$i, this);
      }
    }, (_descriptor$M = _applyDecoratedDescriptor(_class$1w.prototype, "default", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          position: "relative",
          overflow: "auto",
          overflowY: "hidden"
        };
      }
    }), _descriptor2$F = _applyDecoratedDescriptor(_class$1w.prototype, "tableContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          height: "100%",
          width: "100%",
          position: "relative"
        };
      }
    }), _descriptor3$x = _applyDecoratedDescriptor(_class$1w.prototype, "scrollablePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: "auto",
          height: "calc(100% - 30px)",
          width: "100%"
        };
      }
    }), _descriptor4$t = _applyDecoratedDescriptor(_class$1w.prototype, "fakePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor5$q = _applyDecoratedDescriptor(_class$1w.prototype, "footer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontWeight: "bold",
          textAlign: "center",
          position: "absolute",
          bottom: "0px",
          width: "100%",
          whiteSpace: "nowrap",
          paddingBottom: "15px",
          paddingTop: "3px"
        };
      }
    }), _descriptor6$m = _applyDecoratedDescriptor(_class$1w.prototype, "jumpToButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "5px",
          padding: "2.3px 10px",
          verticalAlign: "bottom"
        };
      }
    }), _descriptor7$i = _applyDecoratedDescriptor(_class$1w.prototype, "table", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "calc(100% - 15px)",
          marginBottom: "0px",
          top: "0px",
          position: "absolute",
          pointerEvents: "none",
          ">tbody>tr>td": {
            height: `${this.rowHeight}px !important`,
            whiteSpace: "nowrap !important"
          }
        };
      }
    })), _class$1w);

    class EntriesManager extends Dispatchable {
      constructor(entries, options = {}) {
        super();
        this.rawEntries = entries;
        this.options = options;
        this.cacheEntries();
      }
      getRawEntries() {
        return this.rawEntries;
      }
      cacheEntries() {
        let entries = this.getRawEntries();
        entries = this.filterEntries(entries);
        this.cachedEntries = this.sortEntries(entries);
        this.dispatchChange();
      }
      getEntries() {
        return this.cachedEntries;
      }
      getEntriesCount() {
        return this.cachedEntries.length;
      }
      getEntriesRange(low, high) {
        return this.cachedEntries.slice(low, high);
      }
      updateEntries(entries) {
        this.rawEntries = entries;
        this.cacheEntries();
      }
      sortEntries(entries) {
        const comparator = this.getComparator();
        if (comparator) {
          entries = entries.sort(comparator);
        }
        return entries;
      }
      filterEntries(entries) {
        const filter = this.getFilter();
        return filter ? entries.filter(filter) : entries;
      }
      getComparator() {
        return this.options.comparator;
      }
      setComparator(comparator) {
        this.options.comparator = comparator;
        this.cacheEntries();
      }
      getFilter() {
        return this.options.filter;
      }
      setFilter(filter) {
        this.options.filter = filter;
        this.cacheEntries();
      }
    }

    // A wrapper for tables which optimizes rendering when many entries / updates are involved. It currently has hardcoded
    // row height for functionality reasons.
    function RangeTableInterface(TableClass) {
      class RangeTable extends UI$1.Primitive(TableClass, "div") {
        constructor(options) {
          super(options);
          this.lowIndex = 0;
          this.highIndex = 0;
        }
        getRangePanelStyleSheet() {
          return RangePanelStyle.getInstance();
        }
        getRowHeight() {
          return this.options.rowHeight || this.getRangePanelStyleSheet().rowHeight;
        }
        getEntriesManager() {
          if (!this.entriesManager) {
            this.entriesManager = new EntriesManager(super.getEntries());
          }
          return this.entriesManager;
        }
        extraNodeAttributes(attr) {
          attr.addClass(this.getRangePanelStyleSheet().default);
        }
        render() {
          const rangePanelStyleSheet = this.getRangePanelStyleSheet();
          const fakePanelHeight = this.getRowHeight() * this.getEntriesManager().getEntriesCount() + 1 + "px";
          const headHeight = this.thead?.getHeight() || 0;
          this.computeIndices();

          // Margin is added at redraw for the case when the scoreboard has horizontal scrolling during a redraw.
          const margin = this.node && this.node.scrollLeft || 0;
          return [UI$1.createElement("div", {
            ref: "tableContainer",
            className: rangePanelStyleSheet.tableContainer,
            style: {
              paddingTop: headHeight + "px",
              marginLeft: margin + "px"
            }
          }, UI$1.createElement("div", {
            ref: "scrollablePanel",
            className: rangePanelStyleSheet.scrollablePanel
          }, UI$1.createElement("div", {
            ref: "fakePanel",
            className: rangePanelStyleSheet.fakePanel,
            style: {
              height: fakePanelHeight
            }
          }), UI$1.createElement("table", {
            ref: "container",
            className: `${this.styleSheet.table} ${rangePanelStyleSheet.table}`,
            style: {
              marginLeft: -margin + "px"
            }
          }, this.renderTableHead(), UI$1.createElement("tbody", {
            ref: "containerBody"
          }, this.renderContainerBody())))), UI$1.createElement("div", {
            ref: "footer",
            className: rangePanelStyleSheet.footer,
            style: {
              marginLeft: margin + "px"
            }
          }, UI$1.createElement("span", {
            ref: "tableFooterText"
          }, this.getFooterContent()), UI$1.createElement(NumberInput, {
            ref: "jumpToInput",
            placeholder: "jump to...",
            style: {
              textAlign: "center"
            }
          }), UI$1.createElement(Button$1, {
            ref: "jumpToButton",
            size: Size.SMALL,
            className: rangePanelStyleSheet.jumpToButton
          }, "Go"))];
        }
        applyScrollState() {
          this.scrollablePanel.node.scrollTop = this.scrollState;
        }
        saveScrollState() {
          if (this.scrollablePanel && this.scrollablePanel.node) {
            this.scrollState = this.scrollablePanel.node.scrollTop;
          }
        }
        renderContainerBody() {
          // TODO: this method should not be here, and tables should have a method "getEntriesToRender" which will be overwritten in this class.
          this.rows = [];
          const entries = this.getEntriesManager().getEntriesRange(this.lowIndex, this.highIndex);
          for (let i = 0; i < entries.length; i += 1) {
            const entry = entries[i];
            const RowClass = this.getRowClass(entry);
            this.rows.push(UI$1.createElement(RowClass, this.getRowOptions(entry, i + this.lowIndex)));
          }
          return this.rows;
        }
        getFooterContent() {
          if (this.lowIndex + 1 > this.highIndex) {
            return `No results. Jump to `;
          }
          return `${this.lowIndex + 1}  ${this.highIndex} of ${this.getEntriesManager().getEntriesCount()}. `;
        }
        jumpToIndex(index) {
          // Set the scroll so that the requested position is in the center.
          const lowIndex = parseInt(index - (this.highIndex - this.lowIndex) / 2 + 1);
          const scrollRatio = lowIndex / (this.getEntriesManager().getEntriesCount() + 0.5);
          this.scrollablePanel.node.scrollTop = scrollRatio * this.scrollablePanel.node.scrollHeight;
        }
        computeIndices() {
          if (!this.tableContainer || !this.thead || !this.footer) {
            return;
          }
          const scrollRatio = this.scrollablePanel.node.scrollTop / this.scrollablePanel.node.scrollHeight;
          const entriesCount = this.getEntriesManager().getEntriesCount();
          // Computing of entries range is made using the physical scroll on the fake panel.
          this.lowIndex = parseInt(scrollRatio * (entriesCount + 0.5));
          if (isNaN(this.lowIndex)) {
            this.lowIndex = 0;
          }
          this.highIndex = Math.min(this.lowIndex + parseInt((this.getHeight() - this.thead.getHeight() - this.footer.getHeight()) / this.getRowHeight()), entriesCount);
        }
        setScroll() {
          // This is the main logic for rendering the right entries. Right now, it best works with a fixed row height,
          // for other cases no good results are guaranteed. For now, that row height is hardcoded in the class'
          // stylesheet.

          if (this.inSetScroll) {
            return;
          }
          if (!document.body.contains(this.node)) {
            this.tableFooterText.setChildren(this.getFooterContent());
            this.containerBody.setChildren(this.renderContainerBody());
            return;
          }
          this.inSetScroll = true;
          this.computeIndices();
          // Ugly hack for chrome stabilization.
          // This padding top makes the scrollbar appear only on the tbody side
          this.tableContainer.setStyle("paddingTop", this.thead.getHeight() + "px");
          this.fakePanel.setHeight(this.getRowHeight() * this.getEntriesManager().getEntriesCount() + "px");
          // The scrollable panel must have the exact height of the tbody so that there is consistency between entries
          // rendering and scroll position.
          this.scrollablePanel.setHeight(this.getRowHeight() * (this.highIndex - this.lowIndex) + "px");
          // Update the entries and the footer info.
          this.tableFooterText.setChildren(this.getFooterContent());
          this.containerBody.setChildren(this.renderContainerBody());
          // This is for setting the scrollbar outside of the table area, otherwise the scrollbar wouldn't be clickable
          // because of the logic in "addCompatibilityListeners".
          this.container.setWidth(this.fakePanel.getWidth() + "px");
          this.inSetScroll = false;
        }
        addCompatibilityListeners() {
          // The physical table has z-index -1 so it does not respond to mouse events, as it is "behind" fake panel.
          // The following listeners repair that.
          this.addNodeListener("mousedown", () => {
            this.container.setStyle("pointerEvents", "all");
          });
          this.container.addNodeListener("mouseup", event => {
            const mouseDownEvent = new MouseEvent("click", event);
            const domElement = document.elementFromPoint(parseFloat(event.clientX), parseFloat(event.clientY));
            setTimeout(() => {
              this.container.setStyle("pointerEvents", "none");
              domElement.dispatchEvent(mouseDownEvent);
            }, 100);
          });

          // Adding listeners that force resizing
          this.addListener("setActive", () => {
            this.setScroll();
          });
          this.addListener("resize", () => {
            this.setScroll();
          });
          window.addEventListener("resize", () => {
            this.setScroll();
          });
        }
        addTableAPIListeners() {
          // This event isn't used anywhere but this is how range updates should be made.
          this.addListener("entriesChange", event => {
            if (!(event.leftIndex >= this.highIndex || event.rightIndex < this.lowIndex)) {
              this.setScroll();
            }
          });
          this.addListener("showCurrentUser", () => {
            const index = this.getEntriesManager().getEntries().map(entry => entry.userId).indexOf(USER.id) + 1;
            this.jumpToIndex(index);
          });
          // Delay is added for smoother experience of scrolling.
          this.attachChangeListener(this.getEntriesManager(), () => {
            this.setScroll();
          });
        }
        addSelfListeners() {
          this.scrollablePanel.addNodeListener("scroll", () => {
            this.setScroll();
          });
          this.addNodeListener("scroll", () => {
            this.tableContainer.setStyle("marginLeft", this.node.scrollLeft);
            this.footer.setStyle("marginLeft", this.node.scrollLeft);
            this.container.setStyle("marginLeft", -this.node.scrollLeft);
          });
          window.addEventListener("resize", () => {
            this.tableContainer.setStyle("marginLeft", 0);
            this.footer.setStyle("marginLeft", 0);
            this.container.setStyle("marginLeft", 0);
          });
          this.jumpToInput.addNodeListener("keyup", event => {
            if (event.code === "Enter") {
              this.jumpToIndex(parseInt(this.jumpToInput.getValue()));
            }
          });
          this.jumpToButton.addClickListener(() => {
            this.jumpToIndex(parseInt(this.jumpToInput.getValue()));
          });
        }
        onMount() {
          super.onMount();
          this.addCompatibilityListeners();
          this.addTableAPIListeners();
          this.addSelfListeners();
          setTimeout(() => {
            this.redraw();
          });
        }
      }
      return RangeTable;
    }

    var _class$1v, _descriptor$L, _descriptor2$E, _descriptor3$w, _descriptor4$s;
    let TableStyle = (_class$1v = class TableStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.cellStyle = {
          padding: 8,
          lineHeight: "1.42857143",
          verticalAlign: "top",
          borderTop: "1px solid #ddd"
        };
        _initializerDefineProperty(this, "thead", _descriptor$L, this);
        _initializerDefineProperty(this, "container", _descriptor2$E, this);
        _initializerDefineProperty(this, "tableStripped", _descriptor3$w, this);
        _initializerDefineProperty(this, "tableRow", _descriptor4$s, this);
      }
    }, (_descriptor$L = _applyDecoratedDescriptor(_class$1v.prototype, "thead", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "2px solid #ddd",
          borderTop: 0
        };
      }
    }), _descriptor2$E = _applyDecoratedDescriptor(_class$1v.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "100%",
          marginBottom: 20,
          borderSpacing: 0,
          borderCollapse: "collapse",
          ">*>*>td,th": this.cellStyle
        };
      }
    }), _descriptor3$w = _applyDecoratedDescriptor(_class$1v.prototype, "tableStripped", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">tbody>tr:nth-of-type(odd)": {
            backgroundColor: "#f5f5f5"
          }
        };
      }
    }), _descriptor4$s = _applyDecoratedDescriptor(_class$1v.prototype, "tableRow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // Available for overwriting
        };
      }
    })), _class$1v);

    // Useful for tables or CSV file utils
    // Takes in an array ["Name", obj => obj.field, options] or simply an array of options
    class ColumnHandler {
      constructor(options, index) {
        if (Array.isArray(options)) {
          options = {
            headerName: options[0],
            value: options[1],
            ...options[2]
          };
        }
        Object.assign(this, options);
        if (index != null) {
          this.index = index;
        }
        this.name = this.name || this.headerName;
      }

      // If an entry already as a ColumnHandler, it's left as-is
      static mapColumns(columns) {
        columns = columns.filter(x => x); // Remove null or false columns
        return columns.map((column, index) => {
          if (column instanceof ColumnHandler) {
            return column;
          }
          return new ColumnHandler(column, index);
        });
      }
    }

    var _dec$Z, _class$1u;

    // TODO: the whole table architecture probably needs a rethinking
    class TableRow extends UI$1.Primitive("tr") {
      getColumns() {
        return this.options.columns;
      }
      render() {
        const columns = this.getColumns();
        return columns.map((column, index) => this.renderEntryCell(column, index));
      }
      renderEntryCell(column, columnIndex) {
        // TODO support more complex style options and {...columns.extraOptions(entry)}
        return UI$1.createElement("td", {
          style: column.cellStyle,
          key: columnIndex
        }, column.value(this.options.entry, this.options.rowIndex, columnIndex, this));
      }
    }
    let Table = (_dec$Z = registerStyle(TableStyle), _dec$Z(_class$1u = class Table extends UI$1.Primitive("table") {
      getDefaultOptions(options) {
        const entries = this.getDefaultEntries(options);
        const columns = this.getDefaultColumns(options, entries);
        return {
          columns,
          entries,
          rowClass: TableRow
        };
      }
      getDefaultEntries(options) {
        return options.entries || [];
      }
      getDefaultColumns(options, entries) {
        return options.columns || [];
      }
      setOptions(options) {
        super.setOptions(options);
        if (this.options.columns) {
          this.options.columns = ColumnHandler.mapColumns(this.options.columns);
        }
      }
      getRowClass() {
        return this.options.rowClass;
      }
      makeRow(entry, rowIndex) {
        if (entry instanceof UI$1.Element && (entry.getNodeType() === "tr" || entry.getNodeType() === "tbody")) {
          return entry;
        }
        const RowClass = this.getRowClass(entry, rowIndex);
        return UI$1.createElement(RowClass, this.getRowOptions(entry, rowIndex));
      }
      getRowOptions(entry, rowIndex) {
        const {
          columns
        } = this.options;
        return {
          entry,
          columns,
          rowIndex,
          parent: this,
          className: this.styleSheet.tableRow,
          key: this.getEntryKey(entry, rowIndex)
        };
      }
      getRowByEntry(entry) {
        // TODO not nice that this is O(N)
        for (const row of this.rows) {
          if (row.options.entry === entry) {
            return row;
          }
        }
        return null;
      }
      render() {
        return [this.renderTableHead(), this.renderTableBody()];
      }
      renderTableHead() {
        const {
          noHeader,
          columns
        } = this.options;
        return !noHeader && UI$1.createElement("thead", {
          ref: "thead",
          className: this.styleSheet.thead
        }, UI$1.createElement("tr", null, columns.map((column, index) => this.renderHeaderCell(column, index))));
      }
      getEntryKey(entry, index) {
        return entry?.id ?? index;
      }
      renderRows() {
        const entries = this.getEntries();
        this.rows = entries.map((entry, index) => this.makeRow(entry, index));
        return this.rows;
      }
      renderTableBody() {
        return UI$1.createElement("tbody", null, this.renderRows());
      }

      // Renders the whole header cell based on a column
      renderHeaderCell(column, index) {
        return UI$1.createElement("th", {
          style: column.headerStyle,
          ref: "columnHeader" + index
        }, this.renderColumnHeader(column));
      }

      // Only renders the content of the header cell
      renderColumnHeader(column) {
        if (typeof column.headerName === "function") {
          return column.headerName();
        }
        return column.headerName;
      }
      getEntries() {
        return this.options.entries || [];
      }
      setEntries(entries) {
        this.updateOptions({
          entries
        });
      }
    }) || _class$1u);

    var _class$1t, _descriptor$K, _dec$Y, _class2$L;
    class TableRowInCollapsibleTable extends TableRow {
      getNodeType() {
        return "tbody";
      }
      render() {
        return UI$1.createElement("tr", null, super.render());
      }
    }
    let CollapsibleTableStyle = (_class$1t = class CollapsibleTableStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "heading", _descriptor$K, this);
      }
    }, (_descriptor$K = _applyDecoratedDescriptor(_class$1t.prototype, "heading", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "10px 15px",
          backgroundColor: "initial !important"
        };
      }
    })), _class$1t); // TODO: refactor this to support redraw and render override
    let CollapsibleTableRow = (_dec$Y = registerStyle(CollapsibleTableStyle), _dec$Y(_class2$L = class CollapsibleTableRow extends CollapsibleMixin(TableRow) {
      getNodeType() {
        return "tbody";
      }
      getDefaultOptions(options) {
        return {
          collapsed: true
        };
      }
      getPreservedOptions() {
        return {
          collapsed: this.options.collapsed
        };
      }
      renderEntryCell(column, columnIndex) {
        if (columnIndex === 0) {
          return UI$1.createElement("td", {
            onClick: () => this.toggle(),
            className: this.getCollapsibleStyleSheet().toggleButton,
            style: column.cellStyle,
            key: columnIndex
          }, this.getToggleIcon());
        }
        return super.renderEntryCell(column, columnIndex);
      }
      toggle() {
        if (!this.options.collapsed) {
          this.collapse();
        } else {
          this.expand();
        }
      }
      getInitialCollapsedContent() {
        const {
          renderCollapsible,
          entry
        } = this.options;
        if (renderCollapsible) {
          return renderCollapsible(entry, this);
        }
        return this.renderCollapsible(this.options.entry, this);
      }
      renderCollapsible() {
        return [];
      }
      getMainRowContent() {
        return super.render();
      }
      getMainRow() {
        return UI$1.createElement("tr", {
          className: this.styleSheet.heading
        }, this.getMainRowContent());
      }
      getCollapsibleRow() {
        const {
          collapsed
        } = this.options;
        return UI$1.createElement("tr", null, UI$1.createElement("td", {
          style: {
            padding: 0,
            overflow: "hidden",
            height: "auto"
          },
          colspan: this.options.columns.length
        }, UI$1.createElement("div", {
          ref: "contentArea",
          className: collapsed ? GlobalStyle.hidden : null
        }, this.getInitialCollapsedContent())));
      }
      render() {
        return [this.getMainRow(), this.getCollapsibleRow()];
      }
    }) || _class2$L);
    function CollapsibleTableInterface(BaseTableClass) {
      return class CollapsibleTable extends BaseTableClass {
        getDefaultOptions(options) {
          return {
            ...super.getDefaultOptions(options),
            rowClass: CollapsibleTableRow
          };
        }
        setOptions(options) {
          super.setOptions(options);
          if (!this.options.columns[0]?.isToggleColumn) {
            this.options.columns = [this.getToggleColumn(), ...this.options.columns];
          }
        }
        getRowOptions(entry, rowIndex) {
          const {
            renderCollapsible
          } = this.options;
          return {
            ...super.getRowOptions(entry, rowIndex),
            renderCollapsible
          };
        }
        renderTableBody() {
          return this.renderRows();
        }
        getToggleColumn() {
          return new ColumnHandler({
            isToggleColumn: true,
            value: () => null,
            cellStyle: {
              width: "1%",
              whiteSpace: "nowrap"
            },
            headerStyle: {
              width: 30 // TODO not flexible to hardcode this here
            }
          });
        }
      };
    }
    const CollapsibleTable = CollapsibleTableInterface(Table);

    var _class$1s, _descriptor$J, _descriptor2$D;
    let SortableTableStyle = (_class$1s = class SortableTableStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$J, this);
        _initializerDefineProperty(this, "sortIcon", _descriptor2$D, this);
      }
    }, (_descriptor$J = _applyDecoratedDescriptor(_class$1s.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          [" th:hover ." + this.sortIcon.getClassName()]: {
            visibility: "inherit"
          },
          " th:hover": {
            cursor: "pointer"
          }
        };
      }
    }), _descriptor2$D = _applyDecoratedDescriptor(_class$1s.prototype, "sortIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "absolute",
          right: 0,
          bottom: 0,
          visibility: "hidden",
          float: "right"
        };
      }
    })), _class$1s);
    function SortableTableInterface(BaseTableClass) {
      class SortableTable extends BaseTableClass {
        getSortableStyleSheet() {
          return SortableTableStyle.getInstance(this.getTheme()); // Make this optional maybe
        }
        extraNodeAttributes(attr) {
          super.extraNodeAttributes(attr);
          attr.addClass(this.getSortableStyleSheet().container);
        }
        setOptions(options) {
          super.setOptions(options);
          this.columnSortingOrder = options.columnSortingOrder || [];
        }
        renderColumnHeader(column) {
          if (column.noSort) {
            return super.renderColumnHeader(column);
          }
          this.getSortableStyleSheet(); // TODO: use properly

          let sortIcon = UI$1.createElement("span", {
            style: {
              opacity: 0.4
            }
          }, MakeIcon("sort"));
          if (this.sortBy === column) {
            if (this.sortDescending) {
              sortIcon = MakeIcon("sort-desc");
            } else {
              sortIcon = MakeIcon("sort-asc");
            }
          }
          const reorderCallback = () => {
            this.sortByColumn(column);
            this.dispatch("reorder");
          };
          return UI$1.createElement("div", {
            style: {
              position: "relative"
            },
            onClick: reorderCallback
          }, super.renderColumnHeader(column), " ", sortIcon);
        }
        sortByColumn(column) {
          if (column === this.sortBy) {
            this.sortDescending = this.sortDescending != true;
          } else {
            this.sortDescending = true;
          }
          this.sortBy = column;
          this.redraw();
        }
        getComparator() {
          if (!this.sortBy && this.columnSortingOrder.length === 0) {
            return null;
          }
          const colCmp = (a, b, column, sortDescending) => {
            if (!column) {
              return 0;
            }
            const keyA = column.rawValue ? column.rawValue(a) : column.value(a);
            const keyB = column.rawValue ? column.rawValue(b) : column.value(b);
            const comparator = column.cmp || defaultComparator;
            const result = comparator(keyA, keyB);
            return sortDescending ? -result : result;
          };
          return (a, b) => {
            if (this.sortBy) {
              const cmpRes = colCmp(a, b, this.sortBy, this.sortDescending);
              if (cmpRes) {
                return cmpRes;
              }
            }
            for (const column of this.columnSortingOrder) {
              const cmpRes = colCmp(a, b, column, column.sortDescending);
              if (cmpRes) {
                return cmpRes;
              }
            }
            return 0;
          };
        }
        sortEntries(entries) {
          let sortedEntries = entries.slice();
          const comparator = this.getComparator();
          if (comparator) {
            sortedEntries.sort(comparator);
          }
          return sortedEntries;
        }
        getEntries() {
          return this.sortEntries(super.getEntries());
        }
      }
      return SortableTable;
    }
    const SortableTable = SortableTableInterface(Table);

    // File meant to handle server time/client time differences
    const ServerTime = {
      now() {
        return new StemDate().subtract(this.getOffset());
      },
      getOffset() {
        return this.offset;
      },
      set(date, onlyIfMissing = false) {
        if (!onlyIfMissing || this.offset == null) {
          this.offset = Date.now() - new StemDate(date);
        }
      },
      setPageLoadTime(unixTime, estimatedLatency = 0) {
        this.serverPageLoad = unixTime;
        this.offset = performance.timing.responseStart - unixTime * 1000;
      }
    };

    // TODO deprecate
    function isDifferentDay(timeA, timeB) {
      timeA = new StemDate(timeA);
      timeB = new StemDate(timeB);

      // First check if difference is gre
      if (timeA.diff(timeB) > +TimeUnit.DAY) {
        return true;
      }
      // Check if different day of the month, when difference is less than a day
      return timeA.getDate() !== timeB.getDate();
    }

    const Draggable = (BaseClass = UI$1.Element) => class Draggable extends BaseClass {
      constructor(...args) {
        super(...args);
        this._clickCallbacks = new Map();
        this._clickDragListeners = new Map();
      }
      addClickListener(callback) {
        if (this._clickCallbacks.has(callback)) {
          return;
        }
        let callbackWrapper = () => {
          if (this._okForClick) {
            callback();
          }
        };
        this._clickCallbacks.set(callback, callbackWrapper);
        super.addClickListener(callbackWrapper);
        if (this._clickDragListeners.has(callback)) {
          return;
        }
        let clickDragListener = {
          onStart: () => {
            this.dragForClickStarted();
          },
          onDrag: () => {
            this.dragForClick();
          }
        };
        this._clickDragListeners.set(callback, clickDragListener);
        this.addDragListener(clickDragListener);
      }
      dragForClickStarted() {
        this._okForClick = true;
      }
      dragForClick() {
        this._okForClick = false;
      }
      removeClickListener(callback) {
        let callbackWrapper = this._clickCallbacks.get(callback);
        if (callbackWrapper) {
          this._clickCallbacks.delete(callback);
          super.removeClickListener(callbackWrapper);
        }
        if (!this._clickDragListeners) {
          return;
        }
        let clickDragListener = this._clickDragListeners.get(callback);
        if (clickDragListener) {
          this._clickDragListeners.delete(callback);
          this.removeDragListener(clickDragListener);
        }
      }
      createDragGenericListenerWrapper(listeners, dragEventType) {
        let listenerWrapper = Object.assign({}, listeners);
        let dragStarted = false;
        listenerWrapper.onWrapperDrag = event => {
          if (!dragStarted) {
            return;
          }
          const eventX = Device.getEventX(event) || 0;
          const eventY = Device.getEventY(event) || 0;
          let deltaX = eventX - listenerWrapper._lastX;
          listenerWrapper._lastX = eventX;
          let deltaY = eventY - listenerWrapper._lastY;
          listenerWrapper._lastY = eventY;
          listeners.onDrag(deltaX, deltaY);
        };
        listenerWrapper.onWrapperStart = event => {
          dragStarted = true;
          listenerWrapper._lastX = Device.getEventX(event);
          listenerWrapper._lastY = Device.getEventY(event);
          if (listeners.onStart) {
            listeners.onStart(event);
          }

          // TODO: Replace with our body
          document.body.addEventListener(dragEventType, listenerWrapper.onWrapperDrag);
        };
        listenerWrapper.onWrapperEnd = event => {
          if (dragStarted) {
            if (listeners.onEnd) {
              listeners.onEnd(event);
            }
          }
          dragStarted = false;

          // TODO: Replace with our body
          document.body.removeEventListener(dragEventType, listenerWrapper.onWrapperDrag);
        };
        return listenerWrapper;
      }
      createDragListenerWrapper(listeners) {
        return this.createDragGenericListenerWrapper(listeners, "mousemove");
      }
      createTouchDragListenerWrapper(listeners) {
        return this.createDragGenericListenerWrapper(listeners, "touchmove");
      }
      addDragListener(listeners) {
        let listenerWrapper = this.createDragListenerWrapper(listeners);
        let touchListenerWrapper = this.createTouchDragListenerWrapper(listeners);
        this.addNodeListener("touchstart", touchListenerWrapper.onWrapperStart);
        if (!Device.isMobileDevice()) {
          this.addNodeListener("mousedown", listenerWrapper.onWrapperStart);
        }

        // TODO: Replace with our body
        document.body.addEventListener("touchend", touchListenerWrapper.onWrapperEnd);
        if (!Device.isMobileDevice()) {
          document.body.addEventListener("mouseup", listenerWrapper.onWrapperEnd);
        }
        if (!this.hasOwnProperty("_dragListeners")) {
          this._dragListeners = [];
        }
        this._dragListeners.push(touchListenerWrapper);
        this._dragListeners.push(listenerWrapper);
      }
      removeDragListener(listeners) {
        if (this._dragListeners) {
          for (let i = this._dragListeners.length - 1; i >= 0; i -= 1) {
            if (this._dragListeners[i].onStart === listeners.onStart && this._dragListeners[i].onDrag === listeners.onDrag && this._dragListeners[i].onEnd === listeners.onEnd) {
              this.removeNodeListener("touchstart", this._dragListeners[i].onWrapperStart);
              document.body.removeEventListener("touchmove", this._dragListeners[i].onWrapperDrag);
              document.body.removeEventListener("touchmove", this._dragListeners[i].onWrapperEnd);
              this.removeNodeListener("mousedown", this._dragListeners[i].onWrapperStart);
              document.body.removeEventListener("mousemove", this._dragListeners[i].onWrapperDrag);
              document.body.removeEventListener("mousemove", this._dragListeners[i].onWrapperEnd);
              this._dragListeners.splice(i, 1);
            }
          }
        }
      }
    };
    Draggable();

    // TODO This should extend an input
    class SlideBar extends Draggable(UI$1.Element) {
      getDefaultOptions() {
        return {
          value: 0
        };
      }
      extraNodeAttributes(attr) {
        attr.setStyle("display", "inline-block");
        attr.setStyle("position", "relative");
        attr.setStyle("cursor", "pointer");
      }
      getSliderValue() {
        return this.options.value * this.options.size - this.options.barSize / 2;
      }
      render() {
        return [UI$1.createElement(ProgressBar, {
          ref: "progressBar",
          active: "true",
          value: this.options.value,
          disableTransition: true,
          orientation: this.getOrientation(),
          style: Object.assign({
            position: "relative"
          }, this.getProgressBarStyle())
        }), UI$1.createElement("div", {
          ref: "slider",
          style: Object.assign({
            backgroundColor: "black",
            position: "absolute"
          }, this.getSliderStyle())
        })];
      }
      setValue(value) {
        value = Math.max(value, 0);
        value = Math.min(value, 1);
        this.options.value = value;
        this.progressBar.set(this.options.value);
        this.slider.setStyle(this.getOrientationAttribute(), this.getSliderValue() + "px");
        this.dispatch("change", this.options.value);
      }
      getValue() {
        return this.options.value;
      }
      onMount() {
        this.addDragListener(this.getDragConfig());
      }
    }
    class HorizontalSlideBar extends SlideBar {
      setOptions(options) {
        options.size = options.size || options.width || 100;
        options.barSize = options.barSize || options.barWidth || 5;
        super.setOptions(options);
      }
      getProgressBarStyle() {
        return {
          height: "5px",
          width: this.options.size + "px",
          top: "15px"
        };
      }
      getSliderStyle() {
        return {
          width: this.options.barSize + "px",
          height: "20px",
          left: this.getSliderValue() + "px",
          top: "7.5px"
        };
      }
      getOrientationAttribute() {
        return "left";
      }
      getOrientation() {
        return Orientation$1.HORIZONTAL;
      }
      getDragConfig() {
        return {
          onStart: event => {
            this.setValue((Device.getEventX(event) - getOffset(this.progressBar)[this.getOrientationAttribute()]) / this.options.size);
          },
          onDrag: (deltaX, deltaY) => {
            this.setValue(this.options.value + deltaX / this.options.size);
          }
        };
      }
    }
    class VerticalSlideBar extends SlideBar {
      setOptions(options) {
        options.size = options.size || options.height || 100;
        options.barSize = options.barSize || options.barHeight || 5;
        super.setOptions(options);
      }
      getProgressBarStyle() {
        return {
          height: this.options.size + "px",
          width: "5px",
          left: "15px"
        };
      }
      getSliderStyle() {
        return {
          height: this.options.barSize + "px",
          width: "20px",
          top: this.getSliderValue() + "px",
          left: "7.5px"
        };
      }
      getOrientationAttribute() {
        return "top";
      }
      getOrientation() {
        return Orientation$1.VERTICAL;
      }
      getDragConfig() {
        return {
          onStart: event => {
            this.setValue((Device.getEventY(event) - getOffset(this.progressBar)[this.getOrientationAttribute()]) / this.options.size);
          },
          onDrag: (deltaX, deltaY) => {
            this.setValue(this.options.value + deltaY / this.options.size);
          }
        };
      }
    }

    // TODO deprecate
    class DatePickerTable extends UI$1.Element {}
    class TimePickerWidget extends UI$1.Element {
      render() {
        let hours = parseInt(this.options.time / (60 * 60 * 1000));
        let minutes = parseInt((this.options.time - 60 * 60 * 1000 * hours) / (60 * 1000));
        let seconds = parseInt((this.options.time - 60 * 60 * 1000 * hours - 60 * 1000 * minutes) / 1000);
        let textSpanStyle = {
          display: "inline-block",
          flex: 1,
          textAlign: "center",
          fontSize: "1.5em",
          fontWeight: "bold",
          padding: "0 5px"
        };
        return [UI$1.createElement("div", {
          style: {
            width: "130px",
            display: "flex"
          }
        }, UI$1.createElement("div", {
          style: textSpanStyle,
          ref: "hours"
        }), UI$1.createElement("div", {
          style: textSpanStyle
        }, ":"), UI$1.createElement("div", {
          style: textSpanStyle,
          ref: "minutes"
        }), UI$1.createElement("div", {
          style: textSpanStyle
        }, ":"), UI$1.createElement("div", {
          style: textSpanStyle,
          ref: "seconds"
        })), UI$1.createElement("div", {
          style: {
            width: "130px",
            display: "flex"
          }
        }, UI$1.createElement(VerticalSlideBar, {
          value: hours / 23,
          ref: "hourSlider",
          height: 200,
          barHeight: 5,
          style: {
            flex: 1
          }
        }), UI$1.createElement("div", {
          style: {
            flex: 1
          }
        }), UI$1.createElement(VerticalSlideBar, {
          value: minutes / 59,
          ref: "minuteSlider",
          height: 200,
          barHeight: 5,
          style: {
            flex: 1
          }
        }), UI$1.createElement("div", {
          style: {
            flex: 1
          }
        }), UI$1.createElement(VerticalSlideBar, {
          value: seconds / 59,
          ref: "secondSlider",
          height: 200,
          barHeight: 5,
          style: {
            flex: 1,
            marginRight: "5px"
          }
        }))];
      }
      onMount() {
        let changeCallback = () => {
          let hours = parseInt(this.hourSlider.getValue() * 23);
          let minutes = parseInt(this.minuteSlider.getValue() * 59);
          let seconds = parseInt(this.secondSlider.getValue() * 59);
          this.hours.node.innerHTML = (hours < 10 ? "0" : "") + hours;
          this.minutes.node.innerHTML = (minutes < 10 ? "0" : "") + minutes;
          this.seconds.node.innerHTML = (seconds < 10 ? "0" : "") + seconds;
          let time = (hours * 60 * 60 + minutes * 60 + seconds) * 1000;
          this.dispatch("changeTime", time);
        };
        this.hourSlider.addListener("change", changeCallback);
        this.minuteSlider.addListener("change", changeCallback);
        this.secondSlider.addListener("change", changeCallback);
        changeCallback();
      }
    }
    class DateTimePicker extends UI$1.Element {
      setOptions(options) {
        options.format = options.format || "DD/MM/YYYY HH:mm:ss";
        super.setOptions(options);
        if (this.options.date) {
          this.setDate(this.options.date);
        }
      }
      parseDateFromString(str, format) {
        if (format !== "DD/MM/YYYY HH:mm:ss") {
          throw Error("Format not supported!");
        }
        // Just parsing DD/MM/YYYY HH:mm:ss for now
        while (str.indexOf('/') !== -1) {
          str = str.replace('/', ' ');
        }
        while (str.indexOf(':') !== -1) {
          str = str.replace(':', ' ');
        }
        let tokens = str.split(' ');
        let integerTokens = [];
        for (let token of tokens) {
          let number = parseFloat(token);
          if (!isNaN(number)) {
            integerTokens.push(number);
          }
        }
        let years = integerTokens.length >= 3 ? integerTokens[2] : 0;
        let months = integerTokens.length >= 2 ? integerTokens[1] - 1 : 0;
        let days = integerTokens.length >= 1 ? integerTokens[0] : 0;
        let hours = integerTokens.length >= 4 ? integerTokens[3] : 0;
        let minutes = integerTokens.length >= 5 ? integerTokens[4] : 0;
        let seconds = integerTokens.length >= 6 ? integerTokens[5] : 0;
        let date = new StemDate(years, months, days, hours, minutes, seconds);
        if (!date.getTime()) {
          return null;
        }
        return date;
      }
      getDate() {
        let str = this.textInput.getValue();
        if (!str) {
          return null;
        }
        let format = this.options.format;
        return this.parseDateFromString(str, format);
      }
      setDate(date) {
        this.options.date = date;
        this.options.dateString = date.format(this.options.format);
        if (this.textInput) {
          this.textInput.setValue(this.options.dateString);
        }
      }
      render() {
        return [UI$1.createElement(TextInput, {
          ref: "textInput",
          placeholder: this.options.format,
          value: this.options.dateString || ""
        })
        /*<Button ref="calendarSpan" faIcon="calendar"/>*/];
      }

      // onMount() {
      //     this.calendarSpan.addClickListener((event) => {
      //         if (!this.dateTimeWindow) {
      //             let textInputOffset = getOffset(this.textInput);
      //             this.dateTimeWindow = DateTimeWindow.create(document.body, {
      //                 style: {
      //                     top: textInputOffset.top + 5 + this.textInput.getHeight() + "px",
      //                     left: textInputOffset.left + 5 + "px"
      //                 },
      //                 initialDateTime: this.textInput.getValue(),
      //                 output: this.textInput
      //             });
      //         } else {
      //             this.dateTimeWindow.hide();
      //             delete this.dateTimeWindow;
      //         }
      //         event.stopPropagation();
      //     });
      // }
    }

    class TimePassedSpan extends UI$1.Primitive("span") {
      render() {
        return this.getTimeDeltaDisplay(this.options.timeStamp);
      }
      getDefaultOptions() {
        return {
          style: {
            color: "#aaa"
          }
        };
      }
      getTimeDeltaDisplay(timeStamp) {
        let timeNow = Date.now();
        let timeDelta = parseInt((timeNow - timeStamp * 1000) / 1000);
        let timeUnitsInSeconds = [31556926, 2629743, 604800, 86400, 3600, 60];
        let timeUnits = ["year", "month", "week", "day", "hour", "minute"];
        if (timeDelta < 0) {
          timeDelta = 0;
        }
        for (let i = 0; i < timeUnits.length; i += 1) {
          let value = parseInt(timeDelta / timeUnitsInSeconds[i]);
          if (timeUnitsInSeconds[i] <= timeDelta) {
            return value + " " + timeUnits[i] + (value > 1 ? "s" : "") + " ago";
          }
        }
        return "Few seconds ago";
      }
      static addIntervalListener(callback) {
        if (!this.updateFunction) {
          this.TIME_DISPATCHER = new Dispatchable();
          this.updateFunction = setInterval(() => {
            this.TIME_DISPATCHER.dispatch("updateTimeValue");
          }, 5000);
        }
        return this.TIME_DISPATCHER.addListener("updateTimeValue", callback);
      }
      onMount() {
        this._updateListener = this.constructor.addIntervalListener(() => {
          this.redraw();
        });
      }
      onUnmount() {
        this._updateListener && this._updateListener.remove();
      }
    }

    // Just putting in a lot of methods, to try to think of an interface
    class ScrollableMixin extends UI$1.Element {
      getDesiredExcessHeightTop() {
        return 600;
      }
      getDesiredExcessHeightBottom() {
        return 600;
      }
      getHeightScrollPercent() {
        let scrollHeight = this.node.scrollHeight;
        let height = this.node.clientHeight;
        if (scrollHeight === height) {
          return 0;
        }
        return this.node.scrollTop / (scrollHeight - height);
      }
      getExcessTop() {
        return this.node.scrollTop;
      }
      getExcessBottom() {
        let scrollHeight = this.node.scrollHeight;
        let height = this.node.clientHeight;
        return scrollHeight - height - this.node.scrollTop;
      }
      haveExcessTop() {
        return this.getExcessTop() > this.getDesiredExcessHeightTop();
      }
      haveExcessBottom() {
        return this.getExcessBottom() > this.getDesiredExcessHeightBottom();
      }
      popChildTop() {
        this.eraseChildAtIndex(0);
      }
      popChildBottom() {
        this.eraseChildAtIndex(this.children.length - 1);
      }
      removeExcessTop() {
        while (this.haveExcessTop()) {
          this.popChildTop();
        }
      }
      removeExcessBottom() {
        while (this.haveExcessBottom()) {
          this.popChildBottom();
        }
      }
      pushChildTop(element, removeExcessBottom = true) {
        if (removeExcessBottom) {
          this.removeExcessBottom();
        }
        this.insertChild(element, 0);
      }
      pushChildBottom(element, removeExcessTop = true) {
        if (removeExcessTop) {
          this.removeExcessTop();
        }
        this.appendChild(element);
        this.appendChild(element);
      }
      saveScrollPosition() {
        // If at top or bottom, save that
        // If anywhere in the middle, save the offset of the first child with a positive offset, and keep that constant
        this.options.scrollTop = this.node.scrollTop;
        let maxScrollTop = this.node.scrollHeight - this.node.clientHeight;
        this.options.scrollInfo = {
          scrollAtTop: this.options.scrollTop === 0,
          scrollAtBottom: this.options.scrollTop === maxScrollTop
          // visibleChildrenOffsets: {}
        };
      }
      applyScrollPosition() {
        this.node.scrollTop = this.options.scrollTop || this.node.scrollTop;
      }
      scrollToHeight(height) {
        this.node.scrollTop = height;
      }
      scrollToTop() {
        this.scrollToHeight(0);
      }
      scrollToBottom() {
        this.scrollToHeight(this.node.scrollHeight);
      }
    }

    //TODO: this class would need some binary searches
    class InfiniteScrollable extends ScrollableMixin {
      setOptions(options) {
        options = Object.assign({
          entries: [],
          entryComparator: (a, b) => {
            return a.id - b.id;
          },
          firstRenderedEntry: 0,
          lastRenderedEntry: -1
        }, options);
        super.setOptions(options);
        // TODO: TEMP for testing
        this.options.children = [];
        if (this.options.staticTop) {
          this.options.children.push(this.options.staticTop);
        }
        for (let entry of this.options.entries) {
          this.options.children.push(this.renderEntry(entry));
        }
      }
      getFirstVisibleIndex() {}
      getLastVisibleIndex() {}
      renderEntry(entry) {
        if (this.options.entryRenderer) {
          return this.options.entryRenderer(entry);
        } else {
          console.error("You need to pass option entryRenderer or overwrite the renderEntry method");
        }
      }
      pushEntry(entry) {
        this.insertEntry(entry, this.options.entries.length);
      }
      insertEntry(entry, index) {
        let entries = this.options.entries;
        if (index == null) {
          index = 0;
          while (index < entries.length && this.options.entryComparator(entries[index], entry) <= 0) {
            index++;
          }
        }
        entries.splice(index, 0, entry);

        // Adjust to the children
        if (this.options.staticTop) {
          index += 1;
        }

        // TODO: only if in the rendered range, insert in options.children;
        let uiElement = this.renderEntry(entry);
        this.insertChild(uiElement, index);
      }
    }

    class ViewportMeta extends UI$1.Primitive("meta") {
      getDefaultOptions() {
        return {
          scale: this.getDesiredScale(),
          initialScale: 1,
          maximumScale: 1
        };
      }
      getDesiredScale() {
        const MIN_WIDTH = this.options.minDeviceWidth;
        return MIN_WIDTH ? Math.min(window.screen.availWidth, MIN_WIDTH) / MIN_WIDTH : 1;
      }
      getContent() {
        let rez = "width=device-width";
        rez += ",initial-scale=" + this.options.scale;
        rez += ",maximum-scale=" + this.options.scale;
        rez += ",user-scalable=no";
        return rez;
      }
      extraNodeAttributes(attr) {
        attr.setAttribute("name", "viewport");
        attr.setAttribute("content", this.getContent());
      }
      maybeUpdate() {
        const desiredScale = this.getDesiredScale();
        if (desiredScale != this.options.scale) {
          this.updateOptions({
            scale: desiredScale
          });
        }
      }
      onMount() {
        window.addEventListener("resize", () => this.maybeUpdate());
      }
    }

    // Beware coder: If you ever use this class, you should have a well documented reason
    class RawHTML extends UI$1.Element {
      getInnerHTML() {
        return this.options.innerHTML || this.options.__innerHTML || "";
      }
      redraw() {
        this.node.innerHTML = this.getInnerHTML();
        this.applyNodeAttributes();
        this.applyRef();
      }
    }

    class BasePopup extends FloatingWindow {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.x = 0;
        options.y = 0;
        options.contentPadding = "7px";
        options.contentStyle = {};
        options.arrowDirection = Direction.UP;
        options.arrowColor = "white";
        options.backgroundColor = "white";
        return options;
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.style = Object.assign({
          boxShadow: "0px 0px 4px rgba(0,0,0,0.5)",
          borderRadius: "5px",
          display: "table",
          width: "300px",
          backgroundColor: this.options.backgroundColor,
          position: "absolute",
          left: this.options.x + "px",
          top: this.options.y + "px",
          zIndex: "3",
          right: "0px"
        }, this.options.style);
        this.createArrowStyle();
      }
      setContent(content) {
        this.options.children = content;
        this.redraw();
      }
      getContent() {
        return UI$1.createElement("div", {
          style: Object.assign({
            padding: this.options.contentPadding
          }, this.options.contentStyle),
          ref: "contentArea"
        }, this.options.children);
      }
      createArrowStyle() {
        let baseArrowOutline = {
          "left": "50%",
          "z-index": "-3",
          "position": "absolute",
          "width": "0",
          "height": "0",
          "border-left": "10px solid transparent",
          "border-right": "10px solid transparent",
          marginLeft: "-11px"
        };
        this["arrow" + Direction.UP + "Outline"] = Object.assign({
          "border-bottom": "10px solid #C8C8C8",
          "margin-top": "-10.8px",
          marginLeft: "-11px"
        }, baseArrowOutline);
        this["arrow" + Direction.DOWN + "Outline"] = Object.assign({
          "border-top": "10px solid #C8C8C8",
          "margin-top": "2px"
        }, baseArrowOutline);
        let baseArrow = {
          "left": "50%",
          "position": "absolute",
          "width": "0",
          "height": "0",
          "border-left": "10px solid transparent",
          "border-right": "10px solid transparent"
        };
        this["arrow" + Direction.UP] = Object.assign({
          "margin-top": "-10px",
          "border-bottom": "10px solid " + this.options.arrowColor
        }, baseArrow);
        this["arrow" + Direction.DOWN] = Object.assign({
          "border-top": "10px solid " + this.options.arrowColor
        }, baseArrow);
      }
      getArrow() {
        let direction = this.options.arrowDirection;
        return [UI$1.createElement(Panel, {
          ref: "popupArrow",
          style: this["arrow" + direction]
        }), UI$1.createElement(Panel, {
          ref: "popupArrowOutline",
          style: this["arrow" + direction + "Outline"]
        })];
      }
      render() {
        return this.options.arrowDirection === Direction.UP ? [this.getArrow(), this.getContent()] : [this.getContent(), this.getArrow()];
      }
      bindInsideParent() {
        if (this.target) {
          this.options.x = this.target.offsetWidth / 2;
          this.options.y = this.options.arrowDirection === Direction.UP ? this.target.offsetHeight : 0;
        }
        let left = parseFloat(this.options.x);
        let top = parseFloat(this.options.y) + (this.options.arrowDirection === Direction.UP ? 11 : -this.getHeight() - 11);
        let arrowMargin = -11;
        left -= this.getWidth() / 2;
        if (this.options.bodyPlaced && this.target) {
          const rect = this.target.getBoundingClientRect();
          left += rect.left;
          top += rect.top;
        }
        if (this.target && !this.options.bodyPlaced) {
          if (this.node.offsetParent && !this.options.bodyPlaced) {
            let left2 = left + this.node.offsetParent.offsetLeft;
            if (left2 < 0) {
              left -= left2 - 2;
              arrowMargin += left2 + 2;
            } else if (left2 + this.getWidth() > this.node.offsetParent.offsetParent.offsetWidth) {
              let delta = this.node.offsetParent.offsetParent.offsetWidth - (left2 + this.getWidth());
              arrowMargin -= delta - 2;
              left += delta - 2;
            }
          }
        } else {
          if (left < 0) {
            arrowMargin += left + 2;
            left = 2;
          } else if (left + this.getWidth() > this.parentNode.offsetWidth) {
            let delta = left + this.getWidth() - this.parentNode.offsetWidth;
            arrowMargin += delta;
            left -= delta;
          }
        }
        this.popupArrow.setStyle("margin-left", arrowMargin + "px");
        this.popupArrowOutline.setStyle("margin-left", arrowMargin + "px");
        this.setStyle("left", left + "px");
        this.setStyle("top", top + "px");
      }
      setParent(parent) {
        let newParent;
        if (parent instanceof HTMLElement) {
          newParent = parent;
        } else {
          newParent = parent.node;
        }
        if (newParent === this.parentNode) {
          return;
        }
        if (this.isInDocument()) {
          this.parentNode.removeChild(this.node);
          newParent.appendChild(this.node);
          this.setParentNode(newParent);
        } else {
          this.setParentNode(newParent);
        }
      }
      setCenter(center, manual = false) {
        this.options.x = center.x;
        this.options.y = center.y;
        if (manual) {
          setTimeout(() => {
            this.bindInsideParent();
          }, 0);
        } else {
          this.bindInsideParent();
        }
      }
      static clearBodyPopups() {
        for (const popup of this.bodyPopups) {
          popup.hide();
        }
        this.bodyPopups.clear();
      }
      onUnmount() {
        super.onUnmount();
        if (this.options.bodyPlaced && this.target) {
          this.constructor.bodyPopups.delete(this);
        }
      }
      onMount() {
        if (this.options.target) {
          if (this.options.target instanceof HTMLElement) {
            this.target = this.options.target;
          } else {
            this.target = this.options.target.node;
          }
          this.options.x = this.target.offsetWidth / 2;
          this.options.y = this.target.offsetHeight;
        }
        super.onMount();
        // Set the Popup inside the parent
        this.bindInsideParent();
        if (this.options.bodyPlaced && this.target) {
          this.constructor.bodyPopups.add(this);
        }
      }
    }
    BasePopup.bodyPopups = new Set();
    class Popup extends BasePopup {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.titleFontSize = "12pt";
        options.contentFontSize = "10pt";
        options.arrowColor = "#F3F3F3";
        return options;
      }
      getContent() {
        let contentArea = super.getContent();
        contentArea.options.style = Object.assign({
          fontSize: this.options.contentFontSize
        }, contentArea.options.style || {});
        return [UI$1.createElement(Panel, {
          ref: "titleArea",
          style: {
            backgroundColor: "#F3F3F3",
            paddingLeft: "20px",
            fontSize: this.options.titleFontSize,
            fontWeight: "bold",
            paddingTop: "6px",
            paddingBottom: "6px",
            textAlign: "center",
            borderBottom: "1px solid #BEBEBE"
          }
        }, this.getTitleAreaContent()), contentArea];
      }
      setTitle(newTitle) {
        this.options.title = newTitle;
        this.redraw();
      }
      getTitleAreaContent() {
        return [UI$1.createElement(Button$1, {
          className: "pull-right",
          ref: "closeButton",
          style: {
            backgroundColor: "transparent",
            border: "none",
            color: "#888888",
            fontSize: "18pt",
            padding: "2px",
            marginRight: "3px",
            marginTop: "-12px"
          },
          label: "\xD7"
        }), UI$1.createElement("div", {
          style: {
            marginRight: "25px"
          }
        }, this.options.title)];
      }
      bindWindowListeners() {
        this.addClickListener(event => {
          event.stopPropagation();
        });
        let documentListener = () => {
          this.hide();
          if (!Device.supportsEvent("click")) {
            document.removeEventListener("touchstart", documentListener);
          } else {
            document.removeEventListener("click", documentListener);
          }
        };
        if (!Device.supportsEvent("click")) {
          document.addEventListener("touchstart", documentListener);
        } else {
          document.addEventListener("click", documentListener);
        }
      }
      show() {
        super.show();
        this.bindWindowListeners();
      }
      redraw() {
        if (this.isInDocument()) {
          this.bindInsideParent();
        }
        super.redraw();
      }
      onMount() {
        super.onMount();

        // fake a click event that will propagate to window and trigger
        // the events of any other popup, closing them
        let fakeClickEvent = document.createEvent("MouseEvents");
        fakeClickEvent.initEvent("click", true, false);
        document.body.dispatchEvent(fakeClickEvent);

        // Make the popup close when something else is clicked
        this.bindWindowListeners();

        // Close button behavior
        this.closeButton.addClickListener(() => {
          this.hide();
          this.closeButton.node.blur();
        });
        let closeButtonColor = this.closeButton.options.style.color;
        this.closeButton.addNodeListener("mouseover", () => {
          this.closeButton.setStyle("color", "#0082AD");
        });
        this.closeButton.addNodeListener("mouseout", () => {
          this.closeButton.setStyle("color", closeButtonColor);
        });
      }
    }

    //YOU CANNOT SET A NEW PARENT IN PLAYER POPUP!
    class PlayerPopup extends BasePopup {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.backgroundColor = "#F7F2CB";
        options.arrowColor = "#F7F2CB";
        options.arrowDirection = Direction.DOWN;
        options.className = (options.className || "") + " hidden";
        return options;
      }
      setContent(content) {
        this.contentArea.options.children = content;
        this.contentArea.redraw();
      }
      getPopupData() {
        return {
          panel: this.parentNode,
          content: this.options.children,
          center: {
            x: this.options.x,
            y: this.options.y
          }
        };
      }
      setPopupData(data) {
        this.setContent(data.content);
        this.setCenter(data.center);
      }
      show() {
        if (this.hasClass("hidden")) {
          this.removeClass("hidden");
        }
      }
      hide() {
        if (!this.hasClass("hidden")) {
          this.addClass("hidden");
        }
      }
      showPopupTransition(content, rawPosition, duration, dependsOn = [], startTime = 0, inMovie = true) {
        let position;
        if (typeof rawPosition === "function") {
          position = rawPosition();
        } else {
          position = rawPosition;
        }
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        let showPopupModifier = new Modifier({
          func: context => {
            context.content = this.options.children;
            //context.parent = this.options.parentNode;
            context.center = {
              x: this.options.x,
              y: this.options.y
            };
            if (this.options.style) {
              context.opacity = this.options.style.opacity || 1;
            } else {
              context.opacity = 1;
            }
            this.setContent(content);
            this.setCenter(position, true);
            this.setStyle("opacity", 0);
            this.show();
          },
          reverseFunc: context => {
            this.setContent(context.content);
            this.setCenter(context.center, true);
            this.setStyle("opacity", context.opacity);
            this.hide();
          },
          context: {}
        });
        result.push(showPopupModifier, false);
        let changeOpacityTransition = new Transition$1({
          func: t => {
            this.setStyle("opacity", t);
          },
          duration: duration / 2,
          dependsOn: [showPopupModifier],
          inMovie: inMovie
        });
        result.push(changeOpacityTransition, false);
        result.push(new Transition$1({
          func: t => {},
          duration: duration / 2,
          inMovie: inMovie
        }), false);
        result.setStartTime(startTime);
        return result;
      }
      hidePopupTransition(duration, dependsOn = [], startTime = 0, inMovie = true) {
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        let changeOpacityTransition = new Transition$1({
          func: t => {
            this.setStyle("opacity", 1 - t);
          },
          duration: duration,
          dependsOn: [],
          inMovie: inMovie
        });
        result.push(changeOpacityTransition, false);
        result.push(new Modifier({
          func: () => {
            this.hide();
          },
          reverseFunc: () => {
            this.show();
          },
          dependsOn: [changeOpacityTransition]
        }), false);
        result.setStartTime(startTime);
        return result;
      }
    }
    class PopupDefinition extends Popup {
      constructor(options) {
        super(options);
        this.stack = [{
          content: this.options.content,
          title: this.options.title
        }];
      }
      getTitleAreaContent() {
        return [UI$1.createElement(Button$1, {
          ref: "backButton",
          className: "pull-left",
          style: {
            border: "none",
            backgroundColor: "transparent",
            fontSize: "18pt",
            color: "#888888",
            padding: "2px",
            marginTop: "-12px",
            marginLeft: "-15px",
            marginRight: "-15px"
          },
          label: "<"
        }), ...super.getTitleAreaContent()];
      }
      getContent() {
        return [UI$1.createElement(Panel, {
          ref: "titleArea",
          style: {
            backgroundColor: "#F3F3F3",
            paddingLeft: "20px",
            fontSize: this.options.titleFontSize,
            fontWeight: "bold",
            paddingTop: "6px",
            paddingBottom: "6px",
            textAlign: "center",
            borderBottom: "1px solid #BEBEBE"
          }
        }, this.getTitleAreaContent()), UI$1.createElement(MarkupRenderer, {
          value: this.options.content,
          style: {
            padding: "8px"
          }
        })];
      }
      pushDefinition(definition) {
        this.stack.push(definition);
        this.setStyle("left", "0px");
        this.setStyle("top", "0px");
        this.options.content = definition.content;
        this.options.title = definition.title;
        this.redraw();
        //this.recalculatePosition();
        this.bindInsideParent();
        if (this.stack.length > 1) {
          this.backButton.removeClass("hidden");
        }
      }
      popDefinition() {
        this.stack.pop();
        this.setStyle("left", "0px");
        this.setStyle("top", "0px");
        this.options.content = this.stack[this.stack.length - 1].content;
        this.options.title = this.stack[this.stack.length - 1].title;
        this.redraw();
        //this.recalculatePosition();
        this.bindInsideParent();
        if (this.stack.length === 1) {
          this.backButton.addClass("hidden");
        }
      }
      recalculatePosition() {
        // Compute the x and y coordinates of the popup
        let element = this.options.definition.node;
        let x = element.offsetWidth / 2;
        let y = element.offsetHeight;
        while (element !== this.parentNode && element.style.position !== "relative") {
          x += element.offsetLeft - element.scrollLeft;
          y += element.offsetTop - element.scrollTop;
          element = element.offsetParent;
        }
        this.setCenter({
          x: x,
          y: y
        });
      }
      onMount() {
        //this.recalculatePosition();
        super.onMount();
        //Recompute position as it is not calculated properly

        //Back button behavior
        this.backButton.addClickListener(event => {
          event.stopPropagation();
          this.popDefinition();
          this.backButton.node.blur();
        });
        let backButtonColor = this.backButton.options.style.color;
        this.backButton.node.addEventListener("mouseover", () => {
          this.backButton.setStyle("color", "#0082AD");
        });
        this.backButton.node.addEventListener("mouseout", () => {
          this.backButton.setStyle("color", backButtonColor);
        });
        if (this.stack.length > 1) {
          this.backButton.removeClass("hidden");
        } else {
          this.backButton.addClass("hidden");
        }
      }
    }
    class Definition extends UI$1.Element {
      setOptions(options) {
        super.setOptions(options);
        this.options.term = this.options.term || this.options.value;
        if (this.options.term) {
          this.options.definition = TermDefinition.getDefinition(this.options.term.trim());
        }
        if (this.options.children.length == 0) {
          this.options.children = [this.options.value || this.options.term];
        }
      }
      getNodeType() {
        return "span";
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("position", "relative");
        return attr;
      }
      render() {
        return [UI$1.createElement("span", {
          ref: "termDefinition",
          style: {
            fontWeight: "bold",
            color: "#0082AD",
            cursor: "pointer"
          }
        }, this.options.children)];
      }
      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
          let element = this;
          let popupContained = false;
          while (element) {
            if (element instanceof PopupDefinition) {
              popupContained = true;
            }
            element = element.parent;
          }
          let title = this.options.definition.title;
          let definition = this.options.definition.definition;
          if (!popupContained) {
            if (this.constructor.activeDefinition === this) {
              this.constructor.Popup.hide();
              this.constructor.Popup = null;
              this.constructor.activeDefinition = null;
              return;
            }
            if (this.constructor.Popup && this.constructor.Popup.isInDocument()) {
              this.constructor.Popup.hide();
            }
            this.constructor.Popup = PopupDefinition.create(this, {
              target: this.termDefinition,
              definition: this,
              title: title,
              content: definition,
              width: "300px"
            });
          } else {
            this.constructor.Popup.pushDefinition({
              title: title,
              content: definition
            });
          }
          this.constructor.activeDefinition = this;
        });
      }
    }

    const {
      EmojiData
    } = self;
    class EmojiModifier extends MarkupModifier {
      constructor(options) {
        super(options);

        // TODO should be probably build when needed
        this.emojiMap = new Map();
        this.unicodeToEmojiMap = new Map();
        for (let emoji in EmojiData.EMOJI) {
          this.emojiMap.set(EmojiData.EMOJI[emoji].key, emoji);
          this.unicodeToEmojiMap.set(EmojiData.EMOJI[emoji].unicode, emoji);
        }
        for (let emoticon in EmojiData.EMOTICONS) {
          let emoji = this.unicodeToEmojiMap.get(EmojiData.EMOTICONS[emoticon]);
          this.emojiMap.set(emoticon, emoji);
        }
      }
      modify(currentArray, originalString) {
        let newArray = [];
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let lineStart = 0;
        let checkAndAddEmoji = (start, end) => {
          let substr = originalString.substring(start, end);
          if (this.emojiMap.has(substr)) {
            if (currentElement.start < start) {
              newArray.push({
                isString: true,
                start: currentElement.start,
                end: start
              });
            }
            newArray.push({
              content: {
                tag: "Emoji",
                value: this.emojiMap.get(substr)
              },
              start: start,
              end: end
            });
            currentElement = {
              isString: true,
              start: end,
              end: currentElement.end
            };
          }
        };
        for (let i = 0; i < originalString.length; i += 1) {
          if (i >= currentElement.end) {
            newArray.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }
          if (currentElement.isJSX) {
            continue;
          }
          if (/\s/.test(originalString[i])) {
            checkAndAddEmoji(lineStart, i);
            lineStart = i + 1;
          }
        }
        if (lineStart < originalString.length) {
          checkAndAddEmoji(lineStart, originalString.length);
        }
        if (currentElement.start < originalString.length) {
          newArray.push(currentElement);
        }
        return newArray;
      }
    }
    MarkupParser.modifiers.push(new EmojiModifier());
    class Emoji extends UI$1.Element {
      setOptions(options) {
        options.height = options.height || "1.25em";
        options.width = options.width || "1.25em";
        super.setOptions(options);
      }
      getNodeType() {
        return "span";
      }
      render() {
        if (!EmojiData.isFull) {
          return [];
        }
        if (EmojiData.EMOJI[this.options.value]) {
          return UI$1.createElement(SVG.SVGRoot, {
            ref: "svg",
            height: this.options.height,
            width: this.options.width,
            style: {
              "display": "inline-block",
              "margin": "-.2ex .15em .2ex",
              "line-height": "normal",
              "vertical-align": "middle"
            }
          });
        } else {
          return [];
        }
      }
      getNodeAttributes() {
        const attr = super.getNodeAttributes();
        if (EmojiData.EMOJI[this.options.value]) {
          attr.setAttribute("title", ":" + this.options.value + ":");
        }
        if (this.options.title) {
          attr.setAttribute("title", this.options.title);
        }
        return attr;
      }
      updateEmojiContent() {
        if (EmojiData.EMOJI[this.options.value]) {
          this.svg.node.innerHTML = EmojiData.EMOJI[this.options.value].svgData;
          this.svg.node.setAttribute("viewBox", "0 0 64 64");
        } else {
          console.error("Invalid emoji value", this.options.value);
        }
      }
      redraw() {
        if (EmojiData.isFull) {
          super.redraw();
          this.updateEmojiContent();
          return;
        }
        // TODO add some configs to ensure, so just say ensure("Emoji", callback);
        ensure(`/static/js/Emoji.js?v=${JS_VERSION}`, () => {
          if (this.node) {
            this.redraw();
          }
        });
      }
    }

    const DelayedElement = BaseClass => class DelayedElement extends BaseClass {
      applyNodeAttributesNotLoaded() {
        super.applyNodeAttributes();
      }
      applyNodeAttributesLoaded() {
        super.applyNodeAttributes();
      }
      applyNodeAttributes() {
        if (!this._loaded) {
          return this.applyNodeAttributesNotLoaded();
        } else {
          return this.applyNodeAttributesLoaded();
        }
      }
      renderNotLoaded() {
        return "Loading component...";
      }
      renderLoaded() {
        return super.render();
      }
      render() {
        if (!this._loaded) {
          return this.renderNotLoaded();
        } else {
          return this.renderLoaded();
        }
      }
      setLoaded() {
        if (this._loaded) {
          return;
        }
        this._loaded = true;
        if (!this.node) {
          return;
        }
        super.redraw();
        if (!this._executedMount) {
          this._executedMount = true;
          this.onDelayedMount();
        }
      }
      beforeRedrawNotLoaded() {
        // Implement here anything you might need
      }
      redrawNotLoaded() {
        this.beforeRedrawNotLoaded();
        // The previous code might have triggered a redraw, skip if that was the case
        if (!this._loaded) {
          super.redraw();
        }
      }
      redrawLoaded() {
        super.redraw();
      }
      redraw() {
        if (!this._loaded) {
          return this.redrawNotLoaded();
        }
        return this.redrawLoaded();
      }
      onMount() {
        // Nothing to be done here
      }
      onDelayedMount() {
        super.onMount();
      }
    };
    const ScriptDelayedElement = (BaseClass, scripts) => class ScriptDelayedElement extends DelayedElement(BaseClass) {
      beforeRedrawNotLoaded() {
        ensure(scripts, () => {
          this.setLoaded();
        });
      }
    };

    var _class$1r, _descriptor$I, _descriptor2$C, _descriptor3$v, _descriptor4$r, _descriptor5$p, _descriptor6$l, _descriptor7$h, _descriptor8$g, _descriptor9$c, _descriptor10$a, _descriptor11$8, _descriptor12$6, _descriptor13$6, _descriptor14$6, _descriptor15$5, _descriptor16$5, _descriptor17$5, _descriptor18$3, _descriptor19$2, _descriptor20$2;
    let NavStyle = (_class$1r = class NavStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.dimensions = {
          collapseArrowWidth: "20px",
          navbarHeight: "50px",
          sidepanelElementHeight: "30px",
          sidepanelWidthLeft: "250px",
          sidepanelWidth: "330px",
          sidepanelHideWidth: "335px",
          sidepanelTransitionDuration: ".15s",
          boxShadowWidth: "5px",
          backgroundTransitionDuration: ".2s"
        };
        // Icons
        _initializerDefineProperty(this, "icon", _descriptor$I, this);
        _initializerDefineProperty(this, "sideIcon", _descriptor2$C, this);
        _initializerDefineProperty(this, "wrappedIcon", _descriptor3$v, this);
        // Nav manager elements
        this.navElement = {
          transition: `background-color ${this.dimensions.backgroundTransitionDuration}`
        };
        _initializerDefineProperty(this, "navLinkElement", _descriptor4$r, this);
        // Navbar
        _initializerDefineProperty(this, "navManager", _descriptor5$p, this);
        // Navbar elements
        _initializerDefineProperty(this, "navElementHorizontal", _descriptor6$l, this);
        _initializerDefineProperty(this, "navElementHorizontalArrow", _descriptor7$h, this);
        _initializerDefineProperty(this, "navElementValueHorizontal", _descriptor8$g, this);
        _initializerDefineProperty(this, "navSectionHorizontal", _descriptor9$c, this);
        // Sidepanel
        this.sidePanel = {
          top: "0",
          bottom: "0",
          height: "100%",
          backgroundColor: () => this.getColors().sidepanelBackground,
          overflow: "hidden",
          position: "fixed",
          zIndex: "3000",
          boxShadow: () => this.getColors().boxShadowSidePanel,
          width: () => this.dimensions.sidepanelWidth,
          transitionDuration: () => this.dimensions.sidepanelTransitionDuration
        };
        _initializerDefineProperty(this, "leftSidePanel", _descriptor10$a, this);
        _initializerDefineProperty(this, "rightSidePanel", _descriptor11$8, this);
        // Sidepanel elements
        _initializerDefineProperty(this, "navElementVertical", _descriptor12$6, this);
        _initializerDefineProperty(this, "navElementVerticalArrow", _descriptor13$6, this);
        _initializerDefineProperty(this, "navElementValueVertical", _descriptor14$6, this);
        _initializerDefineProperty(this, "navSectionVertical", _descriptor15$5, this);
        _initializerDefineProperty(this, "navCollapseElement", _descriptor16$5, this);
        _initializerDefineProperty(this, "sidePanelGroup", _descriptor17$5, this);
        _initializerDefineProperty(this, "hrStyle", _descriptor18$3, this);
        // Sidepanel transitions
        _initializerDefineProperty(this, "navVerticalLeftHide", _descriptor19$2, this);
        _initializerDefineProperty(this, "navVerticalRightHide", _descriptor20$2, this);
      }
      // Custom variables
      getColors() {
        const themeProps = this.themeProps;
        const navManagerColor = themeProps.COLOR_PRIMARY;
        const navBarColor = themeProps.NAV_MANAGER_COLOR_NAV_BAR || navManagerColor;
        const sidePanelColor = themeProps.NAV_MANAGER_COLOR_SIDE_PANEL || enhance(navManagerColor, 0.05);
        this.colors = {
          boxShadowNavManager: themeProps.NAV_MANAGER_BOX_SHADOW_NAVBAR,
          boxShadowSidePanel: themeProps.NAV_MANAGER_BOX_SHADOW_SIDE_PANEL,
          sidepanelBackground: themeProps.NAV_MANAGER_SIDE_PANEL_BACKGROUND_COLOR || sidePanelColor,
          sidepanelHover: themeProps.NAV_MANAGER_SIDE_PANEL_HOVER_COLOR || enhance(sidePanelColor, 0.1),
          navbarBackground: themeProps.NAV_MANAGER_NAV_BAR_BACKGROUND_COLOR || navBarColor,
          navbarHover: themeProps.NAV_MANAGER_NAV_BAR_HOVER_COLOR || enhance(navBarColor, 0.1),
          hr: themeProps.NAV_MANAGER_HR_COLOR || enhance(sidePanelColor, 0.15),
          text: themeProps.NAV_MANAGER_TEXT_COLOR || enhance(navManagerColor, 1)
        };
        return this.colors;
      }
    }, (_descriptor$I = _applyDecoratedDescriptor(_class$1r.prototype, "icon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          lineHeight: this.dimensions.navbarHeight,
          height: this.dimensions.navbarHeight,
          width: this.dimensions.navbarHeight,
          display: "inline-block",
          cursor: "pointer",
          textAlign: "center",
          ":hover": {
            backgroundColor: this.getColors().navbarHover
          }
        };
      }
    }), _descriptor2$C = _applyDecoratedDescriptor(_class$1r.prototype, "sideIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "120%"
        };
      }
    }), _descriptor3$v = _applyDecoratedDescriptor(_class$1r.prototype, "wrappedIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "100%",
          flex: "1"
        };
      }
    }), _descriptor4$r = _applyDecoratedDescriptor(_class$1r.prototype, "navLinkElement", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "block",
          color: this.getColors().text,
          textDecoration: "none",
          listStyleType: "none",
          ":hover": {
            backgroundColor: this.getColors().sidepanelHover,
            color: this.getColors().text,
            textDecoration: "none"
          },
          ":focus": {
            color: this.getColors().text,
            textDecoration: "none"
          },
          ":active": {
            color: this.getColors().text,
            textDecoration: "none"
          },
          ":visited": {
            color: this.getColors().text,
            textDecoration: "none"
          }
        };
      }
    }), _descriptor5$p = _applyDecoratedDescriptor(_class$1r.prototype, "navManager", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          height: this.dimensions.navbarHeight,
          lineHeight: this.dimensions.navbarHeight,
          width: "100%",
          backgroundColor: this.getColors().navbarBackground,
          boxShadow: this.getColors().boxShadowNavManager,
          zIndex: "9999",
          position: "fixed"
        };
      }
    }), _descriptor6$l = _applyDecoratedDescriptor(_class$1r.prototype, "navElementHorizontal", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          backgroundColor: this.getColors().navbarBackground,
          listStyleType: "none",
          cursor: "pointer",
          ">:nth-child(2)": {
            position: "absolute"
          }
        };
      }
    }), _descriptor7$h = _applyDecoratedDescriptor(_class$1r.prototype, "navElementHorizontalArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: ".1em",
          verticalAlign: "middle"
        };
      }
    }), _descriptor8$g = _applyDecoratedDescriptor(_class$1r.prototype, "navElementValueHorizontal", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.navElement, {
          padding: "0 0.7em",
          color: this.getColors().text,
          width: "100%",
          ":hover": {
            backgroundColor: this.getColors().navbarHover
          }
        }];
      }
    }), _descriptor9$c = _applyDecoratedDescriptor(_class$1r.prototype, "navSectionHorizontal", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          paddingLeft: "0",
          height: this.dimensions.navbarHeight,
          marginBottom: "0"
        };
      }
    }), _descriptor10$a = _applyDecoratedDescriptor(_class$1r.prototype, "leftSidePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.sidePanel, {
          overflowY: "scroll",
          width: this.dimensions.sidepanelWidthLeft,
          "-ms-overflow-style": "none",
          overflow: "-moz-scrollbars-none",
          "::-webkit-scrollbar": {
            display: "none"
          }
        }];
      }
    }), _descriptor11$8 = _applyDecoratedDescriptor(_class$1r.prototype, "rightSidePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.sidePanel;
      }
    }), _descriptor12$6 = _applyDecoratedDescriptor(_class$1r.prototype, "navElementVertical", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          cursor: "pointer",
          listStyleType: "none",
          minHeight: this.dimensions.sidepanelElementHeight,
          overflow: "hidden",
          position: "relative",
          ">*": {
            paddingLeft: this.dimensions.collapseArrowWidth
          }
        };
      }
    }), _descriptor13$6 = _applyDecoratedDescriptor(_class$1r.prototype, "navElementVerticalArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: this.dimensions.collapseArrowWidth,
          textAlign: "center"
        };
      }
    }), _descriptor14$6 = _applyDecoratedDescriptor(_class$1r.prototype, "navElementValueVertical", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.navElement, {
          color: this.getColors().text,
          zIndex: "1",
          position: "relative",
          width: "100%",
          height: this.dimensions.sidepanelElementHeight,
          lineHeight: this.dimensions.sidepanelElementHeight,
          ":hover": {
            backgroundColor: this.getColors().sidepanelHover
          }
        }];
      }
    }), _descriptor15$5 = _applyDecoratedDescriptor(_class$1r.prototype, "navSectionVertical", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: "0",
          marginBottom: "0",
          width: "100%"
        };
      }
    }), _descriptor16$5 = _applyDecoratedDescriptor(_class$1r.prototype, "navCollapseElement", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          textAlign: "initial",
          lineHeight: this.dimensions.sidepanelElementHeight
        };
      }
    }), _descriptor17$5 = _applyDecoratedDescriptor(_class$1r.prototype, "sidePanelGroup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingTop: this.dimensions.navbarHeight,
          height: "inherit",
          width: this.dimensions.sidepanelWidth,
          position: "absolute",
          zIndex: "3"
        };
      }
    }), _descriptor18$3 = _applyDecoratedDescriptor(_class$1r.prototype, "hrStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "10px 5%",
          borderTop: () => "2px solid " + this.getColors().hr
        };
      }
    }), _descriptor19$2 = _applyDecoratedDescriptor(_class$1r.prototype, "navVerticalLeftHide", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "-" + this.dimensions.sidepanelHideWidth,
          overflow: "hidden"
        };
      }
    }), _descriptor20$2 = _applyDecoratedDescriptor(_class$1r.prototype, "navVerticalRightHide", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginRight: "-" + this.dimensions.sidepanelHideWidth,
          overflow: "hidden"
        };
      }
    })), _class$1r);

    // Class for working with the Window.localStorage and Window.sessionStorage objects
    // All keys are prefixed with our custom name, so we don't have to worry about polluting the global storage namespace
    // Keys must be strings, and values are modified by the serialize/deserialize methods,
    // which by default involve JSON conversion
    class StorageMap extends Dispatchable {
      constructor(storage, name = "") {
        super();
        this.storage = storage;
        this.name = name;
        this.prefix = name + this.constructor.SEPARATOR;
      }
      getPrefix() {
        return this.prefix;
      }
      getRawKey(key) {
        return this.getPrefix() + key;
      }

      // Method to serialize the values
      serialize(value) {
        return JSON.stringify(value);
      }

      // Method to deserialize the value (which can be null if there is no value)
      deserialize(value) {
        return value && JSON.parse(value);
      }
      set(key, value) {
        try {
          this.storage.setItem(this.getRawKey(key), this.serialize(value));
        } catch (e) {
          return false;
        }
        return true;
      }
      delete(key) {
        this.storage.removeItem(this.getRawKey(key));
      }
      getRaw(key) {
        return this.storage.getItem(this.getRawKey(key));
      }
      get(key, defaultValue = null) {
        const value = this.getRaw(key);
        if (value == null) {
          return defaultValue;
        }
        return this.deserialize(value);
      }
      has(key) {
        return this.getRaw(key) != null;
      }
      keys() {
        let result = [];
        const totalStorageKeys = this.storage.length;
        const prefixLenth = this.getPrefix().length;
        for (let i = 0; i < totalStorageKeys; i++) {
          const key = this.storage.key(i);
          if (key.startsWith(this.getPrefix())) {
            result.push(key.substr(prefixLenth));
          }
        }
        return result;
      }
      values() {
        return this.keys().map(key => this.get(key));
      }
      entries() {
        return this.keys().map(key => [key, this.get(key)]);
      }
      [Symbol.iterator]() {
        return this.entries();
      }

      // Remove all of the keys that start with out prefix
      clear() {
        for (let key of this.keys()) {
          this.delete(key);
        }
      }
    }

    // SessionStorageMap can be used to preserve data on tab refreshes
    StorageMap.SEPARATOR = "-@#%-";
    class SessionStorageMap extends StorageMap {
      constructor(name = "") {
        super(window.sessionStorage, name);
      }
    }

    // LocalStorageMap can be used to store data across all our tabs
    class LocalStorageMap extends StorageMap {
      constructor(name = "") {
        super(window.localStorage, name);
      }

      // Since we don't want a listener attached to window storage event for each map, we create a global one
      // Any raw key that contains our separator has its original map identified and gets dispatched only for that map
      static getChangeDispatchable() {
        if (!this.CHANGE_DISPATCHABLE) {
          this.CHANGE_DISPATCHABLE = new Dispatchable();
          window.addEventListener("storage", event => {
            let separatorIndex = event.key.indexOf(this.SEPARATOR);
            if (separatorIndex === -1) {
              // This is not an event associated with a storage map
              return;
            }
            const name = event.key.substr(0, separatorIndex);
            const actualKey = event.key.substr(separatorIndex + this.SEPARATOR.length);
            let newEvent = {
              originalEvent: event,
              key: actualKey,
              oldValue: event.oldValue,
              newValue: event.newValue
            };
            this.CHANGE_DISPATCHABLE.dispatch(name, newEvent);
          });
        }
        return this.CHANGE_DISPATCHABLE;
      }

      // Add a listener for all change event on the current map
      // Only works if we're being backed by Window.localStorage and only received events from other tabs (not the current tab)
      // The event has the following fields: key, oldValue, newValue, url, storageArea, originalEvent
      // The key is modified to be the same the one you used in the map
      addChangeListener(callback, doDeserialization = true) {
        let realCallback = callback;
        if (doDeserialization) {
          realCallback = event => {
            event.oldValue = this.deserialize(event.oldValue);
            event.newValue = this.deserialize(event.newValue);
            callback(event);
          };
        }
        return this.constructor.getChangeDispatchable().addListener(this.name, realCallback);
      }
    }

    let navSessionManager = new SessionStorageMap("navManager");
    const BasicOrientedElementInterface = BaseClass => class BasicOrientedElement extends BaseClass {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }
      getOrientation() {
        if (this.options.orientation) {
          return this.options.orientation;
        }
        if (this.parent && typeof this.parent.getOrientation === "function") {
          return this.parent.getOrientation();
        }
        return Orientation$1.HORIZONTAL;
      }
    };
    const BasicOrientedElement = BasicOrientedElementInterface(UI$1.Element);
    const BasicOrientedLinkElement = BasicOrientedElementInterface(Link);

    // NavElements should know if they are in vertical or horizontal mode, so they can behave differently
    const NavElementInterface = BaseClass => class NavElement extends BaseClass {
      constructor(...args) {
        super(...args);
        this.isToggled = this.getToggledState();
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        if (this.getOrientation() === Orientation$1.HORIZONTAL) {
          // it is in the navbar
          attr.addClass(this.styleSheet.navElementHorizontal);
          if (this.parent instanceof NavSection) {
            attr.setStyle("float", "left");
          } else {
            // it is an element in a dropdown
            attr.addClass(this.styleSheet.navCollapseElement);
          }
        } else {
          // it is in the sidebar
          attr.addClass(this.styleSheet.navElementVertical);
        }
      }
      getSelf() {
        const style = this.getOrientation() === Orientation$1.HORIZONTAL ? this.styleSheet.navElementValueHorizontal : this.styleSheet.navElementValueVertical;
        const marginLeft = this.getOrientation() === Orientation$1.VERTICAL && unwrapArray(this.render()).length ? "-20px" : "0";
        return UI$1.createElement(BasicOrientedElement, {
          className: style,
          style: {
            marginLeft: marginLeft
          }
        }, this.getValue());
      }
      getSubElements() {
        let childrenToRender = unwrapArray(this.render());
        if (childrenToRender.length) {
          let subElementsClass;
          if (!this.isToggled) {
            subElementsClass = "hidden";
          }
          return UI$1.createElement(BasicOrientedElement, {
            ref: "contentArea",
            className: subElementsClass
          }, childrenToRender);
        }
        return null;
      }
      getValue() {
        let result;
        if (unwrapArray(this.render()).length) {
          if (this.getOrientation() === Orientation$1.VERTICAL) {
            // is in the sidebar
            result = [UI$1.createElement(FACollapseIcon, {
              ref: "collapseIcon",
              collapsed: !this.isToggled,
              className: this.styleSheet.navElementVerticalArrow
            }), this.options.value];
          } else if (this.getOrientation() === Orientation$1.HORIZONTAL) {
            // is in the navbar
            result = [this.options.value, UI$1.createElement(FACollapseIcon, {
              collapsed: false,
              className: this.styleSheet.navElementHorizontalArrow
            })];
          }
        } else {
          result = this.options.value;
        }
        return result;
      }
      getChildrenToRender() {
        return [this.getSelf(), this.getSubElements()];
      }
      showChildren() {
        this.contentArea.removeClass("hidden");
      }
      hideChildren() {
        this.contentArea.addClass("hidden");
      }
      toggleChildren() {
        if (!unwrapArray(this.render()).length) {
          return;
        }
        if (!this.isToggled) {
          this.showChildren();
        } else {
          this.hideChildren();
        }
        if (this.collapseIcon) {
          this.collapseIcon.setCollapsed(this.isToggled);
        }
        this.isToggled = !this.isToggled;
        this.saveToggledState();
      }
      getSessionKeyName() {
        let sessionKeyName = this.options.sessionKey || this.options.href;
        if (!sessionKeyName) {
          throw Error("Persistent nav element needs a unique session key!");
        }
        return sessionKeyName;
      }
      getLocalToggledState() {
        if (this.hasOwnProperty("isToggled")) {
          return !!this.isToggled;
        }
        return !!this.options.defaultToggled;
      }
      getToggledState() {
        if (!this.options.persistent) {
          return this.getLocalToggledState();
        }
        let sessionKeyName = this.getSessionKeyName();
        return navSessionManager.get(sessionKeyName, this.getLocalToggledState());
      }
      saveToggledState() {
        if (!this.options.persistent) {
          return;
        }
        let sessionKeyName = this.getSessionKeyName();
        navSessionManager.set(sessionKeyName, this.getLocalToggledState());
      }
      onMount() {
        super.onMount();
        this.addNodeListener("mouseenter", () => {
          if (this.getOrientation() === Orientation$1.HORIZONTAL && unwrapArray(this.render()).length) {
            this.showChildren();
          }
        });
        this.addNodeListener("mouseleave", () => {
          if (this.getOrientation() === Orientation$1.HORIZONTAL && unwrapArray(this.render()).length) {
            this.hideChildren();
          }
        });
        this.addClickListener(event => {
          if (this.getOrientation() === Orientation$1.VERTICAL) {
            event.stopPropagation();
            this.toggleChildren();
          }
        });
      }
    };
    const NavElement = NavElementInterface(UI$1.Primitive(BasicOrientedElement, "li"));
    class NavLinkElement extends NavElementInterface(BasicOrientedLinkElement) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.navLinkElement);
      }
      render() {
        return this.options.children;
      }
    }
    class NavSection extends UI$1.Primitive("ul") {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }
      extraNodeAttributes(attr) {
        if (this.getOrientation() === Orientation$1.HORIZONTAL) {
          // it is in the navbar
          attr.addClass(this.styleSheet.navSectionHorizontal);
          // this is functionality, should be isolated from the actual design
          attr.setStyle("float", this.getAnchor());
        } else {
          // it is in the sidebar
          attr.addClass(this.styleSheet.navSectionVertical);
        }
      }
      getAnchor() {
        return this.options.anchor || Direction.LEFT;
      }
      getOrientation() {
        return this.parent.getOrientation();
      }
    }
    class NavAnchoredNotifications extends NavSection {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          position: "relative"
        });
      }
      getSwitcherStyle() {
        return {
          position: "absolute",
          maxWidth: "calc(100vw - 76px)",
          top: "50px",
          right: "0",
          height: "300px",
          width: "400px",
          boxShadow: "0px 0px 10px #666",
          zIndex: "-1"
        };
      }
      render() {
        return [this.options.children, UI$1.createElement(Switcher, {
          ref: "switcher",
          style: this.getSwitcherStyle(),
          className: "hidden"
        })];
      }
      show(content, child) {
        this.activeChild = child;
        this.switcher.removeClass("hidden");
        this.switcher.setActive(content, child);
        this.bodyListener = document.body.addEventListener("click", () => this.hide());
      }
      hide() {
        this.switcher.addClass("hidden");
        this.activeChild = null;
        document.body.removeEventListener("click", this.bodyListener);
      }
      onMount() {
        this.addListener("changeSwitcher", (content, child) => {
          if (this.activeChild == child) {
            this.hide();
          } else {
            this.show(content, child);
          }
        });
        this.switcher.addClickListener(event => {
          event.stopPropagation();
        });
      }
    }

    class NavIcon extends NavElement {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.icon);
      }
      getValue() {
        return [this.getIcon(), this.getContent()];
      }
      getContent() {
        return null;
      }
      getIcon() {
        return null;
      }
      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }
    }
    class LeftSideNavIcon extends NavIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.sideIcon);
      }
      getIcon() {
        return UI$1.createElement(FAIcon, {
          icon: "bars",
          size: Size.LARGE
        });
      }
    }
    class RightSideNavIcon extends NavIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.sideIcon);
      }
      getIcon() {
        return UI$1.createElement(FAIcon, {
          icon: "ellipsis-v",
          size: Size.LARGE
        });
      }
    }
    class WrappedNavIcon extends NavIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.wrappedIcon);
      }
      getIcon() {
        return UI$1.createElement(FAIcon, {
          icon: "ellipsis-h",
          size: Size.LARGE
        });
      }
    }

    let DEFAULT_MAX_DISTANCE_FROM_SIDE = 25; // Pixels
    let minSwipeDistance = 60; // Pixels
    let minSwipeSpeed = 0.5; // Pixels per millisecond

    function touchEventHandler(ignoreCondition, successCondition, onSuccess, xType = "client") {
      return event => {
        if (ignoreCondition(event.targetTouches[0][xType + "X"])) {
          return;
        }
        let startX = event.targetTouches[0][xType + "X"];
        let panelToggler = new Dispatcher();
        let startTime = StemDate.now();
        let touchCallback = event => {
          if (successCondition(event.targetTouches[0][xType + "X"], startX, StemDate.now() - startTime)) {
            panelToggler.dispatch(true);
          }
        };
        let touchendCallback = () => {
          panelToggler.dispatch(false);
        };
        document.addEventListener("touchmove", touchCallback);
        document.addEventListener("touchend", touchendCallback);
        panelToggler.addListener(success => {
          if (success) {
            onSuccess();
          }
          document.removeEventListener("touchmove", touchCallback);
          document.removeEventListener("touchend", touchendCallback);
        });
      };
    }
    function initializeSwipeRight(navManager, maxDistance = DEFAULT_MAX_DISTANCE_FROM_SIDE, minDistance = minSwipeDistance, minSpeed = minSwipeSpeed) {
      document.addEventListener("touchstart", touchEventHandler(touchX => navManager.leftSidePanel.visible || window.pageXOffset !== 0 || touchX > maxDistance, (touchX, startX, duration) => touchX - startX >= minDistance && (touchX - startX) / duration >= minSpeed, () => navManager.toggleLeftSidePanel()));
      navManager.leftSidePanel.addNodeListener("touchstart", touchEventHandler(() => !navManager.leftSidePanel.visible, (touchX, startX) => startX - touchX >= minDistance && startX - touchX >= minSpeed, () => navManager.toggleLeftSidePanel()));
    }
    function initializeSwipeLeft(navManager, maxDistance = DEFAULT_MAX_DISTANCE_FROM_SIDE, minDistance = minSwipeDistance, minSpeed = minSwipeSpeed) {
      document.addEventListener("touchstart", touchEventHandler(touchX => navManager.rightSidePanel.visible || window.innerWidth - touchX > maxDistance, (touchX, startX, duration) => startX - touchX >= minDistance && (startX - touchX) / duration >= minSpeed, () => navManager.toggleRightSidePanel()));
      navManager.rightSidePanel.addNodeListener("touchstart", touchEventHandler(() => !navManager.rightSidePanel.visible, (touchX, startX, duration) => touchX - startX >= minDistance && (touchX - startX) / duration >= minSpeed, () => navManager.toggleRightSidePanel()));
    }
    function initializeSwipeEvents(navManager, maxDistanceFromSide = DEFAULT_MAX_DISTANCE_FROM_SIDE, minDistance = minSwipeDistance, minSpeed = minSwipeSpeed) {
      if (!Device.isTouchDevice()) {
        return;
      }
      if (navManager.leftSidePanel) {
        initializeSwipeRight(navManager, maxDistanceFromSide, minDistance, minSpeed);
      }
      if (navManager.rightSidePanel) {
        initializeSwipeLeft(navManager, maxDistanceFromSide, minDistance, minSpeed);
      }
    }

    var _dec$X, _class$1q, _dec2$m, _class2$K;
    class SidePanelGroup extends UI$1.Element {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.sidePanelGroup);
        if (this.options.anchor === Direction.RIGHT) {
          attr.setStyle("right", 0);
        } else {
          attr.setStyle("width", "250px");
        }
      }
      getOrientation() {
        return Orientation$1.VERTICAL;
      }
    }
    let SidePanel = (_dec$X = registerStyle(NavStyle), _dec$X(_class$1q = class SidePanel extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.initNode();
        this.applyVisibility();
      }
      initNode() {
        if (!this.node) {
          this.mount(document.body);
        }
      }
      applyVisibility() {
        if (this.options.name) {
          this.storageSerializer = new SessionStorageMap("sidePanel" + this.options.name);
          this.visible = this.storageSerializer.get("visible");
        }
        if (this.visible) {
          this.show();
        } else {
          this.hide();
        }
      }
      extraNodeAttributes(attr) {
        if (this.options.anchor === Direction.RIGHT) {
          attr.addClass(this.styleSheet.rightSidePanel);
          attr.setStyle("right", "0");
        } else {
          attr.addClass(this.styleSheet.leftSidePanel);
        }
      }
      setVisible(value) {
        this.visible = value;
        if (this.storageSerializer) {
          this.storageSerializer.set("visible", value);
        }
      }
      show() {
        if (this.options.anchor === Direction.RIGHT) {
          this.removeClass(this.styleSheet.navVerticalRightHide);
        } else {
          this.removeClass(this.styleSheet.navVerticalLeftHide);
        }
        this.setVisible(true);
      }
      hide() {
        if (this.options.anchor === Direction.RIGHT) {
          this.addClass(this.styleSheet.navVerticalRightHide);
        } else {
          this.addClass(this.styleSheet.navVerticalLeftHide);
        }
        this.setVisible(false);
      }
      toggle() {
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }
      getChildrenToRender() {
        return UI$1.createElement(SidePanelGroup, {
          ref: "this.wrappedPanel",
          anchor: this.options.anchor
        }, this.render());
      }
      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }
    }) || _class$1q);
    class NavCarouselStyle extends CarouselStyle {
      constructor(...args) {
        super(...args);
        this.hoverColor = () => NavStyle.getInstance().getColors().sidepanelHover;
        this.textColor = () => NavStyle.getInstance().getColors().text;
        this.navigatorTransitionTime = () => NavStyle.getInstance().dimensions.backgroundTransitionDuration;
      }
    }
    let NavManager = (_dec2$m = registerStyle(NavStyle), _dec2$m(_class2$K = class NavManager extends UI$1.Primitive("nav") {
      getCarouselStyleSheet() {
        return this.options.carouselStyleSheet || NavCarouselStyle.getInstance();
      }
      getDefaultOptions() {
        return {
          persistentLeftSidePanel: true,
          persistentRightSidePanel: true
        };
      }
      initLeftSidePanel() {
        this.leftSidePanel = UI$1.createElement(SidePanel, {
          anchor: Direction.LEFT,
          name: "left",
          persistent: this.options.persistentLeftSidePanel
        }, UI$1.createElement(Carousel, {
          ref: this.refLink("carousel"),
          styleSheet: this.getCarouselStyleSheet()
        }, UI$1.createElement(BasicOrientedElement, {
          orientation: Orientation$1.VERTICAL,
          ref: this.refLink("navigationPanel"),
          styleSheet: this.styleSheet
        }, this.getLeftSidePanelChildren())));
      }
      initRightSidePanel() {
        this.rightSidePanel = UI$1.createElement(SidePanel, {
          className: "no-print",
          anchor: Direction.RIGHT,
          name: "right",
          persistent: this.options.persistentRightSidePanel
        }, this.getRightSidePanelChildren());
      }
      constructor(options) {
        super(options);
        this.initLeftSidePanel();
        this.initRightSidePanel();
      }
      getLeftSidePanelChildren() {
        return [];
      }
      getRightSidePanelChildren() {
        return [];
      }
      getLeftConditionedChildren() {
        return [];
      }
      getRightConditionedChildren() {
        return [];
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.navManager);
      }
      getOrientation() {
        return Orientation$1.HORIZONTAL;
      }
      leftSideIconAction() {
        if (this.wrapped) {
          if (this.carousel.getActive() === this.navigationPanel) {
            this.toggleLeftSidePanel();
          } else {
            this.carousel.setActive(this.navigationPanel);
            if (!this.leftSidePanel.visible) {
              this.toggleLeftSidePanel();
            }
          }
        } else {
          this.toggleLeftSidePanel();
        }
      }

      // TODO: lots of duplicate code here, with left/right stuff
      getLeftSideIcon() {
        if (!this.leftSidePanel) {
          return null;
        }
        if (!this.leftPanelToggler) {
          this.leftPanelToggler = UI$1.createElement(LeftSideNavIcon, {
            onClick: () => this.leftSideIconAction()
          });
        }
        return this.leftPanelToggler;
      }
      rightSideIconAction() {
        this.toggleRightSidePanel();
      }
      getRightSideIcon() {
        if (!this.rightSidePanel) {
          return null;
        }
        if (!this.rightPanelToggler) {
          this.rightPanelToggler = UI$1.createElement(RightSideNavIcon, {
            onClick: () => this.rightSideIconAction()
          });
        }
        return this.rightPanelToggler;
      }
      getFixedWidth() {
        let width = 10;
        for (let child of this.children) {
          width += child.getWidth();
        }
        width -= this.getLeftConditioned().getWidth();
        width -= this.getRightConditioned().getWidth();
        return width;
      }
      wrappedIconAction() {
        if (this.wrapped) {
          if (this.carousel.getActive() === this.wrappedPanel) {
            this.toggleLeftSidePanel();
          } else {
            this.carousel.setActive(this.wrappedPanel);
            if (!this.leftSidePanel.visible) {
              this.toggleLeftSidePanel();
            }
          }
        } else {
          this.toggleLeftSidePanel();
        }
      }
      getWrappedIcon() {
        if (!this.wrappedToggler) {
          this.wrappedToggler = UI$1.createElement(WrappedNavIcon, {
            onClick: () => this.wrappedIconAction(),
            className: this.wrapped ? "" : "hidden"
          });
        }
        return this.wrappedToggler;
      }
      getLeftFixed() {
        return [];
      }
      getRightFixed() {
        return [];
      }
      getLeftConditionedWrapper() {
        if (!this.leftConditionedWrapper) {
          this.leftConditionedWrapper = UI$1.createElement(NavSection, {
            anchor: Direction.LEFT
          }, this.getLeftConditioned());
        }
        return this.leftConditionedWrapper;
      }
      getRightConditionedWrapper() {
        if (!this.rightConditionedWrapper) {
          this.rightConditionedWrapper = UI$1.createElement(NavSection, {
            anchor: Direction.RIGHT
          }, this.getRightConditioned());
        }
        return this.rightConditionedWrapper;
      }
      getLeftConditioned() {
        if (!this.leftConditioned) {
          this.leftConditioned = UI$1.createElement(NavSection, null, this.getLeftConditionedChildren());
        }
        return this.leftConditioned;
      }
      getRightConditioned() {
        if (!this.rightConditioned) {
          this.rightConditioned = UI$1.createElement(NavSection, null, this.getRightConditionedChildren());
        }
        return this.rightConditioned;
      }
      toggleSidePanel(mainPanel, toggleEvent) {
        let secondaryPanel = mainPanel == this.leftSidePanel ? this.rightSidePanel : this.leftSidePanel;
        mainPanel.toggle();
        this.dispatch(toggleEvent, mainPanel.visible);
        if (secondaryPanel && mainPanel.visible && secondaryPanel.visible) {
          mainPanel.setStyle("z-index", 3001);
          secondaryPanel.setStyle("z-index", 3000);
        }
      }
      toggleLeftSidePanel() {
        this.toggleSidePanel(this.leftSidePanel, "toggledLeftSide");
      }
      toggleRightSidePanel() {
        this.toggleSidePanel(this.rightSidePanel, "toggledRightSide");
      }
      render() {
        return [this.getLeftSideIcon(), this.getLeftFixed(), this.getLeftConditionedWrapper(), this.getWrappedIcon(), UI$1.createElement(NavSection, {
          style: {
            marginLeft: "auto"
          }
        }, this.getRightConditionedWrapper()), this.getRightFixed(), this.getRightSideIcon()];
      }
      bindToNode() {
        super.bindToNode(...arguments);
        this.onMount();
      }

      // This method enforces the wrapping to be skipped. It is useful when navbar elements change.
      skipWrap() {
        this.wrapSkip = true;
        this.wrapScheduled = false;
      }
      unskipWrap() {
        this.wrapSkip = false;
        if (this.wrapScheduled) {
          this.checkForWrap();
        }
      }
      checkForWrap() {
        if (this.wrapSkip) {
          this.wrapScheduled = true;
          return;
        }
        const wrapNavElements = () => {
          this.wrapped = true;
          this.wrappedPanel = UI$1.createElement(BasicOrientedElement, {
            orientation: Orientation$1.VERTICAL,
            styleSheet: this.styleSheet
          });
          this.carousel.appendChild(this.wrappedPanel);
          changeParent(this.getRightConditioned(), this.wrappedPanel);
          changeParent(this.getLeftConditioned(), this.wrappedPanel);
          this.getRightConditioned().redraw();
          this.getLeftConditioned().redraw();
          this.getWrappedIcon().removeClass("hidden");
        };
        const unwrapNavElements = () => {
          this.wrapped = false;
          this.getWrappedIcon().addClass("hidden");
          changeParent(this.getLeftConditioned(), this.getLeftConditionedWrapper());
          changeParent(this.getRightConditioned(), this.getRightConditionedWrapper());
          this.carousel.eraseChild(this.wrappedPanel);
          this.getLeftConditioned().redraw();
          this.getRightConditioned().redraw();
        };
        if (this.getLeftConditioned().children.length || this.getRightConditioned().children.length) {
          if (!this.wrapped) {
            this.unwrappedTotalWidth = 10;
            for (let child of this.children) {
              this.unwrappedTotalWidth += child.getWidth();
            }
          }
          if (window.innerWidth < this.unwrappedTotalWidth && !this.wrapped) {
            wrapNavElements();
            this.dispatch("wrapped", true);
          } else if (window.innerWidth >= this.unwrappedTotalWidth && this.wrapped) {
            unwrapNavElements();
            this.dispatch("wrapped", false);
          }
        } else if (this.wrapped) {
          unwrapNavElements();
        }
      }
      onMount() {
        NavManager.Global = this;
        initializeSwipeEvents(this);
        setTimeout(() => this.checkForWrap());
        window.addEventListener("resize", () => this.checkForWrap());
        this.addListener("maybeWrap", () => this.checkForWrap());
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }
    }) || _class2$K);

    // Use to keep compatibility with the old Stem UI.js
    // If you want that, use import from "ui/UI";
    IconableInterface.prototype.getIcon = function () {
      const {
        icon
      } = this.options;
      return icon && MakeIcon(icon, {
        style: {
          marginRight: 5
        }
      });
    };

    function isWhiteSpace(character) {
      return (character + "").trim() === "";
    }

    // TODO: why is there a callback second argument??
    function consoleTokenizer(input, callback) {
      var currentToken = "";
      var doubleQuotesOpen = false;
      var tokens = [];
      var i = 0;
      while (i < input.length) {
        if (input[i] === "\\") {
          // A backslash can only be followed by another backslash or double quotes
          if (input[i + 1] === "\\" || input[i + 1] === "\"") {
            currentToken += input[i + 1];
            i += 2;
          } else {
            throw "A backslash must be followed by another backslash or double quotes";
          }
        } else if (input[i] === "\"") {
          // Double quotes that are placed at the end of the token must be at the end of the string or followed by
          // a white character, meaning the current token is ended and needs to be inserted in the array
          if (doubleQuotesOpen === true && (i + 1 === input.length || isWhiteSpace(input[i + 1]))) {
            doubleQuotesOpen = false;
            tokens.push(currentToken);
            currentToken = "";
            i += 2;
          } else if (doubleQuotesOpen === false && currentToken === "") {
            // Double quotes can also mean the beginning of a token with special characters
            doubleQuotesOpen = true;
            i += 1;
          } else {
            throw "Double quotes must be preceded by backslash if they are inside a word";
          }
        } else if (!doubleQuotesOpen && isWhiteSpace(input[i])) {
          // A whitespace outside of double quotes closure means the end of a token, so it is inserted in the
          // array and reinitialized with empty string
          if (currentToken !== "") {
            tokens.push(currentToken);
            currentToken = "";
          }
          i += 1;
        } else {
          // If there is no special case we append the current letter to the end of the token
          currentToken += input[i];
          i += 1;
        }
      }

      // Insert the current token if it isn't empty
      if (currentToken !== "") {
        tokens.push(currentToken);
      }

      // Double quotes open are a syntax error
      if (doubleQuotesOpen === true) {
        throw "Double quotes can't be left open";
      }
      return tokens;
    }
    const Formatter = {
      cpuTime: function (value) {
        if (value == null) {
          return "-";
        }
        return Math.round(value * 1000.0) + " ms";
      },
      memory: function (value, shortForm = false) {
        if (value == null) {
          return "-";
        }
        if (value < 2048) {
          return value + (shortForm ? "" : " ") + "B";
        }
        var memUsage = value / 1024;
        var suffix = "KB";
        if (memUsage >= 1024 * 1024) {
          memUsage /= 1024 * 1024;
          suffix = "GB";
        } else if (memUsage >= 10 * 1024) {
          memUsage /= 1024;
          suffix = "MB";
        }
        memUsage = Math.round(memUsage * 10) / 10;
        return memUsage.toString() + (shortForm ? "" : " ") + suffix;
      },
      duration: (value, options) => {
        // value in milliseconds
        value = new Duration(value);
        let result = [];
        if (options.days && value.toDays()) {
          let d = value.toDays() + " day";
          if (value.toDays() >= 2) {
            d += "s";
          }
          result.push(d);
        }
        if (options.hours && value.getHours()) {
          let h = value.getHours() + " hour";
          if (value.getHours() >= 2) {
            h += "s";
          }
          result.push(h);
        }
        if (options.minutes && value.getMinutes()) {
          let m = value.getMinutes() + " minute";
          if (value.getMinutes() >= 2) {
            m += "s";
          }
          result.push(m);
        }
        if (options.seconds && value.getSeconds()) {
          let s = value.getSeconds() + " second";
          if (value.getSeconds() >= 2) {
            s += "s";
          }
          result.push(s);
        }
        if (result.length === 0) {
          return "";
        }
        if (result.length === 1) {
          return result[0];
        }
        if (options.lastSeparator) {
          let firstPart = result.slice(0, -1).join(options.separator || " ");
          return firstPart + options.lastSeparator + result[result.length - 1];
        }
        return result.join(options.separator || " ");
      },
      truncate: (value, precision = 0) => {
        var power = Math.pow(10, precision);
        if (typeof value === "string") {
          value = parseFloat(value);
        }
        return Math.round(value * power) / power;
      }
    };
    function getTextWidth(text, options) {
      options = options || {};
      // Re-use canvas object for better performance
      var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
      var context = canvas.getContext("2d");
      context.font = (options.fontSize || 12) + "px " + (options.font || "Segoe UI");
      var metrics = context.measureText(text);
      return metrics.width;
    }
    function parseIntegers(str) {
      let int = [];
      let currentInt = 0;
      let started = false;
      let sign = 1;
      for (let i = 0; i < str.length; i += 1) {
        if ("0123456789".indexOf(str[i]) !== -1) {
          started = true;
          currentInt = currentInt * 10 + str.charCodeAt(i) - 48;
        } else if ("-".indexOf(str[i]) !== -1 && !started) {
          sign = -1;
        } else {
          if (started) {
            int.push(sign * currentInt);
          }
          currentInt = 0;
          sign = 1;
          if ("-".indexOf(str[i]) !== -1) {
            sign = -1;
          }
          started = false;
        }
      }
      if (started) {
        int.push(sign * currentInt);
      }
      return int;
    }

    // This is how you calculate viewport height. See: https://stackoverflow.com/questions/1248081/get-the-browser-viewport-dimensions-with-javascript
    //var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
    //var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)

    // Codes for an individual run
    const RunStatusCodes = {
      OK: 1,
      RESTRICTED_FUNCTION: 2,
      TIME_LIMIT_EXCEEDED: 3,
      WALL_TIME_LIMIT_EXCEEDED: 4,
      MEMORY_LIMIT_EXCEEDED: 5,
      OUTPUT_LIMIT_EXCEEDED: 6,
      NON_ZERO_EXIT_STATUS: 7,
      RUNTIME_ERROR: 8,
      ABNORMAL_TERMINATION: 9,
      INTERNAL_ERROR: 10
    };
    const LinuxSignals = {
      1: "SIGHUP",
      2: "SIGINT",
      3: "SIGQUIT",
      4: "SIGILL",
      5: "SIGTRAP",
      6: "SIGABRT",
      7: "SIGBUS",
      8: {
        shortName: "SIGFPE",
        longName: "Arithmetic exception",
        description: "Can occur at a division by zero or some overflows"
      },
      9: "SIGKILL",
      10: "SIGUSR1",
      11: {
        shortName: "SIGSEGV",
        longName: "Segmentation fault",
        description: "Invalid memory reference, such as accessing outside the bounds of an array."
      },
      12: "SIGUSR2",
      13: "SIGPIPE",
      14: "SIGALRM",
      15: "SIGTERM",
      16: "SIGSTKFLT",
      17: "SIGCHLD",
      18: "SIGCONT",
      19: "SIGSTOP",
      20: "SIGTSTP",
      21: "SIGTTIN",
      22: "SIGTTOU",
      23: "SIGURG",
      24: "SIGXCPU",
      25: "SIGXFSZ",
      26: "SIGVTALRM",
      27: "SIGPROF",
      28: "SIGWINCH",
      29: "SIGIO",
      30: "SIGPWR",
      31: "SIGSYS"
    };
    function getSignalDescriptor(signalCode) {
      let signalDescriptor = LinuxSignals[signalCode];
      if (!signalDescriptor) {
        signalDescriptor = "Signal " + signalCode;
      }
      if (isString(signalDescriptor)) {
        signalDescriptor = {
          shortName: signalDescriptor
        };
      }
      return signalDescriptor;
    }
    class BaseUserSubmission extends StoreObject {
      getProgrammingLanguage() {
        return ProgrammingLanguage.get(this.programmingLanguageId);
      }
      getSize() {
        return this.sourceText.length;
      }
      getSourceText() {
        return this.sourceText;
      }
      isCompiling() {
        return this.compileStarted && this.compileOK == null;
      }
      hasCompileError() {
        return this.compileOK === false;
      }
      getDuration() {
        return this.duration;
      }
      getCompilationStatusMessage() {
        if (!this.compileStarted) {
          return "";
        }
        if (this.isCompiling()) {
          return "Compilation running...";
        }
        const duration = this.getDuration();
        if (this.hasCompileError()) {
          const durationMessage = duration ? " (" + duration + " seconds)." : ".";
          return "Compilation failed" + durationMessage;
        } else {
          const durationMessage = duration ? " in " + duration + " seconds." : ".";
          return "Compilation done" + durationMessage;
        }
      }
    }

    // Basically a WeakMap with a default getter and which provides control over the Symbol key
    class PropertyCache {
      // When getter is null, assume that the first argument is the getter.
      constructor(key, getter = null) {
        if (isString(key)) {
          key = Symbol.for(key);
        }
        if (getter == null) {
          getter = key;
          key = Symbol();
        }
        this.key = key;
        this.getter = getter;
      }
      get(obj, getter = this.getter) {
        const key = this.key;
        if (obj.hasOwnProperty(key)) {
          return obj[key];
        }
        return obj[key] = getter(obj);
      }
    }

    // TODO: maybe have better names
    const autoRedrawListenersLazy = new PropertyCache("autoRedrawHandler", () => new Set());
    const redrawHandlerLazy = new PropertyCache("autoRedrawListener", obj => {
      return event => obj.enqueueRedraw(event);
    });

    // Decorator that attaches a change listener on all store objects in options
    // The logic is very crude, but works in most cases
    function autoredrawDecorator(Cls, ...args) {
      const listenersDefault = () => new Set([...args]);
      // TODO: we only need to do this once, throw an error if applying multiple times to the same class

      if (Cls.autoRedrawImplemented) {
        console.error("Can't use autoredraw on a class that inherited another class using autoredraw");
        return;
      }
      Cls.autoRedrawImplemented = true;
      const oldSetOptions = Cls.prototype.setOptions;
      // TODO: optimize to only attach after onMount
      Cls.prototype.setOptions = function setOptions(options) {
        oldSetOptions.call(this, options);
        let listenerTargetSet = autoRedrawListenersLazy.get(this, listenersDefault);
        const objArray = Object.values(options || {}).filter(obj => {
          return obj instanceof StoreObject && !listenerTargetSet.has(obj);
        });

        // TODO: we don't remove listeners here, just results in some extra redraws when reassigning options

        // Add the new extra ones, and attach the lister if mounted
        for (let obj of objArray) {
          // Technically we could just add these listeners, but this would also leave us with listeners on temp ui elements
          // TODO: probably need to remove at cleanup
          if (this.node) {
            this.attachChangeListener(obj, redrawHandlerLazy.get(this));
          }
          listenerTargetSet.add(obj);
        }
      };

      // TODO @Mihai this should be a listener with @mounted
      const oldOnMount = Cls.prototype.onMount;
      Cls.prototype.onMount = function onMount() {
        oldOnMount.call(this);
        const listenerTargetSet = autoRedrawListenersLazy.get(this, listenersDefault);
        for (const obj of listenerTargetSet) {
          const redrawHandler = redrawHandlerLazy.get(this);
          this.attachChangeListener(obj, redrawHandler);
        }
      };
      return Cls;
    }

    // Can be called decorated as @autoredraw or @autoredraw(Watch1, Watch2, ...)
    function autoredraw(...args) {
      if (args[0]?.prototype instanceof BaseUIElement) {
        return autoredrawDecorator(args[0]);
      } else {
        return Cls => autoredrawDecorator(Cls, ...args);
      }
    }

    var _class$1p, _class2$J;
    let CompilationStatusPanel = autoredraw(_class$1p = class CompilationStatusPanel extends Panel {
      render() {
        const {
          customRun
        } = this.options;
        if (!customRun) {
          return null;
        }
        const compilationMessage = customRun.compilerMessage ? UI$1.createElement("pre", {
          className: "compilerOutputMessage"
        }, customRun.compilerMessage) : null;
        return [UI$1.createElement("strong", {
          style: {
            padding: "5px",
            lineHeight: "2em"
          }
        }, customRun.getCompilationStatusMessage()), compilationMessage];
      }
      setCustomRun(customRun) {
        this.updateOptions({
          customRun
        });
      }
    }) || _class$1p;
    let ExecutionStatusPanel = autoredraw(_class2$J = class ExecutionStatusPanel extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(GlobalStyle.FlexContainer.HORIZONTAL);
        attr.setStyle({
          paddingLeft: "5px",
          paddingRight: "5px"
        });
      }
      render() {
        const {
          customRun
        } = this.options;
        if (!customRun) {
          return null;
        }
        let content = [UI$1.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI$1.createElement(CardPanel, {
          title: UI$1.T("CPU Time"),
          level: customRun.results.internalStatus === RunStatusCodes.TIME_LIMIT_EXCEEDED ? Level.DANGER : Level.PRIMARY,
          bodyCentered: true
        }, UI$1.createElement("div", {
          style: {
            padding: 8
          }
        }, Formatter.cpuTime(customRun.results.cpuTime)))), UI$1.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI$1.createElement(CardPanel, {
          title: UI$1.T("Memory Usage"),
          level: parseInt(customRun.results.signalCode) === 9 ? Level.DANGER : Level.PRIMARY,
          bodyCentered: true
        }, UI$1.createElement("div", {
          style: {
            padding: "8px"
          }
        }, Formatter.memory(customRun.results.memUsage)))), UI$1.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI$1.createElement(CardPanel, {
          title: UI$1.T("Exit Code"),
          level: parseInt(customRun.results.exitCode || 0) !== 0 ? Level.DANGER : Level.PRIMARY,
          bodyCentered: true
        }, UI$1.createElement("div", {
          style: {
            padding: 8
          }
        }, customRun.results.exitCode || "-")))];
        if (customRun.results.signalCode) {
          const signalDescriptor = getSignalDescriptor(customRun.results.signalCode);
          let signalElement = signalDescriptor.shortName;
          if (signalDescriptor.longName) {
            signalElement = signalDescriptor.longName + " (" + signalElement + ")";
          }
          if (signalDescriptor.description) {
            signalElement = [signalElement, UI$1.createElement("div", null, signalDescriptor.description)];
          }
          content.push(UI$1.createElement("div", {
            style: {
              marginTop: "30px"
            }
          }, UI$1.createElement(CardPanel, {
            title: UI$1.T("Runtime error"),
            level: Level.DANGER,
            bodyCentered: true
          }, UI$1.createElement("div", {
            style: {
              padding: "8px"
            }
          }, signalElement))));
        }
        return content;
      }
      setCustomRun(customRun) {
        this.updateOptions({
          customRun
        });
      }
    }) || _class2$J;

    class UserReactionCollection extends StoreObject {
      getUserReactionStore() {
        return this.getStore().getState().getStore("UserReaction");
      }

      // TODO should be done as generator? Clearly needs to have indexed data!
      getReactions() {
        let reactions = [];
        for (let reaction of this.getUserReactionStore().all()) {
          if (reaction.collectionId == this.id) {
            reactions.push(reaction);
          }
        }
        return reactions;
      }
      getCurrentUserReaction() {
        let currentUser = window.USER;
        for (const userReaction of this.getReactions()) {
          if (userReaction.userId == currentUser.id) {
            return userReaction;
          }
        }
        return null;
      }
      getCurrentUserReactionType() {
        const currentUserReaction = this.getCurrentUserReaction();
        return currentUserReaction && currentUserReaction.type;
      }
    }
    class UserReaction extends StoreObject {}
    let UserReactionCollectionStore = new GenericObjectStore("UserReactionCollection", UserReactionCollection);
    new GenericObjectStore("UserReaction", UserReaction);

    class MessageInstance extends VirtualStoreObjectMixin(StoreObject) {
      constructor(obj, event) {
        super(obj, event);
        PublicUserStore.create(event.user);
      }
      getNormalizedId() {
        // TODO: Pretty bad implementation, works though
        let messageId = this.id + "";
        if (messageId.startsWith("temp-")) {
          messageId = messageId.substr(5);
        }
        return parseInt(messageId);
      }
      getDate() {
        return this.timeAdded;
      }
      getUser() {
        let user = PublicUserStore.get(this.userId);
        if (user) {
          return user.username;
        }
        return "user-" + this.userId;
      }
      getContent() {
        return this.content;
      }
      getMessageThread() {
        return MessageThreadStore.get(this.messageThreadId);
      }
      getReactionCollection(fakeIfMissing = false) {
        let reactionCollection = UserReactionCollectionStore.get(this.reactionCollectionId);
        if (fakeIfMissing && !reactionCollection) {
          return {
            upvotesCount: 0,
            downvotesCount: 0,
            getCurrentUserReactionType() {}
          };
        }
        return reactionCollection;
      }
      getNumLikes() {
        return this.getReactionCollection(true).upvotesCount;
      }
      getNumDislikes() {
        return this.getReactionCollection(true).downvotesCount;
      }
      getVotesBalance() {
        return this.getNumLikes() - this.getNumDislikes();
      }
      getUserVote() {
        return this.getReactionCollection(true).getCurrentUserReactionType();
      }
      getPreviousMessage() {
        // TODO: this should be cached and kept by the message thread
        let ans = null;
        let currentId = this.getNormalizedId();
        // If message has temporary id, then it is identical with the previous message id, so instead the
        // previous previous message would be found instead.
        if (this.hasTemporaryId()) {
          currentId += 1;
        }
        for (let message of this.getMessageThread().getMessages()) {
          if (message.id < currentId && (!ans || ans.id < message.id)) {
            ans = message;
          }
        }
        return ans;
      }
      getNextMessage() {
        throw "Implement me!";
      }
      hasMarkupEnabled() {
        return this.getMessageThread().hasMarkupEnabled();
      }
      getTimeOfDay() {
        return StemDate.unix(this.timeAdded).format("HH:mm");
      }
      edit(content, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/chat/edit_message/", {
          messageId: this.id,
          message: content
        }).then(onSuccess, onError);
      }
      react(reaction, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/chat/edit_message/", {
          messageId: this.id,
          reaction: reaction
        }).then(onSuccess, onError);
      }
      like(onSuccess, onError) {
        this.react("like", onSuccess, onError);
      }
      dislike(onSuccess, onError) {
        this.react("dislike", onSuccess, onError);
      }
      resetReaction(onSuccess, onError) {
        this.react("resetReaction", onSuccess, onError);
      }
      deleteMessage(onSuccess, onError) {
        Ajax.postJSON("/chat/edit_message/", {
          messageId: this.id,
          hidden: true
        }).then(onSuccess, onError);
      }
      applyEvent(event) {
        if (event.type === "messageEdit") {
          Object.assign(this, event.data);
          this.dispatch("edit", event);
        } else if (event.type === "reaction") {
          Object.assign(this, event.data);
          this.dispatch("reaction", event);
        } else if (event.type === "messageDelete") {
          this.dispatch("delete", event);
          this.getMessageThread().deleteMessageInstance(this);
        } else {
          super.applyEvent(event);
        }
      }
      updateId(newId) {
        if (this.id == newId) {
          return;
        }
        let oldId = this.id;
        super.updateId(newId);
        let messageThread = this.getMessageThread();
        messageThread.messages.delete(oldId);
        messageThread.messages.set(this.id, this);
      }
      setPostError(postError) {
        this.postError = postError;
        this.dispatch("postError", postError);
        console.log("Post error: ", postError);
      }
    }
    class MessageThread extends StoreObject {
      constructor(obj) {
        super(obj);
        this.messages = new Map();
        // TODO: don't change the global here, you fool!
        if (!this.streamName.startsWith("messagethread-privatechat-") && !this.streamName.startsWith("temp-")) {
          GlobalState$1.registerStream(this.streamName);
        }
        this.online = new Set(this.online || []);
        this.online.delete(0);
      }
      hasMarkupEnabled() {
        return this.markupEnabled || false;
      }
      addMessageInstance(messageInstance, event) {
        this.messages.set(messageInstance.id, messageInstance);
        this.dispatch("newMessage", event);
      }
      deleteMessageInstance(messageInstance) {
        this.messages.delete(messageInstance.id);
      }
      applyEvent(event) {
        if (event.data.online) {
          this.online = event.data.online = new Set(event.data.online);
          this.online.delete(0);
        }
        if (event.type === "online") {
          this.dispatch("usersChanged", event);
        } else if (event.type === "onlineDeltaJoined") {
          if (event.data.userId != 0) {
            this.online.add(event.data.userId);
          }
          this.dispatch("usersChanged", event);
        } else if (event.type === "onlineDeltaLeft") {
          if (event.data.userId != 0) {
            this.online.delete(event.data.userId);
          }
          this.dispatch("usersChanged", event);
        } else {
          super.applyEvent(event);
        }
      }
      getMessages(orderDescending = false) {
        // TODO: should be also as iterable
        let messages = Array.from(this.messages.values());
        if (orderDescending) {
          return messages.sort((a, b) => {
            return b.id - a.id;
          });
        }
        return messages.sort((a, b) => {
          return a.id - b.id;
        });
      }
      getNumMessages() {
        return this.messages.size;
      }
      getMaxMessageId() {
        let value = 0;
        for (let messageInstance of this.messages.values()) {
          if (!messageInstance.hasTemporaryId() && messageInstance.id > value) {
            value = messageInstance.id;
          }
        }
        return value;
      }

      // This method will return the last message of the message thread,
      // regardless of whether it is virtual or real.
      getLastMessage() {
        let lastMessage = null;
        for (let messageInstance of this.messages.values()) {
          if (!lastMessage || lastMessage.getNormalizedId() < messageInstance.getNormalizedId() || lastMessage.getNormalizedId() === messageInstance.getNormalizedId() && messageInstance.hasTemporaryId()) {
            lastMessage = messageInstance;
          }
        }
        return lastMessage;
      }
    }
    class MessageInstanceStoreClass extends VirtualStoreMixin(GenericObjectStore) {
      constructor() {
        super("MessageInstance", MessageInstance, {
          dependencies: ["messagethread", "publicuser"]
        });
      }
      createVirtualMessageInstance(messageContent, messageThread, temporaryId) {
        let virtualMessageInstance = {
          content: messageContent,
          temporaryId: temporaryId,
          id: "temp-" + temporaryId,
          timeAdded: ServerTime.now().toUnix(),
          userId: parseInt(USER.id),
          messageThreadId: messageThread.id,
          meta: {}
        };
        return this.create(virtualMessageInstance, {
          isVirtual: true
        });
      }
    }
    const MessageInstanceStore = new MessageInstanceStoreClass();
    MessageInstanceStore.addCreateListener((messageInstance, createEvent) => {
      messageInstance.getMessageThread().addMessageInstance(messageInstance, createEvent);
    });
    const MessageThreadStore = new GenericObjectStore("messagethread", MessageThread);
    class BaseChatObject extends StoreObject {
      getMessageThread() {
        return MessageThreadStore.get(this.messageThreadId);
      }
      getOnlineUserIds() {
        return this.getMessageThread().online;
      }
    }
    class GroupChat extends BaseChatObject {}
    const GroupChatStoreClass = AjaxFetchMixin(GenericObjectStore);
    const GroupChatStore = new GroupChatStoreClass("groupChat", GroupChat, {
      fetchURL: "/chat/group_chat_state/",
      maxFetchObjectCount: 1
    });
    GroupChatStore.getFetchRequestData = function (ids, fetchJobs) {
      return {
        chatId: ids[0]
      };
    };
    class PrivateChat extends BaseChatObject {
      getOtherUserId() {
        return USER.id === this.user1Id ? this.user2Id : this.user1Id;
      }
    }
    const PrivateChatStore = new GenericObjectStore("PrivateChat", PrivateChat, {});
    PrivateChatStore.getChatWithUser = function (userId) {
      let myUserId = USER.id;
      if (myUserId === userId) {
        for (let privateChat of this.all()) {
          if (privateChat.user1Id === userId && privateChat.user2Id === userId) {
            return privateChat;
          }
        }
        return null;
      }
      for (const privateChat of this.all()) {
        if (privateChat.user1Id === userId || privateChat.user2Id === userId) {
          return privateChat;
        }
      }
    };
    PrivateChatStore.fetchForUser = function (userId, onSuccess, onError) {
      Ajax.postJSON("/chat/private_chat_state/", {
        userId: userId
      }).then(data => onSuccess(PrivateChatStore.get(data.privateChatId)), onError);
    };
    PrivateChatStore.addChangeListener((obj, event) => {
      if (event.type === "privateMessage") {
        GlobalState$1.importState(event.state);
      }
    });

    class Article extends StoreObject {
      constructor(obj) {
        super(obj);
        this.edits = new Map();
      }
      canBeEditedByUser(user = USER) {
        return user.isSuperUser || this.userCreatedId == user.id;
      }
      addEdit(articleEdit) {
        this.edits.set(articleEdit.id, articleEdit);
      }
      getEdits() {
        return Array.from(this.edits.values());
      }
      getTranslation(language = Language.Locale) {
        for (let article of ArticleStore.all()) {
          if (article.baseArticleId === this.id && article.languageId === language.id) {
            return article;
          }
        }
        return this;
      }
      getBaseArticle() {
        return ArticleStore.get(this.baseArticleId) || this;
      }
    }
    class ArticleEdit extends StoreObject {
      getArticle() {
        return ArticleStore.get(this.articleId);
      }
    }
    class ArticleStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      getTranslation(id, language = Language.Locale) {
        let baseArticle = this.get(id);
        if (baseArticle) {
          baseArticle = baseArticle.getTranslation(language);
        }
        return baseArticle;
      }
    }
    var ArticleStore = new ArticleStoreClass("article", Article, {
      fetchURL: "/fetch_article/",
      maxFetchObjectCount: 32
    });
    var ArticleEditStore = new GenericObjectStore("articleedit", ArticleEdit, {
      dependencies: ["article"]
    });
    ArticleEditStore.addCreateListener(articleEdit => {
      let article = articleEdit.getArticle();
      article.addEdit(articleEdit);
    });

    class UserGroup extends StoreObject {
      constructor(...args) {
        super(...args);
        this.members = new Map();
        this.membersByUserId = new Map();
      }
      addMember(groupMember) {
        this.members.set(groupMember.id, groupMember);
        this.membersByUserId.set(groupMember.userId, groupMember);
      }
      getMember(groupMemberId) {
        return this.members.get(groupMemberId);
      }
      getMemberById(groupMemberId) {
        return this.getMember(groupMemberId);
      }
      getMemberByUserId(userId) {
        return this.membersByUserId.get(userId);
      }
      removeMemberByUserId(userId) {
        const member = this.getMemberByUserId(userId);
        if (member) {
          this.members.delete(member.id);
          this.membersByUserId.delete(member.userId);
          UserGroupMemberStore.applyDeleteEvent({
            objectId: member.id
          });
        }
      }
      getMembers() {
        return [...this.members.values()];
      }
    }
    class UserGroupStoreClass extends GenericObjectStore {
      constructor() {
        super("UserGroup", UserGroup);
      }
      getByName(name) {
        return this.all().find(group => group.name === name);
      }
    }
    const UserGroupStore = new UserGroupStoreClass();
    class UserGroupMember extends StoreObject {
      constructor(...args) {
        super(...args);
        this.getGroup().addMember(this);
      }
      delete() {
        this.getGroup().removeMemberByUserId(this.userId);
      }
      getGroup() {
        return UserGroupStore.get(this.groupId);
      }
      getPublicUser() {
        return PublicUserStore.get(this.userId);
      }
    }
    const UserGroupMemberStore = new GenericObjectStore("UserGroupMember", UserGroupMember, {
      dependencies: ["UserGroup"]
    });

    function compareTotalScoreAndPenalty(a, b) {
      if (a.totalScore === b.totalScore) {
        return (a.penalty || 1e12) - (b.penalty || 1e12); // TODO was Infinity
      }
      return (b.totalScore || -1) - (a.totalScore || -1);
    }
    function compareContestUsers(a, b) {
      if (a.haveSubmitted() !== b.haveSubmitted()) {
        return b.numSubmissions - a.numSubmissions;
      } else {
        return compareTotalScoreAndPenalty(a, b);
      }
    }

    // Calculate the score across a meta-contest composed of multiple contests
    function compareMetaContestUsers(a, b) {
      if (a.metaScore === b.metaScore) {
        return compareContestUsers(a, b);
      }
      return b.metaScore - a.metaScore;
    }

    class Contest extends StoreObject {
      constructor(obj) {
        super(obj);
        this.contestTasks = new Map();
        this.contestUsers = new Map();
        this.addListener("contestUserUpdate", () => this.enqueueRecalculateUserRanks());
      }
      getScoring() {
        return ContestScoringStore.get(this.scoringId);
      }
      addPermission(userId, permissionName, callback) {
        return Ajax.postJSON("/contest/change_permission/", {
          contestId: this.id,
          userId: userId,
          permissionName: permissionName,
          action: "give"
        }).then(callback);
      }
      removePermission(userId, permissionName, callback) {
        return Ajax.postJSON("/contest/change_permission/", {
          contestId: this.id,
          userId: userId,
          permissionName: permissionName,
          action: "remove"
        }).then(() => {
          this.getPermissionGroup(permissionName).removeMemberByUserId(userId);
          callback();
        });
      }
      getPermissionGroup(permName) {
        return UserGroupStore.getByName("contest-" + this.id + "-perm-" + permName);
      }
      getUserPermission(userId, permName) {
        return !!this.getPermissionGroup(permName).getMemberByUserId(userId);
      }
      canReceiveQuestions() {
        return !this.systemGenerated && this.hasStarted() && !this.isInfinite();
      }
      getAnnouncements() {
        return this.getStore("ContestAnnouncement").all().filter(announcement => announcement.contestId === this.id).sort((a, b) => b.id - a.id);
      }
      getQuestions() {
        return this.getStore("ContestQuestion").all().filter(question => question.contestId === this.id).sort((a, b) => b.id - a.id);
      }
      getFullURL() {
        // TODO: should be a setting, if the contest url is top level or not
        const prefix = this.name.startsWith("ieeextreme") ? "/" : "/contest/";
        return prefix + this.name + "/";
      }
      addContestUser(contestUser) {
        this.contestUsers.set(contestUser.id, contestUser);
      }
      addContestTask(contestTask) {
        if (this.contestTasks.has(contestTask.id)) {
          return false;
        }
        this.contestTasks.set(contestTask.id, contestTask);
        this.dispatch("addTask", contestTask);
        return true;
      }
      getContestTaskById(contestTaskId) {
        return this.contestTasks.get(contestTaskId);
      }
      hasAnyTask() {
        return this.getContestTasks().length > 0;
      }
      enqueueRecalculateUserRanks() {
        // TODO: should add a setTimeout(0, if none is scheduled
        this.recalculateUsers();
      }
      applyEvent(event) {
        if (event.data.hasOwnProperty("questions")) {
          for (let questionId in event.data.questions) {
            this.questions[questionId] = event.data.questions[questionId];
          }
          event.data.questions;
          delete event.data.questions;
        }
        super.applyEvent(event);
        if (event.type === "contestTaskUpdate") {
          this.recalculateUsers();
        }
        if (event.numUsersOnline) {
          this.numUsersOnline = event.numUsersOnline;
        }
      }
      isVirtual() {
        return !!this.baseContestId;
      }
      getBaseContest() {
        if (this.baseContestId) {
          return ContestStore.get(this.baseContestId);
        } else {
          return this;
        }
      }
      getVirtualContest() {
        if (this.virtualContestId) {
          return ContestStore.get(this.virtualContestId);
        } else {
          return this;
        }
      }
      getUser(userId) {
        for (let contestUser of this.contestUsers.values()) {
          if (contestUser.userId === userId) {
            return contestUser;
          }
        }
        return null;
      }
      getUsers() {
        return Array.from(this.contestUsers.values());
      }
      getNumUsers() {
        let numUsers = this.getBaseContest().numRegistered;
        // TODO: fix this to only count virtual users if showVirtualUsers=true
        if ((this.isVirtual() || this.virtualContestId) && this.getVirtualContest()) {
          //numUsers += !!this.getVirtualContest().getUser(USER.id);
          numUsers += this.getVirtualContest().numRegistered;
        }
        return numUsers;
      }

      // TODO: this should return a Date directly
      getStartTime(contestUser) {
        contestUser = contestUser || this.getUser(USER.id);
        if (!this.isVirtual() || !contestUser) {
          return this.startTime;
        }
        return parseInt(contestUser.timeRegistered) || this.startTime;
      }
      getEndTime(contestUser) {
        contestUser = contestUser || this.getUser(USER.id);
        if (!this.isVirtual() || !contestUser) {
          return this.endTime;
        }
        return parseInt(contestUser.timeRegistered + this.endTime - this.startTime) || this.endTime;
      }
      getName() {
        if (this.isVirtual()) {
          return "Virtual " + this.getBaseContest().longName;
        } else {
          return this.longName;
        }
      }

      // A bit inefficient, cache later
      getRelatedContests() {
        if (this.parentId) {
          return ContestStore.filterBy({
            parentId: this.parentId
          }).filter(contest => contest !== this);
        }
        return [];
      }

      // TODO: maybe tighten up the duplicated code
      static calculateMetaRanks(users) {
        for (let i = 0; i < users.length; i += 1) {
          users[i].recalculateMetaScore();
        }
        users.sort(compareMetaContestUsers);
        for (let i = 0; i < users.length; i += 1) {
          if (i > 0 && compareMetaContestUsers(users[i], users[i - 1]) === 0) {
            users[i].metaRank = users[i - 1].metaRank;
          } else {
            users[i].metaRank = i + 1;
          }
        }
      }
      static calculateRanks(users) {
        for (let i = 0; i < users.length; i += 1) {
          users[i].recalculateTotalScore();
        }
        users.sort(compareContestUsers);
        for (let i = 0; i < users.length; i += 1) {
          if (i > 0 && compareContestUsers(users[i], users[i - 1]) === 0) {
            users[i].rank = users[i - 1].rank;
          } else {
            users[i].rank = i + 1;
          }
        }
      }
      recalculateUsers() {
        if (this.recalculatingUserInProgress) {
          return;
        }
        this.recalculatingUserInProgress = true;
        setTimeout(() => {
          let users = this.getBaseContest().getUsers();
          if ((this.isVirtual() || this.virtualContestId) && this.getVirtualContest()) {
            users = [...users, ...this.getVirtualContest().getUsers()];
          }
          this.constructor.calculateRanks(users);
          if (this.getRelatedContests().length > 0) {
            this.constructor.calculateMetaRanks(users);
          }
          this.dispatch("rankingsChange");
          this.recalculatingUserInProgress = false;
        }, 500);
      }
      getChat() {
        return GroupChatStore.get(this.chatId);
      }
      getContestTasks() {
        let contestTasks = Array.from(this.contestTasks.values());
        contestTasks.sort((a, b) => {
          if (a.contestIndex === b.contestIndex) {
            return a.id - b.id;
          }
          if (a.contestIndex === 0) {
            a.contestIndex = Infinity;
          }
          if (b.contestIndex === 0) {
            b.contestIndex = Infinity;
          }
          return a.contestIndex - b.contestIndex;
        });
        return contestTasks;
      }
      getAnalysisArticle() {
        return ArticleStore.getTranslation(this.analysisArticleId);
      }
      getDescriptionArticle() {
        if (!this.descriptionArticleId) {
          return null;
        }
        return ArticleStore.get(this.descriptionArticleId);
      }
      getMatchingContestTask(contestTask) {
        if (contestTask.contestId === this.id) {
          return contestTask;
        }
        for (let myContestTask of this.getContestTasks()) {
          if (myContestTask.evalTaskId === contestTask.evalTaskId) {
            return myContestTask;
          }
        }
        return null;
      }
      hasPenalty() {
        return this.getScoring().hasPenalty;
      }
      hasDynamicPoints() {
        return this.getScoring().hasDynamicPoints;
      }
      hasStarted() {
        return !this.getStartTime() || ServerTime.now().unix() > this.getStartTime();
      }
      hasFinished() {
        return this.getEndTime() && ServerTime.now().unix() > this.getEndTime();
      }
      isRunning() {
        return this.hasStarted() && !this.hasFinished();
      }
      isInfinite() {
        return !this.getEndTime();
      }
      canShowScoreboard() {
        return USER.isSuperUser || this.liveResults || this.hasFinished();
      }
      canShowPublicSources() {
        return this.publicSources && (this.hasFinished() || this.isInfinite());
      }
      getFormattedTime(time, format = "dddd, MMMM Do, H:mm") {
        let timeFormat = time.format(format);
        let utcTimeFormat;
        if (time.getDate() === time.utc().getDate()) {
          utcTimeFormat = time.utc().format("H:mm");
        } else {
          utcTimeFormat = time.utc().format(format);
        }
        return timeFormat + " local time (" + utcTimeFormat + " UTC)";
      }
      getFormattedStartTime(format = "dddd, MMMM Do, H:mm:ss") {
        let startTime = StemDate.unix(this.getStartTime());
        return this.getFormattedTime(startTime, format);
      }
      getFormattedEndTime(format = "dddd, MMMM Do, H:mm:ss") {
        let endTime = StemDate.unix(this.getEndTime());
        return this.getFormattedTime(endTime, format);
      }
      getFormattedDuration() {
        let startTime = new StemDate(this.getStartTime());
        let duration = new StemDate(this.getEndTime()).diff(startTime);
        let durationFormat = Formatter.duration(duration, {
          days: true,
          hours: true,
          minutes: true,
          separator: ", ",
          lastSeparator: " and "
        });
        return durationFormat;
      }
      toString() {
        return this.longName;
      }
      getCountries() {
        let countryIds = new Set();
        for (let contestUser of this.getUsers()) {
          let user = contestUser.getPublicUser();
          if (user && user.countryId && !countryIds.has(user.countryId)) {
            countryIds.add(user.countryId);
          }
        }
        return CountryStore.getCountriesFromIds(countryIds);
      }
      getStatistics() {
        const fields = ["numUsersOnline", "numSubmissions", "numExampleRuns", "numCompiles", "numCustomRuns"];
        let stats = {};
        for (const field of fields) {
          if (this.hasOwnProperty(field)) {
            stats[field] = this[field].toString();
          }
        }
        return stats;
      }
      getNextTaskTimestamp() {
        if (!this.nextBroadcastTask) {
          return null;
        }
        return new StemDate(this.nextBroadcastTask).unix();
      }
      getExtraSummary() {
        return this.extraSummary || {};
      }
      getLogoURL() {
        return this.getExtraSummary().logoURL;
      }
      getSubpages() {
        return this.getExtraSummary().subpages || [];
      }
    }
    Contest.scoreboardType = {
      TASK_NAME: 0,
      TASK_LETTER: 1,
      TOTAL_SCORE_ONLY: 2
    };
    Contest.ModeratedAction = {
      VIEW: "view",
      EDIT_TASKS: "edit-tasks",
      EDIT_SETTINGS: "edit-settings",
      ANSWER_QUESTIONS: "answer-question",
      BROADCAST_ANNOUNCEMENTS: "broadcast-announcement"
    };
    Contest.VerboseModeratedAction = {
      VIEW: "View",
      EDIT_TASKS: "Edit tasks",
      EDIT_SETTINGS: "Edit settings",
      ANSWER_QUESTIONS: "Answer questions",
      BROADCAST_ANNOUNCEMENTS: "Broadcast announcements"
    };
    const ContestStore = new GenericObjectStore("contest", Contest);
    class ContestEvent extends StoreObject {}
    const ContestEventStore = new GenericObjectStore("contestevent", ContestEvent, {
      dependencies: ["contest", "contestuser"]
    });

    class FieldDescriptor {
      constructor(type, options) {
        this.type = type;
        Object.assign(this, options);
      }
      setTarget(targetProto, key, rawDescriptor) {
        if (!targetProto.fieldDescriptors) {
          targetProto.fieldDescriptors = [];
        }
        targetProto.fieldDescriptors.push(this);
        this.targetProto = targetProto;
        this.key = key;
        this.rawDescriptor = rawDescriptor;
      }

      // TODO Use this to support lazy initialization
      getDefaultValue(obj) {
        const {
          initializer
        } = this.rawDescriptor;
        return initializer?.call(obj);
      }
      makeDescriptor() {
        // TODO "self" should mean type = this.targetProto
        if (isString(this.type)) {
          // We're a Foreign key
          this.rawField = this.rawField || (key => key + "Id"); // By default we'll add a suffix
          this.cacheField = false;
          const storeName = this.type === "self" ? null : this.type;
          this.loader = (value, obj) => {
            // TODO Instead of calling GlobalState, the object should implement .getState()
            const store = obj.getStore ? obj.getStore(storeName) : GlobalState$1.getStore(storeName);
            return store.get(value);
          };
        }

        // First let the type modify this, in case it needs to overwrite some behavior
        if (!this.loader && this.type.makeFieldLoader) {
          this.loader = this.type.makeFieldLoader(this);
          // We actually prefer by default to have a cache to that object[field] === object[field] (which would have been invalidated by another load)
          this.cacheField = this.cacheField ?? Symbol("cached-" + this.key);
        }

        // Apply default logic in case it was not explicitly given
        if (isFunction(this.rawField)) {
          this.rawField = this.rawField(this.key, this);
        }
        if (!this.rawField) {
          this.rawField = Symbol("_" + this.key);
        } else {
          this.isReadOnly = true;
        }

        // Extracting for speed in the functions bellow
        const {
          rawField,
          cacheField,
          loader,
          isReadOnly,
          key
        } = this;
        return {
          get() {
            if (cacheField && this[cacheField]) {
              return this[cacheField];
            }
            const value = this[rawField];
            if (value == null || !loader) {
              return value;
            }
            const result = loader(value, this);
            if (cacheField) {
              this[cacheField] = result;
            }
            return result;
          },
          set(value) {
            if (isReadOnly) {
              throw `Not allowed to change field ${key}`;
            }
            // TODO type validation
            // if (!(value instanceof type)) {
            //     console.warn("Invalid type detected", key, value);
            // }
            this[rawField] = value;
            if (cacheField) {
              delete this[cacheField];
            }
          }
        };
      }
    }

    // TODO Implement a way to say @field(Array, "StoreObject") for instance
    function field(type, arg = {}) {
      // The actual descriptor
      return (targetProto, name, rawDescriptor) => {
        const fieldDescriptor = new FieldDescriptor(type, arg);
        fieldDescriptor.setTarget(targetProto, name, rawDescriptor);
        return fieldDescriptor.makeDescriptor();
      };
    }

    // Default handling of objects
    Date.makeFieldLoader = () => {
      return value => StemDate.optionally(value);
    };

    var _dec$W, _class$1o, _descriptor$H;
    let EvalTask = (_dec$W = field("Contest"), (_class$1o = class EvalTask extends StoreObject {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "defaultContest", _descriptor$H, this);
      }
      toString() {
        return this.longName;
      }
      canBeEditedByUser(user = USER) {
        return user.isSuperUser || this.ownerId === user.id;
      }
      getEditUrl() {
        return `/task/${this.urlName}/edit/`;
      }
      getStatementArticle() {
        return ArticleStore.get(this.statementArticleId);
      }
      getTimeLimit(languageId = 1) {
        const programmingLanguage = ProgrammingLanguage.get(languageId);
        let extraTime = programmingLanguage.extraTime || 0;
        let timeRatio = programmingLanguage.timeRatio || 1.0;
        const ownLimits = this.programmingLanguageLimits[languageId];
        if (ownLimits) {
          extraTime = ownLimits.extraTime || extraTime;
          timeRatio = ownLimits.timeRatio || timeRatio;
        }
        return this.timeLimit * timeRatio + extraTime;
      }
      getMemoryLimit(languageId = 1) {
        const programmingLanguage = ProgrammingLanguage.get(languageId);
        let extraMemory = programmingLanguage.extraMemory || 0;
        const ownLimits = this.programmingLanguageLimits[languageId];
        if (ownLimits) {
          extraMemory = ownLimits.extraMemory || extraMemory;
        }
        return this.memoryLimit + extraMemory;
      }
      getSolutionArticle() {
        return ArticleStore.get(this.solutionArticleId);
      }
      getHiddenSolutionArticle() {
        return ArticleStore.get(this.hiddenSolutionArticleId);
      }
      getWorkspace(userId = USER.id) {
        const EvalTaskUserSummaryStore = this.getStore("EvalTaskUserSummary");
        const evalTaskUserSummary = EvalTaskUserSummaryStore.findBy({
          evalTaskId: this.id,
          userId
        });
        return evalTaskUserSummary?.getWorkspace();
      }
      getType() {
        return this.type;
      }
      isInteractive() {
        return this.getType() === 1;
      }
      getTemplate(language) {
        if (this.enforcedTemplates && this.enforcedTemplates[language.id]) {
          let template = "";
          for (let block of this.enforcedTemplates[language.id]) {
            template += block.lines.join("\n") + "\n";
          }
          return template;
        }
        return null;
      }
      getAvailableLanguages() {
        if (!this.hasEnforcedTemplates()) {
          return ProgrammingLanguage.all();
        }
        let languages = [];
        for (let language of ProgrammingLanguage.all()) {
          if (this.enforcedTemplates[language.id] && this.enforcedTemplates[language.id].length > 0) {
            languages.push(language);
          }
        }
        return languages;
      }
      hasEnforcedTemplates() {
        return !!this.enforcedTemplates;
      }
    }, (_descriptor$H = _applyDecoratedDescriptor(_class$1o.prototype, "defaultContest", [_dec$W], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    })), _class$1o));
    class EvalTaskStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      constructor() {
        super("evaltask", EvalTask, {
          dependencies: ["article"],
          maxFetchObjectCount: 32,
          fetchURL: "/eval/fetch_eval_task/"
        });
      }
      applyEvent(event) {
        if (this.get(event.objectId)) {
          super.applyEvent(event);
        }
      }
    }
    const EvalTaskStore = new EvalTaskStoreClass();

    class EvalTaskStatistics extends StoreObject {
      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }
    }
    class EvalTaskStatisticsStoreClass extends GenericObjectStore {
      constructor() {
        super("EvalTaskStatistics", EvalTaskStatistics, {
          dependencies: ["evaltask"]
        });
        this.evalTaskMap = new Map();
        this.addCreateListener(evalTaskStatistics => {
          this.evalTaskMap.set(evalTaskStatistics.evalTaskId, evalTaskStatistics);
        });
      }
      getByEvalTaskId(evalTaskId) {
        return this.evalTaskMap.get(evalTaskId);
      }
    }
    const EvalTaskStatisticsStore = new EvalTaskStatisticsStoreClass();

    class ContestTask extends StoreObject {
      constructor(obj) {
        super(obj);
        if (this.getContest()) {
          this.getContest().addContestTask(this);
        } else {
          console.warn("Contest task with id =", this.id, "does not have a contest.");
        }
      }
      getFullURL() {
        // TODO: should have URLHelper.join(paths)
        return this.getContest().getFullURL() + "task/" + this.name + "/";
      }
      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }
      hasStateLoaded() {
        return this.getContest() && this.getEvalTask() && this.getStatementArticle();
      }
      getDifficulty() {
        if (this.hasOwnProperty("difficulty")) {
          return this.difficulty;
        }
        let statistics = EvalTaskStatisticsStore.getByEvalTaskId(this.evalTaskId);
        if (statistics) {
          return statistics.difficulty;
        }
        return 0;
      }
      getOriginalContest() {
        return ContestStore.get(this.originalContestId);
      }
      getStatementArticle() {
        if (this.statementArticleId) {
          return ArticleStore.get(this.statementArticleId);
        }
        return this.getEvalTask().getStatementArticle();
      }
      getContest() {
        return ContestStore.get(this.contestId);
      }
      getTimeAvailable() {
        let time = new StemDate(this.getContest().getStartTime());
        if (this.broadcastDelay) {
          time.addUnit(TimeUnit.SECOND, this.broadcastDelay);
        }
        return time;
      }
      getBroadcastDelay() {
        if (this.broadcastDelay) {
          // broadcast delay is in seconds, and the argument needs to be passed in milliseconds.
          return new Duration(this.broadcastDelay * 1000);
        } else {
          return new Duration(0);
        }
      }
      getBaseTask() {
        let contest = this.getContest().getBaseContest();
        return contest.getMatchingContestTask(this);
      }
      getVirtualTask() {
        let contest = this.getContest();
        if (contest.isVirtual()) {
          return this;
        }
        for (let contestTask of contest.getVirtualContest().getContestTasks()) {
          if (contestTask.evalTaskId === this.evalTaskId) {
            return contestTask;
          }
        }
        return null;
      }
      applyEvent(event) {
        super.applyEvent(event);
        let contest = this.getContest();
        if (contest) {
          contest.applyEvent({
            type: "contestTaskUpdate",
            contestTaskId: this.id,
            contestTaskEvent: event,
            data: {}
          });
        }
      }
      hasPartialScore() {
        return this.getContest() && this.getContest().getScoring().hasPartialScoring;
      }
      hasPenalty() {
        return this.getContest() && this.getContest().hasPenalty();
      }
      hasScore() {
        return this.hasOwnProperty("pointsWorth") && this.pointsWorth != 1;
      }
      toString() {
        return this.longName;
      }
      canShowStatistics() {
        return this.getContest() && this.getContest().canShowPublicSources();
      }
    }
    ContestTask.ScoreType = {
      ACM: 0,
      // to AC or not AC
      PARTIAL: 1,
      // tests or groups of tests
      OPTIMIZATION: 2,
      // % out of best score, for optimizing NP-complete tasks for instance
      SPECIAL_JUDGE: 3
    };
    class ContestTaskStoreClass extends GenericObjectStore {
      constructor() {
        super("contesttask", ContestTask, {
          dependencies: ["contest"]
        });
      }
      getByEvalTaskId(evalTaskId) {
        return this.all().find(contestTask => contestTask.evalTaskId === evalTaskId);
      }
      getByContestIdAndUrlName(contestId, urlName) {
        // TODO: Keep a map here
        return this.all().find(contestTask => contestTask.name === urlName && contestTask.contestId === contestId);
      }
    }
    const ContestTaskStore = new ContestTaskStoreClass();

    class PrivateArchiveUser {
      constructor(userId, contestUsers) {
        this.userId = userId;
        this.contestUsers = contestUsers;
      }
      getContestUser(contestTask) {
        for (let contestUser of this.contestUsers) {
          if (contestUser.getContest() === contestTask.getEvalTask().defaultContest) {
            return contestUser;
          }
        }
        return null;
      }
    }
    class PrivateArchive extends StoreObject {
      getName() {
        return this.longName;
      }
      getEvalTasks() {
        let evalTasks = [];
        for (let evalTaskId of this.evalTaskIds) {
          let evalTask = EvalTaskStore.get(evalTaskId);
          if (evalTask) {
            evalTasks.push(evalTask);
          }
        }
        return evalTasks;
      }
      getContestTasks() {
        let contestTasks = [];
        let evalTasks = this.getEvalTasks();
        for (let evalTask of evalTasks) {
          let contestTask = ContestTaskStore.get(evalTask.defaultContestTaskId);
          if (contestTask) {
            contestTasks.push(contestTask);
          }
        }
        return contestTasks;
      }
      getContests() {
        let contests = [];
        let evalTasks = this.getEvalTasks();
        for (let evalTask of evalTasks) {
          contests.push(evalTask.defaultContest);
        }
        return contests;
      }
      getUsers() {
        let contestUsers = new Map();
        let contests = this.getContests();
        for (let contest of contests) {
          for (let contestUser of contest.getUsers()) {
            if (!contestUsers.has(contestUser.userId)) {
              contestUsers.set(contestUser.userId, []);
            }
            contestUsers.get(contestUser.userId).push(contestUser);
          }
        }
        let privateArchiveUsers = [];
        for (let [userId, contestUser] of contestUsers.entries()) {
          privateArchiveUsers.push(new PrivateArchiveUser(userId, contestUser));
        }
        return privateArchiveUsers;
      }
      toString() {
        return this.longName;
      }
    }
    const PrivateArchiveStore = new GenericObjectStore("PrivateArchive", PrivateArchive);

    // The FileSaver class is mean to be able to create a Save as... file dialog from text/bytes
    // TODO: this file is work in progress
    let autoBom = function (blob) {
      // Add the unicode boom if not present
      if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(UNICODE_BOM_CHARACTER), blob], {
          type: blob.type
        });
      }
      return blob;
    };
    class FileSaver extends Dispatchable {
      constructor(blob, fileName, options = {}) {
        super();
        this.blob = blob;
        this.fileName = fileName;
        this.options = options;
        if (this.options.autoBom) {
          this.blob = autoBom(this.blob);
        }

        // TODO: these should be static
        this.saveLink = document.createElement("a");
        let canUseSaveLink = ("download" in this.saveLink);
        let is_safari = /constructor/i.test(window.HTMLElement) || window.safari;
        let is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent);
        let force = blob.type === "application/octet-stream";
        let objectUrl;
        this.readyState = FileSaver.INIT;
        if (canUseSaveLink) {
          objectUrl = window.URL.createObjectURL(blob);
          setTimeout(() => {
            this.saveLink.href = objectUrl;
            this.saveLink.download = this.fileName;
            this.click();
            this.revoke(objectUrl);
            this.readyState = FileSaver.DONE;
          }, 0);
          return;
        }
        if ((is_chrome_ios || force && is_safari) && window.FileReader) {
          // Safari doesn't allow downloading of blob urls
          let reader = new FileReader();
          reader.onloadend = () => {
            let url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
            let popup = window.open(url, '_blank');
            if (!popup) {
              window.location.href = url;
            }
            url = void 0; // release reference before dispatching
            this.readyState = FileSaver.DONE;
          };
          reader.readAsDataURL(blob);
          this.readyState = FileSaver.INIT;
          return;
        }
        if (!objectUrl) {
          objectUrl = window.URL.createObjectURL(blob);
        }
        if (force) {
          window.location.href = objectUrl;
        } else {
          let opened = window.open(objectUrl, "_blank");
          if (!opened) {
            // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
            window.location.href = objectUrl;
          }
        }
        this.readyState = FileSaver.DONE;
        this.revoke(objectUrl);
      }
      static saveAs(blob, fileName, blobOptions = {
        type: "text/plain;charset=utf-8"
      }) {
        if (!(blob instanceof Blob)) {
          let value = blob;
          if (!Array.isArray(value)) {
            value = [value];
          }
          blob = new Blob(value, blobOptions);
        }
        let fileSaver = new FileSaver(blob, fileName);
        return fileSaver;
      }
      click() {
        let clickEvent = new MouseEvent("click");
        this.saveLink.dispatchEvent(clickEvent);
      }
      revoke(file) {
        setTimeout(() => {
          if (typeof file === "string") {
            window.URL.revokeObjectURL(file);
          } else {
            file.remove();
          }
        }, 1000 * 40);
      }
    }
    FileSaver.readyState = FileSaver.INIT = 0;
    FileSaver.WRITING = 1;
    FileSaver.DONE = 2;
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
      FileSaver.saveAs = function (blob, name, no_auto_bom) {
        name = name || blob.name || "download";
        if (!no_auto_bom) {
          blob = autoBom(blob);
        }
        return navigator.msSaveOrOpenBlob(blob, name);
      };
    }

    class EvalJob extends BaseUserSubmission {
      constructor(obj) {
        super(obj);
        this.tests = [];
        this.exampleTests = [];
        this.loadTests(obj);
      }
      applyEvent(event) {
        if (event.type === "test_results") {
          this.loadTests(event.data);
        } else {
          super.applyEvent(event);
          if (event.type === "started") {
            this.exampleTests = [];
            this.tests = [];
          } else {
            this.reloadTests();
          }
        }
      }
      updateTests(exampleTests, tests) {
        const addTestToArray = (test, array) => {
          const existingTest = array.find(existingTest => existingTest.id === test.id);
          if (!existingTest) {
            array.push(test);
          } else {
            array[array.indexOf(existingTest)] = test;
          }
        };
        for (let test of tests) {
          addTestToArray(test, this.tests);
        }
        for (let exampleTest of exampleTests) {
          addTestToArray(exampleTest, this.exampleTests);
        }
      }
      loadTests(obj) {
        let tests = [];
        let exampleTests = [];
        for (let testId of Object.keys(obj.tests)) {
          let test = obj.tests[testId];
          if (this.getExampleTest(test.id)) {
            exampleTests.push(test);
          } else {
            tests.push(test);
          }
        }
        this.updateTests(exampleTests, tests);
      }
      reloadTests() {
        this.tests = this.tests.concat(this.exampleTests || []);
        let tests = this.tests.filter(test => !this.getExampleTest(test.id));
        let exampleTests = this.tests.filter(test => !!this.getExampleTest(test.id));
        this.exampleTests = [];
        this.tests = [];
        this.updateTests(exampleTests, tests);
      }
      getExampleTests() {
        return Array.from(this.exampleTests);
      }
      getAllTests(testGroup) {
        let tests = this.exampleTests.concat(this.tests);
        if (testGroup) {
          const testIndexSet = new Set(testGroup.testIndexes);
          tests = tests.filter(testCase => testIndexSet.has(testCase.testIndex));
        }
        return tests;
      }
      getContestTask() {
        return ContestTaskStore.get(this.contestTaskId);
      }
      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }
      hasPartialScoring() {
        let contestTask = this.getContestTask();
        return contestTask && contestTask.hasPartialScore();
      }
      getLastTest() {
        if (this.tests.length > 0) {
          return this.tests[this.tests.length - 1];
        }
        if (this.exampleTests.length > 0) {
          return this.exampleTests[this.exampleTests.length - 1];
        }
        return null;
      }
      getStatus() {
        if (!this.compileStarted && !this.compileOK && (!this.tests || !this.tests.length)) {
          return EvalJob.Status.WAITING;
        }
        if (!this.hasOwnProperty("compileOK")) {
          return EvalJob.Status.COMPILING;
        }
        if (!this.isDone) {
          return EvalJob.Status.RUNNING;
        }
        return EvalJob.Status.DONE;
      }
      getResultStatus() {
        if (this.getStatus() !== EvalJob.Status.DONE) {
          return EvalJob.ResultStatus.UNKNOWN;
        }
        if (this.hasCompileError()) {
          return EvalJob.ResultStatus.COMPILE_ERROR;
        }
        if (this.hasInternalJudgeError()) {
          return EvalJob.ResultStatus.INTERNAL_JUDGE_ERROR;
        }
        let lastTest = this.getLastTest();
        if (!lastTest) {
          return EvalJob.ResultStatus.UNKNOWN;
        }
        if (lastTest.internalStatus === RunStatusCodes.TIME_LIMIT_EXCEEDED) {
          return EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED;
        }
        if (lastTest.internalStatus === RunStatusCodes.RUNTIME_ERROR) {
          return EvalJob.ResultStatus.RUNTIME_ERROR;
        }
        if (lastTest.internalStatus === RunStatusCodes.MEMORY_LIMIT_EXCEEDED) {
          if (parseInt(lastTest.signalCode) === 9) {
            return EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED;
          }
          return EvalJob.ResultStatus.KILLED_BY_SIGNAL;
        }
        return EvalJob.ResultStatus.ACCEPTED;
      }
      getNumTestsPassed() {
        let testsPassed = 0;
        for (const test of this.tests.concat(this.exampleTests)) {
          if (test.checkerPassed) {
            testsPassed += 1;
          }
        }
        return testsPassed;
      }
      hasInternalJudgeError() {
        const lastTest = this.getLastTest();
        return lastTest && lastTest.internalStatus === RunStatusCodes.INTERNAL_ERROR;
      }
      getExampleTest(testId) {
        let evalTask = this.getEvalTask();
        if (!evalTask) {
          return null;
        }
        for (let exampleTest of evalTask.exampleTests || []) {
          if (exampleTest.id === parseInt(testId)) {
            return exampleTest;
          }
        }
        return null;
      }
    }
    EvalJob.Status = {
      WAITING: 1,
      COMPILING: 2,
      RUNNING: 3,
      DONE: 4
    };
    EvalJob.ResultStatus = {
      COMPILE_ERROR: 1,
      INTERNAL_JUDGE_ERROR: 2,
      TIME_LIMIT_EXCEEDED: 3,
      MEMORY_LIMIT_EXCEEDED: 4,
      RUNTIME_ERROR: 5,
      KILLED_BY_SIGNAL: 6,
      WRONG_ANSWER: 7,
      PASSED: 8,
      // Both of these are the same
      ACCEPTED: 8,
      // It depends on ContestTask type
      UNKNOWN: 9
    };
    class EvalJobStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      constructor() {
        super("evaljob", EvalJob, {
          fetchURL: "/eval/get_eval_jobs/",
          maxFetchObjectCount: 64,
          dependencies: ["evaltask", "publicuser"]
        });
      }
      applyEvent(event) {
        if (event.type === "reevalDone") {
          return this.dispatch("reevalDone", event);
        }
        return super.applyEvent(event);
      }
      getFetchRequestData(ids, fetchJobs) {
        let requestData = super.getFetchRequestData(ids, fetchJobs);
        let contestRequests = [];
        for (const fetchJob of fetchJobs) {
          if (fetchJob.requestContest) {
            contestRequests.push(fetchJob.id);
          }
        }
        if (contestRequests.length > 0) {
          requestData.contestRequests = contestRequests;
        }
        return requestData;
      }
      fetchWithContest(id, successCallback, errorCallback, forceFetch = false) {
        this.fetch(id, successCallback, errorCallback, forceFetch);
        let fetchJob = this.fetchJobs[this.fetchJobs.length - 1];
        fetchJob.requestContest = true;
      }
    }
    const EvalJobStore = new EvalJobStoreClass();

    let UserHandle$1 = class UserHandle extends UI$1.Element {
      setOptions(options) {
        options.userId = options.userId || options.id;
        super.setOptions(options);
        this.setUser(PublicUserStore.get(this.options.userId));
      }
      setUser(user) {
        this.user = user;
      }
      getNodeType() {
        return "span";
      }
      getRatingColor() {
        const defaultColor = window.USER_HANDLE_COLOR || "#468";
        if (!this.user) {
          return defaultColor;
        }
        if (this.user.isAdmin) {
          return "black";
        }
        if (!this.user.rating) {
          return defaultColor;
        }
        const ratingBands = window.RATING_BANDS || [];
        for (let ratingBand of ratingBands) {
          if (ratingBand.minRating <= this.user.rating && this.user.rating < ratingBand.maxRating) {
            return ratingBand.color;
          }
        }
        return defaultColor;
      }
      setColor(color) {
        this.options.color = color;
        this.handle.setStyle("color", color);
      }
      render() {
        let handle, countryEmoji;
        if (!this.user) {
          PublicUserStore.fetch(this.options.userId, user => {
            this.setUser(user);
            this.redraw();
          });
          handle = UI$1.createElement("span", {
            ref: "handle",
            style: {
              color: "#BBB"
            },
            onClick: () => null
          }, "user-" + this.options.userId);
        } else {
          let clickFunc = null;
          if (!this.options.hasOwnProperty("disableClick")) {
            clickFunc = () => {
              this.togglePopup();
              window.event.stopPropagation();
              window.event.preventDefault();
            };
          }
          if (this.options.showCountry && this.user.countryId) {
            countryEmoji = UI$1.createElement(Emoji, {
              style: {
                paddingRight: "2px"
              },
              width: "1.6em",
              height: "1.6em",
              value: this.user.getCountry().getEmojiName(),
              title: this.user.getCountry().name
            });
          }
          handle = UI$1.createElement("span", {
            ref: "handle",
            style: {
              cursor: "pointer",
              color: this.options.color ? this.options.color : this.getRatingColor()
            },
            onClick: clickFunc
          }, UI$1.createElement("b", null, this.user.getDisplayHandle()));
        }

        //The purpose of the container is to simplify the usage of the popup.
        return [UI$1.createElement("span", {
          ref: "container",
          style: {
            position: "relative"
          }
        }, countryEmoji, handle, this.options.children)];
      }
      getPopupTitle() {
        let profileLink = UI$1.createElement(Link, {
          href: this.user.getProfileUrl(),
          value: this.user.name || this.user.username || "user-" + this.user.id
        });
        if (USER.isSuperUser) {
          return UI$1.createElement("span", {
            style: {
              position: "relative"
            }
          }, profileLink, UI$1.createElement("br", null), UI$1.createElement("span", null, "id: " + this.user.id));
        } else {
          return profileLink;
        }
      }
      getPopupContent() {
        let rez = [];
        if (this.user.rating) {
          rez.push(UI$1.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, "Rating: " + this.user.rating));
          rez.push(UI$1.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, UI$1.createElement(Link, {
            href: "/ratings",
            value: "Rank: " + this.user.globalRatingRank
          })));
        } else {
          rez.push(UI$1.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, "Rating: N/A"));
        }
        if (this.user.countryId) {
          let country = CountryStore.get(this.user.countryId);
          let emojiName = country.getEmojiName();
          rez.push(UI$1.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, "Country: ", country.name, UI$1.createElement(Emoji, {
            style: {
              paddingLeft: "3px"
            },
            title: country.name,
            value: emojiName,
            height: "1.6em",
            width: "1.6em"
          })));
        }
        //if (USER.isSuperUser) {
        //    rez.push(<p><ReputationWidget reputation={this.user.reputation}/></p>);
        //}
        return rez;
      }
      togglePopup() {
        if (this.options.noPopup) {
          window.open(this.user.getProfileUrl(), "_blank");
          return;
        }
        if (this.popup && this.popup.isInDocument()) {
          this.popup.hide();
          return;
        }
        this.popup = Popup.create(this.container, Object.assign({
          target: this.handle,
          title: this.getPopupTitle(),
          children: this.getPopupContent(),
          transitionTime: 300,
          titleFontSize: "10pt",
          style: {
            minWidth: "150px",
            maxWidth: "270px"
          }
        }));
      }
    };

    var _class$1n;
    class SubmissionPointsLabel extends UI$1.TextElement {
      getContestTask() {
        return this.options.contestTask;
      }
      getValue() {
        const score = this.options.score;
        const contestTask = this.getContestTask();
        const pointsWorth = contestTask && contestTask.pointsWorth || 1;
        let value = Formatter.truncate(score * pointsWorth, 2) + " points";
        if (pointsWorth != 100) {
          value += " (" + Formatter.truncate(score * 100) + "%)";
        }
        return value;
      }
      onMount() {
        if (this.options.contestTask) {
          this.attachChangeListener(this.options.contestTask, () => this.redraw());
        }
      }
    }

    // TODO: this whole class shouldn't exist, but just be a set of functions
    class EvalJobUIHandler {
      constructor(evalJob) {
        this.evalJob = evalJob;
      }
      getSummary() {
        const {
          evalJob
        } = this;
        let cpuTime = 0,
          memoryUsage = 0;
        for (const test of evalJob.tests) {
          cpuTime = Math.max(cpuTime, test.cpuTime || 0);
          memoryUsage = Math.max(memoryUsage, test.memUsage);
        }
        const comment = this.getComment();
        return UI$1.createElement("div", null, UI$1.createElement("p", null, UI$1.T("User:"), " ", this.getUserHandle()), UI$1.createElement("p", null, UI$1.T("Verdict:"), " ", this.getStatus()), UI$1.createElement("p", null, UI$1.T(""), " "), UI$1.createElement("p", null, UI$1.T("Language:"), " ", evalJob.getProgrammingLanguage().name), UI$1.createElement("p", null, UI$1.T("CPU Time usage:"), " ", Formatter.cpuTime(cpuTime)), UI$1.createElement("p", null, UI$1.T("Memory usage:"), " ", Formatter.memory(memoryUsage), " "), UI$1.createElement("p", null, UI$1.T("Source code:"), " ", Formatter.memory(evalJob.sourceText.length), " "), comment && UI$1.createElement("p", null, UI$1.T("Comment:"), " ", comment));
      }
      getJobId() {
        return "Job #" + this.evalJob.id;
      }
      getJobIdWithExternalLink() {
        return ["Job ", UI$1.createElement("span", {
          onClick: () => {
            window.event.stopPropagation();
          }
        }, UI$1.createElement(Link, {
          href: "/submission/" + this.evalJob.id,
          newTab: true,
          value: ["#" + this.evalJob.id + " ", UI$1.createElement(FAIcon, {
            icon: "external-link"
          })]
        }), " ")];
      }
      getTimeSubmitted() {
        let timeSubmitted = new StemDate();
        if (this.evalJob.timeSubmitted) {
          timeSubmitted = StemDate.unix(this.evalJob.timeSubmitted);
        }
        timeSubmitted = timeSubmitted.format("DD MMM YYYY HH:mm:ss");
        return timeSubmitted;
      }
      getUserHandle() {
        return UI$1.createElement(UserHandle$1, {
          userId: this.evalJob.userId
        });
      }
      getComment() {
        const {
          comment
        } = this.evalJob;
        return comment && UI$1.createElement(MarkupRenderer, {
          value: comment,
          style: {
            display: "inline-block"
          }
        });
      }
      getTask() {
        let contestTask = ContestTaskStore.getByEvalTaskId(this.evalJob.evalTaskId);
        if (contestTask) {
          return "Task " + contestTask.longName;
        }
        return "Task id #" + this.evalJob.evalTaskId;
      }
      getContest() {
        let contest = ContestStore.get(this.evalJob.contestId);
        if (contest) {
          return contest.longName;
        }
        return "Contest #" + this.evalJob.contestId;
      }
      getStatus() {
        const evalJob = this.evalJob;
        let statusLabel = "";
        let status = evalJob.getStatus();
        const statusMessage = new Map([[EvalJob.Status.WAITING, "Waiting"], [EvalJob.Status.COMPILING, "Compiling"], [EvalJob.Status.RUNNING, "Running"]]);
        if (status === EvalJob.Status.DONE) {
          // TODO: This is not the only partial scoring case
          let hasPartialScoring = evalJob.hasPartialScoring();
          if (evalJob.hasCompileError()) {
            statusLabel = "Compilation Error";
          } else if (evalJob.hasInternalJudgeError()) {
            statusLabel = "Internal Judge Error!";
          } else if (!evalJob.onlyExamples) {
            if (hasPartialScoring) {
              const score = evalJob.score;
              const contestTask = evalJob.getContestTask();
              return UI$1.createElement(SubmissionPointsLabel, {
                score: score,
                contestTask: contestTask,
                value: ""
              });
            } else if (evalJob.getNumTestsPassed() < evalJob.exampleTests.length) {
              statusLabel = "Passed " + evalJob.getNumTestsPassed() + "/" + evalJob.exampleTests.length + " examples";
            } else {
              let resultStatus = evalJob.getResultStatus();
              let lastTest = evalJob.getLastTest();
              let resultStatusMessage = new Map([[EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED, "Time Limit Exceeded"], [EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED, "Memory Limit Exceeded"], [EvalJob.ResultStatus.RUNTIME_ERROR, "Runtime Error"], [EvalJob.ResultStatus.KILLED_BY_SIGNAL, lastTest ? lastTest.message : ""], [EvalJob.ResultStatus.WRONG_ANSWER, lastTest ? lastTest.message : ""], [EvalJob.ResultStatus.ACCEPTED, "Accepted"], [EvalJob.ResultStatus.UNKNOWN, "Internal Judge Error!"]]);
              statusLabel = resultStatusMessage.get(resultStatus);
            }
          } else {
            statusLabel = evalJob.getNumTestsPassed() + "/" + evalJob.exampleTests.length;
          }
        } else {
          statusLabel = statusMessage.get(status);
        }
        return statusLabel;
      }
    }
    let EvalJobSummaryPanel = autoredraw(_class$1n = class EvalJobSummaryPanel extends UI$1.Element {
      getEvalJob() {
        return this.options.evalJob;
      }
      render() {
        const temp = new EvalJobUIHandler(this.getEvalJob());
        // TODO: move this from EvalJobUIHandler directly here
        return temp.getSummary();
      }
    }) || _class$1n;

    var _class$1m, _descriptor$G, _descriptor2$B, _descriptor3$u, _dec$V, _class2$I;
    let InteractiveExampleBubbleStyle = (_class$1m = class InteractiveExampleBubbleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$G, this);
        _initializerDefineProperty(this, "inputMessage", _descriptor2$B, this);
        _initializerDefineProperty(this, "outputMessage", _descriptor3$u, this);
      }
    }, (_descriptor$G = _applyDecoratedDescriptor(_class$1m.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor2$B = _applyDecoratedDescriptor(_class$1m.prototype, "inputMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "left",
          maxWidth: "45%",
          marginRight: "50%",
          minWidth: "20%"
        };
      }
    }), _descriptor3$u = _applyDecoratedDescriptor(_class$1m.prototype, "outputMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "right",
          maxWidth: "45%",
          marginLeft: "50%",
          minWidth: "20%"
        };
      }
    })), _class$1m);
    let InteractiveTaskLog = (_dec$V = registerStyle(InteractiveExampleBubbleStyle), _dec$V(_class2$I = class InteractiveTaskLog extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setAttribute("extra", this.options.extra);
        attr.setAttribute("align", this.options.align);
      }
      render() {
        const {
          extra
        } = this.options;
        return toArray(extra).map(message => UI$1.createElement("pre", {
          className: message.type == 1 ? this.styleSheet.inputMessage : this.styleSheet.outputMessage
        }, message.message.trim()));
      }
    }) || _class2$I);

    var _class$1l;
    class EvalTaskPublicTestRow extends CollapsibleTableRow {
      getEvalTask() {
        return this.options.evalJob.getEvalTask();
      }
      getTest() {
        // TODO: Should return TestCaseStore.get(this.options.entry.id)
        throw Error("Unimplemented. This method should be implemented by subclasses.");
      }
      getLoadButton() {
        throw Error("Unimplemented. This method should be implemented by subclasses.");
      }
      getColumns() {
        // TODO this is dumb that it's done here, and not in the table
        let columns = super.getColumns();
        const loadButton = this.getLoadButton();
        if (loadButton) {
          columns = [...columns, {
            value: () => loadButton
          }];
        }
        return columns;
      }
      renderFilePanel(title, content, key, panelStyle) {
        return UI$1.createElement(Panel, {
          key: key,
          style: panelStyle
        }, UI$1.createElement("div", {
          style: {
            height: 20,
            paddingLeft: 10,
            boxSizing: "border-box",
            backgroundColor: "white"
          }
        }, title), UI$1.createElement(StaticCodeHighlighter, {
          style: {
            width: "100%",
            height: 150
          },
          value: content
        }));
      }
      renderCollapsible() {
        let {
          entry
        } = this.options;
        let test = this.getTest();
        let panelStyle = {
          height: "170px",
          width: "49%",
          display: "inline-block"
        };
        if (!test) {
          return [UI$1.createElement("h3", null, "Test loading..."), UI$1.createElement("span", {
            className: "fa fa-spinner fa-spin"
          })];
        }
        let inputName = " Input " + Formatter.memory(test.inputSize);
        if (test.inputSize > test.input.length) {
          inputName = inputName + " (truncated to 1 MB)";
        }
        let outputName = " Judge output " + Formatter.memory(test.outputSize);
        if (test.outputSize > test.output.length) {
          outputName = outputName + " (truncated to 1 MB)";
        }
        let panels = [this.renderFilePanel(inputName, test.input, Math.random(), panelStyle), this.renderFilePanel(outputName, test.output, Math.random(), panelStyle)];
        if (entry.hasOwnProperty("stdout")) {
          // The key must be random, else the content of the ace editor is not updated correctly
          panels.push(this.renderFilePanel(" Your output", entry.stdout, Math.random(), panelStyle));
          panelStyle.width = "32%";
        }
        return UI$1.createElement(Panel, {
          className: "section" + entry.testNumber,
          key: entry.testNumber,
          orientation: Orientation$1.HORIZONTAL,
          style: {
            height: panelStyle.height,
            width: "100%",
            padding: "5px"
          }
        }, UI$1.createElement(SectionDivider, {
          style: {
            height: "100%"
          },
          orientation: Orientation$1.HORIZONTAL
        }, panels));
      }
    }
    class EvalTaskDownloadableTestRow extends EvalTaskPublicTestRow {
      getLoadButton() {
        if (this.getEvalTask().isPublic) {
          let onSuccess = test => {
            if (test.inputSize > test.input.length) {
              this.expand();
            } else {
              Dispatcher.Global.dispatch("loadWorkspaceInput", test.input);
            }
          };
          return UI$1.createElement(AjaxButton, {
            ref: "loadTestButton",
            level: Level.INFO,
            size: Size.SMALL,
            onClick: () => this.loadTest(this.options.entry.id, onSuccess),
            statusOptions: ["Load", {
              icon: "spinner fa-spin",
              label: ""
            }, "Load", "Failed"]
          });
        }
      }
      getTest() {
        return this.getEvalTask().systemTests[this.options.entry.id];
      }
      expand() {
        if (!this.getTest()) {
          this.loadTest(this.options.entry.id);
        }
        super.expand();
      }
      loadTest(testId, onSuccess) {
        let evalTask = this.getEvalTask();
        if (evalTask.systemTests[testId]) {
          if (onSuccess) {
            onSuccess(evalTask.systemTests[testId]);
          }
          return;
        }
        this.loadTestButton.getJSON("/eval/download_test/", {
          evalTaskId: evalTask.id,
          testId: testId
        }).then(data => {
          evalTask.systemTests[testId] = data;
          this.redraw();
          if (onSuccess) {
            onSuccess(data);
          }
        });
      }
    }
    class EvalTaskExampleRow extends EvalTaskPublicTestRow {
      getLoadButton() {
        return UI$1.createElement(Button$1, {
          ref: "loadTestButton",
          label: "Load",
          level: Level.INFO,
          size: Size.SMALL,
          onClick: () => Dispatcher.Global.dispatch("loadWorkspaceInput", this.getTest().input)
        });
      }
      getTest() {
        return this.options.evalJob.getExampleTest(this.options.entry.id);
      }
    }
    class InteractiveEvalTaskExampleRow extends CollapsibleTableRow {
      renderCollapsible() {
        const {
          entry
        } = this.options;
        let panelStyle = {
          height: 170,
          width: "49%",
          display: "inline-block"
        };
        let result = UI$1.createElement(InteractiveTaskLog, {
          extra: entry.extra
        });
        return UI$1.createElement(Panel, {
          className: "section" + entry.testNumber,
          key: entry.testNumber,
          orientation: Orientation$1.HORIZONTAL,
          style: {
            height: panelStyle.height,
            width: "100%",
            padding: "5px"
          }
        }, result);
      }
    }
    let EvalJobResultsTable = autoredraw(_class$1l = class EvalJobResultsTable extends CollapsibleTableInterface(SortableTable) {
      getRowClass(entry) {
        const {
          evalJob
        } = this.options;
        const evalTask = evalJob.getEvalTask();
        if (evalJob.getExampleTest(entry.id)) {
          if (evalTask.getType() === 0) {
            return EvalTaskExampleRow;
          } else {
            return InteractiveEvalTaskExampleRow;
          }
        }
        if (evalTask?.isPublic && evalTask.getType() === 0) {
          evalTask.systemTests = evalTask.systemTests || {};
          return EvalTaskDownloadableTestRow;
        }
        return TableRowInCollapsibleTable;
      }
      getRowOptions(entry, rowIndex) {
        return {
          ...super.getRowOptions(entry, rowIndex),
          evalJob: this.options.evalJob
        };
      }
      getEntries() {
        const {
          evalJob,
          testGroup
        } = this.options;
        if (!evalJob) {
          return [];
        }
        let entries = evalJob.getAllTests(testGroup);
        for (let i = 0; i < entries.length; i += 1) {
          entries[i].testNumber = i;
        }
        entries.reverse();
        return this.sortEntries(entries);
      }
      getDefaultColumns() {
        const numberStyle = {
          textAlign: "right"
        };
        return [{
          headerName: "Test Number",
          value: entry => entry.testNumber,
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          headerName: "CPU Usage",
          value: entry => Formatter.cpuTime(entry.cpuTime),
          rawValue: entry => entry.cpuTime || 0,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          headerName: "Memory Usage",
          value: entry => Formatter.memory(entry.memUsage),
          rawValue: entry => entry.memUsage || 0,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          headerName: "Result",
          value: entry => entry.message ?? "-",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }];
      }
    }) || _class$1l;

    var _class$1k;
    let SubmissionStatusPanel = autoredraw(_class$1k = class SubmissionStatusPanel extends Panel {
      constructor(...args) {
        super(...args);
        this.haveShown = new Set();
      }
      renderTestGroupingPanel(evalJob, testGroup, testGroupIndex) {
        const tests = evalJob.getAllTests(testGroup);
        const evalTask = evalJob.getEvalTask();
        if (!tests?.length) {
          return null;
        }
        const getTestGroupDescription = (testGroup, testGroupIndex) => {
          if (!testGroup) {
            return "All Tests";
          }
          const testsMoreToGo = testGroup.testIndexes.length - tests.length;
          const minTestScore = Math.min(...tests.map(test => test.checkerScore || 0));
          const pointsReceived = testGroup.pointsWorth * minTestScore;

          // Examples are worth 0 points, but we still care about the min score
          const status = minTestScore > 0 ? " Passed" : "Failed";
          const description = testsMoreToGo ? `${testsMoreToGo} tests pending` : `${status} ${pointsReceived} points`;
          return `Group #${testGroupIndex + 1} ${description}`;
        };
        const groupDescription = getTestGroupDescription(testGroup, testGroupIndex);
        return UI.createElement(CollapsiblePanel, {
          title: groupDescription
        }, UI.createElement("div", {
          style: {
            padding: 8
          }
        }, testGroup?.comment && UI.createElement("div", null, UI.createElement(MarkupRenderer, {
          classMap: evalTask.articleClassMap,
          value: testGroup.comment
        })), UI.createElement(EvalJobResultsTable, {
          evalJob: evalJob,
          testGroup: testGroup
        })));
      }
      renderEvalJobSummary() {
        const {
          evalJob
        } = this.options; // TODO This should be an option param, not internal state
        if (!evalJob) {
          return null;
        }
        const evalTask = evalJob.getEvalTask();
        if (evalTask?.testGrouping) {
          return [evalTask.testGrouping.map((testGroup, index) => this.renderTestGroupingPanel(evalJob, testGroup, index)), this.renderTestGroupingPanel(evalJob, null, null)];
        }
        return UI.createElement(EvalJobResultsTable, {
          evalJob: evalJob
        });
      }
      render() {
        return [this.options.evalJob?.getEvalTask() && UI.createElement(ProgressBar, _extends({
          ref: "resultsProgressBar"
        }, this.getRunProgress())), this.renderEvalJobSummary()];
      }
      setEvalJob(evalJob) {
        this.updateOptions({
          evalJob
        });
      }
      getRunProgress() {
        const {
          evalJob
        } = this.options;
        if (!evalJob) return {};
        const evalTask = evalJob.getEvalTask();
        const progress = {};
        const testResults = evalJob.getAllTests() || [];
        const status = evalJob.getStatus();
        let numTotalTests = evalTask.numSystemTests;
        if (evalTask.exampleTests) {
          numTotalTests += evalTask.exampleTests.length;
        }
        progress.value = testResults.length / numTotalTests;
        let worstCPU = 0;
        let worstMemory = 0;
        for (let i = 0; i < testResults.length; i += 1) {
          worstCPU = Math.max(worstCPU, testResults[i].cpuTime || 0);
          worstMemory = Math.max(worstMemory, testResults[i].memUsage || 0);
        }
        const labelInfo = "(" + Formatter.cpuTime(worstCPU) + " - " + Formatter.memory(worstMemory) + ")";
        if (status === EvalJob.Status.RUNNING) {
          progress.active = true;
          progress.striped = true;
          if (testResults.length > 0) {
            progress.label = "Successfully done " + testResults.length + " tests" + labelInfo;
          } else {
            progress.label = "Running";
          }
        } else {
          progress.value = 0;
          progress.active = false;
          progress.striped = false;
          progress.disableSmoothTransision = true;
        }
        if (status === EvalJob.Status.DONE) {
          let resultStatus = evalJob.getResultStatus();
          progress.value = 1;
          if (evalJob.hasCompileError()) {
            progress.level = Level.WARNING;
            progress.label = "Compilation Error";
          } else if (evalJob.hasInternalJudgeError()) {
            progress.level = Level.DANGER;
            progress.label = "Internal Judge Error!";
          } else {
            if (evalJob.hasPartialScoring()) {
              let score = evalJob.score;
              progress.label = "Score: " + Formatter.truncate(score * 100, 2) + "/100 " + labelInfo;
              if (score == 1) {
                progress.level = Level.SUCCESS;
              } else {
                progress.level = Level.WARNING;
              }
            } else {
              let lastTest = evalJob.getLastTest();
              let labelResult = new Map([[EvalJob.ResultStatus.ACCEPTED, "Accepted " + labelInfo], [EvalJob.ResultStatus.WRONG_ANSWER, lastTest.message + " on test " + lastTest.testNumber], [EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED, "Time Limit Exceeded"], [EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED, "Memory Limit Exceeded"], [EvalJob.ResultStatus.RUNTIME_ERROR, "Runtime Error"], [EvalJob.ResultStatus.KILLED_BY_SIGNAL, lastTest.message]]);
              progress.level = resultStatus === EvalJob.ResultStatus.ACCEPTED ? Level.SUCCESS : Level.DANGER;
              progress.label = labelResult.get(resultStatus);
            }
          }
        }
        return progress;
      }
      redraw(event) {
        super.redraw();
        if (event?.type === "test_results" && !this.haveShown.has(event.objectId)) {
          this.haveShown.add(event.objectId);
          this.dispatch("show");
        }
      }
      async onMount() {
        const {
          evalJob
        } = this.options;
        if (!evalJob) {
          return;
        }
        const contestTaskId = evalJob.contestTaskId;
        const evalTask = evalJob.getEvalTask();
        if (!ContestTaskStore.get(contestTaskId) || !evalTask) {
          await Ajax.postJSON("/contest/get_contest_task/", {
            contestTaskId,
            requestContestTask: true
          });
          this.redraw();
        }
      }
    }) || _class$1k;

    var _class$1j, _descriptor$F, _dec$U, _class2$H;
    class SubmissionModal extends Modal {
      hide() {
        super.hide();
        // Refocus the submission once the modal is hid, so that user will know what submission the modal came from.
        this.options.submissionSummary.node.focus();
      }
    }
    class EvalJobSourcePanel extends UI$1.Element {
      getEvalJob() {
        return this.options.evalJob;
      }
      render() {
        const {
          evalJob
        } = this.options;
        const buttonStyle = {
          margin: "0.3em"
        };
        let codeHighlighterOptions = {};
        const programmingLanguage = evalJob.getProgrammingLanguage();
        if (programmingLanguage) {
          codeHighlighterOptions.aceMode = programmingLanguage.aceMode;
        }
        return [UI$1.createElement("div", {
          key: "optionButtons",
          className: "row",
          style: {
            padding: "10px"
          }
        }, UI$1.createElement(Button$1, {
          ref: "downloadSourceButton",
          label: UI$1.T("Download Source"),
          level: Level.INFO,
          icon: "download",
          style: buttonStyle
        }), UI$1.createElement(Button$1, {
          ref: "loadInWorkspaceButton",
          label: UI$1.T("Load in Workspace"),
          level: Level.INFO,
          style: buttonStyle
        })), UI$1.createElement(StaticCodeHighlighter, _extends({
          ref: "sourceCodeHighlighter",
          value: evalJob.sourceText,
          maxLines: this.options.maxCodeLines || 32
        }, codeHighlighterOptions))];
      }
      onMount() {
        this.downloadSourceButton.addClickListener(() => {
          let fileContentBlob = new Blob([this.getEvalJob().sourceText], {
            type: "text/plain;charset=utf-8"
          });
          let programmingLanguage = this.getEvalJob().getProgrammingLanguage();
          let fileName = this.getEvalJob().id;
          if (programmingLanguage) {
            fileName += "." + programmingLanguage.getExtension();
          }
          FileSaver.saveAs(fileContentBlob, fileName);
        });
        this.loadInWorkspaceButton.addClickListener(() => {
          Dispatcher.Global.dispatch("loadEvalJobSource", {
            evalJob: this.getEvalJob()
          });
        });
      }
    }
    class SubmissionSummaryTabArea extends UI$1.Element {
      render() {
        const {
          evalJob
        } = this.options;
        let panelStyle = {
          padding: "1em"
        };
        this.options.style = {
          padding: "0px",
          margin: "0px"
        };
        return UI$1.createElement(FlatTabArea, null, UI$1.createElement(Panel, {
          ref: "sourceCodeTabPanel",
          title: UI$1.T("Source"),
          style: panelStyle
        }, UI$1.createElement(EvalJobSourcePanel, {
          evalJob: evalJob
        })), UI$1.createElement(Panel, {
          ref: "summaryTabPanel",
          title: UI$1.T("Summary"),
          style: panelStyle
        }, UI$1.createElement(EvalJobSummaryPanel, {
          evalJob: evalJob
        })), UI$1.createElement(Panel, {
          ref: "resultsTabPanel",
          title: UI$1.T("Results"),
          style: panelStyle
        }, UI$1.createElement(SubmissionStatusPanel, {
          evalJob: evalJob
        })), UI$1.createElement(Panel, {
          ref: "compilationTabPanel",
          title: UI$1.T("Compilation messages"),
          style: panelStyle
        }, UI$1.createElement(CompilationStatusPanel, {
          customRun: evalJob
        })));
      }
    }
    let SubmissionSummaryStyle = (_class$1j = class SubmissionSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "submissionSummary", _descriptor$F, this);
      }
    }, (_descriptor$F = _applyDecoratedDescriptor(_class$1j.prototype, "submissionSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "white",
          cursor: "pointer",
          margin: "10px 0",
          padding: "10px 15px",
          boxShadow: "0 1px 3px " + enhance(Theme.Global.properties.COLOR_BACKGROUND, 0.3),
          transition: "0.2s",
          ":hover": {
            boxShadow: "0 1px 5px " + enhance(Theme.Global.properties.COLOR_BACKGROUND, 0.5),
            transition: "0.2s"
          }
        };
      }
    })), _class$1j);
    let SubmissionSummary = (_dec$U = registerStyle(SubmissionSummaryStyle), autoredraw(_class2$H = _dec$U(_class2$H = class SubmissionSummary extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.submissionSummary);
        // Element needs a tab index so that focus works.
        attr.setAttribute("tabindex", "0");
      }
      getEvalJob() {
        return this.options.evalJob;
      }
      render() {
        const {
          hideTaskName,
          includeComment
        } = this.options;
        const evalJobUIHandler = new EvalJobUIHandler(this.getEvalJob());
        const comment = includeComment && evalJobUIHandler.getComment();
        return UI$1.createElement("div", null, [evalJobUIHandler.getJobIdWithExternalLink(), " ", evalJobUIHandler.getTimeSubmitted(), " ", evalJobUIHandler.getUserHandle(), " -- ", comment && [comment, " "], !hideTaskName && evalJobUIHandler.getTask(), " ", evalJobUIHandler.getContest(), " -- ", evalJobUIHandler.getStatus()]);
      }
      onMount() {
        this.addClickListener(() => {
          SubmissionModal.show({
            fillScreen: true,
            children: [UI$1.createElement(SubmissionSummaryTabArea, {
              evalJob: this.getEvalJob()
            })],
            submissionSummary: this
          });
        });
        this.attachChangeListener(this.getEvalJob(), () => {
          this.redraw();
        });
      }
    }) || _class2$H) || _class2$H);
    class SubmissionSummaryPanel extends Panel {
      constructor(options) {
        super(options);
        this.submissionSummaryMap = new Map();
      }
      setOptions(options) {
        super.setOptions(options);
        this.fetchEvalJobs();
      }
      editFilters(filters) {
        const newFilters = {
          ...this.options.filters,
          ...filters
        };
        this.updateOptions({
          filters: newFilters
        }); // Will also redraw filters
      }
      render() {
        let evalJobs = EvalJobStore.all().filter(evalJob => this.filterEvalJob(evalJob)).sort((a, b) => {
          return b.id - a.id;
        });
        this.options.children = evalJobs.map(evalJob => this.getSubmissionSummary(evalJob));
        return this.options.children;
      }
      getSubmissionSummary(evalJob) {
        return UI$1.createElement(SubmissionSummary, {
          evalJob: evalJob,
          key: evalJob.id
        });
      }
      onMount() {
        super.onMount();
        this.attachCreateListener(EvalJobStore, evalJob => {
          if (this.filterEvalJob(evalJob)) {
            let submissionSummary = this.getSubmissionSummary(evalJob);
            let numChildren = this.options.children.length;
            if (numChildren === 0) {
              this.appendChild(submissionSummary);
              return;
            }
            let maxId = this.options.children[0].options.evalJob.id;
            let minId = this.options.children[numChildren - 1].options.evalJob.id;
            if (evalJob.id > maxId) {
              this.insertChild(submissionSummary);
            } else if (evalJob.id < minId) {
              this.appendChild(submissionSummary);
            } else {
              let checkPosition = position => {
                if (position >= numChildren) {
                  return false;
                }
                let positionId = this.options.children[position].options.evalJob.id;
                return positionId > evalJob.id;
              };
              let position = -1;
              for (let bit = 1 << 20; bit > 0; bit >>= 1) {
                if (checkPosition(position + bit)) {
                  position += bit;
                }
              }
              position += 1;
              if (this.options.children[position].options.evalJob.id < evalJob.id) {
                this.insertChild(submissionSummary, position);
              }
            }
          }
        });
      }
      getFilters() {
        return this.options.filters;
      }
      filterEvalJob(evalJob) {
        let filters = Object.assign({
          examplesPassed: true,
          onlyExamples: false
        }, this.getFilters());
        if (filters.onlyWithComments && !evalJob.comment && !evalJob.expectedResult) {
          return false;
        }
        if (filters.startTime && evalJob.timeSubmitted < filters.startTime) {
          return false;
        }
        if (filters.endTime && evalJob.timeSubmitted > filters.endTime) {
          return false;
        }
        if (filters.status && evalJob.getStatus() !== filters.status) {
          return false;
        }
        if (filters.resultStatus && (evalJob.getStatus() !== EvalJob.Status.DONE || evalJob.getResultStatus() !== filters.resultStatus)) {
          return false;
        }
        const strictFilters = ["userId", "contestId", "contestTaskId", "evalTaskId", "score", "programmingLanguageId", "onlyExamples"];
        for (let filter of strictFilters) {
          if (filters.hasOwnProperty(filter) && evalJob[filter] !== filters[filter]) {
            return false;
          }
        }
        return true;
      }
      fetchEvalJobs(requestCount = false) {
        let request = this.getEvalJobRequest(requestCount);
        Ajax.getJSON("/eval/get_eval_jobs/", request).then(data => {
          if (data.jobCount) {
            EvalJobStore.jobCount = data.jobCount;
          }
        }, () => {});
      }
      getEvalJobRequest(requestCount, numJobs = 200) {
        let request = {
          numJobs: numJobs || 200,
          requestCount: requestCount
        };
        Object.assign(request, this.getFilters());
        return cleanObject(request);
      }
    }
    class SubmissionSummaryMarkup extends UI$1.Element {
      setOptions(options) {
        super.setOptions(options);
        this.options.evalJobId = this.options.evalJobId || this.options.id;
        this.options.evalJob = EvalJobStore.get(this.options.evalJobId);
      }
      render() {
        if (this.options.error) {
          return [UI$1.createElement("span", {
            className: "fa fa-warning"
          }), UI$1.createElement("strong", null, "Failed to open submission with id ", this.options.evalJobId)];
        }
        if (this.options.evalJob) {
          return [UI$1.createElement(SubmissionSummary, {
            evalJob: this.options.evalJob,
            maxCodeLines: 32
          })];
        } else {
          let onSuccess = evalJob => {
            this.options.evalJob = evalJob;
            if (!this.node) {
              this.createNode();
            }
            this.redraw();
          };
          let onError = error => {
            this.options.error = error || "Error";
            this.redraw();
          };

          // TODO: handle failure to fetch
          EvalJobStore.fetch(this.options.evalJobId, onSuccess, onError);
          return [];
        }
      }
    }
    function GetProgrammingLanguageOptions(noSelectedOptionName = "") {
      return [{
        toString: () => noSelectedOptionName
      }, ...ProgrammingLanguage.all()];
    }
    function GetStatusOptions() {
      return [{
        toString: () => ""
      }, {
        value: EvalJob.Status.WAITING,
        toString: () => "Waiting"
      }, {
        value: EvalJob.Status.COMPILING,
        toString: () => "Compiling"
      }, {
        value: EvalJob.Status.RUNNING,
        toString: () => "Running"
      }, {
        value: EvalJob.Status.DONE,
        toString: () => "Done"
      }];
    }
    function GetResultStatusOptions() {
      return [{
        toString: () => ""
      }, {
        value: EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED,
        toString: () => "Time Limit Exceeded"
      }, {
        value: EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED,
        toString: () => "Memory Limit Exceeded"
      }, {
        value: EvalJob.ResultStatus.RUNTIME_ERROR,
        toString: () => "Runtime Error"
      }, {
        value: EvalJob.ResultStatus.KILLED_BY_SIGNAL,
        toString: () => "Killed by signal"
      }, {
        value: EvalJob.ResultStatus.WRONG_ANSWER,
        toString: () => "Wrong answer"
      }, {
        value: EvalJob.ResultStatus.ACCEPTED,
        toString: () => "Accepted"
      }, {
        value: EvalJob.ResultStatus.UNKNOWN,
        toString: () => "Internal Judge Error!"
      }];
    }
    class SubmissionSummaryGlobalFilter extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(GlobalStyle.SMALL);
        attr.setStyle({
          width: 900,
          maxWidth: "calc(100% - 30px)",
          margin: "0 auto",
          padding: 15
        });
      }
      render() {
        let statusOptions = GetStatusOptions();
        let resultStatusOptions = GetResultStatusOptions();
        let programmingLanguageOptions = GetProgrammingLanguageOptions();
        return [UI$1.createElement("h2", null, "Filter jobs"), UI$1.createElement("div", null, UI$1.createElement(FormField, {
          label: "After:",
          inline: true
        }, UI$1.createElement(DateTimePicker, {
          ref: "startTimePicker"
        })), UI$1.createElement(FormField, {
          label: "Before:",
          inline: true
        }, UI$1.createElement(DateTimePicker, {
          ref: "endTimePicker"
        })), UI$1.createElement(FormField, {
          label: "Status:",
          inline: true
        }, UI$1.createElement(Select, {
          options: statusOptions,
          ref: "statusSelect"
        })), UI$1.createElement(FormField, {
          label: "Result status:",
          inline: true
        }, UI$1.createElement(Select, {
          options: resultStatusOptions,
          ref: "resultStatusSelect"
        })), UI$1.createElement(FormField, {
          label: "User id:",
          inline: true
        }, UI$1.createElement(NumberInput, {
          ref: "userIdInput"
        })), UI$1.createElement(FormField, {
          label: "Language:"
        }, UI$1.createElement(Select, {
          options: programmingLanguageOptions,
          ref: "programmingLanguageSelect"
        })), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: UI$1.T("Set filter"),
          onClick: () => this.setFilters()
        })))), UI$1.createElement("br", null), UI$1.createElement(SubmissionSummaryPanel, {
          ref: "submissionSummaryPanel"
        })];
      }
      setFilters() {
        let filters = {};
        let startTime = this.startTimePicker.getDate();
        if (startTime) {
          if (!startTime.isValid()) {
            alert("Invalid time");
            return;
          }
          filters.startTime = startTime.unix();
        }
        let endTime = this.endTimePicker.getDate();
        if (endTime) {
          if (!endTime.isValid()) {
            alert("Invalid time");
            return;
          }
          filters.endTime = endTime.unix();
        }
        let status = this.statusSelect.get().value;
        if (status) {
          filters.status = status;
        }
        let resultStatus = this.resultStatusSelect.get().value;
        if (resultStatus) {
          filters.resultStatus = resultStatus;
        }
        let programmingLanguageId = this.programmingLanguageSelect.get().id;
        if (programmingLanguageId) {
          filters.programmingLanguageId = programmingLanguageId;
        }
        let userId = this.userIdInput.getValue();
        if (userId) {
          filters.userId = userId;
        }
        this.submissionSummaryPanel.updateOptions({
          filters
        });
      }
      onMount() {
        GlobalState$1.registerStream("evaljobs");
      }
    }
    class SubmissionSummaryContestFilter extends UI$1.Element {
      setOptions(options) {
        super.setOptions(options);
        this.contest = ContestStore.get(options.contestId);
      }
      render() {
        let filterView;
        if (this.contest.canShowPublicSources()) {
          let statusOptions = GetStatusOptions();
          let resultStatusOptions = GetResultStatusOptions();
          let programmingLanguageOptions = GetProgrammingLanguageOptions("All");
          let contestTaskSelect;
          if (!this.options.contestTaskId) {
            contestTaskSelect = UI$1.createElement(FormField, {
              label: "Contest task:"
            }, UI$1.createElement(Select, {
              options: [""].concat(this.contest.getContestTasks()),
              ref: "contestTaskSelect"
            }));
          }
          filterView = [UI$1.createElement(CollapsiblePanel, {
            ref: "filterView",
            title: UI$1.T("Filter jobs")
          }, UI$1.createElement("div", null, UI$1.createElement(FormField, {
            label: "After:"
          }, UI$1.createElement(DateTimePicker, {
            ref: "startTimePicker"
          })), UI$1.createElement(FormField, {
            label: "Before:"
          }, UI$1.createElement(DateTimePicker, {
            ref: "endTimePicker"
          })), contestTaskSelect, UI$1.createElement(FormField, {
            label: "Status:"
          }, UI$1.createElement(Select, {
            options: statusOptions,
            ref: "statusSelect"
          })), UI$1.createElement(FormField, {
            label: "Result status:"
          }, UI$1.createElement(Select, {
            options: resultStatusOptions,
            ref: "resultStatusSelect"
          })), UI$1.createElement(FormField, {
            label: "Language:"
          }, UI$1.createElement(Select, {
            options: programmingLanguageOptions,
            ref: "programmingLanguageSelect"
          })), UI$1.createElement(FormField, {
            label: "Show my submissions:"
          }, UI$1.createElement(RawCheckboxInput, {
            ref: "userOnlyCheckbox",
            style: {
              display: "inline-block",
              width: "initial"
            }
          })), UI$1.createElement(FormField, {
            label: " "
          }, UI$1.createElement("div", null, UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            label: UI$1.T("Set filter"),
            onClick: () => this.setFilters()
          })))))];
        }
        return [filterView, UI$1.createElement(SubmissionSummaryPanel, {
          ref: "submissionSummaryPanel",
          filters: this.getFilters()
        })];
      }
      getFilters() {
        let filters = {};
        if (!this.options.allContests) {
          filters.contestId = this.contest.id;
        }
        if (this.options.contestTaskId) {
          filters.contestTaskId = this.options.contestTaskId;
        } else if (this.filterView) {
          let contestTask = this.contestTaskSelect.get();
          if (contestTask) {
            if (!this.options.allContests) {
              filters.contestTaskId = contestTask.id;
            } else {
              filters.evalTaskId = contestTask.evalTaskId;
            }
          }
        } else {
          // by default we only show own sources
          filters.userId = USER.id;
        }
        if (!this.filterView) {
          return filters;
        }
        let startTime = this.startTimePicker.getDate();
        if (startTime) {
          if (!startTime.isValid()) {
            alert("Invalid time");
            return;
          }
          filters.startTime = startTime.unix();
        }
        let endTime = this.endTimePicker.getDate();
        if (endTime) {
          if (!endTime.isValid()) {
            alert("Invalid time");
            return;
          }
          filters.endTime = endTime.unix();
        }
        let status = this.statusSelect.get().value;
        if (status) {
          filters.status = status;
        }
        let resultStatus = this.resultStatusSelect.get().value;
        if (resultStatus) {
          filters.resultStatus = resultStatus;
        }
        let programmingLanguageId = this.programmingLanguageSelect.get().id;
        if (programmingLanguageId) {
          filters.programmingLanguageId = programmingLanguageId;
        }
        let userOnly = this.userOnlyCheckbox.getValue();
        if (userOnly) {
          filters.userId = USER.id;
        }
        return filters;
      }
      setFilters() {
        this.submissionSummaryPanel.updateOptions({
          filters: this.getFilters()
        });
      }
    }
    class SubmissionSummaryInterviewFilter extends SubmissionSummaryPanel {
      getFilters() {
        let filters = {};
        filters.contestId = this.options.contestTask.contestId;
        filters.contestTaskId = this.options.contestTask.id;
        if (!USER.isSuperUser) {
          filters.userId = USER.id;
        }
        return filters;
      }
    }
    class SubmissionSummaryPrivateArchiveFilter extends UI$1.Element {
      render() {
        return [UI$1.createElement(SubmissionSummaryPanel, {
          ref: "submissionSummaryPanel",
          filters: this.getFilters()
        })];
      }
      getFilters() {
        let filters = {};
        let privateArchive = PrivateArchiveStore.get(this.options.privateArchiveId);
        let contestTasks = privateArchive.getContestTasks();
        let contestTaskIds = [];
        for (let contestTask of contestTasks) {
          contestTaskIds.push(contestTask.id);
        }
        filters.contestTaskIdList = contestTaskIds;
        return filters;
      }
    }

    /**
     * Lexing or parsing positional information for error reporting.
     * This object is immutable.
     */class SourceLocation{// The + prefix indicates that these fields aren't writeable
    // Lexer holding the input string.
    // Start offset, zero-based inclusive.
    // End offset, zero-based exclusive.
    constructor(lexer,start,end){this.lexer=void 0;this.start=void 0;this.end=void 0;this.lexer=lexer;this.start=start;this.end=end;}/**
       * Merges two `SourceLocation`s from location providers, given they are
       * provided in order of appearance.
       * - Returns the first one's location if only the first is provided.
       * - Returns a merged range of the first and the last if both are provided
       *   and their lexers match.
       * - Otherwise, returns null.
       */static range(first,second){if(!second){return first&&first.loc;}else if(!first||!first.loc||!second.loc||first.loc.lexer!==second.loc.lexer){return null;}else {return new SourceLocation(first.loc.lexer,first.loc.start,second.loc.end);}}}/**
     * Interface required to break circular dependency between Token, Lexer, and
     * ParseError.
     */ /**
     * The resulting token returned from `lex`.
     *
     * It consists of the token text plus some position information.
     * The position information is essentially a range in an input string,
     * but instead of referencing the bare input string, we refer to the lexer.
     * That way it is possible to attach extra metadata to the input string,
     * like for example a file name or similar.
     *
     * The position information is optional, so it is OK to construct synthetic
     * tokens if appropriate. Not providing available position information may
     * lead to degraded error reporting, though.
     */class Token{// don't expand the token
    // used in \noexpand
    constructor(text,// the text of this token
    loc){this.text=void 0;this.loc=void 0;this.noexpand=void 0;this.treatAsRelax=void 0;this.text=text;this.loc=loc;}/**
       * Given a pair of tokens (this and endToken), compute a `Token` encompassing
       * the whole input range enclosed by these two.
       */range(endToken,// last token of the range, inclusive
    text)// the text of the newly constructed token
    {return new Token(text,SourceLocation.range(this,endToken));}}/**
     * This is the ParseError class, which is the main error thrown by KaTeX
     * functions when something has gone wrong. This is used to distinguish internal
     * errors from errors in the expression that the user provided.
     *
     * If possible, a caller should provide a Token or ParseNode with information
     * about where in the source string the problem occurred.
     */class ParseError{// Error position based on passed-in Token or ParseNode.
    constructor(message,// The error message
    token)// An object providing position information
    {this.position=void 0;let error="KaTeX parse error: "+message;let start;const loc=token&&token.loc;if(loc&&loc.start<=loc.end){// If we have the input and a position, make the error a bit fancier
    // Get the input
    const input=loc.lexer.input;// Prepend some information
    start=loc.start;const end=loc.end;if(start===input.length){error+=" at end of input: ";}else {error+=" at position "+(start+1)+": ";}// Underline token in question using combining underscores
    const underlined=input.slice(start,end).replace(/[^]/g,"$&\u0332");// Extract some context from the input and add it to the error
    let left;if(start>15){left=""+input.slice(start-15,start);}else {left=input.slice(0,start);}let right;if(end+15<input.length){right=input.slice(end,end+15)+"";}else {right=input.slice(end);}error+=left+underlined+right;}// Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    const self=new Error(error);self.name="ParseError";// $FlowFixMe
    self.__proto__=ParseError.prototype;// $FlowFixMe
    self.position=start;return self;}}// $FlowFixMe More hackery
    ParseError.prototype.__proto__=Error.prototype;/**
     * This file contains a list of utility functions which are useful in other
     * files.
     */ /**
     * Return whether an element is contained in a list
     */const contains$1=function contains(list,elem){return list.indexOf(elem)!==-1;};/**
     * Provide a default value if a setting is undefined
     * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
     */const deflt=function deflt(setting,defaultIfUndefined){return setting===undefined?defaultIfUndefined:setting;};// hyphenate and escape adapted from Facebook's React under Apache 2 license
    const uppercase=/([A-Z])/g;const hyphenate=function hyphenate(str){return str.replace(uppercase,"-$1").toLowerCase();};const ESCAPE_LOOKUP={"&":"&amp;",">":"&gt;","<":"&lt;","\"":"&quot;","'":"&#x27;"};const ESCAPE_REGEX=/[&><"']/g;/**
     * Escapes text to prevent scripting attacks.
     */function escape(text){return String(text).replace(ESCAPE_REGEX,match=>ESCAPE_LOOKUP[match]);}/**
     * Sometimes we want to pull out the innermost element of a group. In most
     * cases, this will just be the group itself, but when ordgroups and colors have
     * a single element, we want to pull that out.
     */const getBaseElem=function getBaseElem(group){if(group.type==="ordgroup"){if(group.body.length===1){return getBaseElem(group.body[0]);}else {return group;}}else if(group.type==="color"){if(group.body.length===1){return getBaseElem(group.body[0]);}else {return group;}}else if(group.type==="font"){return getBaseElem(group.body);}else {return group;}};/**
     * TeXbook algorithms often reference "character boxes", which are simply groups
     * with a single character in them. To decide if something is a character box,
     * we find its innermost group, and see if it is a single character.
     */const isCharacterBox=function isCharacterBox(group){const baseElem=getBaseElem(group);// These are all they types of groups which hold single characters
    return baseElem.type==="mathord"||baseElem.type==="textord"||baseElem.type==="atom";};const assert=function assert(value){if(!value){throw new Error('Expected non-null, but got '+String(value));}return value;};/**
     * Return the protocol of a URL, or "_relative" if the URL does not specify a
     * protocol (and thus is relative).
     */const protocolFromUrl=function protocolFromUrl(url){const protocol=/^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);return protocol!=null?protocol[1]:"_relative";};var utils={contains: contains$1,deflt,escape,hyphenate,getBaseElem,isCharacterBox,protocolFromUrl};/* eslint no-console:0 */ /**
     * The main Settings object
     *
     * The current options stored are:
     *  - displayMode: Whether the expression should be typeset as inline math
     *                 (false, the default), meaning that the math starts in
     *                 \textstyle and is placed in an inline-block); or as display
     *                 math (true), meaning that the math starts in \displaystyle
     *                 and is placed in a block with vertical margin.
     */class Settings{constructor(options){this.displayMode=void 0;this.output=void 0;this.leqno=void 0;this.fleqn=void 0;this.throwOnError=void 0;this.errorColor=void 0;this.macros=void 0;this.minRuleThickness=void 0;this.colorIsTextColor=void 0;this.strict=void 0;this.trust=void 0;this.maxSize=void 0;this.maxExpand=void 0;this.globalGroup=void 0;// allow null options
    options=options||{};this.displayMode=utils.deflt(options.displayMode,false);this.output=utils.deflt(options.output,"htmlAndMathml");this.leqno=utils.deflt(options.leqno,false);this.fleqn=utils.deflt(options.fleqn,false);this.throwOnError=utils.deflt(options.throwOnError,true);this.errorColor=utils.deflt(options.errorColor,"#cc0000");this.macros=options.macros||{};this.minRuleThickness=Math.max(0,utils.deflt(options.minRuleThickness,0));this.colorIsTextColor=utils.deflt(options.colorIsTextColor,false);this.strict=utils.deflt(options.strict,"warn");this.trust=utils.deflt(options.trust,false);this.maxSize=Math.max(0,utils.deflt(options.maxSize,Infinity));this.maxExpand=Math.max(0,utils.deflt(options.maxExpand,1000));this.globalGroup=utils.deflt(options.globalGroup,false);}/**
       * Report nonstrict (non-LaTeX-compatible) input.
       * Can safely not be called if `this.strict` is false in JavaScript.
       */reportNonstrict(errorCode,errorMsg,token){let strict=this.strict;if(typeof strict==="function"){// Allow return value of strict function to be boolean or string
    // (or null/undefined, meaning no further processing).
    strict=strict(errorCode,errorMsg,token);}if(!strict||strict==="ignore"){return;}else if(strict===true||strict==="error"){throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': "+`${errorMsg} [${errorCode}]`,token);}else if(strict==="warn"){typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to 'warn': "+`${errorMsg} [${errorCode}]`);}else {// won't happen in type-safe code
    typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to "+`unrecognized '${strict}': ${errorMsg} [${errorCode}]`);}}/**
       * Check whether to apply strict (LaTeX-adhering) behavior for unusual
       * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
       * instead, "error" translates to a return value of `true`, while "ignore"
       * translates to a return value of `false`.  May still print a warning:
       * "warn" prints a warning and returns `false`.
       * This is for the second category of `errorCode`s listed in the README.
       */useStrictBehavior(errorCode,errorMsg,token){let strict=this.strict;if(typeof strict==="function"){// Allow return value of strict function to be boolean or string
    // (or null/undefined, meaning no further processing).
    // But catch any exceptions thrown by function, treating them
    // like "error".
    try{strict=strict(errorCode,errorMsg,token);}catch(error){strict="error";}}if(!strict||strict==="ignore"){return false;}else if(strict===true||strict==="error"){return true;}else if(strict==="warn"){typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to 'warn': "+`${errorMsg} [${errorCode}]`);return false;}else {// won't happen in type-safe code
    typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to "+`unrecognized '${strict}': ${errorMsg} [${errorCode}]`);return false;}}/**
       * Check whether to test potentially dangerous input, and return
       * `true` (trusted) or `false` (untrusted).  The sole argument `context`
       * should be an object with `command` field specifying the relevant LaTeX
       * command (as a string starting with `\`), and any other arguments, etc.
       * If `context` has a `url` field, a `protocol` field will automatically
       * get added by this function (changing the specified object).
       */isTrusted(context){if(context.url&&!context.protocol){context.protocol=utils.protocolFromUrl(context.url);}const trust=typeof this.trust==="function"?this.trust(context):this.trust;return Boolean(trust);}}/**
     * This file contains information and classes for the various kinds of styles
     * used in TeX. It provides a generic `Style` class, which holds information
     * about a specific style. It then provides instances of all the different kinds
     * of styles possible, and provides functions to move between them and get
     * information about them.
     */ /**
     * The main style class. Contains a unique id for the style, a size (which is
     * the same for cramped and uncramped version of a style), and a cramped flag.
     */class Style{constructor(id,size,cramped){this.id=void 0;this.size=void 0;this.cramped=void 0;this.id=id;this.size=size;this.cramped=cramped;}/**
       * Get the style of a superscript given a base in the current style.
       */sup(){return styles[sup[this.id]];}/**
       * Get the style of a subscript given a base in the current style.
       */sub(){return styles[sub[this.id]];}/**
       * Get the style of a fraction numerator given the fraction in the current
       * style.
       */fracNum(){return styles[fracNum[this.id]];}/**
       * Get the style of a fraction denominator given the fraction in the current
       * style.
       */fracDen(){return styles[fracDen[this.id]];}/**
       * Get the cramped version of a style (in particular, cramping a cramped style
       * doesn't change the style).
       */cramp(){return styles[cramp[this.id]];}/**
       * Get a text or display version of this style.
       */text(){return styles[text[this.id]];}/**
       * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
       */isTight(){return this.size>=2;}}// Export an interface for type checking, but don't expose the implementation.
    // This way, no more styles can be generated.
    // IDs of the different styles
    const D=0;const Dc=1;const T=2;const Tc=3;const S=4;const Sc=5;const SS=6;const SSc=7;// Instances of the different styles
    const styles=[new Style(D,0,false),new Style(Dc,0,true),new Style(T,1,false),new Style(Tc,1,true),new Style(S,2,false),new Style(Sc,2,true),new Style(SS,3,false),new Style(SSc,3,true)];// Lookup tables for switching from one style to another
    const sup=[S,Sc,S,Sc,SS,SSc,SS,SSc];const sub=[Sc,Sc,Sc,Sc,SSc,SSc,SSc,SSc];const fracNum=[T,Tc,S,Sc,SS,SSc,SS,SSc];const fracDen=[Tc,Tc,Sc,Sc,SSc,SSc,SSc,SSc];const cramp=[Dc,Dc,Tc,Tc,Sc,Sc,SSc,SSc];const text=[D,Dc,T,Tc,T,Tc,T,Tc];// We only export some of the styles.
    var Style$1={DISPLAY:styles[D],TEXT:styles[T],SCRIPT:styles[S],SCRIPTSCRIPT:styles[SS]};/*
     * This file defines the Unicode scripts and script families that we
     * support. To add new scripts or families, just add a new entry to the
     * scriptData array below. Adding scripts to the scriptData array allows
     * characters from that script to appear in \text{} environments.
     */ /**
     * Each script or script family has a name and an array of blocks.
     * Each block is an array of two numbers which specify the start and
     * end points (inclusive) of a block of Unicode codepoints.
     */ /**
     * Unicode block data for the families of scripts we support in \text{}.
     * Scripts only need to appear here if they do not have font metrics.
     */const scriptData=[{// Latin characters beyond the Latin-1 characters we have metrics for.
    // Needed for Czech, Hungarian and Turkish text, for example.
    name:'latin',blocks:[[0x0100,0x024f],// Latin Extended-A and Latin Extended-B
    [0x0300,0x036f]]},{// The Cyrillic script used by Russian and related languages.
    // A Cyrillic subset used to be supported as explicitly defined
    // symbols in symbols.js
    name:'cyrillic',blocks:[[0x0400,0x04ff]]},{// The Brahmic scripts of South and Southeast Asia
    // Devanagari (0900097F)
    // Bengali (098009FF)
    // Gurmukhi (0A000A7F)
    // Gujarati (0A800AFF)
    // Oriya (0B000B7F)
    // Tamil (0B800BFF)
    // Telugu (0C000C7F)
    // Kannada (0C800CFF)
    // Malayalam (0D000D7F)
    // Sinhala (0D800DFF)
    // Thai (0E000E7F)
    // Lao (0E800EFF)
    // Tibetan (0F000FFF)
    // Myanmar (1000109F)
    name:'brahmic',blocks:[[0x0900,0x109F]]},{name:'georgian',blocks:[[0x10A0,0x10ff]]},{// Chinese and Japanese.
    // The "k" in cjk is for Korean, but we've separated Korean out
    name:"cjk",blocks:[[0x3000,0x30FF],// CJK symbols and punctuation, Hiragana, Katakana
    [0x4E00,0x9FAF],// CJK ideograms
    [0xFF00,0xFF60]]},{// Korean
    name:'hangul',blocks:[[0xAC00,0xD7AF]]}];/**
     * Given a codepoint, return the name of the script or script family
     * it is from, or null if it is not part of a known block
     */function scriptFromCodepoint(codepoint){for(let i=0;i<scriptData.length;i++){const script=scriptData[i];for(let i=0;i<script.blocks.length;i++){const block=script.blocks[i];if(codepoint>=block[0]&&codepoint<=block[1]){return script.name;}}}return null;}/**
     * A flattened version of all the supported blocks in a single array.
     * This is an optimization to make supportedCodepoint() fast.
     */const allBlocks=[];scriptData.forEach(s=>s.blocks.forEach(b=>allBlocks.push(...b)));/**
     * Given a codepoint, return true if it falls within one of the
     * scripts or script families defined above and false otherwise.
     *
     * Micro benchmarks shows that this is faster than
     * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
     * in Firefox, Chrome and Node.
     */function supportedCodepoint(codepoint){for(let i=0;i<allBlocks.length;i+=2){if(codepoint>=allBlocks[i]&&codepoint<=allBlocks[i+1]){return true;}}return false;}/**
     * This file provides support to domTree.js and delimiter.js.
     * It's a storehouse of path geometry for SVG images.
     */ // In all paths below, the viewBox-to-em scale is 1000:1.
    const hLinePad=80;// padding above a sqrt viniculum. Prevents image cropping.
    // The viniculum of a \sqrt can be made thicker by a KaTeX rendering option.
    // Think of variable extraViniculum as two detours in the SVG path.
    // The detour begins at the lower left of the area labeled extraViniculum below.
    // The detour proceeds one extraViniculum distance up and slightly to the right,
    // displacing the radiused corner between surd and viniculum. The radius is
    // traversed as usual, then the detour resumes. It goes right, to the end of
    // the very long viniculumn, then down one extraViniculum distance,
    // after which it resumes regular path geometry for the radical.
    /*                                                  viniculum
                                                       /
             /extraViniculum
            / 0.04em (40 unit) std viniculum thickness
           / /
          / /
         / /\
        / / surd
    */const sqrtMain=function sqrtMain(extraViniculum,hLinePad){// sqrtMain path geometry is from glyph U221A in the font KaTeX Main
    return `M95,${622+extraViniculum+hLinePad}
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l${extraViniculum/2.075} -${extraViniculum}
c5.3,-9.3,12,-14,20,-14
H400000v${40+extraViniculum}H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M${834+extraViniculum} ${hLinePad}h400000v${40+extraViniculum}h-400000z`;};const sqrtSize1=function sqrtSize1(extraViniculum,hLinePad){// size1 is from glyph U221A in the font KaTeX_Size1-Regular
    return `M263,${601+extraViniculum+hLinePad}c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l${extraViniculum/2.084} -${extraViniculum}
c4.7,-7.3,11,-11,19,-11
H40000v${40+extraViniculum}H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M${1001+extraViniculum} ${hLinePad}h400000v${40+extraViniculum}h-400000z`;};const sqrtSize2=function sqrtSize2(extraViniculum,hLinePad){// size2 is from glyph U221A in the font KaTeX_Size2-Regular
    return `M983 ${10+extraViniculum+hLinePad}
l${extraViniculum/3.13} -${extraViniculum}
c4,-6.7,10,-10,18,-10 H400000v${40+extraViniculum}
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M${1001+extraViniculum} ${hLinePad}h400000v${40+extraViniculum}h-400000z`;};const sqrtSize3=function sqrtSize3(extraViniculum,hLinePad){// size3 is from glyph U221A in the font KaTeX_Size3-Regular
    return `M424,${2398+extraViniculum+hLinePad}
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l${extraViniculum/4.223} -${extraViniculum}c4,-6.7,10,-10,18,-10 H400000
v${40+extraViniculum}H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M${1001+extraViniculum} ${hLinePad}
h400000v${40+extraViniculum}h-400000z`;};const sqrtSize4=function sqrtSize4(extraViniculum,hLinePad){// size4 is from glyph U221A in the font KaTeX_Size4-Regular
    return `M473,${2713+extraViniculum+hLinePad}
c339.3,-1799.3,509.3,-2700,510,-2702 l${extraViniculum/5.298} -${extraViniculum}
c3.3,-7.3,9.3,-11,18,-11 H400000v${40+extraViniculum}H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM${1001+extraViniculum} ${hLinePad}h400000v${40+extraViniculum}H1017.7z`;};const sqrtTall=function sqrtTall(extraViniculum,hLinePad,viewBoxHeight){// sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
    // One path edge has a variable length. It runs vertically from the viniculumn
    // to a point near (14 units) the bottom of the surd. The viniculum
    // is normally 40 units thick. So the length of the line in question is:
    const vertSegment=viewBoxHeight-54-hLinePad-extraViniculum;return `M702 ${extraViniculum+hLinePad}H400000${40+extraViniculum}
H742v${vertSegment}l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ${hLinePad}H400000v${40+extraViniculum}H742z`;};const sqrtPath=function sqrtPath(size,extraViniculum,viewBoxHeight){extraViniculum=1000*extraViniculum;// Convert from document ems to viewBox.
    let path="";switch(size){case"sqrtMain":path=sqrtMain(extraViniculum,hLinePad);break;case"sqrtSize1":path=sqrtSize1(extraViniculum,hLinePad);break;case"sqrtSize2":path=sqrtSize2(extraViniculum,hLinePad);break;case"sqrtSize3":path=sqrtSize3(extraViniculum,hLinePad);break;case"sqrtSize4":path=sqrtSize4(extraViniculum,hLinePad);break;case"sqrtTall":path=sqrtTall(extraViniculum,hLinePad,viewBoxHeight);}return path;};const path={// Two paths that cover gaps in built-up parentheses.
    leftParenInner:`M291 0 H417 V300 H291 z`,rightParenInner:`M457 0 H583 V300 H457 z`,// The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
    doubleleftarrow:`M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,// doublerightarrow is from glyph U+21D2 in font KaTeX Main
    doublerightarrow:`M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,// leftarrow is from glyph U+2190 in font KaTeX Main
    leftarrow:`M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,// overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
    leftbrace:`M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,leftbraceunder:`M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,// overgroup is from the MnSymbol package (public domain)
    leftgroup:`M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,leftgroupunder:`M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,// Harpoons are from glyph U+21BD in font KaTeX Main
    leftharpoon:`M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,leftharpoonplus:`M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,leftharpoondown:`M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,leftharpoondownplus:`M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,// hook is from glyph U+21A9 in font KaTeX Main
    lefthook:`M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,leftlinesegment:`M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,leftmapsto:`M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,// tofrom is from glyph U+21C4 in font KaTeX AMS Regular
    leftToFrom:`M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,longequal:`M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,midbrace:`M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,midbraceunder:`M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,oiintSize1:`M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,oiintSize2:`M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,oiiintSize1:`M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,oiiintSize2:`M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,rightarrow:`M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,rightbrace:`M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,rightbraceunder:`M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,rightgroup:`M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,rightgroupunder:`M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,rightharpoon:`M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,rightharpoonplus:`M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,rightharpoondown:`M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,rightharpoondownplus:`M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,righthook:`M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,rightlinesegment:`M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,rightToFrom:`M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,// twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
    twoheadleftarrow:`M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,twoheadrightarrow:`M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,// tilde1 is a modified version of a glyph from the MnSymbol package
    tilde1:`M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,// ditto tilde2, tilde3, & tilde4
    tilde2:`M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,tilde3:`M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,tilde4:`M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,// vec is from glyph U+20D7 in font KaTeX Main
    vec:`M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,// widehat1 is a modified version of a glyph from the MnSymbol package
    widehat1:`M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,// ditto widehat2, widehat3, & widehat4
    widehat2:`M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,widehat3:`M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,widehat4:`M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,// widecheck paths are all inverted versions of widehat
    widecheck1:`M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,widecheck2:`M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,widecheck3:`M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,widecheck4:`M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,// The next ten paths support reaction arrows from the mhchem package.
    // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
    // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
    baraboveleftarrow:`M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,// rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
    rightarrowabovebar:`M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,// The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
    // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
    baraboveshortleftharpoon:`M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,rightharpoonaboveshortbar:`M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,shortbaraboveleftharpoon:`M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,shortrightharpoonabovebar:`M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`};/**
     * This node represents a document fragment, which contains elements, but when
     * placed into the DOM doesn't have any representation itself. It only contains
     * children and doesn't have any DOM node properties.
     */class DocumentFragment{// HtmlDomNode
    // Never used; needed for satisfying interface.
    constructor(children){this.children=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.maxFontSize=void 0;this.style=void 0;this.children=children;this.classes=[];this.height=0;this.depth=0;this.maxFontSize=0;this.style={};}hasClass(className){return utils.contains(this.classes,className);}/** Convert the fragment into a node. */toNode(){const frag=document.createDocumentFragment();for(let i=0;i<this.children.length;i++){frag.appendChild(this.children[i].toNode());}return frag;}/** Convert the fragment into HTML markup. */toMarkup(){let markup="";// Simply concatenate the markup for the children together.
    for(let i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}return markup;}/**
       * Converts the math node into a string, similar to innerText. Applies to
       * MathDomNode's only.
       */toText(){// To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    // $FlowFixMe: Only works for ChildType = MathDomNode.
    const toText=child=>child.toText();return this.children.map(toText).join("");}}/**
     * These objects store the data about the DOM nodes we create, as well as some
     * extra data. They can then be transformed into real DOM nodes with the
     * `toNode` function or HTML markup using `toMarkup`. They are useful for both
     * storing extra properties on the nodes, as well as providing a way to easily
     * work with the DOM.
     *
     * Similar functions for working with MathML nodes exist in mathMLTree.js.
     *
     * TODO: refactor `span` and `anchor` into common superclass when
     * target environments support class inheritance
     */ /**
     * Create an HTML className based on a list of classes. In addition to joining
     * with spaces, we also remove empty classes.
     */const createClass=function createClass(classes){return classes.filter(cls=>cls).join(" ");};const initNode=function initNode(classes,options,style){this.classes=classes||[];this.attributes={};this.height=0;this.depth=0;this.maxFontSize=0;this.style=style||{};if(options){if(options.style.isTight()){this.classes.push("mtight");}const color=options.getColor();if(color){this.style.color=color;}}};/**
     * Convert into an HTML node
     */const toNode=function toNode(tagName){const node=document.createElement(tagName);// Apply the class
    node.className=createClass(this.classes);// Apply inline styles
    for(const style in this.style){if(this.style.hasOwnProperty(style)){// $FlowFixMe Flow doesn't seem to understand span.style's type.
    node.style[style]=this.style[style];}}// Apply attributes
    for(const attr in this.attributes){if(this.attributes.hasOwnProperty(attr)){node.setAttribute(attr,this.attributes[attr]);}}// Append the children, also as HTML nodes
    for(let i=0;i<this.children.length;i++){node.appendChild(this.children[i].toNode());}return node;};/**
     * Convert into an HTML markup string
     */const toMarkup=function toMarkup(tagName){let markup=`<${tagName}`;// Add the class
    if(this.classes.length){markup+=` class="${utils.escape(createClass(this.classes))}"`;}let styles="";// Add the styles, after hyphenation
    for(const style in this.style){if(this.style.hasOwnProperty(style)){styles+=`${utils.hyphenate(style)}:${this.style[style]};`;}}if(styles){markup+=` style="${utils.escape(styles)}"`;}// Add the attributes
    for(const attr in this.attributes){if(this.attributes.hasOwnProperty(attr)){markup+=` ${attr}="${utils.escape(this.attributes[attr])}"`;}}markup+=">";// Add the markup of the children, also as markup
    for(let i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}markup+=`</${tagName}>`;return markup;};// Making the type below exact with all optional fields doesn't work due to
    // - https://github.com/facebook/flow/issues/4582
    // - https://github.com/facebook/flow/issues/5688
    // However, since *all* fields are optional, $Shape<> works as suggested in 5688
    // above.
    // This type does not include all CSS properties. Additional properties should
    // be added as needed.
    /**
     * This node represents a span node, with a className, a list of children, and
     * an inline style. It also contains information about its height, depth, and
     * maxFontSize.
     *
     * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
     * otherwise. This typesafety is important when HTML builders access a span's
     * children.
     */class Span{constructor(classes,children,options,style){this.children=void 0;this.attributes=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.width=void 0;this.maxFontSize=void 0;this.style=void 0;initNode.call(this,classes,options,style);this.children=children||[];}/**
       * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
       * all browsers support attributes the same, and having too many custom
       * attributes is probably bad.
       */setAttribute(attribute,value){this.attributes[attribute]=value;}hasClass(className){return utils.contains(this.classes,className);}toNode(){return toNode.call(this,"span");}toMarkup(){return toMarkup.call(this,"span");}}/**
     * This node represents an anchor (<a>) element with a hyperlink.  See `span`
     * for further details.
     */class Anchor{constructor(href,classes,children,options){this.children=void 0;this.attributes=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.maxFontSize=void 0;this.style=void 0;initNode.call(this,classes,options);this.children=children||[];this.setAttribute('href',href);}setAttribute(attribute,value){this.attributes[attribute]=value;}hasClass(className){return utils.contains(this.classes,className);}toNode(){return toNode.call(this,"a");}toMarkup(){return toMarkup.call(this,"a");}}/**
     * This node represents an image embed (<img>) element.
     */class Img{constructor(src,alt,style){this.src=void 0;this.alt=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.maxFontSize=void 0;this.style=void 0;this.alt=alt;this.src=src;this.classes=["mord"];this.style=style;}hasClass(className){return utils.contains(this.classes,className);}toNode(){const node=document.createElement("img");node.src=this.src;node.alt=this.alt;node.className="mord";// Apply inline styles
    for(const style in this.style){if(this.style.hasOwnProperty(style)){// $FlowFixMe
    node.style[style]=this.style[style];}}return node;}toMarkup(){let markup=`<img  src='${this.src} 'alt='${this.alt}' `;// Add the styles, after hyphenation
    let styles="";for(const style in this.style){if(this.style.hasOwnProperty(style)){styles+=`${utils.hyphenate(style)}:${this.style[style]};`;}}if(styles){markup+=` style="${utils.escape(styles)}"`;}markup+="'/>";return markup;}}const iCombinations={'':'\u0131\u0302','':'\u0131\u0308','':'\u0131\u0301',// '': '\u0131\u0304', // enable when we add Extended Latin
    '':'\u0131\u0300'};/**
     * A symbol node contains information about a single symbol. It either renders
     * to a single text node, or a span with a single text node in it, depending on
     * whether it has CSS classes, styles, or needs italic correction.
     */class SymbolNode{constructor(text,height,depth,italic,skew,width,classes,style){this.text=void 0;this.height=void 0;this.depth=void 0;this.italic=void 0;this.skew=void 0;this.width=void 0;this.maxFontSize=void 0;this.classes=void 0;this.style=void 0;this.text=text;this.height=height||0;this.depth=depth||0;this.italic=italic||0;this.skew=skew||0;this.width=width||0;this.classes=classes||[];this.style=style||{};this.maxFontSize=0;// Mark text from non-Latin scripts with specific classes so that we
    // can specify which fonts to use.  This allows us to render these
    // characters with a serif font in situations where the browser would
    // either default to a sans serif or render a placeholder character.
    // We use CSS class names like cjk_fallback, hangul_fallback and
    // brahmic_fallback. See ./unicodeScripts.js for the set of possible
    // script names
    const script=scriptFromCodepoint(this.text.charCodeAt(0));if(script){this.classes.push(script+"_fallback");}if(/[]/.test(this.text)){// add  when we add Extended Latin
    this.text=iCombinations[this.text];}}hasClass(className){return utils.contains(this.classes,className);}/**
       * Creates a text node or span from a symbol node. Note that a span is only
       * created if it is needed.
       */toNode(){const node=document.createTextNode(this.text);let span=null;if(this.italic>0){span=document.createElement("span");span.style.marginRight=this.italic+"em";}if(this.classes.length>0){span=span||document.createElement("span");span.className=createClass(this.classes);}for(const style in this.style){if(this.style.hasOwnProperty(style)){span=span||document.createElement("span");// $FlowFixMe Flow doesn't seem to understand span.style's type.
    span.style[style]=this.style[style];}}if(span){span.appendChild(node);return span;}else {return node;}}/**
       * Creates markup for a symbol node.
       */toMarkup(){// TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    let needsSpan=false;let markup="<span";if(this.classes.length){needsSpan=true;markup+=" class=\"";markup+=utils.escape(createClass(this.classes));markup+="\"";}let styles="";if(this.italic>0){styles+="margin-right:"+this.italic+"em;";}for(const style in this.style){if(this.style.hasOwnProperty(style)){styles+=utils.hyphenate(style)+":"+this.style[style]+";";}}if(styles){needsSpan=true;markup+=" style=\""+utils.escape(styles)+"\"";}const escaped=utils.escape(this.text);if(needsSpan){markup+=">";markup+=escaped;markup+="</span>";return markup;}else {return escaped;}}}/**
     * SVG nodes are used to render stretchy wide elements.
     */class SvgNode{constructor(children,attributes){this.children=void 0;this.attributes=void 0;this.children=children||[];this.attributes=attributes||{};}toNode(){const svgNS="http://www.w3.org/2000/svg";const node=document.createElementNS(svgNS,"svg");// Apply attributes
    for(const attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){node.setAttribute(attr,this.attributes[attr]);}}for(let i=0;i<this.children.length;i++){node.appendChild(this.children[i].toNode());}return node;}toMarkup(){let markup="<svg";// Apply attributes
    for(const attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){markup+=` ${attr}='${this.attributes[attr]}'`;}}markup+=">";for(let i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}markup+="</svg>";return markup;}}class PathNode{constructor(pathName,alternate){this.pathName=void 0;this.alternate=void 0;this.pathName=pathName;this.alternate=alternate;// Used only for \sqrt
    }toNode(){const svgNS="http://www.w3.org/2000/svg";const node=document.createElementNS(svgNS,"path");if(this.alternate){node.setAttribute("d",this.alternate);}else {node.setAttribute("d",path[this.pathName]);}return node;}toMarkup(){if(this.alternate){return `<path d='${this.alternate}'/>`;}else {return `<path d='${path[this.pathName]}'/>`;}}}class LineNode{constructor(attributes){this.attributes=void 0;this.attributes=attributes||{};}toNode(){const svgNS="http://www.w3.org/2000/svg";const node=document.createElementNS(svgNS,"line");// Apply attributes
    for(const attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){node.setAttribute(attr,this.attributes[attr]);}}return node;}toMarkup(){let markup="<line";for(const attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){markup+=` ${attr}='${this.attributes[attr]}'`;}}markup+="/>";return markup;}}function assertSymbolDomNode(group){if(group instanceof SymbolNode){return group;}else {throw new Error(`Expected symbolNode but got ${String(group)}.`);}}function assertSpan(group){if(group instanceof Span){return group;}else {throw new Error(`Expected span<HtmlDomNode> but got ${String(group)}.`);}}// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
    var metricMap={"AMS-Regular":{"32":[0,0,0,0,0.25],"65":[0,0.68889,0,0,0.72222],"66":[0,0.68889,0,0,0.66667],"67":[0,0.68889,0,0,0.72222],"68":[0,0.68889,0,0,0.72222],"69":[0,0.68889,0,0,0.66667],"70":[0,0.68889,0,0,0.61111],"71":[0,0.68889,0,0,0.77778],"72":[0,0.68889,0,0,0.77778],"73":[0,0.68889,0,0,0.38889],"74":[0.16667,0.68889,0,0,0.5],"75":[0,0.68889,0,0,0.77778],"76":[0,0.68889,0,0,0.66667],"77":[0,0.68889,0,0,0.94445],"78":[0,0.68889,0,0,0.72222],"79":[0.16667,0.68889,0,0,0.77778],"80":[0,0.68889,0,0,0.61111],"81":[0.16667,0.68889,0,0,0.77778],"82":[0,0.68889,0,0,0.72222],"83":[0,0.68889,0,0,0.55556],"84":[0,0.68889,0,0,0.66667],"85":[0,0.68889,0,0,0.72222],"86":[0,0.68889,0,0,0.72222],"87":[0,0.68889,0,0,1.0],"88":[0,0.68889,0,0,0.72222],"89":[0,0.68889,0,0,0.72222],"90":[0,0.68889,0,0,0.66667],"107":[0,0.68889,0,0,0.55556],"160":[0,0,0,0,0.25],"165":[0,0.675,0.025,0,0.75],"174":[0.15559,0.69224,0,0,0.94666],"240":[0,0.68889,0,0,0.55556],"295":[0,0.68889,0,0,0.54028],"710":[0,0.825,0,0,2.33334],"732":[0,0.9,0,0,2.33334],"770":[0,0.825,0,0,2.33334],"771":[0,0.9,0,0,2.33334],"989":[0.08167,0.58167,0,0,0.77778],"1008":[0,0.43056,0.04028,0,0.66667],"8245":[0,0.54986,0,0,0.275],"8463":[0,0.68889,0,0,0.54028],"8487":[0,0.68889,0,0,0.72222],"8498":[0,0.68889,0,0,0.55556],"8502":[0,0.68889,0,0,0.66667],"8503":[0,0.68889,0,0,0.44445],"8504":[0,0.68889,0,0,0.66667],"8513":[0,0.68889,0,0,0.63889],"8592":[-0.03598,0.46402,0,0,0.5],"8594":[-0.03598,0.46402,0,0,0.5],"8602":[-0.13313,0.36687,0,0,1.0],"8603":[-0.13313,0.36687,0,0,1.0],"8606":[0.01354,0.52239,0,0,1.0],"8608":[0.01354,0.52239,0,0,1.0],"8610":[0.01354,0.52239,0,0,1.11111],"8611":[0.01354,0.52239,0,0,1.11111],"8619":[0,0.54986,0,0,1.0],"8620":[0,0.54986,0,0,1.0],"8621":[-0.13313,0.37788,0,0,1.38889],"8622":[-0.13313,0.36687,0,0,1.0],"8624":[0,0.69224,0,0,0.5],"8625":[0,0.69224,0,0,0.5],"8630":[0,0.43056,0,0,1.0],"8631":[0,0.43056,0,0,1.0],"8634":[0.08198,0.58198,0,0,0.77778],"8635":[0.08198,0.58198,0,0,0.77778],"8638":[0.19444,0.69224,0,0,0.41667],"8639":[0.19444,0.69224,0,0,0.41667],"8642":[0.19444,0.69224,0,0,0.41667],"8643":[0.19444,0.69224,0,0,0.41667],"8644":[0.1808,0.675,0,0,1.0],"8646":[0.1808,0.675,0,0,1.0],"8647":[0.1808,0.675,0,0,1.0],"8648":[0.19444,0.69224,0,0,0.83334],"8649":[0.1808,0.675,0,0,1.0],"8650":[0.19444,0.69224,0,0,0.83334],"8651":[0.01354,0.52239,0,0,1.0],"8652":[0.01354,0.52239,0,0,1.0],"8653":[-0.13313,0.36687,0,0,1.0],"8654":[-0.13313,0.36687,0,0,1.0],"8655":[-0.13313,0.36687,0,0,1.0],"8666":[0.13667,0.63667,0,0,1.0],"8667":[0.13667,0.63667,0,0,1.0],"8669":[-0.13313,0.37788,0,0,1.0],"8672":[-0.064,0.437,0,0,1.334],"8674":[-0.064,0.437,0,0,1.334],"8705":[0,0.825,0,0,0.5],"8708":[0,0.68889,0,0,0.55556],"8709":[0.08167,0.58167,0,0,0.77778],"8717":[0,0.43056,0,0,0.42917],"8722":[-0.03598,0.46402,0,0,0.5],"8724":[0.08198,0.69224,0,0,0.77778],"8726":[0.08167,0.58167,0,0,0.77778],"8733":[0,0.69224,0,0,0.77778],"8736":[0,0.69224,0,0,0.72222],"8737":[0,0.69224,0,0,0.72222],"8738":[0.03517,0.52239,0,0,0.72222],"8739":[0.08167,0.58167,0,0,0.22222],"8740":[0.25142,0.74111,0,0,0.27778],"8741":[0.08167,0.58167,0,0,0.38889],"8742":[0.25142,0.74111,0,0,0.5],"8756":[0,0.69224,0,0,0.66667],"8757":[0,0.69224,0,0,0.66667],"8764":[-0.13313,0.36687,0,0,0.77778],"8765":[-0.13313,0.37788,0,0,0.77778],"8769":[-0.13313,0.36687,0,0,0.77778],"8770":[-0.03625,0.46375,0,0,0.77778],"8774":[0.30274,0.79383,0,0,0.77778],"8776":[-0.01688,0.48312,0,0,0.77778],"8778":[0.08167,0.58167,0,0,0.77778],"8782":[0.06062,0.54986,0,0,0.77778],"8783":[0.06062,0.54986,0,0,0.77778],"8785":[0.08198,0.58198,0,0,0.77778],"8786":[0.08198,0.58198,0,0,0.77778],"8787":[0.08198,0.58198,0,0,0.77778],"8790":[0,0.69224,0,0,0.77778],"8791":[0.22958,0.72958,0,0,0.77778],"8796":[0.08198,0.91667,0,0,0.77778],"8806":[0.25583,0.75583,0,0,0.77778],"8807":[0.25583,0.75583,0,0,0.77778],"8808":[0.25142,0.75726,0,0,0.77778],"8809":[0.25142,0.75726,0,0,0.77778],"8812":[0.25583,0.75583,0,0,0.5],"8814":[0.20576,0.70576,0,0,0.77778],"8815":[0.20576,0.70576,0,0,0.77778],"8816":[0.30274,0.79383,0,0,0.77778],"8817":[0.30274,0.79383,0,0,0.77778],"8818":[0.22958,0.72958,0,0,0.77778],"8819":[0.22958,0.72958,0,0,0.77778],"8822":[0.1808,0.675,0,0,0.77778],"8823":[0.1808,0.675,0,0,0.77778],"8828":[0.13667,0.63667,0,0,0.77778],"8829":[0.13667,0.63667,0,0,0.77778],"8830":[0.22958,0.72958,0,0,0.77778],"8831":[0.22958,0.72958,0,0,0.77778],"8832":[0.20576,0.70576,0,0,0.77778],"8833":[0.20576,0.70576,0,0,0.77778],"8840":[0.30274,0.79383,0,0,0.77778],"8841":[0.30274,0.79383,0,0,0.77778],"8842":[0.13597,0.63597,0,0,0.77778],"8843":[0.13597,0.63597,0,0,0.77778],"8847":[0.03517,0.54986,0,0,0.77778],"8848":[0.03517,0.54986,0,0,0.77778],"8858":[0.08198,0.58198,0,0,0.77778],"8859":[0.08198,0.58198,0,0,0.77778],"8861":[0.08198,0.58198,0,0,0.77778],"8862":[0,0.675,0,0,0.77778],"8863":[0,0.675,0,0,0.77778],"8864":[0,0.675,0,0,0.77778],"8865":[0,0.675,0,0,0.77778],"8872":[0,0.69224,0,0,0.61111],"8873":[0,0.69224,0,0,0.72222],"8874":[0,0.69224,0,0,0.88889],"8876":[0,0.68889,0,0,0.61111],"8877":[0,0.68889,0,0,0.61111],"8878":[0,0.68889,0,0,0.72222],"8879":[0,0.68889,0,0,0.72222],"8882":[0.03517,0.54986,0,0,0.77778],"8883":[0.03517,0.54986,0,0,0.77778],"8884":[0.13667,0.63667,0,0,0.77778],"8885":[0.13667,0.63667,0,0,0.77778],"8888":[0,0.54986,0,0,1.11111],"8890":[0.19444,0.43056,0,0,0.55556],"8891":[0.19444,0.69224,0,0,0.61111],"8892":[0.19444,0.69224,0,0,0.61111],"8901":[0,0.54986,0,0,0.27778],"8903":[0.08167,0.58167,0,0,0.77778],"8905":[0.08167,0.58167,0,0,0.77778],"8906":[0.08167,0.58167,0,0,0.77778],"8907":[0,0.69224,0,0,0.77778],"8908":[0,0.69224,0,0,0.77778],"8909":[-0.03598,0.46402,0,0,0.77778],"8910":[0,0.54986,0,0,0.76042],"8911":[0,0.54986,0,0,0.76042],"8912":[0.03517,0.54986,0,0,0.77778],"8913":[0.03517,0.54986,0,0,0.77778],"8914":[0,0.54986,0,0,0.66667],"8915":[0,0.54986,0,0,0.66667],"8916":[0,0.69224,0,0,0.66667],"8918":[0.0391,0.5391,0,0,0.77778],"8919":[0.0391,0.5391,0,0,0.77778],"8920":[0.03517,0.54986,0,0,1.33334],"8921":[0.03517,0.54986,0,0,1.33334],"8922":[0.38569,0.88569,0,0,0.77778],"8923":[0.38569,0.88569,0,0,0.77778],"8926":[0.13667,0.63667,0,0,0.77778],"8927":[0.13667,0.63667,0,0,0.77778],"8928":[0.30274,0.79383,0,0,0.77778],"8929":[0.30274,0.79383,0,0,0.77778],"8934":[0.23222,0.74111,0,0,0.77778],"8935":[0.23222,0.74111,0,0,0.77778],"8936":[0.23222,0.74111,0,0,0.77778],"8937":[0.23222,0.74111,0,0,0.77778],"8938":[0.20576,0.70576,0,0,0.77778],"8939":[0.20576,0.70576,0,0,0.77778],"8940":[0.30274,0.79383,0,0,0.77778],"8941":[0.30274,0.79383,0,0,0.77778],"8994":[0.19444,0.69224,0,0,0.77778],"8995":[0.19444,0.69224,0,0,0.77778],"9416":[0.15559,0.69224,0,0,0.90222],"9484":[0,0.69224,0,0,0.5],"9488":[0,0.69224,0,0,0.5],"9492":[0,0.37788,0,0,0.5],"9496":[0,0.37788,0,0,0.5],"9585":[0.19444,0.68889,0,0,0.88889],"9586":[0.19444,0.74111,0,0,0.88889],"9632":[0,0.675,0,0,0.77778],"9633":[0,0.675,0,0,0.77778],"9650":[0,0.54986,0,0,0.72222],"9651":[0,0.54986,0,0,0.72222],"9654":[0.03517,0.54986,0,0,0.77778],"9660":[0,0.54986,0,0,0.72222],"9661":[0,0.54986,0,0,0.72222],"9664":[0.03517,0.54986,0,0,0.77778],"9674":[0.11111,0.69224,0,0,0.66667],"9733":[0.19444,0.69224,0,0,0.94445],"10003":[0,0.69224,0,0,0.83334],"10016":[0,0.69224,0,0,0.83334],"10731":[0.11111,0.69224,0,0,0.66667],"10846":[0.19444,0.75583,0,0,0.61111],"10877":[0.13667,0.63667,0,0,0.77778],"10878":[0.13667,0.63667,0,0,0.77778],"10885":[0.25583,0.75583,0,0,0.77778],"10886":[0.25583,0.75583,0,0,0.77778],"10887":[0.13597,0.63597,0,0,0.77778],"10888":[0.13597,0.63597,0,0,0.77778],"10889":[0.26167,0.75726,0,0,0.77778],"10890":[0.26167,0.75726,0,0,0.77778],"10891":[0.48256,0.98256,0,0,0.77778],"10892":[0.48256,0.98256,0,0,0.77778],"10901":[0.13667,0.63667,0,0,0.77778],"10902":[0.13667,0.63667,0,0,0.77778],"10933":[0.25142,0.75726,0,0,0.77778],"10934":[0.25142,0.75726,0,0,0.77778],"10935":[0.26167,0.75726,0,0,0.77778],"10936":[0.26167,0.75726,0,0,0.77778],"10937":[0.26167,0.75726,0,0,0.77778],"10938":[0.26167,0.75726,0,0,0.77778],"10949":[0.25583,0.75583,0,0,0.77778],"10950":[0.25583,0.75583,0,0,0.77778],"10955":[0.28481,0.79383,0,0,0.77778],"10956":[0.28481,0.79383,0,0,0.77778],"57350":[0.08167,0.58167,0,0,0.22222],"57351":[0.08167,0.58167,0,0,0.38889],"57352":[0.08167,0.58167,0,0,0.77778],"57353":[0,0.43056,0.04028,0,0.66667],"57356":[0.25142,0.75726,0,0,0.77778],"57357":[0.25142,0.75726,0,0,0.77778],"57358":[0.41951,0.91951,0,0,0.77778],"57359":[0.30274,0.79383,0,0,0.77778],"57360":[0.30274,0.79383,0,0,0.77778],"57361":[0.41951,0.91951,0,0,0.77778],"57366":[0.25142,0.75726,0,0,0.77778],"57367":[0.25142,0.75726,0,0,0.77778],"57368":[0.25142,0.75726,0,0,0.77778],"57369":[0.25142,0.75726,0,0,0.77778],"57370":[0.13597,0.63597,0,0,0.77778],"57371":[0.13597,0.63597,0,0,0.77778]},"Caligraphic-Regular":{"32":[0,0,0,0,0.25],"65":[0,0.68333,0,0.19445,0.79847],"66":[0,0.68333,0.03041,0.13889,0.65681],"67":[0,0.68333,0.05834,0.13889,0.52653],"68":[0,0.68333,0.02778,0.08334,0.77139],"69":[0,0.68333,0.08944,0.11111,0.52778],"70":[0,0.68333,0.09931,0.11111,0.71875],"71":[0.09722,0.68333,0.0593,0.11111,0.59487],"72":[0,0.68333,0.00965,0.11111,0.84452],"73":[0,0.68333,0.07382,0,0.54452],"74":[0.09722,0.68333,0.18472,0.16667,0.67778],"75":[0,0.68333,0.01445,0.05556,0.76195],"76":[0,0.68333,0,0.13889,0.68972],"77":[0,0.68333,0,0.13889,1.2009],"78":[0,0.68333,0.14736,0.08334,0.82049],"79":[0,0.68333,0.02778,0.11111,0.79611],"80":[0,0.68333,0.08222,0.08334,0.69556],"81":[0.09722,0.68333,0,0.11111,0.81667],"82":[0,0.68333,0,0.08334,0.8475],"83":[0,0.68333,0.075,0.13889,0.60556],"84":[0,0.68333,0.25417,0,0.54464],"85":[0,0.68333,0.09931,0.08334,0.62583],"86":[0,0.68333,0.08222,0,0.61278],"87":[0,0.68333,0.08222,0.08334,0.98778],"88":[0,0.68333,0.14643,0.13889,0.7133],"89":[0.09722,0.68333,0.08222,0.08334,0.66834],"90":[0,0.68333,0.07944,0.13889,0.72473],"160":[0,0,0,0,0.25]},"Fraktur-Regular":{"32":[0,0,0,0,0.25],"33":[0,0.69141,0,0,0.29574],"34":[0,0.69141,0,0,0.21471],"38":[0,0.69141,0,0,0.73786],"39":[0,0.69141,0,0,0.21201],"40":[0.24982,0.74947,0,0,0.38865],"41":[0.24982,0.74947,0,0,0.38865],"42":[0,0.62119,0,0,0.27764],"43":[0.08319,0.58283,0,0,0.75623],"44":[0,0.10803,0,0,0.27764],"45":[0.08319,0.58283,0,0,0.75623],"46":[0,0.10803,0,0,0.27764],"47":[0.24982,0.74947,0,0,0.50181],"48":[0,0.47534,0,0,0.50181],"49":[0,0.47534,0,0,0.50181],"50":[0,0.47534,0,0,0.50181],"51":[0.18906,0.47534,0,0,0.50181],"52":[0.18906,0.47534,0,0,0.50181],"53":[0.18906,0.47534,0,0,0.50181],"54":[0,0.69141,0,0,0.50181],"55":[0.18906,0.47534,0,0,0.50181],"56":[0,0.69141,0,0,0.50181],"57":[0.18906,0.47534,0,0,0.50181],"58":[0,0.47534,0,0,0.21606],"59":[0.12604,0.47534,0,0,0.21606],"61":[-0.13099,0.36866,0,0,0.75623],"63":[0,0.69141,0,0,0.36245],"65":[0,0.69141,0,0,0.7176],"66":[0,0.69141,0,0,0.88397],"67":[0,0.69141,0,0,0.61254],"68":[0,0.69141,0,0,0.83158],"69":[0,0.69141,0,0,0.66278],"70":[0.12604,0.69141,0,0,0.61119],"71":[0,0.69141,0,0,0.78539],"72":[0.06302,0.69141,0,0,0.7203],"73":[0,0.69141,0,0,0.55448],"74":[0.12604,0.69141,0,0,0.55231],"75":[0,0.69141,0,0,0.66845],"76":[0,0.69141,0,0,0.66602],"77":[0,0.69141,0,0,1.04953],"78":[0,0.69141,0,0,0.83212],"79":[0,0.69141,0,0,0.82699],"80":[0.18906,0.69141,0,0,0.82753],"81":[0.03781,0.69141,0,0,0.82699],"82":[0,0.69141,0,0,0.82807],"83":[0,0.69141,0,0,0.82861],"84":[0,0.69141,0,0,0.66899],"85":[0,0.69141,0,0,0.64576],"86":[0,0.69141,0,0,0.83131],"87":[0,0.69141,0,0,1.04602],"88":[0,0.69141,0,0,0.71922],"89":[0.18906,0.69141,0,0,0.83293],"90":[0.12604,0.69141,0,0,0.60201],"91":[0.24982,0.74947,0,0,0.27764],"93":[0.24982,0.74947,0,0,0.27764],"94":[0,0.69141,0,0,0.49965],"97":[0,0.47534,0,0,0.50046],"98":[0,0.69141,0,0,0.51315],"99":[0,0.47534,0,0,0.38946],"100":[0,0.62119,0,0,0.49857],"101":[0,0.47534,0,0,0.40053],"102":[0.18906,0.69141,0,0,0.32626],"103":[0.18906,0.47534,0,0,0.5037],"104":[0.18906,0.69141,0,0,0.52126],"105":[0,0.69141,0,0,0.27899],"106":[0,0.69141,0,0,0.28088],"107":[0,0.69141,0,0,0.38946],"108":[0,0.69141,0,0,0.27953],"109":[0,0.47534,0,0,0.76676],"110":[0,0.47534,0,0,0.52666],"111":[0,0.47534,0,0,0.48885],"112":[0.18906,0.52396,0,0,0.50046],"113":[0.18906,0.47534,0,0,0.48912],"114":[0,0.47534,0,0,0.38919],"115":[0,0.47534,0,0,0.44266],"116":[0,0.62119,0,0,0.33301],"117":[0,0.47534,0,0,0.5172],"118":[0,0.52396,0,0,0.5118],"119":[0,0.52396,0,0,0.77351],"120":[0.18906,0.47534,0,0,0.38865],"121":[0.18906,0.47534,0,0,0.49884],"122":[0.18906,0.47534,0,0,0.39054],"160":[0,0,0,0,0.25],"8216":[0,0.69141,0,0,0.21471],"8217":[0,0.69141,0,0,0.21471],"58112":[0,0.62119,0,0,0.49749],"58113":[0,0.62119,0,0,0.4983],"58114":[0.18906,0.69141,0,0,0.33328],"58115":[0.18906,0.69141,0,0,0.32923],"58116":[0.18906,0.47534,0,0,0.50343],"58117":[0,0.69141,0,0,0.33301],"58118":[0,0.62119,0,0,0.33409],"58119":[0,0.47534,0,0,0.50073]},"Main-Bold":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.35],"34":[0,0.69444,0,0,0.60278],"35":[0.19444,0.69444,0,0,0.95833],"36":[0.05556,0.75,0,0,0.575],"37":[0.05556,0.75,0,0,0.95833],"38":[0,0.69444,0,0,0.89444],"39":[0,0.69444,0,0,0.31944],"40":[0.25,0.75,0,0,0.44722],"41":[0.25,0.75,0,0,0.44722],"42":[0,0.75,0,0,0.575],"43":[0.13333,0.63333,0,0,0.89444],"44":[0.19444,0.15556,0,0,0.31944],"45":[0,0.44444,0,0,0.38333],"46":[0,0.15556,0,0,0.31944],"47":[0.25,0.75,0,0,0.575],"48":[0,0.64444,0,0,0.575],"49":[0,0.64444,0,0,0.575],"50":[0,0.64444,0,0,0.575],"51":[0,0.64444,0,0,0.575],"52":[0,0.64444,0,0,0.575],"53":[0,0.64444,0,0,0.575],"54":[0,0.64444,0,0,0.575],"55":[0,0.64444,0,0,0.575],"56":[0,0.64444,0,0,0.575],"57":[0,0.64444,0,0,0.575],"58":[0,0.44444,0,0,0.31944],"59":[0.19444,0.44444,0,0,0.31944],"60":[0.08556,0.58556,0,0,0.89444],"61":[-0.10889,0.39111,0,0,0.89444],"62":[0.08556,0.58556,0,0,0.89444],"63":[0,0.69444,0,0,0.54305],"64":[0,0.69444,0,0,0.89444],"65":[0,0.68611,0,0,0.86944],"66":[0,0.68611,0,0,0.81805],"67":[0,0.68611,0,0,0.83055],"68":[0,0.68611,0,0,0.88194],"69":[0,0.68611,0,0,0.75555],"70":[0,0.68611,0,0,0.72361],"71":[0,0.68611,0,0,0.90416],"72":[0,0.68611,0,0,0.9],"73":[0,0.68611,0,0,0.43611],"74":[0,0.68611,0,0,0.59444],"75":[0,0.68611,0,0,0.90138],"76":[0,0.68611,0,0,0.69166],"77":[0,0.68611,0,0,1.09166],"78":[0,0.68611,0,0,0.9],"79":[0,0.68611,0,0,0.86388],"80":[0,0.68611,0,0,0.78611],"81":[0.19444,0.68611,0,0,0.86388],"82":[0,0.68611,0,0,0.8625],"83":[0,0.68611,0,0,0.63889],"84":[0,0.68611,0,0,0.8],"85":[0,0.68611,0,0,0.88472],"86":[0,0.68611,0.01597,0,0.86944],"87":[0,0.68611,0.01597,0,1.18888],"88":[0,0.68611,0,0,0.86944],"89":[0,0.68611,0.02875,0,0.86944],"90":[0,0.68611,0,0,0.70277],"91":[0.25,0.75,0,0,0.31944],"92":[0.25,0.75,0,0,0.575],"93":[0.25,0.75,0,0,0.31944],"94":[0,0.69444,0,0,0.575],"95":[0.31,0.13444,0.03194,0,0.575],"97":[0,0.44444,0,0,0.55902],"98":[0,0.69444,0,0,0.63889],"99":[0,0.44444,0,0,0.51111],"100":[0,0.69444,0,0,0.63889],"101":[0,0.44444,0,0,0.52708],"102":[0,0.69444,0.10903,0,0.35139],"103":[0.19444,0.44444,0.01597,0,0.575],"104":[0,0.69444,0,0,0.63889],"105":[0,0.69444,0,0,0.31944],"106":[0.19444,0.69444,0,0,0.35139],"107":[0,0.69444,0,0,0.60694],"108":[0,0.69444,0,0,0.31944],"109":[0,0.44444,0,0,0.95833],"110":[0,0.44444,0,0,0.63889],"111":[0,0.44444,0,0,0.575],"112":[0.19444,0.44444,0,0,0.63889],"113":[0.19444,0.44444,0,0,0.60694],"114":[0,0.44444,0,0,0.47361],"115":[0,0.44444,0,0,0.45361],"116":[0,0.63492,0,0,0.44722],"117":[0,0.44444,0,0,0.63889],"118":[0,0.44444,0.01597,0,0.60694],"119":[0,0.44444,0.01597,0,0.83055],"120":[0,0.44444,0,0,0.60694],"121":[0.19444,0.44444,0.01597,0,0.60694],"122":[0,0.44444,0,0,0.51111],"123":[0.25,0.75,0,0,0.575],"124":[0.25,0.75,0,0,0.31944],"125":[0.25,0.75,0,0,0.575],"126":[0.35,0.34444,0,0,0.575],"160":[0,0,0,0,0.25],"163":[0,0.69444,0,0,0.86853],"168":[0,0.69444,0,0,0.575],"172":[0,0.44444,0,0,0.76666],"176":[0,0.69444,0,0,0.86944],"177":[0.13333,0.63333,0,0,0.89444],"184":[0.17014,0,0,0,0.51111],"198":[0,0.68611,0,0,1.04166],"215":[0.13333,0.63333,0,0,0.89444],"216":[0.04861,0.73472,0,0,0.89444],"223":[0,0.69444,0,0,0.59722],"230":[0,0.44444,0,0,0.83055],"247":[0.13333,0.63333,0,0,0.89444],"248":[0.09722,0.54167,0,0,0.575],"305":[0,0.44444,0,0,0.31944],"338":[0,0.68611,0,0,1.16944],"339":[0,0.44444,0,0,0.89444],"567":[0.19444,0.44444,0,0,0.35139],"710":[0,0.69444,0,0,0.575],"711":[0,0.63194,0,0,0.575],"713":[0,0.59611,0,0,0.575],"714":[0,0.69444,0,0,0.575],"715":[0,0.69444,0,0,0.575],"728":[0,0.69444,0,0,0.575],"729":[0,0.69444,0,0,0.31944],"730":[0,0.69444,0,0,0.86944],"732":[0,0.69444,0,0,0.575],"733":[0,0.69444,0,0,0.575],"915":[0,0.68611,0,0,0.69166],"916":[0,0.68611,0,0,0.95833],"920":[0,0.68611,0,0,0.89444],"923":[0,0.68611,0,0,0.80555],"926":[0,0.68611,0,0,0.76666],"928":[0,0.68611,0,0,0.9],"931":[0,0.68611,0,0,0.83055],"933":[0,0.68611,0,0,0.89444],"934":[0,0.68611,0,0,0.83055],"936":[0,0.68611,0,0,0.89444],"937":[0,0.68611,0,0,0.83055],"8211":[0,0.44444,0.03194,0,0.575],"8212":[0,0.44444,0.03194,0,1.14999],"8216":[0,0.69444,0,0,0.31944],"8217":[0,0.69444,0,0,0.31944],"8220":[0,0.69444,0,0,0.60278],"8221":[0,0.69444,0,0,0.60278],"8224":[0.19444,0.69444,0,0,0.51111],"8225":[0.19444,0.69444,0,0,0.51111],"8242":[0,0.55556,0,0,0.34444],"8407":[0,0.72444,0.15486,0,0.575],"8463":[0,0.69444,0,0,0.66759],"8465":[0,0.69444,0,0,0.83055],"8467":[0,0.69444,0,0,0.47361],"8472":[0.19444,0.44444,0,0,0.74027],"8476":[0,0.69444,0,0,0.83055],"8501":[0,0.69444,0,0,0.70277],"8592":[-0.10889,0.39111,0,0,1.14999],"8593":[0.19444,0.69444,0,0,0.575],"8594":[-0.10889,0.39111,0,0,1.14999],"8595":[0.19444,0.69444,0,0,0.575],"8596":[-0.10889,0.39111,0,0,1.14999],"8597":[0.25,0.75,0,0,0.575],"8598":[0.19444,0.69444,0,0,1.14999],"8599":[0.19444,0.69444,0,0,1.14999],"8600":[0.19444,0.69444,0,0,1.14999],"8601":[0.19444,0.69444,0,0,1.14999],"8636":[-0.10889,0.39111,0,0,1.14999],"8637":[-0.10889,0.39111,0,0,1.14999],"8640":[-0.10889,0.39111,0,0,1.14999],"8641":[-0.10889,0.39111,0,0,1.14999],"8656":[-0.10889,0.39111,0,0,1.14999],"8657":[0.19444,0.69444,0,0,0.70277],"8658":[-0.10889,0.39111,0,0,1.14999],"8659":[0.19444,0.69444,0,0,0.70277],"8660":[-0.10889,0.39111,0,0,1.14999],"8661":[0.25,0.75,0,0,0.70277],"8704":[0,0.69444,0,0,0.63889],"8706":[0,0.69444,0.06389,0,0.62847],"8707":[0,0.69444,0,0,0.63889],"8709":[0.05556,0.75,0,0,0.575],"8711":[0,0.68611,0,0,0.95833],"8712":[0.08556,0.58556,0,0,0.76666],"8715":[0.08556,0.58556,0,0,0.76666],"8722":[0.13333,0.63333,0,0,0.89444],"8723":[0.13333,0.63333,0,0,0.89444],"8725":[0.25,0.75,0,0,0.575],"8726":[0.25,0.75,0,0,0.575],"8727":[-0.02778,0.47222,0,0,0.575],"8728":[-0.02639,0.47361,0,0,0.575],"8729":[-0.02639,0.47361,0,0,0.575],"8730":[0.18,0.82,0,0,0.95833],"8733":[0,0.44444,0,0,0.89444],"8734":[0,0.44444,0,0,1.14999],"8736":[0,0.69224,0,0,0.72222],"8739":[0.25,0.75,0,0,0.31944],"8741":[0.25,0.75,0,0,0.575],"8743":[0,0.55556,0,0,0.76666],"8744":[0,0.55556,0,0,0.76666],"8745":[0,0.55556,0,0,0.76666],"8746":[0,0.55556,0,0,0.76666],"8747":[0.19444,0.69444,0.12778,0,0.56875],"8764":[-0.10889,0.39111,0,0,0.89444],"8768":[0.19444,0.69444,0,0,0.31944],"8771":[0.00222,0.50222,0,0,0.89444],"8776":[0.02444,0.52444,0,0,0.89444],"8781":[0.00222,0.50222,0,0,0.89444],"8801":[0.00222,0.50222,0,0,0.89444],"8804":[0.19667,0.69667,0,0,0.89444],"8805":[0.19667,0.69667,0,0,0.89444],"8810":[0.08556,0.58556,0,0,1.14999],"8811":[0.08556,0.58556,0,0,1.14999],"8826":[0.08556,0.58556,0,0,0.89444],"8827":[0.08556,0.58556,0,0,0.89444],"8834":[0.08556,0.58556,0,0,0.89444],"8835":[0.08556,0.58556,0,0,0.89444],"8838":[0.19667,0.69667,0,0,0.89444],"8839":[0.19667,0.69667,0,0,0.89444],"8846":[0,0.55556,0,0,0.76666],"8849":[0.19667,0.69667,0,0,0.89444],"8850":[0.19667,0.69667,0,0,0.89444],"8851":[0,0.55556,0,0,0.76666],"8852":[0,0.55556,0,0,0.76666],"8853":[0.13333,0.63333,0,0,0.89444],"8854":[0.13333,0.63333,0,0,0.89444],"8855":[0.13333,0.63333,0,0,0.89444],"8856":[0.13333,0.63333,0,0,0.89444],"8857":[0.13333,0.63333,0,0,0.89444],"8866":[0,0.69444,0,0,0.70277],"8867":[0,0.69444,0,0,0.70277],"8868":[0,0.69444,0,0,0.89444],"8869":[0,0.69444,0,0,0.89444],"8900":[-0.02639,0.47361,0,0,0.575],"8901":[-0.02639,0.47361,0,0,0.31944],"8902":[-0.02778,0.47222,0,0,0.575],"8968":[0.25,0.75,0,0,0.51111],"8969":[0.25,0.75,0,0,0.51111],"8970":[0.25,0.75,0,0,0.51111],"8971":[0.25,0.75,0,0,0.51111],"8994":[-0.13889,0.36111,0,0,1.14999],"8995":[-0.13889,0.36111,0,0,1.14999],"9651":[0.19444,0.69444,0,0,1.02222],"9657":[-0.02778,0.47222,0,0,0.575],"9661":[0.19444,0.69444,0,0,1.02222],"9667":[-0.02778,0.47222,0,0,0.575],"9711":[0.19444,0.69444,0,0,1.14999],"9824":[0.12963,0.69444,0,0,0.89444],"9825":[0.12963,0.69444,0,0,0.89444],"9826":[0.12963,0.69444,0,0,0.89444],"9827":[0.12963,0.69444,0,0,0.89444],"9837":[0,0.75,0,0,0.44722],"9838":[0.19444,0.69444,0,0,0.44722],"9839":[0.19444,0.69444,0,0,0.44722],"10216":[0.25,0.75,0,0,0.44722],"10217":[0.25,0.75,0,0,0.44722],"10815":[0,0.68611,0,0,0.9],"10927":[0.19667,0.69667,0,0,0.89444],"10928":[0.19667,0.69667,0,0,0.89444],"57376":[0.19444,0.69444,0,0,0]},"Main-BoldItalic":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0.11417,0,0.38611],"34":[0,0.69444,0.07939,0,0.62055],"35":[0.19444,0.69444,0.06833,0,0.94444],"37":[0.05556,0.75,0.12861,0,0.94444],"38":[0,0.69444,0.08528,0,0.88555],"39":[0,0.69444,0.12945,0,0.35555],"40":[0.25,0.75,0.15806,0,0.47333],"41":[0.25,0.75,0.03306,0,0.47333],"42":[0,0.75,0.14333,0,0.59111],"43":[0.10333,0.60333,0.03306,0,0.88555],"44":[0.19444,0.14722,0,0,0.35555],"45":[0,0.44444,0.02611,0,0.41444],"46":[0,0.14722,0,0,0.35555],"47":[0.25,0.75,0.15806,0,0.59111],"48":[0,0.64444,0.13167,0,0.59111],"49":[0,0.64444,0.13167,0,0.59111],"50":[0,0.64444,0.13167,0,0.59111],"51":[0,0.64444,0.13167,0,0.59111],"52":[0.19444,0.64444,0.13167,0,0.59111],"53":[0,0.64444,0.13167,0,0.59111],"54":[0,0.64444,0.13167,0,0.59111],"55":[0.19444,0.64444,0.13167,0,0.59111],"56":[0,0.64444,0.13167,0,0.59111],"57":[0,0.64444,0.13167,0,0.59111],"58":[0,0.44444,0.06695,0,0.35555],"59":[0.19444,0.44444,0.06695,0,0.35555],"61":[-0.10889,0.39111,0.06833,0,0.88555],"63":[0,0.69444,0.11472,0,0.59111],"64":[0,0.69444,0.09208,0,0.88555],"65":[0,0.68611,0,0,0.86555],"66":[0,0.68611,0.0992,0,0.81666],"67":[0,0.68611,0.14208,0,0.82666],"68":[0,0.68611,0.09062,0,0.87555],"69":[0,0.68611,0.11431,0,0.75666],"70":[0,0.68611,0.12903,0,0.72722],"71":[0,0.68611,0.07347,0,0.89527],"72":[0,0.68611,0.17208,0,0.8961],"73":[0,0.68611,0.15681,0,0.47166],"74":[0,0.68611,0.145,0,0.61055],"75":[0,0.68611,0.14208,0,0.89499],"76":[0,0.68611,0,0,0.69777],"77":[0,0.68611,0.17208,0,1.07277],"78":[0,0.68611,0.17208,0,0.8961],"79":[0,0.68611,0.09062,0,0.85499],"80":[0,0.68611,0.0992,0,0.78721],"81":[0.19444,0.68611,0.09062,0,0.85499],"82":[0,0.68611,0.02559,0,0.85944],"83":[0,0.68611,0.11264,0,0.64999],"84":[0,0.68611,0.12903,0,0.7961],"85":[0,0.68611,0.17208,0,0.88083],"86":[0,0.68611,0.18625,0,0.86555],"87":[0,0.68611,0.18625,0,1.15999],"88":[0,0.68611,0.15681,0,0.86555],"89":[0,0.68611,0.19803,0,0.86555],"90":[0,0.68611,0.14208,0,0.70888],"91":[0.25,0.75,0.1875,0,0.35611],"93":[0.25,0.75,0.09972,0,0.35611],"94":[0,0.69444,0.06709,0,0.59111],"95":[0.31,0.13444,0.09811,0,0.59111],"97":[0,0.44444,0.09426,0,0.59111],"98":[0,0.69444,0.07861,0,0.53222],"99":[0,0.44444,0.05222,0,0.53222],"100":[0,0.69444,0.10861,0,0.59111],"101":[0,0.44444,0.085,0,0.53222],"102":[0.19444,0.69444,0.21778,0,0.4],"103":[0.19444,0.44444,0.105,0,0.53222],"104":[0,0.69444,0.09426,0,0.59111],"105":[0,0.69326,0.11387,0,0.35555],"106":[0.19444,0.69326,0.1672,0,0.35555],"107":[0,0.69444,0.11111,0,0.53222],"108":[0,0.69444,0.10861,0,0.29666],"109":[0,0.44444,0.09426,0,0.94444],"110":[0,0.44444,0.09426,0,0.64999],"111":[0,0.44444,0.07861,0,0.59111],"112":[0.19444,0.44444,0.07861,0,0.59111],"113":[0.19444,0.44444,0.105,0,0.53222],"114":[0,0.44444,0.11111,0,0.50167],"115":[0,0.44444,0.08167,0,0.48694],"116":[0,0.63492,0.09639,0,0.385],"117":[0,0.44444,0.09426,0,0.62055],"118":[0,0.44444,0.11111,0,0.53222],"119":[0,0.44444,0.11111,0,0.76777],"120":[0,0.44444,0.12583,0,0.56055],"121":[0.19444,0.44444,0.105,0,0.56166],"122":[0,0.44444,0.13889,0,0.49055],"126":[0.35,0.34444,0.11472,0,0.59111],"160":[0,0,0,0,0.25],"168":[0,0.69444,0.11473,0,0.59111],"176":[0,0.69444,0,0,0.94888],"184":[0.17014,0,0,0,0.53222],"198":[0,0.68611,0.11431,0,1.02277],"216":[0.04861,0.73472,0.09062,0,0.88555],"223":[0.19444,0.69444,0.09736,0,0.665],"230":[0,0.44444,0.085,0,0.82666],"248":[0.09722,0.54167,0.09458,0,0.59111],"305":[0,0.44444,0.09426,0,0.35555],"338":[0,0.68611,0.11431,0,1.14054],"339":[0,0.44444,0.085,0,0.82666],"567":[0.19444,0.44444,0.04611,0,0.385],"710":[0,0.69444,0.06709,0,0.59111],"711":[0,0.63194,0.08271,0,0.59111],"713":[0,0.59444,0.10444,0,0.59111],"714":[0,0.69444,0.08528,0,0.59111],"715":[0,0.69444,0,0,0.59111],"728":[0,0.69444,0.10333,0,0.59111],"729":[0,0.69444,0.12945,0,0.35555],"730":[0,0.69444,0,0,0.94888],"732":[0,0.69444,0.11472,0,0.59111],"733":[0,0.69444,0.11472,0,0.59111],"915":[0,0.68611,0.12903,0,0.69777],"916":[0,0.68611,0,0,0.94444],"920":[0,0.68611,0.09062,0,0.88555],"923":[0,0.68611,0,0,0.80666],"926":[0,0.68611,0.15092,0,0.76777],"928":[0,0.68611,0.17208,0,0.8961],"931":[0,0.68611,0.11431,0,0.82666],"933":[0,0.68611,0.10778,0,0.88555],"934":[0,0.68611,0.05632,0,0.82666],"936":[0,0.68611,0.10778,0,0.88555],"937":[0,0.68611,0.0992,0,0.82666],"8211":[0,0.44444,0.09811,0,0.59111],"8212":[0,0.44444,0.09811,0,1.18221],"8216":[0,0.69444,0.12945,0,0.35555],"8217":[0,0.69444,0.12945,0,0.35555],"8220":[0,0.69444,0.16772,0,0.62055],"8221":[0,0.69444,0.07939,0,0.62055]},"Main-Italic":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0.12417,0,0.30667],"34":[0,0.69444,0.06961,0,0.51444],"35":[0.19444,0.69444,0.06616,0,0.81777],"37":[0.05556,0.75,0.13639,0,0.81777],"38":[0,0.69444,0.09694,0,0.76666],"39":[0,0.69444,0.12417,0,0.30667],"40":[0.25,0.75,0.16194,0,0.40889],"41":[0.25,0.75,0.03694,0,0.40889],"42":[0,0.75,0.14917,0,0.51111],"43":[0.05667,0.56167,0.03694,0,0.76666],"44":[0.19444,0.10556,0,0,0.30667],"45":[0,0.43056,0.02826,0,0.35778],"46":[0,0.10556,0,0,0.30667],"47":[0.25,0.75,0.16194,0,0.51111],"48":[0,0.64444,0.13556,0,0.51111],"49":[0,0.64444,0.13556,0,0.51111],"50":[0,0.64444,0.13556,0,0.51111],"51":[0,0.64444,0.13556,0,0.51111],"52":[0.19444,0.64444,0.13556,0,0.51111],"53":[0,0.64444,0.13556,0,0.51111],"54":[0,0.64444,0.13556,0,0.51111],"55":[0.19444,0.64444,0.13556,0,0.51111],"56":[0,0.64444,0.13556,0,0.51111],"57":[0,0.64444,0.13556,0,0.51111],"58":[0,0.43056,0.0582,0,0.30667],"59":[0.19444,0.43056,0.0582,0,0.30667],"61":[-0.13313,0.36687,0.06616,0,0.76666],"63":[0,0.69444,0.1225,0,0.51111],"64":[0,0.69444,0.09597,0,0.76666],"65":[0,0.68333,0,0,0.74333],"66":[0,0.68333,0.10257,0,0.70389],"67":[0,0.68333,0.14528,0,0.71555],"68":[0,0.68333,0.09403,0,0.755],"69":[0,0.68333,0.12028,0,0.67833],"70":[0,0.68333,0.13305,0,0.65277],"71":[0,0.68333,0.08722,0,0.77361],"72":[0,0.68333,0.16389,0,0.74333],"73":[0,0.68333,0.15806,0,0.38555],"74":[0,0.68333,0.14028,0,0.525],"75":[0,0.68333,0.14528,0,0.76888],"76":[0,0.68333,0,0,0.62722],"77":[0,0.68333,0.16389,0,0.89666],"78":[0,0.68333,0.16389,0,0.74333],"79":[0,0.68333,0.09403,0,0.76666],"80":[0,0.68333,0.10257,0,0.67833],"81":[0.19444,0.68333,0.09403,0,0.76666],"82":[0,0.68333,0.03868,0,0.72944],"83":[0,0.68333,0.11972,0,0.56222],"84":[0,0.68333,0.13305,0,0.71555],"85":[0,0.68333,0.16389,0,0.74333],"86":[0,0.68333,0.18361,0,0.74333],"87":[0,0.68333,0.18361,0,0.99888],"88":[0,0.68333,0.15806,0,0.74333],"89":[0,0.68333,0.19383,0,0.74333],"90":[0,0.68333,0.14528,0,0.61333],"91":[0.25,0.75,0.1875,0,0.30667],"93":[0.25,0.75,0.10528,0,0.30667],"94":[0,0.69444,0.06646,0,0.51111],"95":[0.31,0.12056,0.09208,0,0.51111],"97":[0,0.43056,0.07671,0,0.51111],"98":[0,0.69444,0.06312,0,0.46],"99":[0,0.43056,0.05653,0,0.46],"100":[0,0.69444,0.10333,0,0.51111],"101":[0,0.43056,0.07514,0,0.46],"102":[0.19444,0.69444,0.21194,0,0.30667],"103":[0.19444,0.43056,0.08847,0,0.46],"104":[0,0.69444,0.07671,0,0.51111],"105":[0,0.65536,0.1019,0,0.30667],"106":[0.19444,0.65536,0.14467,0,0.30667],"107":[0,0.69444,0.10764,0,0.46],"108":[0,0.69444,0.10333,0,0.25555],"109":[0,0.43056,0.07671,0,0.81777],"110":[0,0.43056,0.07671,0,0.56222],"111":[0,0.43056,0.06312,0,0.51111],"112":[0.19444,0.43056,0.06312,0,0.51111],"113":[0.19444,0.43056,0.08847,0,0.46],"114":[0,0.43056,0.10764,0,0.42166],"115":[0,0.43056,0.08208,0,0.40889],"116":[0,0.61508,0.09486,0,0.33222],"117":[0,0.43056,0.07671,0,0.53666],"118":[0,0.43056,0.10764,0,0.46],"119":[0,0.43056,0.10764,0,0.66444],"120":[0,0.43056,0.12042,0,0.46389],"121":[0.19444,0.43056,0.08847,0,0.48555],"122":[0,0.43056,0.12292,0,0.40889],"126":[0.35,0.31786,0.11585,0,0.51111],"160":[0,0,0,0,0.25],"168":[0,0.66786,0.10474,0,0.51111],"176":[0,0.69444,0,0,0.83129],"184":[0.17014,0,0,0,0.46],"198":[0,0.68333,0.12028,0,0.88277],"216":[0.04861,0.73194,0.09403,0,0.76666],"223":[0.19444,0.69444,0.10514,0,0.53666],"230":[0,0.43056,0.07514,0,0.71555],"248":[0.09722,0.52778,0.09194,0,0.51111],"338":[0,0.68333,0.12028,0,0.98499],"339":[0,0.43056,0.07514,0,0.71555],"710":[0,0.69444,0.06646,0,0.51111],"711":[0,0.62847,0.08295,0,0.51111],"713":[0,0.56167,0.10333,0,0.51111],"714":[0,0.69444,0.09694,0,0.51111],"715":[0,0.69444,0,0,0.51111],"728":[0,0.69444,0.10806,0,0.51111],"729":[0,0.66786,0.11752,0,0.30667],"730":[0,0.69444,0,0,0.83129],"732":[0,0.66786,0.11585,0,0.51111],"733":[0,0.69444,0.1225,0,0.51111],"915":[0,0.68333,0.13305,0,0.62722],"916":[0,0.68333,0,0,0.81777],"920":[0,0.68333,0.09403,0,0.76666],"923":[0,0.68333,0,0,0.69222],"926":[0,0.68333,0.15294,0,0.66444],"928":[0,0.68333,0.16389,0,0.74333],"931":[0,0.68333,0.12028,0,0.71555],"933":[0,0.68333,0.11111,0,0.76666],"934":[0,0.68333,0.05986,0,0.71555],"936":[0,0.68333,0.11111,0,0.76666],"937":[0,0.68333,0.10257,0,0.71555],"8211":[0,0.43056,0.09208,0,0.51111],"8212":[0,0.43056,0.09208,0,1.02222],"8216":[0,0.69444,0.12417,0,0.30667],"8217":[0,0.69444,0.12417,0,0.30667],"8220":[0,0.69444,0.1685,0,0.51444],"8221":[0,0.69444,0.06961,0,0.51444],"8463":[0,0.68889,0,0,0.54028]},"Main-Regular":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.27778],"34":[0,0.69444,0,0,0.5],"35":[0.19444,0.69444,0,0,0.83334],"36":[0.05556,0.75,0,0,0.5],"37":[0.05556,0.75,0,0,0.83334],"38":[0,0.69444,0,0,0.77778],"39":[0,0.69444,0,0,0.27778],"40":[0.25,0.75,0,0,0.38889],"41":[0.25,0.75,0,0,0.38889],"42":[0,0.75,0,0,0.5],"43":[0.08333,0.58333,0,0,0.77778],"44":[0.19444,0.10556,0,0,0.27778],"45":[0,0.43056,0,0,0.33333],"46":[0,0.10556,0,0,0.27778],"47":[0.25,0.75,0,0,0.5],"48":[0,0.64444,0,0,0.5],"49":[0,0.64444,0,0,0.5],"50":[0,0.64444,0,0,0.5],"51":[0,0.64444,0,0,0.5],"52":[0,0.64444,0,0,0.5],"53":[0,0.64444,0,0,0.5],"54":[0,0.64444,0,0,0.5],"55":[0,0.64444,0,0,0.5],"56":[0,0.64444,0,0,0.5],"57":[0,0.64444,0,0,0.5],"58":[0,0.43056,0,0,0.27778],"59":[0.19444,0.43056,0,0,0.27778],"60":[0.0391,0.5391,0,0,0.77778],"61":[-0.13313,0.36687,0,0,0.77778],"62":[0.0391,0.5391,0,0,0.77778],"63":[0,0.69444,0,0,0.47222],"64":[0,0.69444,0,0,0.77778],"65":[0,0.68333,0,0,0.75],"66":[0,0.68333,0,0,0.70834],"67":[0,0.68333,0,0,0.72222],"68":[0,0.68333,0,0,0.76389],"69":[0,0.68333,0,0,0.68056],"70":[0,0.68333,0,0,0.65278],"71":[0,0.68333,0,0,0.78472],"72":[0,0.68333,0,0,0.75],"73":[0,0.68333,0,0,0.36111],"74":[0,0.68333,0,0,0.51389],"75":[0,0.68333,0,0,0.77778],"76":[0,0.68333,0,0,0.625],"77":[0,0.68333,0,0,0.91667],"78":[0,0.68333,0,0,0.75],"79":[0,0.68333,0,0,0.77778],"80":[0,0.68333,0,0,0.68056],"81":[0.19444,0.68333,0,0,0.77778],"82":[0,0.68333,0,0,0.73611],"83":[0,0.68333,0,0,0.55556],"84":[0,0.68333,0,0,0.72222],"85":[0,0.68333,0,0,0.75],"86":[0,0.68333,0.01389,0,0.75],"87":[0,0.68333,0.01389,0,1.02778],"88":[0,0.68333,0,0,0.75],"89":[0,0.68333,0.025,0,0.75],"90":[0,0.68333,0,0,0.61111],"91":[0.25,0.75,0,0,0.27778],"92":[0.25,0.75,0,0,0.5],"93":[0.25,0.75,0,0,0.27778],"94":[0,0.69444,0,0,0.5],"95":[0.31,0.12056,0.02778,0,0.5],"97":[0,0.43056,0,0,0.5],"98":[0,0.69444,0,0,0.55556],"99":[0,0.43056,0,0,0.44445],"100":[0,0.69444,0,0,0.55556],"101":[0,0.43056,0,0,0.44445],"102":[0,0.69444,0.07778,0,0.30556],"103":[0.19444,0.43056,0.01389,0,0.5],"104":[0,0.69444,0,0,0.55556],"105":[0,0.66786,0,0,0.27778],"106":[0.19444,0.66786,0,0,0.30556],"107":[0,0.69444,0,0,0.52778],"108":[0,0.69444,0,0,0.27778],"109":[0,0.43056,0,0,0.83334],"110":[0,0.43056,0,0,0.55556],"111":[0,0.43056,0,0,0.5],"112":[0.19444,0.43056,0,0,0.55556],"113":[0.19444,0.43056,0,0,0.52778],"114":[0,0.43056,0,0,0.39167],"115":[0,0.43056,0,0,0.39445],"116":[0,0.61508,0,0,0.38889],"117":[0,0.43056,0,0,0.55556],"118":[0,0.43056,0.01389,0,0.52778],"119":[0,0.43056,0.01389,0,0.72222],"120":[0,0.43056,0,0,0.52778],"121":[0.19444,0.43056,0.01389,0,0.52778],"122":[0,0.43056,0,0,0.44445],"123":[0.25,0.75,0,0,0.5],"124":[0.25,0.75,0,0,0.27778],"125":[0.25,0.75,0,0,0.5],"126":[0.35,0.31786,0,0,0.5],"160":[0,0,0,0,0.25],"163":[0,0.69444,0,0,0.76909],"167":[0.19444,0.69444,0,0,0.44445],"168":[0,0.66786,0,0,0.5],"172":[0,0.43056,0,0,0.66667],"176":[0,0.69444,0,0,0.75],"177":[0.08333,0.58333,0,0,0.77778],"182":[0.19444,0.69444,0,0,0.61111],"184":[0.17014,0,0,0,0.44445],"198":[0,0.68333,0,0,0.90278],"215":[0.08333,0.58333,0,0,0.77778],"216":[0.04861,0.73194,0,0,0.77778],"223":[0,0.69444,0,0,0.5],"230":[0,0.43056,0,0,0.72222],"247":[0.08333,0.58333,0,0,0.77778],"248":[0.09722,0.52778,0,0,0.5],"305":[0,0.43056,0,0,0.27778],"338":[0,0.68333,0,0,1.01389],"339":[0,0.43056,0,0,0.77778],"567":[0.19444,0.43056,0,0,0.30556],"710":[0,0.69444,0,0,0.5],"711":[0,0.62847,0,0,0.5],"713":[0,0.56778,0,0,0.5],"714":[0,0.69444,0,0,0.5],"715":[0,0.69444,0,0,0.5],"728":[0,0.69444,0,0,0.5],"729":[0,0.66786,0,0,0.27778],"730":[0,0.69444,0,0,0.75],"732":[0,0.66786,0,0,0.5],"733":[0,0.69444,0,0,0.5],"915":[0,0.68333,0,0,0.625],"916":[0,0.68333,0,0,0.83334],"920":[0,0.68333,0,0,0.77778],"923":[0,0.68333,0,0,0.69445],"926":[0,0.68333,0,0,0.66667],"928":[0,0.68333,0,0,0.75],"931":[0,0.68333,0,0,0.72222],"933":[0,0.68333,0,0,0.77778],"934":[0,0.68333,0,0,0.72222],"936":[0,0.68333,0,0,0.77778],"937":[0,0.68333,0,0,0.72222],"8211":[0,0.43056,0.02778,0,0.5],"8212":[0,0.43056,0.02778,0,1.0],"8216":[0,0.69444,0,0,0.27778],"8217":[0,0.69444,0,0,0.27778],"8220":[0,0.69444,0,0,0.5],"8221":[0,0.69444,0,0,0.5],"8224":[0.19444,0.69444,0,0,0.44445],"8225":[0.19444,0.69444,0,0,0.44445],"8230":[0,0.12,0,0,1.172],"8242":[0,0.55556,0,0,0.275],"8407":[0,0.71444,0.15382,0,0.5],"8463":[0,0.68889,0,0,0.54028],"8465":[0,0.69444,0,0,0.72222],"8467":[0,0.69444,0,0.11111,0.41667],"8472":[0.19444,0.43056,0,0.11111,0.63646],"8476":[0,0.69444,0,0,0.72222],"8501":[0,0.69444,0,0,0.61111],"8592":[-0.13313,0.36687,0,0,1.0],"8593":[0.19444,0.69444,0,0,0.5],"8594":[-0.13313,0.36687,0,0,1.0],"8595":[0.19444,0.69444,0,0,0.5],"8596":[-0.13313,0.36687,0,0,1.0],"8597":[0.25,0.75,0,0,0.5],"8598":[0.19444,0.69444,0,0,1.0],"8599":[0.19444,0.69444,0,0,1.0],"8600":[0.19444,0.69444,0,0,1.0],"8601":[0.19444,0.69444,0,0,1.0],"8614":[0.011,0.511,0,0,1.0],"8617":[0.011,0.511,0,0,1.126],"8618":[0.011,0.511,0,0,1.126],"8636":[-0.13313,0.36687,0,0,1.0],"8637":[-0.13313,0.36687,0,0,1.0],"8640":[-0.13313,0.36687,0,0,1.0],"8641":[-0.13313,0.36687,0,0,1.0],"8652":[0.011,0.671,0,0,1.0],"8656":[-0.13313,0.36687,0,0,1.0],"8657":[0.19444,0.69444,0,0,0.61111],"8658":[-0.13313,0.36687,0,0,1.0],"8659":[0.19444,0.69444,0,0,0.61111],"8660":[-0.13313,0.36687,0,0,1.0],"8661":[0.25,0.75,0,0,0.61111],"8704":[0,0.69444,0,0,0.55556],"8706":[0,0.69444,0.05556,0.08334,0.5309],"8707":[0,0.69444,0,0,0.55556],"8709":[0.05556,0.75,0,0,0.5],"8711":[0,0.68333,0,0,0.83334],"8712":[0.0391,0.5391,0,0,0.66667],"8715":[0.0391,0.5391,0,0,0.66667],"8722":[0.08333,0.58333,0,0,0.77778],"8723":[0.08333,0.58333,0,0,0.77778],"8725":[0.25,0.75,0,0,0.5],"8726":[0.25,0.75,0,0,0.5],"8727":[-0.03472,0.46528,0,0,0.5],"8728":[-0.05555,0.44445,0,0,0.5],"8729":[-0.05555,0.44445,0,0,0.5],"8730":[0.2,0.8,0,0,0.83334],"8733":[0,0.43056,0,0,0.77778],"8734":[0,0.43056,0,0,1.0],"8736":[0,0.69224,0,0,0.72222],"8739":[0.25,0.75,0,0,0.27778],"8741":[0.25,0.75,0,0,0.5],"8743":[0,0.55556,0,0,0.66667],"8744":[0,0.55556,0,0,0.66667],"8745":[0,0.55556,0,0,0.66667],"8746":[0,0.55556,0,0,0.66667],"8747":[0.19444,0.69444,0.11111,0,0.41667],"8764":[-0.13313,0.36687,0,0,0.77778],"8768":[0.19444,0.69444,0,0,0.27778],"8771":[-0.03625,0.46375,0,0,0.77778],"8773":[-0.022,0.589,0,0,1.0],"8776":[-0.01688,0.48312,0,0,0.77778],"8781":[-0.03625,0.46375,0,0,0.77778],"8784":[-0.133,0.67,0,0,0.778],"8801":[-0.03625,0.46375,0,0,0.77778],"8804":[0.13597,0.63597,0,0,0.77778],"8805":[0.13597,0.63597,0,0,0.77778],"8810":[0.0391,0.5391,0,0,1.0],"8811":[0.0391,0.5391,0,0,1.0],"8826":[0.0391,0.5391,0,0,0.77778],"8827":[0.0391,0.5391,0,0,0.77778],"8834":[0.0391,0.5391,0,0,0.77778],"8835":[0.0391,0.5391,0,0,0.77778],"8838":[0.13597,0.63597,0,0,0.77778],"8839":[0.13597,0.63597,0,0,0.77778],"8846":[0,0.55556,0,0,0.66667],"8849":[0.13597,0.63597,0,0,0.77778],"8850":[0.13597,0.63597,0,0,0.77778],"8851":[0,0.55556,0,0,0.66667],"8852":[0,0.55556,0,0,0.66667],"8853":[0.08333,0.58333,0,0,0.77778],"8854":[0.08333,0.58333,0,0,0.77778],"8855":[0.08333,0.58333,0,0,0.77778],"8856":[0.08333,0.58333,0,0,0.77778],"8857":[0.08333,0.58333,0,0,0.77778],"8866":[0,0.69444,0,0,0.61111],"8867":[0,0.69444,0,0,0.61111],"8868":[0,0.69444,0,0,0.77778],"8869":[0,0.69444,0,0,0.77778],"8872":[0.249,0.75,0,0,0.867],"8900":[-0.05555,0.44445,0,0,0.5],"8901":[-0.05555,0.44445,0,0,0.27778],"8902":[-0.03472,0.46528,0,0,0.5],"8904":[0.005,0.505,0,0,0.9],"8942":[0.03,0.9,0,0,0.278],"8943":[-0.19,0.31,0,0,1.172],"8945":[-0.1,0.82,0,0,1.282],"8968":[0.25,0.75,0,0,0.44445],"8969":[0.25,0.75,0,0,0.44445],"8970":[0.25,0.75,0,0,0.44445],"8971":[0.25,0.75,0,0,0.44445],"8994":[-0.14236,0.35764,0,0,1.0],"8995":[-0.14236,0.35764,0,0,1.0],"9136":[0.244,0.744,0,0,0.412],"9137":[0.244,0.744,0,0,0.412],"9651":[0.19444,0.69444,0,0,0.88889],"9657":[-0.03472,0.46528,0,0,0.5],"9661":[0.19444,0.69444,0,0,0.88889],"9667":[-0.03472,0.46528,0,0,0.5],"9711":[0.19444,0.69444,0,0,1.0],"9824":[0.12963,0.69444,0,0,0.77778],"9825":[0.12963,0.69444,0,0,0.77778],"9826":[0.12963,0.69444,0,0,0.77778],"9827":[0.12963,0.69444,0,0,0.77778],"9837":[0,0.75,0,0,0.38889],"9838":[0.19444,0.69444,0,0,0.38889],"9839":[0.19444,0.69444,0,0,0.38889],"10216":[0.25,0.75,0,0,0.38889],"10217":[0.25,0.75,0,0,0.38889],"10222":[0.244,0.744,0,0,0.412],"10223":[0.244,0.744,0,0,0.412],"10229":[0.011,0.511,0,0,1.609],"10230":[0.011,0.511,0,0,1.638],"10231":[0.011,0.511,0,0,1.859],"10232":[0.024,0.525,0,0,1.609],"10233":[0.024,0.525,0,0,1.638],"10234":[0.024,0.525,0,0,1.858],"10236":[0.011,0.511,0,0,1.638],"10815":[0,0.68333,0,0,0.75],"10927":[0.13597,0.63597,0,0,0.77778],"10928":[0.13597,0.63597,0,0,0.77778],"57376":[0.19444,0.69444,0,0,0]},"Math-BoldItalic":{"32":[0,0,0,0,0.25],"48":[0,0.44444,0,0,0.575],"49":[0,0.44444,0,0,0.575],"50":[0,0.44444,0,0,0.575],"51":[0.19444,0.44444,0,0,0.575],"52":[0.19444,0.44444,0,0,0.575],"53":[0.19444,0.44444,0,0,0.575],"54":[0,0.64444,0,0,0.575],"55":[0.19444,0.44444,0,0,0.575],"56":[0,0.64444,0,0,0.575],"57":[0.19444,0.44444,0,0,0.575],"65":[0,0.68611,0,0,0.86944],"66":[0,0.68611,0.04835,0,0.8664],"67":[0,0.68611,0.06979,0,0.81694],"68":[0,0.68611,0.03194,0,0.93812],"69":[0,0.68611,0.05451,0,0.81007],"70":[0,0.68611,0.15972,0,0.68889],"71":[0,0.68611,0,0,0.88673],"72":[0,0.68611,0.08229,0,0.98229],"73":[0,0.68611,0.07778,0,0.51111],"74":[0,0.68611,0.10069,0,0.63125],"75":[0,0.68611,0.06979,0,0.97118],"76":[0,0.68611,0,0,0.75555],"77":[0,0.68611,0.11424,0,1.14201],"78":[0,0.68611,0.11424,0,0.95034],"79":[0,0.68611,0.03194,0,0.83666],"80":[0,0.68611,0.15972,0,0.72309],"81":[0.19444,0.68611,0,0,0.86861],"82":[0,0.68611,0.00421,0,0.87235],"83":[0,0.68611,0.05382,0,0.69271],"84":[0,0.68611,0.15972,0,0.63663],"85":[0,0.68611,0.11424,0,0.80027],"86":[0,0.68611,0.25555,0,0.67778],"87":[0,0.68611,0.15972,0,1.09305],"88":[0,0.68611,0.07778,0,0.94722],"89":[0,0.68611,0.25555,0,0.67458],"90":[0,0.68611,0.06979,0,0.77257],"97":[0,0.44444,0,0,0.63287],"98":[0,0.69444,0,0,0.52083],"99":[0,0.44444,0,0,0.51342],"100":[0,0.69444,0,0,0.60972],"101":[0,0.44444,0,0,0.55361],"102":[0.19444,0.69444,0.11042,0,0.56806],"103":[0.19444,0.44444,0.03704,0,0.5449],"104":[0,0.69444,0,0,0.66759],"105":[0,0.69326,0,0,0.4048],"106":[0.19444,0.69326,0.0622,0,0.47083],"107":[0,0.69444,0.01852,0,0.6037],"108":[0,0.69444,0.0088,0,0.34815],"109":[0,0.44444,0,0,1.0324],"110":[0,0.44444,0,0,0.71296],"111":[0,0.44444,0,0,0.58472],"112":[0.19444,0.44444,0,0,0.60092],"113":[0.19444,0.44444,0.03704,0,0.54213],"114":[0,0.44444,0.03194,0,0.5287],"115":[0,0.44444,0,0,0.53125],"116":[0,0.63492,0,0,0.41528],"117":[0,0.44444,0,0,0.68102],"118":[0,0.44444,0.03704,0,0.56666],"119":[0,0.44444,0.02778,0,0.83148],"120":[0,0.44444,0,0,0.65903],"121":[0.19444,0.44444,0.03704,0,0.59028],"122":[0,0.44444,0.04213,0,0.55509],"160":[0,0,0,0,0.25],"915":[0,0.68611,0.15972,0,0.65694],"916":[0,0.68611,0,0,0.95833],"920":[0,0.68611,0.03194,0,0.86722],"923":[0,0.68611,0,0,0.80555],"926":[0,0.68611,0.07458,0,0.84125],"928":[0,0.68611,0.08229,0,0.98229],"931":[0,0.68611,0.05451,0,0.88507],"933":[0,0.68611,0.15972,0,0.67083],"934":[0,0.68611,0,0,0.76666],"936":[0,0.68611,0.11653,0,0.71402],"937":[0,0.68611,0.04835,0,0.8789],"945":[0,0.44444,0,0,0.76064],"946":[0.19444,0.69444,0.03403,0,0.65972],"947":[0.19444,0.44444,0.06389,0,0.59003],"948":[0,0.69444,0.03819,0,0.52222],"949":[0,0.44444,0,0,0.52882],"950":[0.19444,0.69444,0.06215,0,0.50833],"951":[0.19444,0.44444,0.03704,0,0.6],"952":[0,0.69444,0.03194,0,0.5618],"953":[0,0.44444,0,0,0.41204],"954":[0,0.44444,0,0,0.66759],"955":[0,0.69444,0,0,0.67083],"956":[0.19444,0.44444,0,0,0.70787],"957":[0,0.44444,0.06898,0,0.57685],"958":[0.19444,0.69444,0.03021,0,0.50833],"959":[0,0.44444,0,0,0.58472],"960":[0,0.44444,0.03704,0,0.68241],"961":[0.19444,0.44444,0,0,0.6118],"962":[0.09722,0.44444,0.07917,0,0.42361],"963":[0,0.44444,0.03704,0,0.68588],"964":[0,0.44444,0.13472,0,0.52083],"965":[0,0.44444,0.03704,0,0.63055],"966":[0.19444,0.44444,0,0,0.74722],"967":[0.19444,0.44444,0,0,0.71805],"968":[0.19444,0.69444,0.03704,0,0.75833],"969":[0,0.44444,0.03704,0,0.71782],"977":[0,0.69444,0,0,0.69155],"981":[0.19444,0.69444,0,0,0.7125],"982":[0,0.44444,0.03194,0,0.975],"1009":[0.19444,0.44444,0,0,0.6118],"1013":[0,0.44444,0,0,0.48333],"57649":[0,0.44444,0,0,0.39352],"57911":[0.19444,0.44444,0,0,0.43889]},"Math-Italic":{"32":[0,0,0,0,0.25],"48":[0,0.43056,0,0,0.5],"49":[0,0.43056,0,0,0.5],"50":[0,0.43056,0,0,0.5],"51":[0.19444,0.43056,0,0,0.5],"52":[0.19444,0.43056,0,0,0.5],"53":[0.19444,0.43056,0,0,0.5],"54":[0,0.64444,0,0,0.5],"55":[0.19444,0.43056,0,0,0.5],"56":[0,0.64444,0,0,0.5],"57":[0.19444,0.43056,0,0,0.5],"65":[0,0.68333,0,0.13889,0.75],"66":[0,0.68333,0.05017,0.08334,0.75851],"67":[0,0.68333,0.07153,0.08334,0.71472],"68":[0,0.68333,0.02778,0.05556,0.82792],"69":[0,0.68333,0.05764,0.08334,0.7382],"70":[0,0.68333,0.13889,0.08334,0.64306],"71":[0,0.68333,0,0.08334,0.78625],"72":[0,0.68333,0.08125,0.05556,0.83125],"73":[0,0.68333,0.07847,0.11111,0.43958],"74":[0,0.68333,0.09618,0.16667,0.55451],"75":[0,0.68333,0.07153,0.05556,0.84931],"76":[0,0.68333,0,0.02778,0.68056],"77":[0,0.68333,0.10903,0.08334,0.97014],"78":[0,0.68333,0.10903,0.08334,0.80347],"79":[0,0.68333,0.02778,0.08334,0.76278],"80":[0,0.68333,0.13889,0.08334,0.64201],"81":[0.19444,0.68333,0,0.08334,0.79056],"82":[0,0.68333,0.00773,0.08334,0.75929],"83":[0,0.68333,0.05764,0.08334,0.6132],"84":[0,0.68333,0.13889,0.08334,0.58438],"85":[0,0.68333,0.10903,0.02778,0.68278],"86":[0,0.68333,0.22222,0,0.58333],"87":[0,0.68333,0.13889,0,0.94445],"88":[0,0.68333,0.07847,0.08334,0.82847],"89":[0,0.68333,0.22222,0,0.58056],"90":[0,0.68333,0.07153,0.08334,0.68264],"97":[0,0.43056,0,0,0.52859],"98":[0,0.69444,0,0,0.42917],"99":[0,0.43056,0,0.05556,0.43276],"100":[0,0.69444,0,0.16667,0.52049],"101":[0,0.43056,0,0.05556,0.46563],"102":[0.19444,0.69444,0.10764,0.16667,0.48959],"103":[0.19444,0.43056,0.03588,0.02778,0.47697],"104":[0,0.69444,0,0,0.57616],"105":[0,0.65952,0,0,0.34451],"106":[0.19444,0.65952,0.05724,0,0.41181],"107":[0,0.69444,0.03148,0,0.5206],"108":[0,0.69444,0.01968,0.08334,0.29838],"109":[0,0.43056,0,0,0.87801],"110":[0,0.43056,0,0,0.60023],"111":[0,0.43056,0,0.05556,0.48472],"112":[0.19444,0.43056,0,0.08334,0.50313],"113":[0.19444,0.43056,0.03588,0.08334,0.44641],"114":[0,0.43056,0.02778,0.05556,0.45116],"115":[0,0.43056,0,0.05556,0.46875],"116":[0,0.61508,0,0.08334,0.36111],"117":[0,0.43056,0,0.02778,0.57246],"118":[0,0.43056,0.03588,0.02778,0.48472],"119":[0,0.43056,0.02691,0.08334,0.71592],"120":[0,0.43056,0,0.02778,0.57153],"121":[0.19444,0.43056,0.03588,0.05556,0.49028],"122":[0,0.43056,0.04398,0.05556,0.46505],"160":[0,0,0,0,0.25],"915":[0,0.68333,0.13889,0.08334,0.61528],"916":[0,0.68333,0,0.16667,0.83334],"920":[0,0.68333,0.02778,0.08334,0.76278],"923":[0,0.68333,0,0.16667,0.69445],"926":[0,0.68333,0.07569,0.08334,0.74236],"928":[0,0.68333,0.08125,0.05556,0.83125],"931":[0,0.68333,0.05764,0.08334,0.77986],"933":[0,0.68333,0.13889,0.05556,0.58333],"934":[0,0.68333,0,0.08334,0.66667],"936":[0,0.68333,0.11,0.05556,0.61222],"937":[0,0.68333,0.05017,0.08334,0.7724],"945":[0,0.43056,0.0037,0.02778,0.6397],"946":[0.19444,0.69444,0.05278,0.08334,0.56563],"947":[0.19444,0.43056,0.05556,0,0.51773],"948":[0,0.69444,0.03785,0.05556,0.44444],"949":[0,0.43056,0,0.08334,0.46632],"950":[0.19444,0.69444,0.07378,0.08334,0.4375],"951":[0.19444,0.43056,0.03588,0.05556,0.49653],"952":[0,0.69444,0.02778,0.08334,0.46944],"953":[0,0.43056,0,0.05556,0.35394],"954":[0,0.43056,0,0,0.57616],"955":[0,0.69444,0,0,0.58334],"956":[0.19444,0.43056,0,0.02778,0.60255],"957":[0,0.43056,0.06366,0.02778,0.49398],"958":[0.19444,0.69444,0.04601,0.11111,0.4375],"959":[0,0.43056,0,0.05556,0.48472],"960":[0,0.43056,0.03588,0,0.57003],"961":[0.19444,0.43056,0,0.08334,0.51702],"962":[0.09722,0.43056,0.07986,0.08334,0.36285],"963":[0,0.43056,0.03588,0,0.57141],"964":[0,0.43056,0.1132,0.02778,0.43715],"965":[0,0.43056,0.03588,0.02778,0.54028],"966":[0.19444,0.43056,0,0.08334,0.65417],"967":[0.19444,0.43056,0,0.05556,0.62569],"968":[0.19444,0.69444,0.03588,0.11111,0.65139],"969":[0,0.43056,0.03588,0,0.62245],"977":[0,0.69444,0,0.08334,0.59144],"981":[0.19444,0.69444,0,0.08334,0.59583],"982":[0,0.43056,0.02778,0,0.82813],"1009":[0.19444,0.43056,0,0.08334,0.51702],"1013":[0,0.43056,0,0.05556,0.4059],"57649":[0,0.43056,0,0.02778,0.32246],"57911":[0.19444,0.43056,0,0.08334,0.38403]},"SansSerif-Bold":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.36667],"34":[0,0.69444,0,0,0.55834],"35":[0.19444,0.69444,0,0,0.91667],"36":[0.05556,0.75,0,0,0.55],"37":[0.05556,0.75,0,0,1.02912],"38":[0,0.69444,0,0,0.83056],"39":[0,0.69444,0,0,0.30556],"40":[0.25,0.75,0,0,0.42778],"41":[0.25,0.75,0,0,0.42778],"42":[0,0.75,0,0,0.55],"43":[0.11667,0.61667,0,0,0.85556],"44":[0.10556,0.13056,0,0,0.30556],"45":[0,0.45833,0,0,0.36667],"46":[0,0.13056,0,0,0.30556],"47":[0.25,0.75,0,0,0.55],"48":[0,0.69444,0,0,0.55],"49":[0,0.69444,0,0,0.55],"50":[0,0.69444,0,0,0.55],"51":[0,0.69444,0,0,0.55],"52":[0,0.69444,0,0,0.55],"53":[0,0.69444,0,0,0.55],"54":[0,0.69444,0,0,0.55],"55":[0,0.69444,0,0,0.55],"56":[0,0.69444,0,0,0.55],"57":[0,0.69444,0,0,0.55],"58":[0,0.45833,0,0,0.30556],"59":[0.10556,0.45833,0,0,0.30556],"61":[-0.09375,0.40625,0,0,0.85556],"63":[0,0.69444,0,0,0.51945],"64":[0,0.69444,0,0,0.73334],"65":[0,0.69444,0,0,0.73334],"66":[0,0.69444,0,0,0.73334],"67":[0,0.69444,0,0,0.70278],"68":[0,0.69444,0,0,0.79445],"69":[0,0.69444,0,0,0.64167],"70":[0,0.69444,0,0,0.61111],"71":[0,0.69444,0,0,0.73334],"72":[0,0.69444,0,0,0.79445],"73":[0,0.69444,0,0,0.33056],"74":[0,0.69444,0,0,0.51945],"75":[0,0.69444,0,0,0.76389],"76":[0,0.69444,0,0,0.58056],"77":[0,0.69444,0,0,0.97778],"78":[0,0.69444,0,0,0.79445],"79":[0,0.69444,0,0,0.79445],"80":[0,0.69444,0,0,0.70278],"81":[0.10556,0.69444,0,0,0.79445],"82":[0,0.69444,0,0,0.70278],"83":[0,0.69444,0,0,0.61111],"84":[0,0.69444,0,0,0.73334],"85":[0,0.69444,0,0,0.76389],"86":[0,0.69444,0.01528,0,0.73334],"87":[0,0.69444,0.01528,0,1.03889],"88":[0,0.69444,0,0,0.73334],"89":[0,0.69444,0.0275,0,0.73334],"90":[0,0.69444,0,0,0.67223],"91":[0.25,0.75,0,0,0.34306],"93":[0.25,0.75,0,0,0.34306],"94":[0,0.69444,0,0,0.55],"95":[0.35,0.10833,0.03056,0,0.55],"97":[0,0.45833,0,0,0.525],"98":[0,0.69444,0,0,0.56111],"99":[0,0.45833,0,0,0.48889],"100":[0,0.69444,0,0,0.56111],"101":[0,0.45833,0,0,0.51111],"102":[0,0.69444,0.07639,0,0.33611],"103":[0.19444,0.45833,0.01528,0,0.55],"104":[0,0.69444,0,0,0.56111],"105":[0,0.69444,0,0,0.25556],"106":[0.19444,0.69444,0,0,0.28611],"107":[0,0.69444,0,0,0.53056],"108":[0,0.69444,0,0,0.25556],"109":[0,0.45833,0,0,0.86667],"110":[0,0.45833,0,0,0.56111],"111":[0,0.45833,0,0,0.55],"112":[0.19444,0.45833,0,0,0.56111],"113":[0.19444,0.45833,0,0,0.56111],"114":[0,0.45833,0.01528,0,0.37222],"115":[0,0.45833,0,0,0.42167],"116":[0,0.58929,0,0,0.40417],"117":[0,0.45833,0,0,0.56111],"118":[0,0.45833,0.01528,0,0.5],"119":[0,0.45833,0.01528,0,0.74445],"120":[0,0.45833,0,0,0.5],"121":[0.19444,0.45833,0.01528,0,0.5],"122":[0,0.45833,0,0,0.47639],"126":[0.35,0.34444,0,0,0.55],"160":[0,0,0,0,0.25],"168":[0,0.69444,0,0,0.55],"176":[0,0.69444,0,0,0.73334],"180":[0,0.69444,0,0,0.55],"184":[0.17014,0,0,0,0.48889],"305":[0,0.45833,0,0,0.25556],"567":[0.19444,0.45833,0,0,0.28611],"710":[0,0.69444,0,0,0.55],"711":[0,0.63542,0,0,0.55],"713":[0,0.63778,0,0,0.55],"728":[0,0.69444,0,0,0.55],"729":[0,0.69444,0,0,0.30556],"730":[0,0.69444,0,0,0.73334],"732":[0,0.69444,0,0,0.55],"733":[0,0.69444,0,0,0.55],"915":[0,0.69444,0,0,0.58056],"916":[0,0.69444,0,0,0.91667],"920":[0,0.69444,0,0,0.85556],"923":[0,0.69444,0,0,0.67223],"926":[0,0.69444,0,0,0.73334],"928":[0,0.69444,0,0,0.79445],"931":[0,0.69444,0,0,0.79445],"933":[0,0.69444,0,0,0.85556],"934":[0,0.69444,0,0,0.79445],"936":[0,0.69444,0,0,0.85556],"937":[0,0.69444,0,0,0.79445],"8211":[0,0.45833,0.03056,0,0.55],"8212":[0,0.45833,0.03056,0,1.10001],"8216":[0,0.69444,0,0,0.30556],"8217":[0,0.69444,0,0,0.30556],"8220":[0,0.69444,0,0,0.55834],"8221":[0,0.69444,0,0,0.55834]},"SansSerif-Italic":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0.05733,0,0.31945],"34":[0,0.69444,0.00316,0,0.5],"35":[0.19444,0.69444,0.05087,0,0.83334],"36":[0.05556,0.75,0.11156,0,0.5],"37":[0.05556,0.75,0.03126,0,0.83334],"38":[0,0.69444,0.03058,0,0.75834],"39":[0,0.69444,0.07816,0,0.27778],"40":[0.25,0.75,0.13164,0,0.38889],"41":[0.25,0.75,0.02536,0,0.38889],"42":[0,0.75,0.11775,0,0.5],"43":[0.08333,0.58333,0.02536,0,0.77778],"44":[0.125,0.08333,0,0,0.27778],"45":[0,0.44444,0.01946,0,0.33333],"46":[0,0.08333,0,0,0.27778],"47":[0.25,0.75,0.13164,0,0.5],"48":[0,0.65556,0.11156,0,0.5],"49":[0,0.65556,0.11156,0,0.5],"50":[0,0.65556,0.11156,0,0.5],"51":[0,0.65556,0.11156,0,0.5],"52":[0,0.65556,0.11156,0,0.5],"53":[0,0.65556,0.11156,0,0.5],"54":[0,0.65556,0.11156,0,0.5],"55":[0,0.65556,0.11156,0,0.5],"56":[0,0.65556,0.11156,0,0.5],"57":[0,0.65556,0.11156,0,0.5],"58":[0,0.44444,0.02502,0,0.27778],"59":[0.125,0.44444,0.02502,0,0.27778],"61":[-0.13,0.37,0.05087,0,0.77778],"63":[0,0.69444,0.11809,0,0.47222],"64":[0,0.69444,0.07555,0,0.66667],"65":[0,0.69444,0,0,0.66667],"66":[0,0.69444,0.08293,0,0.66667],"67":[0,0.69444,0.11983,0,0.63889],"68":[0,0.69444,0.07555,0,0.72223],"69":[0,0.69444,0.11983,0,0.59722],"70":[0,0.69444,0.13372,0,0.56945],"71":[0,0.69444,0.11983,0,0.66667],"72":[0,0.69444,0.08094,0,0.70834],"73":[0,0.69444,0.13372,0,0.27778],"74":[0,0.69444,0.08094,0,0.47222],"75":[0,0.69444,0.11983,0,0.69445],"76":[0,0.69444,0,0,0.54167],"77":[0,0.69444,0.08094,0,0.875],"78":[0,0.69444,0.08094,0,0.70834],"79":[0,0.69444,0.07555,0,0.73611],"80":[0,0.69444,0.08293,0,0.63889],"81":[0.125,0.69444,0.07555,0,0.73611],"82":[0,0.69444,0.08293,0,0.64584],"83":[0,0.69444,0.09205,0,0.55556],"84":[0,0.69444,0.13372,0,0.68056],"85":[0,0.69444,0.08094,0,0.6875],"86":[0,0.69444,0.1615,0,0.66667],"87":[0,0.69444,0.1615,0,0.94445],"88":[0,0.69444,0.13372,0,0.66667],"89":[0,0.69444,0.17261,0,0.66667],"90":[0,0.69444,0.11983,0,0.61111],"91":[0.25,0.75,0.15942,0,0.28889],"93":[0.25,0.75,0.08719,0,0.28889],"94":[0,0.69444,0.0799,0,0.5],"95":[0.35,0.09444,0.08616,0,0.5],"97":[0,0.44444,0.00981,0,0.48056],"98":[0,0.69444,0.03057,0,0.51667],"99":[0,0.44444,0.08336,0,0.44445],"100":[0,0.69444,0.09483,0,0.51667],"101":[0,0.44444,0.06778,0,0.44445],"102":[0,0.69444,0.21705,0,0.30556],"103":[0.19444,0.44444,0.10836,0,0.5],"104":[0,0.69444,0.01778,0,0.51667],"105":[0,0.67937,0.09718,0,0.23889],"106":[0.19444,0.67937,0.09162,0,0.26667],"107":[0,0.69444,0.08336,0,0.48889],"108":[0,0.69444,0.09483,0,0.23889],"109":[0,0.44444,0.01778,0,0.79445],"110":[0,0.44444,0.01778,0,0.51667],"111":[0,0.44444,0.06613,0,0.5],"112":[0.19444,0.44444,0.0389,0,0.51667],"113":[0.19444,0.44444,0.04169,0,0.51667],"114":[0,0.44444,0.10836,0,0.34167],"115":[0,0.44444,0.0778,0,0.38333],"116":[0,0.57143,0.07225,0,0.36111],"117":[0,0.44444,0.04169,0,0.51667],"118":[0,0.44444,0.10836,0,0.46111],"119":[0,0.44444,0.10836,0,0.68334],"120":[0,0.44444,0.09169,0,0.46111],"121":[0.19444,0.44444,0.10836,0,0.46111],"122":[0,0.44444,0.08752,0,0.43472],"126":[0.35,0.32659,0.08826,0,0.5],"160":[0,0,0,0,0.25],"168":[0,0.67937,0.06385,0,0.5],"176":[0,0.69444,0,0,0.73752],"184":[0.17014,0,0,0,0.44445],"305":[0,0.44444,0.04169,0,0.23889],"567":[0.19444,0.44444,0.04169,0,0.26667],"710":[0,0.69444,0.0799,0,0.5],"711":[0,0.63194,0.08432,0,0.5],"713":[0,0.60889,0.08776,0,0.5],"714":[0,0.69444,0.09205,0,0.5],"715":[0,0.69444,0,0,0.5],"728":[0,0.69444,0.09483,0,0.5],"729":[0,0.67937,0.07774,0,0.27778],"730":[0,0.69444,0,0,0.73752],"732":[0,0.67659,0.08826,0,0.5],"733":[0,0.69444,0.09205,0,0.5],"915":[0,0.69444,0.13372,0,0.54167],"916":[0,0.69444,0,0,0.83334],"920":[0,0.69444,0.07555,0,0.77778],"923":[0,0.69444,0,0,0.61111],"926":[0,0.69444,0.12816,0,0.66667],"928":[0,0.69444,0.08094,0,0.70834],"931":[0,0.69444,0.11983,0,0.72222],"933":[0,0.69444,0.09031,0,0.77778],"934":[0,0.69444,0.04603,0,0.72222],"936":[0,0.69444,0.09031,0,0.77778],"937":[0,0.69444,0.08293,0,0.72222],"8211":[0,0.44444,0.08616,0,0.5],"8212":[0,0.44444,0.08616,0,1.0],"8216":[0,0.69444,0.07816,0,0.27778],"8217":[0,0.69444,0.07816,0,0.27778],"8220":[0,0.69444,0.14205,0,0.5],"8221":[0,0.69444,0.00316,0,0.5]},"SansSerif-Regular":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.31945],"34":[0,0.69444,0,0,0.5],"35":[0.19444,0.69444,0,0,0.83334],"36":[0.05556,0.75,0,0,0.5],"37":[0.05556,0.75,0,0,0.83334],"38":[0,0.69444,0,0,0.75834],"39":[0,0.69444,0,0,0.27778],"40":[0.25,0.75,0,0,0.38889],"41":[0.25,0.75,0,0,0.38889],"42":[0,0.75,0,0,0.5],"43":[0.08333,0.58333,0,0,0.77778],"44":[0.125,0.08333,0,0,0.27778],"45":[0,0.44444,0,0,0.33333],"46":[0,0.08333,0,0,0.27778],"47":[0.25,0.75,0,0,0.5],"48":[0,0.65556,0,0,0.5],"49":[0,0.65556,0,0,0.5],"50":[0,0.65556,0,0,0.5],"51":[0,0.65556,0,0,0.5],"52":[0,0.65556,0,0,0.5],"53":[0,0.65556,0,0,0.5],"54":[0,0.65556,0,0,0.5],"55":[0,0.65556,0,0,0.5],"56":[0,0.65556,0,0,0.5],"57":[0,0.65556,0,0,0.5],"58":[0,0.44444,0,0,0.27778],"59":[0.125,0.44444,0,0,0.27778],"61":[-0.13,0.37,0,0,0.77778],"63":[0,0.69444,0,0,0.47222],"64":[0,0.69444,0,0,0.66667],"65":[0,0.69444,0,0,0.66667],"66":[0,0.69444,0,0,0.66667],"67":[0,0.69444,0,0,0.63889],"68":[0,0.69444,0,0,0.72223],"69":[0,0.69444,0,0,0.59722],"70":[0,0.69444,0,0,0.56945],"71":[0,0.69444,0,0,0.66667],"72":[0,0.69444,0,0,0.70834],"73":[0,0.69444,0,0,0.27778],"74":[0,0.69444,0,0,0.47222],"75":[0,0.69444,0,0,0.69445],"76":[0,0.69444,0,0,0.54167],"77":[0,0.69444,0,0,0.875],"78":[0,0.69444,0,0,0.70834],"79":[0,0.69444,0,0,0.73611],"80":[0,0.69444,0,0,0.63889],"81":[0.125,0.69444,0,0,0.73611],"82":[0,0.69444,0,0,0.64584],"83":[0,0.69444,0,0,0.55556],"84":[0,0.69444,0,0,0.68056],"85":[0,0.69444,0,0,0.6875],"86":[0,0.69444,0.01389,0,0.66667],"87":[0,0.69444,0.01389,0,0.94445],"88":[0,0.69444,0,0,0.66667],"89":[0,0.69444,0.025,0,0.66667],"90":[0,0.69444,0,0,0.61111],"91":[0.25,0.75,0,0,0.28889],"93":[0.25,0.75,0,0,0.28889],"94":[0,0.69444,0,0,0.5],"95":[0.35,0.09444,0.02778,0,0.5],"97":[0,0.44444,0,0,0.48056],"98":[0,0.69444,0,0,0.51667],"99":[0,0.44444,0,0,0.44445],"100":[0,0.69444,0,0,0.51667],"101":[0,0.44444,0,0,0.44445],"102":[0,0.69444,0.06944,0,0.30556],"103":[0.19444,0.44444,0.01389,0,0.5],"104":[0,0.69444,0,0,0.51667],"105":[0,0.67937,0,0,0.23889],"106":[0.19444,0.67937,0,0,0.26667],"107":[0,0.69444,0,0,0.48889],"108":[0,0.69444,0,0,0.23889],"109":[0,0.44444,0,0,0.79445],"110":[0,0.44444,0,0,0.51667],"111":[0,0.44444,0,0,0.5],"112":[0.19444,0.44444,0,0,0.51667],"113":[0.19444,0.44444,0,0,0.51667],"114":[0,0.44444,0.01389,0,0.34167],"115":[0,0.44444,0,0,0.38333],"116":[0,0.57143,0,0,0.36111],"117":[0,0.44444,0,0,0.51667],"118":[0,0.44444,0.01389,0,0.46111],"119":[0,0.44444,0.01389,0,0.68334],"120":[0,0.44444,0,0,0.46111],"121":[0.19444,0.44444,0.01389,0,0.46111],"122":[0,0.44444,0,0,0.43472],"126":[0.35,0.32659,0,0,0.5],"160":[0,0,0,0,0.25],"168":[0,0.67937,0,0,0.5],"176":[0,0.69444,0,0,0.66667],"184":[0.17014,0,0,0,0.44445],"305":[0,0.44444,0,0,0.23889],"567":[0.19444,0.44444,0,0,0.26667],"710":[0,0.69444,0,0,0.5],"711":[0,0.63194,0,0,0.5],"713":[0,0.60889,0,0,0.5],"714":[0,0.69444,0,0,0.5],"715":[0,0.69444,0,0,0.5],"728":[0,0.69444,0,0,0.5],"729":[0,0.67937,0,0,0.27778],"730":[0,0.69444,0,0,0.66667],"732":[0,0.67659,0,0,0.5],"733":[0,0.69444,0,0,0.5],"915":[0,0.69444,0,0,0.54167],"916":[0,0.69444,0,0,0.83334],"920":[0,0.69444,0,0,0.77778],"923":[0,0.69444,0,0,0.61111],"926":[0,0.69444,0,0,0.66667],"928":[0,0.69444,0,0,0.70834],"931":[0,0.69444,0,0,0.72222],"933":[0,0.69444,0,0,0.77778],"934":[0,0.69444,0,0,0.72222],"936":[0,0.69444,0,0,0.77778],"937":[0,0.69444,0,0,0.72222],"8211":[0,0.44444,0.02778,0,0.5],"8212":[0,0.44444,0.02778,0,1.0],"8216":[0,0.69444,0,0,0.27778],"8217":[0,0.69444,0,0,0.27778],"8220":[0,0.69444,0,0,0.5],"8221":[0,0.69444,0,0,0.5]},"Script-Regular":{"32":[0,0,0,0,0.25],"65":[0,0.7,0.22925,0,0.80253],"66":[0,0.7,0.04087,0,0.90757],"67":[0,0.7,0.1689,0,0.66619],"68":[0,0.7,0.09371,0,0.77443],"69":[0,0.7,0.18583,0,0.56162],"70":[0,0.7,0.13634,0,0.89544],"71":[0,0.7,0.17322,0,0.60961],"72":[0,0.7,0.29694,0,0.96919],"73":[0,0.7,0.19189,0,0.80907],"74":[0.27778,0.7,0.19189,0,1.05159],"75":[0,0.7,0.31259,0,0.91364],"76":[0,0.7,0.19189,0,0.87373],"77":[0,0.7,0.15981,0,1.08031],"78":[0,0.7,0.3525,0,0.9015],"79":[0,0.7,0.08078,0,0.73787],"80":[0,0.7,0.08078,0,1.01262],"81":[0,0.7,0.03305,0,0.88282],"82":[0,0.7,0.06259,0,0.85],"83":[0,0.7,0.19189,0,0.86767],"84":[0,0.7,0.29087,0,0.74697],"85":[0,0.7,0.25815,0,0.79996],"86":[0,0.7,0.27523,0,0.62204],"87":[0,0.7,0.27523,0,0.80532],"88":[0,0.7,0.26006,0,0.94445],"89":[0,0.7,0.2939,0,0.70961],"90":[0,0.7,0.24037,0,0.8212],"160":[0,0,0,0,0.25]},"Size1-Regular":{"32":[0,0,0,0,0.25],"40":[0.35001,0.85,0,0,0.45834],"41":[0.35001,0.85,0,0,0.45834],"47":[0.35001,0.85,0,0,0.57778],"91":[0.35001,0.85,0,0,0.41667],"92":[0.35001,0.85,0,0,0.57778],"93":[0.35001,0.85,0,0,0.41667],"123":[0.35001,0.85,0,0,0.58334],"125":[0.35001,0.85,0,0,0.58334],"160":[0,0,0,0,0.25],"710":[0,0.72222,0,0,0.55556],"732":[0,0.72222,0,0,0.55556],"770":[0,0.72222,0,0,0.55556],"771":[0,0.72222,0,0,0.55556],"8214":[-0.00099,0.601,0,0,0.77778],"8593":[1e-05,0.6,0,0,0.66667],"8595":[1e-05,0.6,0,0,0.66667],"8657":[1e-05,0.6,0,0,0.77778],"8659":[1e-05,0.6,0,0,0.77778],"8719":[0.25001,0.75,0,0,0.94445],"8720":[0.25001,0.75,0,0,0.94445],"8721":[0.25001,0.75,0,0,1.05556],"8730":[0.35001,0.85,0,0,1.0],"8739":[-0.00599,0.606,0,0,0.33333],"8741":[-0.00599,0.606,0,0,0.55556],"8747":[0.30612,0.805,0.19445,0,0.47222],"8748":[0.306,0.805,0.19445,0,0.47222],"8749":[0.306,0.805,0.19445,0,0.47222],"8750":[0.30612,0.805,0.19445,0,0.47222],"8896":[0.25001,0.75,0,0,0.83334],"8897":[0.25001,0.75,0,0,0.83334],"8898":[0.25001,0.75,0,0,0.83334],"8899":[0.25001,0.75,0,0,0.83334],"8968":[0.35001,0.85,0,0,0.47222],"8969":[0.35001,0.85,0,0,0.47222],"8970":[0.35001,0.85,0,0,0.47222],"8971":[0.35001,0.85,0,0,0.47222],"9168":[-0.00099,0.601,0,0,0.66667],"10216":[0.35001,0.85,0,0,0.47222],"10217":[0.35001,0.85,0,0,0.47222],"10752":[0.25001,0.75,0,0,1.11111],"10753":[0.25001,0.75,0,0,1.11111],"10754":[0.25001,0.75,0,0,1.11111],"10756":[0.25001,0.75,0,0,0.83334],"10758":[0.25001,0.75,0,0,0.83334]},"Size2-Regular":{"32":[0,0,0,0,0.25],"40":[0.65002,1.15,0,0,0.59722],"41":[0.65002,1.15,0,0,0.59722],"47":[0.65002,1.15,0,0,0.81111],"91":[0.65002,1.15,0,0,0.47222],"92":[0.65002,1.15,0,0,0.81111],"93":[0.65002,1.15,0,0,0.47222],"123":[0.65002,1.15,0,0,0.66667],"125":[0.65002,1.15,0,0,0.66667],"160":[0,0,0,0,0.25],"710":[0,0.75,0,0,1.0],"732":[0,0.75,0,0,1.0],"770":[0,0.75,0,0,1.0],"771":[0,0.75,0,0,1.0],"8719":[0.55001,1.05,0,0,1.27778],"8720":[0.55001,1.05,0,0,1.27778],"8721":[0.55001,1.05,0,0,1.44445],"8730":[0.65002,1.15,0,0,1.0],"8747":[0.86225,1.36,0.44445,0,0.55556],"8748":[0.862,1.36,0.44445,0,0.55556],"8749":[0.862,1.36,0.44445,0,0.55556],"8750":[0.86225,1.36,0.44445,0,0.55556],"8896":[0.55001,1.05,0,0,1.11111],"8897":[0.55001,1.05,0,0,1.11111],"8898":[0.55001,1.05,0,0,1.11111],"8899":[0.55001,1.05,0,0,1.11111],"8968":[0.65002,1.15,0,0,0.52778],"8969":[0.65002,1.15,0,0,0.52778],"8970":[0.65002,1.15,0,0,0.52778],"8971":[0.65002,1.15,0,0,0.52778],"10216":[0.65002,1.15,0,0,0.61111],"10217":[0.65002,1.15,0,0,0.61111],"10752":[0.55001,1.05,0,0,1.51112],"10753":[0.55001,1.05,0,0,1.51112],"10754":[0.55001,1.05,0,0,1.51112],"10756":[0.55001,1.05,0,0,1.11111],"10758":[0.55001,1.05,0,0,1.11111]},"Size3-Regular":{"32":[0,0,0,0,0.25],"40":[0.95003,1.45,0,0,0.73611],"41":[0.95003,1.45,0,0,0.73611],"47":[0.95003,1.45,0,0,1.04445],"91":[0.95003,1.45,0,0,0.52778],"92":[0.95003,1.45,0,0,1.04445],"93":[0.95003,1.45,0,0,0.52778],"123":[0.95003,1.45,0,0,0.75],"125":[0.95003,1.45,0,0,0.75],"160":[0,0,0,0,0.25],"710":[0,0.75,0,0,1.44445],"732":[0,0.75,0,0,1.44445],"770":[0,0.75,0,0,1.44445],"771":[0,0.75,0,0,1.44445],"8730":[0.95003,1.45,0,0,1.0],"8968":[0.95003,1.45,0,0,0.58334],"8969":[0.95003,1.45,0,0,0.58334],"8970":[0.95003,1.45,0,0,0.58334],"8971":[0.95003,1.45,0,0,0.58334],"10216":[0.95003,1.45,0,0,0.75],"10217":[0.95003,1.45,0,0,0.75]},"Size4-Regular":{"32":[0,0,0,0,0.25],"40":[1.25003,1.75,0,0,0.79167],"41":[1.25003,1.75,0,0,0.79167],"47":[1.25003,1.75,0,0,1.27778],"91":[1.25003,1.75,0,0,0.58334],"92":[1.25003,1.75,0,0,1.27778],"93":[1.25003,1.75,0,0,0.58334],"123":[1.25003,1.75,0,0,0.80556],"125":[1.25003,1.75,0,0,0.80556],"160":[0,0,0,0,0.25],"710":[0,0.825,0,0,1.8889],"732":[0,0.825,0,0,1.8889],"770":[0,0.825,0,0,1.8889],"771":[0,0.825,0,0,1.8889],"8730":[1.25003,1.75,0,0,1.0],"8968":[1.25003,1.75,0,0,0.63889],"8969":[1.25003,1.75,0,0,0.63889],"8970":[1.25003,1.75,0,0,0.63889],"8971":[1.25003,1.75,0,0,0.63889],"9115":[0.64502,1.155,0,0,0.875],"9116":[1e-05,0.6,0,0,0.875],"9117":[0.64502,1.155,0,0,0.875],"9118":[0.64502,1.155,0,0,0.875],"9119":[1e-05,0.6,0,0,0.875],"9120":[0.64502,1.155,0,0,0.875],"9121":[0.64502,1.155,0,0,0.66667],"9122":[-0.00099,0.601,0,0,0.66667],"9123":[0.64502,1.155,0,0,0.66667],"9124":[0.64502,1.155,0,0,0.66667],"9125":[-0.00099,0.601,0,0,0.66667],"9126":[0.64502,1.155,0,0,0.66667],"9127":[1e-05,0.9,0,0,0.88889],"9128":[0.65002,1.15,0,0,0.88889],"9129":[0.90001,0,0,0,0.88889],"9130":[0,0.3,0,0,0.88889],"9131":[1e-05,0.9,0,0,0.88889],"9132":[0.65002,1.15,0,0,0.88889],"9133":[0.90001,0,0,0,0.88889],"9143":[0.88502,0.915,0,0,1.05556],"10216":[1.25003,1.75,0,0,0.80556],"10217":[1.25003,1.75,0,0,0.80556],"57344":[-0.00499,0.605,0,0,1.05556],"57345":[-0.00499,0.605,0,0,1.05556],"57680":[0,0.12,0,0,0.45],"57681":[0,0.12,0,0,0.45],"57682":[0,0.12,0,0,0.45],"57683":[0,0.12,0,0,0.45]},"Typewriter-Regular":{"32":[0,0,0,0,0.525],"33":[0,0.61111,0,0,0.525],"34":[0,0.61111,0,0,0.525],"35":[0,0.61111,0,0,0.525],"36":[0.08333,0.69444,0,0,0.525],"37":[0.08333,0.69444,0,0,0.525],"38":[0,0.61111,0,0,0.525],"39":[0,0.61111,0,0,0.525],"40":[0.08333,0.69444,0,0,0.525],"41":[0.08333,0.69444,0,0,0.525],"42":[0,0.52083,0,0,0.525],"43":[-0.08056,0.53055,0,0,0.525],"44":[0.13889,0.125,0,0,0.525],"45":[-0.08056,0.53055,0,0,0.525],"46":[0,0.125,0,0,0.525],"47":[0.08333,0.69444,0,0,0.525],"48":[0,0.61111,0,0,0.525],"49":[0,0.61111,0,0,0.525],"50":[0,0.61111,0,0,0.525],"51":[0,0.61111,0,0,0.525],"52":[0,0.61111,0,0,0.525],"53":[0,0.61111,0,0,0.525],"54":[0,0.61111,0,0,0.525],"55":[0,0.61111,0,0,0.525],"56":[0,0.61111,0,0,0.525],"57":[0,0.61111,0,0,0.525],"58":[0,0.43056,0,0,0.525],"59":[0.13889,0.43056,0,0,0.525],"60":[-0.05556,0.55556,0,0,0.525],"61":[-0.19549,0.41562,0,0,0.525],"62":[-0.05556,0.55556,0,0,0.525],"63":[0,0.61111,0,0,0.525],"64":[0,0.61111,0,0,0.525],"65":[0,0.61111,0,0,0.525],"66":[0,0.61111,0,0,0.525],"67":[0,0.61111,0,0,0.525],"68":[0,0.61111,0,0,0.525],"69":[0,0.61111,0,0,0.525],"70":[0,0.61111,0,0,0.525],"71":[0,0.61111,0,0,0.525],"72":[0,0.61111,0,0,0.525],"73":[0,0.61111,0,0,0.525],"74":[0,0.61111,0,0,0.525],"75":[0,0.61111,0,0,0.525],"76":[0,0.61111,0,0,0.525],"77":[0,0.61111,0,0,0.525],"78":[0,0.61111,0,0,0.525],"79":[0,0.61111,0,0,0.525],"80":[0,0.61111,0,0,0.525],"81":[0.13889,0.61111,0,0,0.525],"82":[0,0.61111,0,0,0.525],"83":[0,0.61111,0,0,0.525],"84":[0,0.61111,0,0,0.525],"85":[0,0.61111,0,0,0.525],"86":[0,0.61111,0,0,0.525],"87":[0,0.61111,0,0,0.525],"88":[0,0.61111,0,0,0.525],"89":[0,0.61111,0,0,0.525],"90":[0,0.61111,0,0,0.525],"91":[0.08333,0.69444,0,0,0.525],"92":[0.08333,0.69444,0,0,0.525],"93":[0.08333,0.69444,0,0,0.525],"94":[0,0.61111,0,0,0.525],"95":[0.09514,0,0,0,0.525],"96":[0,0.61111,0,0,0.525],"97":[0,0.43056,0,0,0.525],"98":[0,0.61111,0,0,0.525],"99":[0,0.43056,0,0,0.525],"100":[0,0.61111,0,0,0.525],"101":[0,0.43056,0,0,0.525],"102":[0,0.61111,0,0,0.525],"103":[0.22222,0.43056,0,0,0.525],"104":[0,0.61111,0,0,0.525],"105":[0,0.61111,0,0,0.525],"106":[0.22222,0.61111,0,0,0.525],"107":[0,0.61111,0,0,0.525],"108":[0,0.61111,0,0,0.525],"109":[0,0.43056,0,0,0.525],"110":[0,0.43056,0,0,0.525],"111":[0,0.43056,0,0,0.525],"112":[0.22222,0.43056,0,0,0.525],"113":[0.22222,0.43056,0,0,0.525],"114":[0,0.43056,0,0,0.525],"115":[0,0.43056,0,0,0.525],"116":[0,0.55358,0,0,0.525],"117":[0,0.43056,0,0,0.525],"118":[0,0.43056,0,0,0.525],"119":[0,0.43056,0,0,0.525],"120":[0,0.43056,0,0,0.525],"121":[0.22222,0.43056,0,0,0.525],"122":[0,0.43056,0,0,0.525],"123":[0.08333,0.69444,0,0,0.525],"124":[0.08333,0.69444,0,0,0.525],"125":[0.08333,0.69444,0,0,0.525],"126":[0,0.61111,0,0,0.525],"127":[0,0.61111,0,0,0.525],"160":[0,0,0,0,0.525],"176":[0,0.61111,0,0,0.525],"184":[0.19445,0,0,0,0.525],"305":[0,0.43056,0,0,0.525],"567":[0.22222,0.43056,0,0,0.525],"711":[0,0.56597,0,0,0.525],"713":[0,0.56555,0,0,0.525],"714":[0,0.61111,0,0,0.525],"715":[0,0.61111,0,0,0.525],"728":[0,0.61111,0,0,0.525],"730":[0,0.61111,0,0,0.525],"770":[0,0.61111,0,0,0.525],"771":[0,0.61111,0,0,0.525],"776":[0,0.61111,0,0,0.525],"915":[0,0.61111,0,0,0.525],"916":[0,0.61111,0,0,0.525],"920":[0,0.61111,0,0,0.525],"923":[0,0.61111,0,0,0.525],"926":[0,0.61111,0,0,0.525],"928":[0,0.61111,0,0,0.525],"931":[0,0.61111,0,0,0.525],"933":[0,0.61111,0,0,0.525],"934":[0,0.61111,0,0,0.525],"936":[0,0.61111,0,0,0.525],"937":[0,0.61111,0,0,0.525],"8216":[0,0.61111,0,0,0.525],"8217":[0,0.61111,0,0,0.525],"8242":[0,0.61111,0,0,0.525],"9251":[0.11111,0.21944,0,0,0.525]}};/**
     * This file contains metrics regarding fonts and individual symbols. The sigma
     * and xi variables, as well as the metricMap map contain data extracted from
     * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
     * `metrics` variable and the getCharacterMetrics function.
     */ // In TeX, there are actually three sets of dimensions, one for each of
    // textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
    // 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
    // provided in the the arrays below, in that order.
    //
    // The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
    // This was determined by running the following script:
    //
    //     latex -interaction=nonstopmode \
    //     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
    //     '$a$ \expandafter\show\the\textfont2' \
    //     '\expandafter\show\the\scriptfont2' \
    //     '\expandafter\show\the\scriptscriptfont2' \
    //     '\stop'
    //
    // The metrics themselves were retreived using the following commands:
    //
    //     tftopl cmsy10
    //     tftopl cmsy7
    //     tftopl cmsy5
    //
    // The output of each of these commands is quite lengthy.  The only part we
    // care about is the FONTDIMEN section. Each value is measured in EMs.
    const sigmasAndXis={slant:[0.250,0.250,0.250],// sigma1
    space:[0.000,0.000,0.000],// sigma2
    stretch:[0.000,0.000,0.000],// sigma3
    shrink:[0.000,0.000,0.000],// sigma4
    xHeight:[0.431,0.431,0.431],// sigma5
    quad:[1.000,1.171,1.472],// sigma6
    extraSpace:[0.000,0.000,0.000],// sigma7
    num1:[0.677,0.732,0.925],// sigma8
    num2:[0.394,0.384,0.387],// sigma9
    num3:[0.444,0.471,0.504],// sigma10
    denom1:[0.686,0.752,1.025],// sigma11
    denom2:[0.345,0.344,0.532],// sigma12
    sup1:[0.413,0.503,0.504],// sigma13
    sup2:[0.363,0.431,0.404],// sigma14
    sup3:[0.289,0.286,0.294],// sigma15
    sub1:[0.150,0.143,0.200],// sigma16
    sub2:[0.247,0.286,0.400],// sigma17
    supDrop:[0.386,0.353,0.494],// sigma18
    subDrop:[0.050,0.071,0.100],// sigma19
    delim1:[2.390,1.700,1.980],// sigma20
    delim2:[1.010,1.157,1.420],// sigma21
    axisHeight:[0.250,0.250,0.250],// sigma22
    // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
    // they correspond to the font parameters of the extension fonts (family 3).
    // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
    // match cmex7, we'd use cmex7.tfm values for script and scriptscript
    // values.
    defaultRuleThickness:[0.04,0.049,0.049],// xi8; cmex7: 0.049
    bigOpSpacing1:[0.111,0.111,0.111],// xi9
    bigOpSpacing2:[0.166,0.166,0.166],// xi10
    bigOpSpacing3:[0.2,0.2,0.2],// xi11
    bigOpSpacing4:[0.6,0.611,0.611],// xi12; cmex7: 0.611
    bigOpSpacing5:[0.1,0.143,0.143],// xi13; cmex7: 0.143
    // The \sqrt rule width is taken from the height of the surd character.
    // Since we use the same font at all sizes, this thickness doesn't scale.
    sqrtRuleThickness:[0.04,0.04,0.04],// This value determines how large a pt is, for metrics which are defined
    // in terms of pts.
    // This value is also used in katex.less; if you change it make sure the
    // values match.
    ptPerEm:[10.0,10.0,10.0],// The space between adjacent `|` columns in an array definition. From
    // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
    doubleRuleSep:[0.2,0.2,0.2],// The width of separator lines in {array} environments. From
    // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
    arrayRuleWidth:[0.04,0.04,0.04],// Two values from LaTeX source2e:
    fboxsep:[0.3,0.3,0.3],//        3 pt / ptPerEm
    fboxrule:[0.04,0.04,0.04]// 0.4 pt / ptPerEm
    };// This map contains a mapping from font name and character code to character
    // should have Latin-1 and Cyrillic characters, but may not depending on the
    // operating system.  The metrics do not account for extra height from the
    // accents.  In the case of Cyrillic characters which have both ascenders and
    // descenders we prefer approximations with ascenders, primarily to prevent
    // the fraction bar or root line from intersecting the glyph.
    // TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
    const extraCharacterMap={// Latin-1
    '':'A','':'C','':'D','':'o','':'a','':'c','':'d','':'o',// Cyrillic
    '':'A','':'B','':'B','':'F','':'A','':'E','':'K','':'3','':'N','':'N','':'K','':'N','':'M','':'H','':'O','':'N','':'P','':'C','':'T','':'y','':'O','':'X','':'U','':'h','':'W','':'W','':'B','':'X','':'B','':'3','':'X','':'R','':'a','':'b','':'a','':'r','':'y','':'e','':'m','':'e','':'n','':'n','':'n','':'n','':'m','':'n','':'o','':'n','':'p','':'c','':'o','':'y','':'b','':'x','':'n','':'n','':'w','':'w','':'a','':'m','':'a','':'e','':'m','':'r'};/**
     * This function adds new font metrics to default metricMap
     * It can also override existing metrics
     */function setFontMetrics(fontName,metrics){metricMap[fontName]=metrics;}/**
     * This function is a convenience function for looking up information in the
     * metricMap table. It takes a character as a string, and a font.
     *
     * Note: the `width` property may be undefined if fontMetricsData.js wasn't
     * built using `Make extended_metrics`.
     */function getCharacterMetrics(character,font,mode){if(!metricMap[font]){throw new Error(`Font metrics not found for font: ${font}.`);}let ch=character.charCodeAt(0);let metrics=metricMap[font][ch];if(!metrics&&character[0]in extraCharacterMap){ch=extraCharacterMap[character[0]].charCodeAt(0);metrics=metricMap[font][ch];}if(!metrics&&mode==='text'){// We don't typically have font metrics for Asian scripts.
    // But since we support them in text mode, we need to return
    // some sort of metrics.
    // So if the character is in a script we support but we
    // don't have metrics for it, just use the metrics for
    // the Latin capital letter M. This is close enough because
    // we (currently) only care about the height of the glpyh
    // not its width.
    if(supportedCodepoint(ch)){metrics=metricMap[font][77];// 77 is the charcode for 'M'
    }}if(metrics){return {depth:metrics[0],height:metrics[1],italic:metrics[2],skew:metrics[3],width:metrics[4]};}}const fontMetricsBySizeIndex={};/**
     * Get the font metrics for a given size.
     */function getGlobalMetrics(size){let sizeIndex;if(size>=5){sizeIndex=0;}else if(size>=3){sizeIndex=1;}else {sizeIndex=2;}if(!fontMetricsBySizeIndex[sizeIndex]){const metrics=fontMetricsBySizeIndex[sizeIndex]={cssEmPerMu:sigmasAndXis.quad[sizeIndex]/18};for(const key in sigmasAndXis){if(sigmasAndXis.hasOwnProperty(key)){metrics[key]=sigmasAndXis[key][sizeIndex];}}}return fontMetricsBySizeIndex[sizeIndex];}/**
     * This file holds a list of all no-argument functions and single-character
     * symbols (like 'a' or ';').
     *
     * For each of the symbols, there are three properties they can have:
     * - font (required): the font to be used for this symbol. Either "main" (the
         normal font), or "ams" (the ams fonts).
     * - group (required): the ParseNode group type the symbol should have (i.e.
         "textord", "mathord", etc).
         See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
     * - replace: the character that this symbol or function should be
     *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
     *   character in the main font).
     *
     * The outermost map in the table indicates what mode the symbols should be
     * accepted in (e.g. "math" or "text").
     */ // Some of these have a "-token" suffix since these are also used as `ParseNode`
    // types for raw text tokens, and we want to avoid conflicts with higher-level
    // `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
    // looking up the `symbols` map.
    const ATOMS={"bin":1,"close":1,"inner":1,"open":1,"punct":1,"rel":1};const NON_ATOMS={"accent-token":1,"mathord":1,"op-token":1,"spacing":1,"textord":1};const symbols={"math":{},"text":{}};/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */function defineSymbol(mode,font,group,replace,name,acceptUnicodeChar){symbols[mode][name]={font,group,replace};if(acceptUnicodeChar&&replace){symbols[mode][replace]=symbols[mode][name];}}// Some abbreviations for commonly used strings.
    // This helps minify the code, and also spotting typos using jshint.
    // modes:
    const math="math";const text$1="text";// fonts:
    const main="main";const ams="ams";// groups:
    const accent="accent-token";const bin="bin";const close="close";const inner="inner";const mathord="mathord";const op="op-token";const open="open";const punct="punct";const rel="rel";const spacing="spacing";const textord="textord";// Now comes the symbol table
    // Relation Symbols
    defineSymbol(math,main,rel,"\u2261","\\equiv",true);defineSymbol(math,main,rel,"\u227a","\\prec",true);defineSymbol(math,main,rel,"\u227b","\\succ",true);defineSymbol(math,main,rel,"\u223c","\\sim",true);defineSymbol(math,main,rel,"\u22a5","\\perp");defineSymbol(math,main,rel,"\u2aaf","\\preceq",true);defineSymbol(math,main,rel,"\u2ab0","\\succeq",true);defineSymbol(math,main,rel,"\u2243","\\simeq",true);defineSymbol(math,main,rel,"\u2223","\\mid",true);defineSymbol(math,main,rel,"\u226a","\\ll",true);defineSymbol(math,main,rel,"\u226b","\\gg",true);defineSymbol(math,main,rel,"\u224d","\\asymp",true);defineSymbol(math,main,rel,"\u2225","\\parallel");defineSymbol(math,main,rel,"\u22c8","\\bowtie",true);defineSymbol(math,main,rel,"\u2323","\\smile",true);defineSymbol(math,main,rel,"\u2291","\\sqsubseteq",true);defineSymbol(math,main,rel,"\u2292","\\sqsupseteq",true);defineSymbol(math,main,rel,"\u2250","\\doteq",true);defineSymbol(math,main,rel,"\u2322","\\frown",true);defineSymbol(math,main,rel,"\u220b","\\ni",true);defineSymbol(math,main,rel,"\u221d","\\propto",true);defineSymbol(math,main,rel,"\u22a2","\\vdash",true);defineSymbol(math,main,rel,"\u22a3","\\dashv",true);defineSymbol(math,main,rel,"\u220b","\\owns");// Punctuation
    defineSymbol(math,main,punct,"\u002e","\\ldotp");defineSymbol(math,main,punct,"\u22c5","\\cdotp");// Misc Symbols
    defineSymbol(math,main,textord,"\u0023","\\#");defineSymbol(text$1,main,textord,"\u0023","\\#");defineSymbol(math,main,textord,"\u0026","\\&");defineSymbol(text$1,main,textord,"\u0026","\\&");defineSymbol(math,main,textord,"\u2135","\\aleph",true);defineSymbol(math,main,textord,"\u2200","\\forall",true);defineSymbol(math,main,textord,"\u210f","\\hbar",true);defineSymbol(math,main,textord,"\u2203","\\exists",true);defineSymbol(math,main,textord,"\u2207","\\nabla",true);defineSymbol(math,main,textord,"\u266d","\\flat",true);defineSymbol(math,main,textord,"\u2113","\\ell",true);defineSymbol(math,main,textord,"\u266e","\\natural",true);defineSymbol(math,main,textord,"\u2663","\\clubsuit",true);defineSymbol(math,main,textord,"\u2118","\\wp",true);defineSymbol(math,main,textord,"\u266f","\\sharp",true);defineSymbol(math,main,textord,"\u2662","\\diamondsuit",true);defineSymbol(math,main,textord,"\u211c","\\Re",true);defineSymbol(math,main,textord,"\u2661","\\heartsuit",true);defineSymbol(math,main,textord,"\u2111","\\Im",true);defineSymbol(math,main,textord,"\u2660","\\spadesuit",true);defineSymbol(text$1,main,textord,"\u00a7","\\S",true);defineSymbol(text$1,main,textord,"\u00b6","\\P",true);// Math and Text
    defineSymbol(math,main,textord,"\u2020","\\dag");defineSymbol(text$1,main,textord,"\u2020","\\dag");defineSymbol(text$1,main,textord,"\u2020","\\textdagger");defineSymbol(math,main,textord,"\u2021","\\ddag");defineSymbol(text$1,main,textord,"\u2021","\\ddag");defineSymbol(text$1,main,textord,"\u2021","\\textdaggerdbl");// Large Delimiters
    defineSymbol(math,main,close,"\u23b1","\\rmoustache",true);defineSymbol(math,main,open,"\u23b0","\\lmoustache",true);defineSymbol(math,main,close,"\u27ef","\\rgroup",true);defineSymbol(math,main,open,"\u27ee","\\lgroup",true);// Binary Operators
    defineSymbol(math,main,bin,"\u2213","\\mp",true);defineSymbol(math,main,bin,"\u2296","\\ominus",true);defineSymbol(math,main,bin,"\u228e","\\uplus",true);defineSymbol(math,main,bin,"\u2293","\\sqcap",true);defineSymbol(math,main,bin,"\u2217","\\ast");defineSymbol(math,main,bin,"\u2294","\\sqcup",true);defineSymbol(math,main,bin,"\u25ef","\\bigcirc");defineSymbol(math,main,bin,"\u2219","\\bullet");defineSymbol(math,main,bin,"\u2021","\\ddagger");defineSymbol(math,main,bin,"\u2240","\\wr",true);defineSymbol(math,main,bin,"\u2a3f","\\amalg");defineSymbol(math,main,bin,"\u0026","\\And");// from amsmath
    // Arrow Symbols
    defineSymbol(math,main,rel,"\u27f5","\\longleftarrow",true);defineSymbol(math,main,rel,"\u21d0","\\Leftarrow",true);defineSymbol(math,main,rel,"\u27f8","\\Longleftarrow",true);defineSymbol(math,main,rel,"\u27f6","\\longrightarrow",true);defineSymbol(math,main,rel,"\u21d2","\\Rightarrow",true);defineSymbol(math,main,rel,"\u27f9","\\Longrightarrow",true);defineSymbol(math,main,rel,"\u2194","\\leftrightarrow",true);defineSymbol(math,main,rel,"\u27f7","\\longleftrightarrow",true);defineSymbol(math,main,rel,"\u21d4","\\Leftrightarrow",true);defineSymbol(math,main,rel,"\u27fa","\\Longleftrightarrow",true);defineSymbol(math,main,rel,"\u21a6","\\mapsto",true);defineSymbol(math,main,rel,"\u27fc","\\longmapsto",true);defineSymbol(math,main,rel,"\u2197","\\nearrow",true);defineSymbol(math,main,rel,"\u21a9","\\hookleftarrow",true);defineSymbol(math,main,rel,"\u21aa","\\hookrightarrow",true);defineSymbol(math,main,rel,"\u2198","\\searrow",true);defineSymbol(math,main,rel,"\u21bc","\\leftharpoonup",true);defineSymbol(math,main,rel,"\u21c0","\\rightharpoonup",true);defineSymbol(math,main,rel,"\u2199","\\swarrow",true);defineSymbol(math,main,rel,"\u21bd","\\leftharpoondown",true);defineSymbol(math,main,rel,"\u21c1","\\rightharpoondown",true);defineSymbol(math,main,rel,"\u2196","\\nwarrow",true);defineSymbol(math,main,rel,"\u21cc","\\rightleftharpoons",true);// AMS Negated Binary Relations
    defineSymbol(math,ams,rel,"\u226e","\\nless",true);// Symbol names preceeded by "@" each have a corresponding macro.
    defineSymbol(math,ams,rel,"\ue010","\\@nleqslant");defineSymbol(math,ams,rel,"\ue011","\\@nleqq");defineSymbol(math,ams,rel,"\u2a87","\\lneq",true);defineSymbol(math,ams,rel,"\u2268","\\lneqq",true);defineSymbol(math,ams,rel,"\ue00c","\\@lvertneqq");defineSymbol(math,ams,rel,"\u22e6","\\lnsim",true);defineSymbol(math,ams,rel,"\u2a89","\\lnapprox",true);defineSymbol(math,ams,rel,"\u2280","\\nprec",true);// unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
    defineSymbol(math,ams,rel,"\u22e0","\\npreceq",true);defineSymbol(math,ams,rel,"\u22e8","\\precnsim",true);defineSymbol(math,ams,rel,"\u2ab9","\\precnapprox",true);defineSymbol(math,ams,rel,"\u2241","\\nsim",true);defineSymbol(math,ams,rel,"\ue006","\\@nshortmid");defineSymbol(math,ams,rel,"\u2224","\\nmid",true);defineSymbol(math,ams,rel,"\u22ac","\\nvdash",true);defineSymbol(math,ams,rel,"\u22ad","\\nvDash",true);defineSymbol(math,ams,rel,"\u22ea","\\ntriangleleft");defineSymbol(math,ams,rel,"\u22ec","\\ntrianglelefteq",true);defineSymbol(math,ams,rel,"\u228a","\\subsetneq",true);defineSymbol(math,ams,rel,"\ue01a","\\@varsubsetneq");defineSymbol(math,ams,rel,"\u2acb","\\subsetneqq",true);defineSymbol(math,ams,rel,"\ue017","\\@varsubsetneqq");defineSymbol(math,ams,rel,"\u226f","\\ngtr",true);defineSymbol(math,ams,rel,"\ue00f","\\@ngeqslant");defineSymbol(math,ams,rel,"\ue00e","\\@ngeqq");defineSymbol(math,ams,rel,"\u2a88","\\gneq",true);defineSymbol(math,ams,rel,"\u2269","\\gneqq",true);defineSymbol(math,ams,rel,"\ue00d","\\@gvertneqq");defineSymbol(math,ams,rel,"\u22e7","\\gnsim",true);defineSymbol(math,ams,rel,"\u2a8a","\\gnapprox",true);defineSymbol(math,ams,rel,"\u2281","\\nsucc",true);// unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
    defineSymbol(math,ams,rel,"\u22e1","\\nsucceq",true);defineSymbol(math,ams,rel,"\u22e9","\\succnsim",true);defineSymbol(math,ams,rel,"\u2aba","\\succnapprox",true);// unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
    defineSymbol(math,ams,rel,"\u2246","\\ncong",true);defineSymbol(math,ams,rel,"\ue007","\\@nshortparallel");defineSymbol(math,ams,rel,"\u2226","\\nparallel",true);defineSymbol(math,ams,rel,"\u22af","\\nVDash",true);defineSymbol(math,ams,rel,"\u22eb","\\ntriangleright");defineSymbol(math,ams,rel,"\u22ed","\\ntrianglerighteq",true);defineSymbol(math,ams,rel,"\ue018","\\@nsupseteqq");defineSymbol(math,ams,rel,"\u228b","\\supsetneq",true);defineSymbol(math,ams,rel,"\ue01b","\\@varsupsetneq");defineSymbol(math,ams,rel,"\u2acc","\\supsetneqq",true);defineSymbol(math,ams,rel,"\ue019","\\@varsupsetneqq");defineSymbol(math,ams,rel,"\u22ae","\\nVdash",true);defineSymbol(math,ams,rel,"\u2ab5","\\precneqq",true);defineSymbol(math,ams,rel,"\u2ab6","\\succneqq",true);defineSymbol(math,ams,rel,"\ue016","\\@nsubseteqq");defineSymbol(math,ams,bin,"\u22b4","\\unlhd");defineSymbol(math,ams,bin,"\u22b5","\\unrhd");// AMS Negated Arrows
    defineSymbol(math,ams,rel,"\u219a","\\nleftarrow",true);defineSymbol(math,ams,rel,"\u219b","\\nrightarrow",true);defineSymbol(math,ams,rel,"\u21cd","\\nLeftarrow",true);defineSymbol(math,ams,rel,"\u21cf","\\nRightarrow",true);defineSymbol(math,ams,rel,"\u21ae","\\nleftrightarrow",true);defineSymbol(math,ams,rel,"\u21ce","\\nLeftrightarrow",true);// AMS Misc
    defineSymbol(math,ams,rel,"\u25b3","\\vartriangle");defineSymbol(math,ams,textord,"\u210f","\\hslash");defineSymbol(math,ams,textord,"\u25bd","\\triangledown");defineSymbol(math,ams,textord,"\u25ca","\\lozenge");defineSymbol(math,ams,textord,"\u24c8","\\circledS");defineSymbol(math,ams,textord,"\u00ae","\\circledR");defineSymbol(text$1,ams,textord,"\u00ae","\\circledR");defineSymbol(math,ams,textord,"\u2221","\\measuredangle",true);defineSymbol(math,ams,textord,"\u2204","\\nexists");defineSymbol(math,ams,textord,"\u2127","\\mho");defineSymbol(math,ams,textord,"\u2132","\\Finv",true);defineSymbol(math,ams,textord,"\u2141","\\Game",true);defineSymbol(math,ams,textord,"\u2035","\\backprime");defineSymbol(math,ams,textord,"\u25b2","\\blacktriangle");defineSymbol(math,ams,textord,"\u25bc","\\blacktriangledown");defineSymbol(math,ams,textord,"\u25a0","\\blacksquare");defineSymbol(math,ams,textord,"\u29eb","\\blacklozenge");defineSymbol(math,ams,textord,"\u2605","\\bigstar");defineSymbol(math,ams,textord,"\u2222","\\sphericalangle",true);defineSymbol(math,ams,textord,"\u2201","\\complement",true);// unicode-math maps U+F0 to \matheth. We map to AMS function \eth
    defineSymbol(math,ams,textord,"\u00f0","\\eth",true);defineSymbol(text$1,main,textord,"\u00f0","\u00f0");defineSymbol(math,ams,textord,"\u2571","\\diagup");defineSymbol(math,ams,textord,"\u2572","\\diagdown");defineSymbol(math,ams,textord,"\u25a1","\\square");defineSymbol(math,ams,textord,"\u25a1","\\Box");defineSymbol(math,ams,textord,"\u25ca","\\Diamond");// unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
    defineSymbol(math,ams,textord,"\u00a5","\\yen",true);defineSymbol(text$1,ams,textord,"\u00a5","\\yen",true);defineSymbol(math,ams,textord,"\u2713","\\checkmark",true);defineSymbol(text$1,ams,textord,"\u2713","\\checkmark");// AMS Hebrew
    defineSymbol(math,ams,textord,"\u2136","\\beth",true);defineSymbol(math,ams,textord,"\u2138","\\daleth",true);defineSymbol(math,ams,textord,"\u2137","\\gimel",true);// AMS Greek
    defineSymbol(math,ams,textord,"\u03dd","\\digamma",true);defineSymbol(math,ams,textord,"\u03f0","\\varkappa");// AMS Delimiters
    defineSymbol(math,ams,open,"\u250c","\\@ulcorner",true);defineSymbol(math,ams,close,"\u2510","\\@urcorner",true);defineSymbol(math,ams,open,"\u2514","\\@llcorner",true);defineSymbol(math,ams,close,"\u2518","\\@lrcorner",true);// AMS Binary Relations
    defineSymbol(math,ams,rel,"\u2266","\\leqq",true);defineSymbol(math,ams,rel,"\u2a7d","\\leqslant",true);defineSymbol(math,ams,rel,"\u2a95","\\eqslantless",true);defineSymbol(math,ams,rel,"\u2272","\\lesssim",true);defineSymbol(math,ams,rel,"\u2a85","\\lessapprox",true);defineSymbol(math,ams,rel,"\u224a","\\approxeq",true);defineSymbol(math,ams,bin,"\u22d6","\\lessdot");defineSymbol(math,ams,rel,"\u22d8","\\lll",true);defineSymbol(math,ams,rel,"\u2276","\\lessgtr",true);defineSymbol(math,ams,rel,"\u22da","\\lesseqgtr",true);defineSymbol(math,ams,rel,"\u2a8b","\\lesseqqgtr",true);defineSymbol(math,ams,rel,"\u2251","\\doteqdot");defineSymbol(math,ams,rel,"\u2253","\\risingdotseq",true);defineSymbol(math,ams,rel,"\u2252","\\fallingdotseq",true);defineSymbol(math,ams,rel,"\u223d","\\backsim",true);defineSymbol(math,ams,rel,"\u22cd","\\backsimeq",true);defineSymbol(math,ams,rel,"\u2ac5","\\subseteqq",true);defineSymbol(math,ams,rel,"\u22d0","\\Subset",true);defineSymbol(math,ams,rel,"\u228f","\\sqsubset",true);defineSymbol(math,ams,rel,"\u227c","\\preccurlyeq",true);defineSymbol(math,ams,rel,"\u22de","\\curlyeqprec",true);defineSymbol(math,ams,rel,"\u227e","\\precsim",true);defineSymbol(math,ams,rel,"\u2ab7","\\precapprox",true);defineSymbol(math,ams,rel,"\u22b2","\\vartriangleleft");defineSymbol(math,ams,rel,"\u22b4","\\trianglelefteq");defineSymbol(math,ams,rel,"\u22a8","\\vDash",true);defineSymbol(math,ams,rel,"\u22aa","\\Vvdash",true);defineSymbol(math,ams,rel,"\u2323","\\smallsmile");defineSymbol(math,ams,rel,"\u2322","\\smallfrown");defineSymbol(math,ams,rel,"\u224f","\\bumpeq",true);defineSymbol(math,ams,rel,"\u224e","\\Bumpeq",true);defineSymbol(math,ams,rel,"\u2267","\\geqq",true);defineSymbol(math,ams,rel,"\u2a7e","\\geqslant",true);defineSymbol(math,ams,rel,"\u2a96","\\eqslantgtr",true);defineSymbol(math,ams,rel,"\u2273","\\gtrsim",true);defineSymbol(math,ams,rel,"\u2a86","\\gtrapprox",true);defineSymbol(math,ams,bin,"\u22d7","\\gtrdot");defineSymbol(math,ams,rel,"\u22d9","\\ggg",true);defineSymbol(math,ams,rel,"\u2277","\\gtrless",true);defineSymbol(math,ams,rel,"\u22db","\\gtreqless",true);defineSymbol(math,ams,rel,"\u2a8c","\\gtreqqless",true);defineSymbol(math,ams,rel,"\u2256","\\eqcirc",true);defineSymbol(math,ams,rel,"\u2257","\\circeq",true);defineSymbol(math,ams,rel,"\u225c","\\triangleq",true);defineSymbol(math,ams,rel,"\u223c","\\thicksim");defineSymbol(math,ams,rel,"\u2248","\\thickapprox");defineSymbol(math,ams,rel,"\u2ac6","\\supseteqq",true);defineSymbol(math,ams,rel,"\u22d1","\\Supset",true);defineSymbol(math,ams,rel,"\u2290","\\sqsupset",true);defineSymbol(math,ams,rel,"\u227d","\\succcurlyeq",true);defineSymbol(math,ams,rel,"\u22df","\\curlyeqsucc",true);defineSymbol(math,ams,rel,"\u227f","\\succsim",true);defineSymbol(math,ams,rel,"\u2ab8","\\succapprox",true);defineSymbol(math,ams,rel,"\u22b3","\\vartriangleright");defineSymbol(math,ams,rel,"\u22b5","\\trianglerighteq");defineSymbol(math,ams,rel,"\u22a9","\\Vdash",true);defineSymbol(math,ams,rel,"\u2223","\\shortmid");defineSymbol(math,ams,rel,"\u2225","\\shortparallel");defineSymbol(math,ams,rel,"\u226c","\\between",true);defineSymbol(math,ams,rel,"\u22d4","\\pitchfork",true);defineSymbol(math,ams,rel,"\u221d","\\varpropto");defineSymbol(math,ams,rel,"\u25c0","\\blacktriangleleft");// unicode-math says that \therefore is a mathord atom.
    // We kept the amssymb atom type, which is rel.
    defineSymbol(math,ams,rel,"\u2234","\\therefore",true);defineSymbol(math,ams,rel,"\u220d","\\backepsilon");defineSymbol(math,ams,rel,"\u25b6","\\blacktriangleright");// unicode-math says that \because is a mathord atom.
    // We kept the amssymb atom type, which is rel.
    defineSymbol(math,ams,rel,"\u2235","\\because",true);defineSymbol(math,ams,rel,"\u22d8","\\llless");defineSymbol(math,ams,rel,"\u22d9","\\gggtr");defineSymbol(math,ams,bin,"\u22b2","\\lhd");defineSymbol(math,ams,bin,"\u22b3","\\rhd");defineSymbol(math,ams,rel,"\u2242","\\eqsim",true);defineSymbol(math,main,rel,"\u22c8","\\Join");defineSymbol(math,ams,rel,"\u2251","\\Doteq",true);// AMS Binary Operators
    defineSymbol(math,ams,bin,"\u2214","\\dotplus",true);defineSymbol(math,ams,bin,"\u2216","\\smallsetminus");defineSymbol(math,ams,bin,"\u22d2","\\Cap",true);defineSymbol(math,ams,bin,"\u22d3","\\Cup",true);defineSymbol(math,ams,bin,"\u2a5e","\\doublebarwedge",true);defineSymbol(math,ams,bin,"\u229f","\\boxminus",true);defineSymbol(math,ams,bin,"\u229e","\\boxplus",true);defineSymbol(math,ams,bin,"\u22c7","\\divideontimes",true);defineSymbol(math,ams,bin,"\u22c9","\\ltimes",true);defineSymbol(math,ams,bin,"\u22ca","\\rtimes",true);defineSymbol(math,ams,bin,"\u22cb","\\leftthreetimes",true);defineSymbol(math,ams,bin,"\u22cc","\\rightthreetimes",true);defineSymbol(math,ams,bin,"\u22cf","\\curlywedge",true);defineSymbol(math,ams,bin,"\u22ce","\\curlyvee",true);defineSymbol(math,ams,bin,"\u229d","\\circleddash",true);defineSymbol(math,ams,bin,"\u229b","\\circledast",true);defineSymbol(math,ams,bin,"\u22c5","\\centerdot");defineSymbol(math,ams,bin,"\u22ba","\\intercal",true);defineSymbol(math,ams,bin,"\u22d2","\\doublecap");defineSymbol(math,ams,bin,"\u22d3","\\doublecup");defineSymbol(math,ams,bin,"\u22a0","\\boxtimes",true);// AMS Arrows
    // Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
    // We'll map it to AMS function \dashrightarrow. It produces the same atom.
    defineSymbol(math,ams,rel,"\u21e2","\\dashrightarrow",true);// unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
    defineSymbol(math,ams,rel,"\u21e0","\\dashleftarrow",true);defineSymbol(math,ams,rel,"\u21c7","\\leftleftarrows",true);defineSymbol(math,ams,rel,"\u21c6","\\leftrightarrows",true);defineSymbol(math,ams,rel,"\u21da","\\Lleftarrow",true);defineSymbol(math,ams,rel,"\u219e","\\twoheadleftarrow",true);defineSymbol(math,ams,rel,"\u21a2","\\leftarrowtail",true);defineSymbol(math,ams,rel,"\u21ab","\\looparrowleft",true);defineSymbol(math,ams,rel,"\u21cb","\\leftrightharpoons",true);defineSymbol(math,ams,rel,"\u21b6","\\curvearrowleft",true);// unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
    defineSymbol(math,ams,rel,"\u21ba","\\circlearrowleft",true);defineSymbol(math,ams,rel,"\u21b0","\\Lsh",true);defineSymbol(math,ams,rel,"\u21c8","\\upuparrows",true);defineSymbol(math,ams,rel,"\u21bf","\\upharpoonleft",true);defineSymbol(math,ams,rel,"\u21c3","\\downharpoonleft",true);defineSymbol(math,ams,rel,"\u22b8","\\multimap",true);defineSymbol(math,ams,rel,"\u21ad","\\leftrightsquigarrow",true);defineSymbol(math,ams,rel,"\u21c9","\\rightrightarrows",true);defineSymbol(math,ams,rel,"\u21c4","\\rightleftarrows",true);defineSymbol(math,ams,rel,"\u21a0","\\twoheadrightarrow",true);defineSymbol(math,ams,rel,"\u21a3","\\rightarrowtail",true);defineSymbol(math,ams,rel,"\u21ac","\\looparrowright",true);defineSymbol(math,ams,rel,"\u21b7","\\curvearrowright",true);// unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
    defineSymbol(math,ams,rel,"\u21bb","\\circlearrowright",true);defineSymbol(math,ams,rel,"\u21b1","\\Rsh",true);defineSymbol(math,ams,rel,"\u21ca","\\downdownarrows",true);defineSymbol(math,ams,rel,"\u21be","\\upharpoonright",true);defineSymbol(math,ams,rel,"\u21c2","\\downharpoonright",true);defineSymbol(math,ams,rel,"\u21dd","\\rightsquigarrow",true);defineSymbol(math,ams,rel,"\u21dd","\\leadsto");defineSymbol(math,ams,rel,"\u21db","\\Rrightarrow",true);defineSymbol(math,ams,rel,"\u21be","\\restriction");defineSymbol(math,main,textord,"\u2018","`");defineSymbol(math,main,textord,"$","\\$");defineSymbol(text$1,main,textord,"$","\\$");defineSymbol(text$1,main,textord,"$","\\textdollar");defineSymbol(math,main,textord,"%","\\%");defineSymbol(text$1,main,textord,"%","\\%");defineSymbol(math,main,textord,"_","\\_");defineSymbol(text$1,main,textord,"_","\\_");defineSymbol(text$1,main,textord,"_","\\textunderscore");defineSymbol(math,main,textord,"\u2220","\\angle",true);defineSymbol(math,main,textord,"\u221e","\\infty",true);defineSymbol(math,main,textord,"\u2032","\\prime");defineSymbol(math,main,textord,"\u25b3","\\triangle");defineSymbol(math,main,textord,"\u0393","\\Gamma",true);defineSymbol(math,main,textord,"\u0394","\\Delta",true);defineSymbol(math,main,textord,"\u0398","\\Theta",true);defineSymbol(math,main,textord,"\u039b","\\Lambda",true);defineSymbol(math,main,textord,"\u039e","\\Xi",true);defineSymbol(math,main,textord,"\u03a0","\\Pi",true);defineSymbol(math,main,textord,"\u03a3","\\Sigma",true);defineSymbol(math,main,textord,"\u03a5","\\Upsilon",true);defineSymbol(math,main,textord,"\u03a6","\\Phi",true);defineSymbol(math,main,textord,"\u03a8","\\Psi",true);defineSymbol(math,main,textord,"\u03a9","\\Omega",true);defineSymbol(math,main,textord,"A","\u0391");defineSymbol(math,main,textord,"B","\u0392");defineSymbol(math,main,textord,"E","\u0395");defineSymbol(math,main,textord,"Z","\u0396");defineSymbol(math,main,textord,"H","\u0397");defineSymbol(math,main,textord,"I","\u0399");defineSymbol(math,main,textord,"K","\u039A");defineSymbol(math,main,textord,"M","\u039C");defineSymbol(math,main,textord,"N","\u039D");defineSymbol(math,main,textord,"O","\u039F");defineSymbol(math,main,textord,"P","\u03A1");defineSymbol(math,main,textord,"T","\u03A4");defineSymbol(math,main,textord,"X","\u03A7");defineSymbol(math,main,textord,"\u00ac","\\neg",true);defineSymbol(math,main,textord,"\u00ac","\\lnot");defineSymbol(math,main,textord,"\u22a4","\\top");defineSymbol(math,main,textord,"\u22a5","\\bot");defineSymbol(math,main,textord,"\u2205","\\emptyset");defineSymbol(math,ams,textord,"\u2205","\\varnothing");defineSymbol(math,main,mathord,"\u03b1","\\alpha",true);defineSymbol(math,main,mathord,"\u03b2","\\beta",true);defineSymbol(math,main,mathord,"\u03b3","\\gamma",true);defineSymbol(math,main,mathord,"\u03b4","\\delta",true);defineSymbol(math,main,mathord,"\u03f5","\\epsilon",true);defineSymbol(math,main,mathord,"\u03b6","\\zeta",true);defineSymbol(math,main,mathord,"\u03b7","\\eta",true);defineSymbol(math,main,mathord,"\u03b8","\\theta",true);defineSymbol(math,main,mathord,"\u03b9","\\iota",true);defineSymbol(math,main,mathord,"\u03ba","\\kappa",true);defineSymbol(math,main,mathord,"\u03bb","\\lambda",true);defineSymbol(math,main,mathord,"\u03bc","\\mu",true);defineSymbol(math,main,mathord,"\u03bd","\\nu",true);defineSymbol(math,main,mathord,"\u03be","\\xi",true);defineSymbol(math,main,mathord,"\u03bf","\\omicron",true);defineSymbol(math,main,mathord,"\u03c0","\\pi",true);defineSymbol(math,main,mathord,"\u03c1","\\rho",true);defineSymbol(math,main,mathord,"\u03c3","\\sigma",true);defineSymbol(math,main,mathord,"\u03c4","\\tau",true);defineSymbol(math,main,mathord,"\u03c5","\\upsilon",true);defineSymbol(math,main,mathord,"\u03d5","\\phi",true);defineSymbol(math,main,mathord,"\u03c7","\\chi",true);defineSymbol(math,main,mathord,"\u03c8","\\psi",true);defineSymbol(math,main,mathord,"\u03c9","\\omega",true);defineSymbol(math,main,mathord,"\u03b5","\\varepsilon",true);defineSymbol(math,main,mathord,"\u03d1","\\vartheta",true);defineSymbol(math,main,mathord,"\u03d6","\\varpi",true);defineSymbol(math,main,mathord,"\u03f1","\\varrho",true);defineSymbol(math,main,mathord,"\u03c2","\\varsigma",true);defineSymbol(math,main,mathord,"\u03c6","\\varphi",true);defineSymbol(math,main,bin,"\u2217","*");defineSymbol(math,main,bin,"+","+");defineSymbol(math,main,bin,"\u2212","-");defineSymbol(math,main,bin,"\u22c5","\\cdot",true);defineSymbol(math,main,bin,"\u2218","\\circ");defineSymbol(math,main,bin,"\u00f7","\\div",true);defineSymbol(math,main,bin,"\u00b1","\\pm",true);defineSymbol(math,main,bin,"\u00d7","\\times",true);defineSymbol(math,main,bin,"\u2229","\\cap",true);defineSymbol(math,main,bin,"\u222a","\\cup",true);defineSymbol(math,main,bin,"\u2216","\\setminus");defineSymbol(math,main,bin,"\u2227","\\land");defineSymbol(math,main,bin,"\u2228","\\lor");defineSymbol(math,main,bin,"\u2227","\\wedge",true);defineSymbol(math,main,bin,"\u2228","\\vee",true);defineSymbol(math,main,textord,"\u221a","\\surd");defineSymbol(math,main,open,"\u27e8","\\langle",true);defineSymbol(math,main,open,"\u2223","\\lvert");defineSymbol(math,main,open,"\u2225","\\lVert");defineSymbol(math,main,close,"?","?");defineSymbol(math,main,close,"!","!");defineSymbol(math,main,close,"\u27e9","\\rangle",true);defineSymbol(math,main,close,"\u2223","\\rvert");defineSymbol(math,main,close,"\u2225","\\rVert");defineSymbol(math,main,rel,"=","=");defineSymbol(math,main,rel,":",":");defineSymbol(math,main,rel,"\u2248","\\approx",true);defineSymbol(math,main,rel,"\u2245","\\cong",true);defineSymbol(math,main,rel,"\u2265","\\ge");defineSymbol(math,main,rel,"\u2265","\\geq",true);defineSymbol(math,main,rel,"\u2190","\\gets");defineSymbol(math,main,rel,">","\\gt",true);defineSymbol(math,main,rel,"\u2208","\\in",true);defineSymbol(math,main,rel,"\ue020","\\@not");defineSymbol(math,main,rel,"\u2282","\\subset",true);defineSymbol(math,main,rel,"\u2283","\\supset",true);defineSymbol(math,main,rel,"\u2286","\\subseteq",true);defineSymbol(math,main,rel,"\u2287","\\supseteq",true);defineSymbol(math,ams,rel,"\u2288","\\nsubseteq",true);defineSymbol(math,ams,rel,"\u2289","\\nsupseteq",true);defineSymbol(math,main,rel,"\u22a8","\\models");defineSymbol(math,main,rel,"\u2190","\\leftarrow",true);defineSymbol(math,main,rel,"\u2264","\\le");defineSymbol(math,main,rel,"\u2264","\\leq",true);defineSymbol(math,main,rel,"<","\\lt",true);defineSymbol(math,main,rel,"\u2192","\\rightarrow",true);defineSymbol(math,main,rel,"\u2192","\\to");defineSymbol(math,ams,rel,"\u2271","\\ngeq",true);defineSymbol(math,ams,rel,"\u2270","\\nleq",true);defineSymbol(math,main,spacing,"\u00a0","\\ ");defineSymbol(math,main,spacing,"\u00a0","~");defineSymbol(math,main,spacing,"\u00a0","\\space");// Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
    defineSymbol(math,main,spacing,"\u00a0","\\nobreakspace");defineSymbol(text$1,main,spacing,"\u00a0","\\ ");defineSymbol(text$1,main,spacing,"\u00a0"," ");defineSymbol(text$1,main,spacing,"\u00a0","~");defineSymbol(text$1,main,spacing,"\u00a0","\\space");defineSymbol(text$1,main,spacing,"\u00a0","\\nobreakspace");defineSymbol(math,main,spacing,null,"\\nobreak");defineSymbol(math,main,spacing,null,"\\allowbreak");defineSymbol(math,main,punct,",",",");defineSymbol(math,main,punct,";",";");defineSymbol(math,ams,bin,"\u22bc","\\barwedge",true);defineSymbol(math,ams,bin,"\u22bb","\\veebar",true);defineSymbol(math,main,bin,"\u2299","\\odot",true);defineSymbol(math,main,bin,"\u2295","\\oplus",true);defineSymbol(math,main,bin,"\u2297","\\otimes",true);defineSymbol(math,main,textord,"\u2202","\\partial",true);defineSymbol(math,main,bin,"\u2298","\\oslash",true);defineSymbol(math,ams,bin,"\u229a","\\circledcirc",true);defineSymbol(math,ams,bin,"\u22a1","\\boxdot",true);defineSymbol(math,main,bin,"\u25b3","\\bigtriangleup");defineSymbol(math,main,bin,"\u25bd","\\bigtriangledown");defineSymbol(math,main,bin,"\u2020","\\dagger");defineSymbol(math,main,bin,"\u22c4","\\diamond");defineSymbol(math,main,bin,"\u22c6","\\star");defineSymbol(math,main,bin,"\u25c3","\\triangleleft");defineSymbol(math,main,bin,"\u25b9","\\triangleright");defineSymbol(math,main,open,"{","\\{");defineSymbol(text$1,main,textord,"{","\\{");defineSymbol(text$1,main,textord,"{","\\textbraceleft");defineSymbol(math,main,close,"}","\\}");defineSymbol(text$1,main,textord,"}","\\}");defineSymbol(text$1,main,textord,"}","\\textbraceright");defineSymbol(math,main,open,"{","\\lbrace");defineSymbol(math,main,close,"}","\\rbrace");defineSymbol(math,main,open,"[","\\lbrack",true);defineSymbol(text$1,main,textord,"[","\\lbrack",true);defineSymbol(math,main,close,"]","\\rbrack",true);defineSymbol(text$1,main,textord,"]","\\rbrack",true);defineSymbol(math,main,open,"(","\\lparen",true);defineSymbol(math,main,close,")","\\rparen",true);defineSymbol(text$1,main,textord,"<","\\textless",true);// in T1 fontenc
    defineSymbol(text$1,main,textord,">","\\textgreater",true);// in T1 fontenc
    defineSymbol(math,main,open,"\u230a","\\lfloor",true);defineSymbol(math,main,close,"\u230b","\\rfloor",true);defineSymbol(math,main,open,"\u2308","\\lceil",true);defineSymbol(math,main,close,"\u2309","\\rceil",true);defineSymbol(math,main,textord,"\\","\\backslash");defineSymbol(math,main,textord,"\u2223","|");defineSymbol(math,main,textord,"\u2223","\\vert");defineSymbol(text$1,main,textord,"|","\\textbar",true);// in T1 fontenc
    defineSymbol(math,main,textord,"\u2225","\\|");defineSymbol(math,main,textord,"\u2225","\\Vert");defineSymbol(text$1,main,textord,"\u2225","\\textbardbl");defineSymbol(text$1,main,textord,"~","\\textasciitilde");defineSymbol(text$1,main,textord,"\\","\\textbackslash");defineSymbol(text$1,main,textord,"^","\\textasciicircum");defineSymbol(math,main,rel,"\u2191","\\uparrow",true);defineSymbol(math,main,rel,"\u21d1","\\Uparrow",true);defineSymbol(math,main,rel,"\u2193","\\downarrow",true);defineSymbol(math,main,rel,"\u21d3","\\Downarrow",true);defineSymbol(math,main,rel,"\u2195","\\updownarrow",true);defineSymbol(math,main,rel,"\u21d5","\\Updownarrow",true);defineSymbol(math,main,op,"\u2210","\\coprod");defineSymbol(math,main,op,"\u22c1","\\bigvee");defineSymbol(math,main,op,"\u22c0","\\bigwedge");defineSymbol(math,main,op,"\u2a04","\\biguplus");defineSymbol(math,main,op,"\u22c2","\\bigcap");defineSymbol(math,main,op,"\u22c3","\\bigcup");defineSymbol(math,main,op,"\u222b","\\int");defineSymbol(math,main,op,"\u222b","\\intop");defineSymbol(math,main,op,"\u222c","\\iint");defineSymbol(math,main,op,"\u222d","\\iiint");defineSymbol(math,main,op,"\u220f","\\prod");defineSymbol(math,main,op,"\u2211","\\sum");defineSymbol(math,main,op,"\u2a02","\\bigotimes");defineSymbol(math,main,op,"\u2a01","\\bigoplus");defineSymbol(math,main,op,"\u2a00","\\bigodot");defineSymbol(math,main,op,"\u222e","\\oint");defineSymbol(math,main,op,"\u2a06","\\bigsqcup");defineSymbol(math,main,op,"\u222b","\\smallint");defineSymbol(text$1,main,inner,"\u2026","\\textellipsis");defineSymbol(math,main,inner,"\u2026","\\mathellipsis");defineSymbol(text$1,main,inner,"\u2026","\\ldots",true);defineSymbol(math,main,inner,"\u2026","\\ldots",true);defineSymbol(math,main,inner,"\u22ef","\\@cdots",true);defineSymbol(math,main,inner,"\u22f1","\\ddots",true);defineSymbol(math,main,textord,"\u22ee","\\varvdots");// \vdots is a macro
    defineSymbol(math,main,accent,"\u02ca","\\acute");defineSymbol(math,main,accent,"\u02cb","\\grave");defineSymbol(math,main,accent,"\u00a8","\\ddot");defineSymbol(math,main,accent,"\u007e","\\tilde");defineSymbol(math,main,accent,"\u02c9","\\bar");defineSymbol(math,main,accent,"\u02d8","\\breve");defineSymbol(math,main,accent,"\u02c7","\\check");defineSymbol(math,main,accent,"\u005e","\\hat");defineSymbol(math,main,accent,"\u20d7","\\vec");defineSymbol(math,main,accent,"\u02d9","\\dot");defineSymbol(math,main,accent,"\u02da","\\mathring");// \imath and \jmath should be invariant to \mathrm, \mathbf, etc., so use PUA
    defineSymbol(math,main,mathord,"\ue131","\\@imath");defineSymbol(math,main,mathord,"\ue237","\\@jmath");defineSymbol(math,main,textord,"\u0131","\u0131");defineSymbol(math,main,textord,"\u0237","\u0237");defineSymbol(text$1,main,textord,"\u0131","\\i",true);defineSymbol(text$1,main,textord,"\u0237","\\j",true);defineSymbol(text$1,main,textord,"\u00df","\\ss",true);defineSymbol(text$1,main,textord,"\u00e6","\\ae",true);defineSymbol(text$1,main,textord,"\u0153","\\oe",true);defineSymbol(text$1,main,textord,"\u00f8","\\o",true);defineSymbol(text$1,main,textord,"\u00c6","\\AE",true);defineSymbol(text$1,main,textord,"\u0152","\\OE",true);defineSymbol(text$1,main,textord,"\u00d8","\\O",true);defineSymbol(text$1,main,accent,"\u02ca","\\'");// acute
    defineSymbol(text$1,main,accent,"\u02cb","\\`");// grave
    defineSymbol(text$1,main,accent,"\u02c6","\\^");// circumflex
    defineSymbol(text$1,main,accent,"\u02dc","\\~");// tilde
    defineSymbol(text$1,main,accent,"\u02c9","\\=");// macron
    defineSymbol(text$1,main,accent,"\u02d8","\\u");// breve
    defineSymbol(text$1,main,accent,"\u02d9","\\.");// dot above
    defineSymbol(text$1,main,accent,"\u02da","\\r");// ring above
    defineSymbol(text$1,main,accent,"\u02c7","\\v");// caron
    defineSymbol(text$1,main,accent,"\u00a8",'\\"');// diaresis
    defineSymbol(text$1,main,accent,"\u02dd","\\H");// double acute
    defineSymbol(text$1,main,accent,"\u25ef","\\textcircled");// \bigcirc glyph
    // These ligatures are detected and created in Parser.js's `formLigatures`.
    const ligatures={"--":true,"---":true,"``":true,"''":true};defineSymbol(text$1,main,textord,"\u2013","--",true);defineSymbol(text$1,main,textord,"\u2013","\\textendash");defineSymbol(text$1,main,textord,"\u2014","---",true);defineSymbol(text$1,main,textord,"\u2014","\\textemdash");defineSymbol(text$1,main,textord,"\u2018","`",true);defineSymbol(text$1,main,textord,"\u2018","\\textquoteleft");defineSymbol(text$1,main,textord,"\u2019","'",true);defineSymbol(text$1,main,textord,"\u2019","\\textquoteright");defineSymbol(text$1,main,textord,"\u201c","``",true);defineSymbol(text$1,main,textord,"\u201c","\\textquotedblleft");defineSymbol(text$1,main,textord,"\u201d","''",true);defineSymbol(text$1,main,textord,"\u201d","\\textquotedblright");//  \degree from gensymb package
    defineSymbol(math,main,textord,"\u00b0","\\degree",true);defineSymbol(text$1,main,textord,"\u00b0","\\degree");// \textdegree from inputenc package
    defineSymbol(text$1,main,textord,"\u00b0","\\textdegree",true);// TODO: In LaTeX, \pounds can generate a different character in text and math
    // mode, but among our fonts, only Main-Regular defines this character "163".
    defineSymbol(math,main,textord,"\u00a3","\\pounds");defineSymbol(math,main,textord,"\u00a3","\\mathsterling",true);defineSymbol(text$1,main,textord,"\u00a3","\\pounds");defineSymbol(text$1,main,textord,"\u00a3","\\textsterling",true);defineSymbol(math,ams,textord,"\u2720","\\maltese");defineSymbol(text$1,ams,textord,"\u2720","\\maltese");// There are lots of symbols which are the same, so we add them in afterwards.
    // All of these are textords in math mode
    const mathTextSymbols="0123456789/@.\"";for(let i=0;i<mathTextSymbols.length;i++){const ch=mathTextSymbols.charAt(i);defineSymbol(math,main,textord,ch,ch);}// All of these are textords in text mode
    const textSymbols="0123456789!@*()-=+\";:?/.,";for(let i=0;i<textSymbols.length;i++){const ch=textSymbols.charAt(i);defineSymbol(text$1,main,textord,ch,ch);}// All of these are textords in text mode, and mathords in math mode
    const letters="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";for(let i=0;i<letters.length;i++){const ch=letters.charAt(i);defineSymbol(math,main,mathord,ch,ch);defineSymbol(text$1,main,textord,ch,ch);}// Blackboard bold and script letters in Unicode range
    defineSymbol(math,ams,textord,"C","\u2102");// blackboard bold
    defineSymbol(text$1,ams,textord,"C","\u2102");defineSymbol(math,ams,textord,"H","\u210D");defineSymbol(text$1,ams,textord,"H","\u210D");defineSymbol(math,ams,textord,"N","\u2115");defineSymbol(text$1,ams,textord,"N","\u2115");defineSymbol(math,ams,textord,"P","\u2119");defineSymbol(text$1,ams,textord,"P","\u2119");defineSymbol(math,ams,textord,"Q","\u211A");defineSymbol(text$1,ams,textord,"Q","\u211A");defineSymbol(math,ams,textord,"R","\u211D");defineSymbol(text$1,ams,textord,"R","\u211D");defineSymbol(math,ams,textord,"Z","\u2124");defineSymbol(text$1,ams,textord,"Z","\u2124");defineSymbol(math,main,mathord,"h","\u210E");// italic h, Planck constant
    defineSymbol(text$1,main,mathord,"h","\u210E");// The next loop loads wide (surrogate pair) characters.
    // We support some letters in the Unicode range U+1D400 to U+1D7FF,
    // Mathematical Alphanumeric Symbols.
    // Some editors do not deal well with wide characters. So don't write the
    // string into this file. Instead, create the string from the surrogate pair.
    let wideChar="";for(let i=0;i<letters.length;i++){const ch=letters.charAt(i);// The hex numbers in the next line are a surrogate pair.
    // 0xD835 is the high surrogate for all letters in the range we support.
    // 0xDC00 is the low surrogate for bold A.
    wideChar=String.fromCharCode(0xD835,0xDC00+i);// A-Z a-z bold
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDC34+i);// A-Z a-z italic
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDC68+i);// A-Z a-z bold italic
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDD04+i);// A-Z a-z Fractur
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDDA0+i);// A-Z a-z sans-serif
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDDD4+i);// A-Z a-z sans bold
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDE08+i);// A-Z a-z sans italic
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDE70+i);// A-Z a-z monospace
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);if(i<26){// KaTeX fonts have only capital letters for blackboard bold and script.
    // See exception for k below.
    wideChar=String.fromCharCode(0xD835,0xDD38+i);// A-Z double struck
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDC9C+i);// A-Z script
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);}// TODO: Add bold script when it is supported by a KaTeX font.
    }// "k" is the only double struck lower case letter in the KaTeX fonts.
    wideChar=String.fromCharCode(0xD835,0xDD5C);// k double struck
    defineSymbol(math,main,mathord,"k",wideChar);defineSymbol(text$1,main,textord,"k",wideChar);// Next, some wide character numerals
    for(let i=0;i<10;i++){const ch=i.toString();wideChar=String.fromCharCode(0xD835,0xDFCE+i);// 0-9 bold
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDFE2+i);// 0-9 sans serif
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDFEC+i);// 0-9 bold sans
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);wideChar=String.fromCharCode(0xD835,0xDFF6+i);// 0-9 monospace
    defineSymbol(math,main,mathord,ch,wideChar);defineSymbol(text$1,main,textord,ch,wideChar);}// We add these Latin-1 letters as symbols for backwards-compatibility,
    // but they are not actually in the font, nor are they supported by the
    // Unicode accent mechanism, so they fall back to Times font and look ugly.
    // TODO(edemaine): Fix this.
    const extraLatin="\u00c7\u00d0\u00de\u00e7\u00fe";for(let i=0;i<extraLatin.length;i++){const ch=extraLatin.charAt(i);defineSymbol(math,main,mathord,ch,ch);defineSymbol(text$1,main,textord,ch,ch);}/**
     * This file provides support for Unicode range U+1D400 to U+1D7FF,
     * Mathematical Alphanumeric Symbols.
     *
     * Function wideCharacterFont takes a wide character as input and returns
     * the font information necessary to render it properly.
     */ /**
     * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
     * That document sorts characters into groups by font type, say bold or italic.
     *
     * In the arrays below, each subarray consists three elements:
     *      * The CSS class of that group when in math mode.
     *      * The CSS class of that group when in text mode.
     *      * The font name, so that KaTeX can get font metrics.
     */const wideLatinLetterData=[["mathbf","textbf","Main-Bold"],// A-Z bold upright
    ["mathbf","textbf","Main-Bold"],// a-z bold upright
    ["mathnormal","textit","Math-Italic"],// A-Z italic
    ["mathnormal","textit","Math-Italic"],// a-z italic
    ["boldsymbol","boldsymbol","Main-BoldItalic"],// A-Z bold italic
    ["boldsymbol","boldsymbol","Main-BoldItalic"],// a-z bold italic
    // Map fancy A-Z letters to script, not calligraphic.
    // This aligns with unicode-math and math fonts (except Cambria Math).
    ["mathscr","textscr","Script-Regular"],// A-Z script
    ["","",""],// a-z script.  No font
    ["","",""],// A-Z bold script. No font
    ["","",""],// a-z bold script. No font
    ["mathfrak","textfrak","Fraktur-Regular"],// A-Z Fraktur
    ["mathfrak","textfrak","Fraktur-Regular"],// a-z Fraktur
    ["mathbb","textbb","AMS-Regular"],// A-Z double-struck
    ["mathbb","textbb","AMS-Regular"],// k double-struck
    ["","",""],// A-Z bold Fraktur No font metrics
    ["","",""],// a-z bold Fraktur.   No font.
    ["mathsf","textsf","SansSerif-Regular"],// A-Z sans-serif
    ["mathsf","textsf","SansSerif-Regular"],// a-z sans-serif
    ["mathboldsf","textboldsf","SansSerif-Bold"],// A-Z bold sans-serif
    ["mathboldsf","textboldsf","SansSerif-Bold"],// a-z bold sans-serif
    ["mathitsf","textitsf","SansSerif-Italic"],// A-Z italic sans-serif
    ["mathitsf","textitsf","SansSerif-Italic"],// a-z italic sans-serif
    ["","",""],// A-Z bold italic sans. No font
    ["","",""],// a-z bold italic sans. No font
    ["mathtt","texttt","Typewriter-Regular"],// A-Z monospace
    ["mathtt","texttt","Typewriter-Regular"]];const wideNumeralData=[["mathbf","textbf","Main-Bold"],// 0-9 bold
    ["","",""],// 0-9 double-struck. No KaTeX font.
    ["mathsf","textsf","SansSerif-Regular"],// 0-9 sans-serif
    ["mathboldsf","textboldsf","SansSerif-Bold"],// 0-9 bold sans-serif
    ["mathtt","texttt","Typewriter-Regular"]];const wideCharacterFont=function wideCharacterFont(wideChar,mode){// IE doesn't support codePointAt(). So work with the surrogate pair.
    const H=wideChar.charCodeAt(0);// high surrogate
    const L=wideChar.charCodeAt(1);// low surrogate
    const codePoint=(H-0xD800)*0x400+(L-0xDC00)+0x10000;const j=mode==="math"?0:1;// column index for CSS class.
    if(0x1D400<=codePoint&&codePoint<0x1D6A4){// wideLatinLetterData contains exactly 26 chars on each row.
    // So we can calculate the relevant row. No traverse necessary.
    const i=Math.floor((codePoint-0x1D400)/26);return [wideLatinLetterData[i][2],wideLatinLetterData[i][j]];}else if(0x1D7CE<=codePoint&&codePoint<=0x1D7FF){// Numerals, ten per row.
    const i=Math.floor((codePoint-0x1D7CE)/10);return [wideNumeralData[i][2],wideNumeralData[i][j]];}else if(codePoint===0x1D6A5||codePoint===0x1D6A6){// dotless i or j
    return [wideLatinLetterData[0][2],wideLatinLetterData[0][j]];}else if(0x1D6A6<codePoint&&codePoint<0x1D7CE){// Greek letters. Not supported, yet.
    return ["",""];}else {// We don't support any wide characters outside 1D4001D7FF.
    throw new ParseError("Unsupported character: "+wideChar);}};/**
     * This file contains information about the options that the Parser carries
     * around with it while parsing. Data is held in an `Options` object, and when
     * recursing, a new `Options` object can be created with the `.with*` and
     * `.reset` functions.
     */const sizeStyleMap=[// Each element contains [textsize, scriptsize, scriptscriptsize].
    // The size mappings are taken from TeX with \normalsize=10pt.
    [1,1,1],// size1: [5, 5, 5]              \tiny
    [2,1,1],// size2: [6, 5, 5]
    [3,1,1],// size3: [7, 5, 5]              \scriptsize
    [4,2,1],// size4: [8, 6, 5]              \footnotesize
    [5,2,1],// size5: [9, 6, 5]              \small
    [6,3,1],// size6: [10, 7, 5]             \normalsize
    [7,4,2],// size7: [12, 8, 6]             \large
    [8,6,3],// size8: [14.4, 10, 7]          \Large
    [9,7,6],// size9: [17.28, 12, 10]        \LARGE
    [10,8,7],// size10: [20.74, 14.4, 12]     \huge
    [11,10,9]];const sizeMultipliers=[// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
    // you change size indexes, change that function.
    0.5,0.6,0.7,0.8,0.9,1.0,1.2,1.44,1.728,2.074,2.488];const sizeAtStyle=function sizeAtStyle(size,style){return style.size<2?size:sizeStyleMap[size-1][style.size-1];};// In these types, "" (empty string) means "no change".
    /**
     * This is the main options class. It contains the current style, size, color,
     * and font.
     *
     * Options objects should not be modified. To create a new Options with
     * different properties, call a `.having*` method.
     */let Options$1 = class Options{// A font family applies to a group of fonts (i.e. SansSerif), while a font
    // represents a specific font (i.e. SansSerif Bold).
    // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
    /**
       * The base size index.
       */constructor(data){this.style=void 0;this.color=void 0;this.size=void 0;this.textSize=void 0;this.phantom=void 0;this.font=void 0;this.fontFamily=void 0;this.fontWeight=void 0;this.fontShape=void 0;this.sizeMultiplier=void 0;this.maxSize=void 0;this.minRuleThickness=void 0;this._fontMetrics=void 0;this.style=data.style;this.color=data.color;this.size=data.size||Options.BASESIZE;this.textSize=data.textSize||this.size;this.phantom=!!data.phantom;this.font=data.font||"";this.fontFamily=data.fontFamily||"";this.fontWeight=data.fontWeight||'';this.fontShape=data.fontShape||'';this.sizeMultiplier=sizeMultipliers[this.size-1];this.maxSize=data.maxSize;this.minRuleThickness=data.minRuleThickness;this._fontMetrics=undefined;}/**
       * Returns a new options object with the same properties as "this".  Properties
       * from "extension" will be copied to the new options object.
       */extend(extension){const data={style:this.style,size:this.size,textSize:this.textSize,color:this.color,phantom:this.phantom,font:this.font,fontFamily:this.fontFamily,fontWeight:this.fontWeight,fontShape:this.fontShape,maxSize:this.maxSize,minRuleThickness:this.minRuleThickness};for(const key in extension){if(extension.hasOwnProperty(key)){data[key]=extension[key];}}return new Options(data);}/**
       * Return an options object with the given style. If `this.style === style`,
       * returns `this`.
       */havingStyle(style){if(this.style===style){return this;}else {return this.extend({style:style,size:sizeAtStyle(this.textSize,style)});}}/**
       * Return an options object with a cramped version of the current style. If
       * the current style is cramped, returns `this`.
       */havingCrampedStyle(){return this.havingStyle(this.style.cramp());}/**
       * Return an options object with the given size and in at least `\textstyle`.
       * Returns `this` if appropriate.
       */havingSize(size){if(this.size===size&&this.textSize===size){return this;}else {return this.extend({style:this.style.text(),size:size,textSize:size,sizeMultiplier:sizeMultipliers[size-1]});}}/**
       * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
       * changes to at least `\textstyle`.
       */havingBaseStyle(style){style=style||this.style.text();const wantSize=sizeAtStyle(Options.BASESIZE,style);if(this.size===wantSize&&this.textSize===Options.BASESIZE&&this.style===style){return this;}else {return this.extend({style:style,size:wantSize});}}/**
       * Remove the effect of sizing changes such as \Huge.
       * Keep the effect of the current style, such as \scriptstyle.
       */havingBaseSizing(){let size;switch(this.style.id){case 4:case 5:size=3;// normalsize in scriptstyle
    break;case 6:case 7:size=1;// normalsize in scriptscriptstyle
    break;default:size=6;// normalsize in textstyle or displaystyle
    }return this.extend({style:this.style.text(),size:size});}/**
       * Create a new options object with the given color.
       */withColor(color){return this.extend({color:color});}/**
       * Create a new options object with "phantom" set to true.
       */withPhantom(){return this.extend({phantom:true});}/**
       * Creates a new options object with the given math font or old text font.
       * @type {[type]}
       */withFont(font){return this.extend({font});}/**
       * Create a new options objects with the given fontFamily.
       */withTextFontFamily(fontFamily){return this.extend({fontFamily,font:""});}/**
       * Creates a new options object with the given font weight
       */withTextFontWeight(fontWeight){return this.extend({fontWeight,font:""});}/**
       * Creates a new options object with the given font weight
       */withTextFontShape(fontShape){return this.extend({fontShape,font:""});}/**
       * Return the CSS sizing classes required to switch from enclosing options
       * `oldOptions` to `this`. Returns an array of classes.
       */sizingClasses(oldOptions){if(oldOptions.size!==this.size){return ["sizing","reset-size"+oldOptions.size,"size"+this.size];}else {return [];}}/**
       * Return the CSS sizing classes required to switch to the base size. Like
       * `this.havingSize(BASESIZE).sizingClasses(this)`.
       */baseSizingClasses(){if(this.size!==Options.BASESIZE){return ["sizing","reset-size"+this.size,"size"+Options.BASESIZE];}else {return [];}}/**
       * Return the font metrics for this size.
       */fontMetrics(){if(!this._fontMetrics){this._fontMetrics=getGlobalMetrics(this.size);}return this._fontMetrics;}/**
       * Gets the CSS color of the current options object
       */getColor(){if(this.phantom){return "transparent";}else {return this.color;}}};Options$1.BASESIZE=6;/**
     * This file does conversion between units.  In particular, it provides
     * calculateSize to convert other units into ems.
     */ // Thus, multiplying a length by this number converts the length from units
    // into pts.  Dividing the result by ptPerEm gives the number of ems
    // *assuming* a font size of ptPerEm (normal size, normal style).
    const ptPerUnit={// https://en.wikibooks.org/wiki/LaTeX/Lengths and
    // https://tex.stackexchange.com/a/8263
    "pt":1,// TeX point
    "mm":7227/2540,// millimeter
    "cm":7227/254,// centimeter
    "in":72.27,// inch
    "bp":803/800,// big (PostScript) points
    "pc":12,// pica
    "dd":1238/1157,// didot
    "cc":14856/1157,// cicero (12 didot)
    "nd":685/642,// new didot
    "nc":1370/107,// new cicero (12 new didot)
    "sp":1/65536,// scaled point (TeX's internal smallest unit)
    // https://tex.stackexchange.com/a/41371
    "px":803/800// \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
    };// Dictionary of relative units, for fast validity testing.
    const relativeUnit={"ex":true,"em":true,"mu":true};/**
     * Determine whether the specified unit (either a string defining the unit
     * or a "size" parse node containing a unit field) is valid.
     */const validUnit=function validUnit(unit){if(typeof unit!=="string"){unit=unit.unit;}return unit in ptPerUnit||unit in relativeUnit||unit==="ex";};/*
     * Convert a "size" parse node (with numeric "number" and string "unit" fields,
     * as parsed by functions.js argType "size") into a CSS em value for the
     * current style/scale.  `options` gives the current options.
     */const calculateSize=function calculateSize(sizeValue,options){let scale;if(sizeValue.unit in ptPerUnit){// Absolute units
    scale=ptPerUnit[sizeValue.unit]// Convert unit to pt
    /options.fontMetrics().ptPerEm// Convert pt to CSS em
    /options.sizeMultiplier;// Unscale to make absolute units
    }else if(sizeValue.unit==="mu"){// `mu` units scale with scriptstyle/scriptscriptstyle.
    scale=options.fontMetrics().cssEmPerMu;}else {// Other relative units always refer to the *textstyle* font
    // in the current size.
    let unitOptions;if(options.style.isTight()){// isTight() means current style is script/scriptscript.
    unitOptions=options.havingStyle(options.style.text());}else {unitOptions=options;}// TODO: In TeX these units are relative to the quad of the current
    // *text* font, e.g. cmr10. KaTeX instead uses values from the
    // comparably-sized *Computer Modern symbol* font. At 10pt, these
    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
    // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
    // TeX \showlists shows a kern of 1.13889 * fontsize;
    // KaTeX shows a kern of 1.171 * fontsize.
    if(sizeValue.unit==="ex"){scale=unitOptions.fontMetrics().xHeight;}else if(sizeValue.unit==="em"){scale=unitOptions.fontMetrics().quad;}else {throw new ParseError("Invalid unit: '"+sizeValue.unit+"'");}if(unitOptions!==options){scale*=unitOptions.sizeMultiplier/options.sizeMultiplier;}}return Math.min(sizeValue.number*scale,options.maxSize);};/* eslint no-console:0 */ /**
     * Looks up the given symbol in fontMetrics, after applying any symbol
     * replacements defined in symbol.js
     */const lookupSymbol=function lookupSymbol(value,// TODO(#963): Use a union type for this.
    fontName,mode){// Replace the value with its replaced value from symbol.js
    if(symbols[mode][value]&&symbols[mode][value].replace){value=symbols[mode][value].replace;}return {value:value,metrics:getCharacterMetrics(value,fontName,mode)};};/**
     * Makes a symbolNode after translation via the list of symbols in symbols.js.
     * Correctly pulls out metrics for the character, and optionally takes a list of
     * classes to be attached to the node.
     *
     * TODO: make argument order closer to makeSpan
     * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
     * should if present come first in `classes`.
     * TODO(#953): Make `options` mandatory and always pass it in.
     */const makeSymbol=function makeSymbol(value,fontName,mode,options,classes){const lookup=lookupSymbol(value,fontName,mode);const metrics=lookup.metrics;value=lookup.value;let symbolNode;if(metrics){let italic=metrics.italic;if(mode==="text"||options&&options.font==="mathit"){italic=0;}symbolNode=new SymbolNode(value,metrics.height,metrics.depth,italic,metrics.skew,metrics.width,classes);}else {// TODO(emily): Figure out a good way to only print this in development
    typeof console!=="undefined"&&console.warn("No character metrics "+`for '${value}' in style '${fontName}' and mode '${mode}'`);symbolNode=new SymbolNode(value,0,0,0,0,0,classes);}if(options){symbolNode.maxFontSize=options.sizeMultiplier;if(options.style.isTight()){symbolNode.classes.push("mtight");}const color=options.getColor();if(color){symbolNode.style.color=color;}}return symbolNode;};/**
     * Makes a symbol in Main-Regular or AMS-Regular.
     * Used for rel, bin, open, close, inner, and punct.
     */const mathsym=function mathsym(value,mode,options,classes){if(classes===void 0){classes=[];}// Decide what font to render the symbol in by its entry in the symbols
    // table.
    // Have a special case for when the value = \ because the \ is used as a
    // textord in unsupported command errors but cannot be parsed as a regular
    // text ordinal and is therefore not present as a symbol in the symbols
    // table for text, as well as a special case for boldsymbol because it
    // can be used for bold + and -
    if(options.font==="boldsymbol"&&lookupSymbol(value,"Main-Bold",mode).metrics){return makeSymbol(value,"Main-Bold",mode,options,classes.concat(["mathbf"]));}else if(value==="\\"||symbols[mode][value].font==="main"){return makeSymbol(value,"Main-Regular",mode,options,classes);}else {return makeSymbol(value,"AMS-Regular",mode,options,classes.concat(["amsrm"]));}};/**
     * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
     * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
     * depending on the symbol.  Use this function instead of fontMap for font
     * "boldsymbol".
     */const boldsymbol=function boldsymbol(value,mode,options,classes,type){if(type!=="textord"&&lookupSymbol(value,"Math-BoldItalic",mode).metrics){return {fontName:"Math-BoldItalic",fontClass:"boldsymbol"};}else {// Some glyphs do not exist in Math-BoldItalic so we need to use
    // Main-Bold instead.
    return {fontName:"Main-Bold",fontClass:"mathbf"};}};/**
     * Makes either a mathord or textord in the correct font and color.
     */const makeOrd=function makeOrd(group,options,type){const mode=group.mode;const text=group.text;const classes=["mord"];// Math mode or Old font (i.e. \rm)
    const isFont=mode==="math"||mode==="text"&&options.font;const fontOrFamily=isFont?options.font:options.fontFamily;if(text.charCodeAt(0)===0xD835){// surrogate pairs get special treatment
    const _wideCharacterFont=wideCharacterFont(text,mode),wideFontName=_wideCharacterFont[0],wideFontClass=_wideCharacterFont[1];return makeSymbol(text,wideFontName,mode,options,classes.concat(wideFontClass));}else if(fontOrFamily){let fontName;let fontClasses;if(fontOrFamily==="boldsymbol"){const fontData=boldsymbol(text,mode,options,classes,type);fontName=fontData.fontName;fontClasses=[fontData.fontClass];}else if(isFont){fontName=fontMap[fontOrFamily].fontName;fontClasses=[fontOrFamily];}else {fontName=retrieveTextFontName(fontOrFamily,options.fontWeight,options.fontShape);fontClasses=[fontOrFamily,options.fontWeight,options.fontShape];}if(lookupSymbol(text,fontName,mode).metrics){return makeSymbol(text,fontName,mode,options,classes.concat(fontClasses));}else if(ligatures.hasOwnProperty(text)&&fontName.substr(0,10)==="Typewriter"){// Deconstruct ligatures in monospace fonts (\texttt, \tt).
    const parts=[];for(let i=0;i<text.length;i++){parts.push(makeSymbol(text[i],fontName,mode,options,classes.concat(fontClasses)));}return makeFragment(parts);}}// Makes a symbol in the default font for mathords and textords.
    if(type==="mathord"){return makeSymbol(text,"Math-Italic",mode,options,classes.concat(["mathnormal"]));}else if(type==="textord"){const font=symbols[mode][text]&&symbols[mode][text].font;if(font==="ams"){const fontName=retrieveTextFontName("amsrm",options.fontWeight,options.fontShape);return makeSymbol(text,fontName,mode,options,classes.concat("amsrm",options.fontWeight,options.fontShape));}else if(font==="main"||!font){const fontName=retrieveTextFontName("textrm",options.fontWeight,options.fontShape);return makeSymbol(text,fontName,mode,options,classes.concat(options.fontWeight,options.fontShape));}else {// fonts added by plugins
    const fontName=retrieveTextFontName(font,options.fontWeight,options.fontShape);// We add font name as a css class
    return makeSymbol(text,fontName,mode,options,classes.concat(fontName,options.fontWeight,options.fontShape));}}else {throw new Error("unexpected type: "+type+" in makeOrd");}};/**
     * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
     * and styles.
     */const canCombine=(prev,next)=>{if(createClass(prev.classes)!==createClass(next.classes)||prev.skew!==next.skew||prev.maxFontSize!==next.maxFontSize){return false;}for(const style in prev.style){if(prev.style.hasOwnProperty(style)&&prev.style[style]!==next.style[style]){return false;}}for(const style in next.style){if(next.style.hasOwnProperty(style)&&prev.style[style]!==next.style[style]){return false;}}return true;};/**
     * Combine consequetive domTree.symbolNodes into a single symbolNode.
     * Note: this function mutates the argument.
     */const tryCombineChars=chars=>{for(let i=0;i<chars.length-1;i++){const prev=chars[i];const next=chars[i+1];if(prev instanceof SymbolNode&&next instanceof SymbolNode&&canCombine(prev,next)){prev.text+=next.text;prev.height=Math.max(prev.height,next.height);prev.depth=Math.max(prev.depth,next.depth);// Use the last character's italic correction since we use
    // it to add padding to the right of the span created from
    // the combined characters.
    prev.italic=next.italic;chars.splice(i+1,1);i--;}}return chars;};/**
     * Calculate the height, depth, and maxFontSize of an element based on its
     * children.
     */const sizeElementFromChildren=function sizeElementFromChildren(elem){let height=0;let depth=0;let maxFontSize=0;for(let i=0;i<elem.children.length;i++){const child=elem.children[i];if(child.height>height){height=child.height;}if(child.depth>depth){depth=child.depth;}if(child.maxFontSize>maxFontSize){maxFontSize=child.maxFontSize;}}elem.height=height;elem.depth=depth;elem.maxFontSize=maxFontSize;};/**
     * Makes a span with the given list of classes, list of children, and options.
     *
     * TODO(#953): Ensure that `options` is always provided (currently some call
     * sites don't pass it) and make the type below mandatory.
     * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
     * should if present come first in `classes`.
     */const makeSpan=function makeSpan(classes,children,options,style){const span=new Span(classes,children,options,style);sizeElementFromChildren(span);return span;};// SVG one is simpler -- doesn't require height, depth, max-font setting.
    // This is also a separate method for typesafety.
    const makeSvgSpan=(classes,children,options,style)=>new Span(classes,children,options,style);const makeLineSpan=function makeLineSpan(className,options,thickness){const line=makeSpan([className],[],options);line.height=Math.max(thickness||options.fontMetrics().defaultRuleThickness,options.minRuleThickness);line.style.borderBottomWidth=line.height+"em";line.maxFontSize=1.0;return line;};/**
     * Makes an anchor with the given href, list of classes, list of children,
     * and options.
     */const makeAnchor=function makeAnchor(href,classes,children,options){const anchor=new Anchor(href,classes,children,options);sizeElementFromChildren(anchor);return anchor;};/**
     * Makes a document fragment with the given list of children.
     */const makeFragment=function makeFragment(children){const fragment=new DocumentFragment(children);sizeElementFromChildren(fragment);return fragment;};/**
     * Wraps group in a span if it's a document fragment, allowing to apply classes
     * and styles
     */const wrapFragment=function wrapFragment(group,options){if(group instanceof DocumentFragment){return makeSpan([],[group],options);}return group;};// These are exact object types to catch typos in the names of the optional fields.
    // Computes the updated `children` list and the overall depth.
    //
    // This helper function for makeVList makes it easier to enforce type safety by
    // allowing early exits (returns) in the logic.
    const getVListChildrenAndDepth=function getVListChildrenAndDepth(params){if(params.positionType==="individualShift"){const oldChildren=params.children;const children=[oldChildren[0]];// Add in kerns to the list of params.children to get each element to be
    // shifted to the correct specified shift
    const depth=-oldChildren[0].shift-oldChildren[0].elem.depth;let currPos=depth;for(let i=1;i<oldChildren.length;i++){const diff=-oldChildren[i].shift-currPos-oldChildren[i].elem.depth;const size=diff-(oldChildren[i-1].elem.height+oldChildren[i-1].elem.depth);currPos=currPos+diff;children.push({type:"kern",size});children.push(oldChildren[i]);}return {children,depth};}let depth;if(params.positionType==="top"){// We always start at the bottom, so calculate the bottom by adding up
    // all the sizes
    let bottom=params.positionData;for(let i=0;i<params.children.length;i++){const child=params.children[i];bottom-=child.type==="kern"?child.size:child.elem.height+child.elem.depth;}depth=bottom;}else if(params.positionType==="bottom"){depth=-params.positionData;}else {const firstChild=params.children[0];if(firstChild.type!=="elem"){throw new Error('First child must have type "elem".');}if(params.positionType==="shift"){depth=-firstChild.elem.depth-params.positionData;}else if(params.positionType==="firstBaseline"){depth=-firstChild.elem.depth;}else {throw new Error(`Invalid positionType ${params.positionType}.`);}}return {children:params.children,depth};};/**
     * Makes a vertical list by stacking elements and kerns on top of each other.
     * Allows for many different ways of specifying the positioning method.
     *
     * See VListParam documentation above.
     */const makeVList=function makeVList(params,options){const _getVListChildrenAndD=getVListChildrenAndDepth(params),children=_getVListChildrenAndD.children,depth=_getVListChildrenAndD.depth;// Create a strut that is taller than any list item. The strut is added to
    // each item, where it will determine the item's baseline. Since it has
    // `overflow:hidden`, the strut's top edge will sit on the item's line box's
    // top edge and the strut's bottom edge will sit on the item's baseline,
    // with no additional line-height spacing. This allows the item baseline to
    // be positioned precisely without worrying about font ascent and
    // line-height.
    let pstrutSize=0;for(let i=0;i<children.length;i++){const child=children[i];if(child.type==="elem"){const elem=child.elem;pstrutSize=Math.max(pstrutSize,elem.maxFontSize,elem.height);}}pstrutSize+=2;const pstrut=makeSpan(["pstrut"],[]);pstrut.style.height=pstrutSize+"em";// Create a new list of actual children at the correct offsets
    const realChildren=[];let minPos=depth;let maxPos=depth;let currPos=depth;for(let i=0;i<children.length;i++){const child=children[i];if(child.type==="kern"){currPos+=child.size;}else {const elem=child.elem;const classes=child.wrapperClasses||[];const style=child.wrapperStyle||{};const childWrap=makeSpan(classes,[pstrut,elem],undefined,style);childWrap.style.top=-pstrutSize-currPos-elem.depth+"em";if(child.marginLeft){childWrap.style.marginLeft=child.marginLeft;}if(child.marginRight){childWrap.style.marginRight=child.marginRight;}realChildren.push(childWrap);currPos+=elem.height+elem.depth;}minPos=Math.min(minPos,currPos);maxPos=Math.max(maxPos,currPos);}// The vlist contents go in a table-cell with `vertical-align:bottom`.
    // This cell's bottom edge will determine the containing table's baseline
    // without overly expanding the containing line-box.
    const vlist=makeSpan(["vlist"],realChildren);vlist.style.height=maxPos+"em";// A second row is used if necessary to represent the vlist's depth.
    let rows;if(minPos<0){// We will define depth in an empty span with display: table-cell.
    // It should render with the height that we define. But Chrome, in
    // contenteditable mode only, treats that span as if it contains some
    // text content. And that min-height over-rides our desired height.
    // So we put another empty span inside the depth strut span.
    const emptySpan=makeSpan([],[]);const depthStrut=makeSpan(["vlist"],[emptySpan]);depthStrut.style.height=-minPos+"em";// Safari wants the first row to have inline content; otherwise it
    // puts the bottom of the *second* row on the baseline.
    const topStrut=makeSpan(["vlist-s"],[new SymbolNode("\u200b")]);rows=[makeSpan(["vlist-r"],[vlist,topStrut]),makeSpan(["vlist-r"],[depthStrut])];}else {rows=[makeSpan(["vlist-r"],[vlist])];}const vtable=makeSpan(["vlist-t"],rows);if(rows.length===2){vtable.classes.push("vlist-t2");}vtable.height=maxPos;vtable.depth=-minPos;return vtable;};// Glue is a concept from TeX which is a flexible space between elements in
    // either a vertical or horizontal list. In KaTeX, at least for now, it's
    // static space between elements in a horizontal layout.
    const makeGlue=(measurement,options)=>{// Make an empty span for the space
    const rule=makeSpan(["mspace"],[],options);const size=calculateSize(measurement,options);rule.style.marginRight=`${size}em`;return rule;};// Takes font options, and returns the appropriate fontLookup name
    const retrieveTextFontName=function retrieveTextFontName(fontFamily,fontWeight,fontShape){let baseFontName="";switch(fontFamily){case"amsrm":baseFontName="AMS";break;case"textrm":baseFontName="Main";break;case"textsf":baseFontName="SansSerif";break;case"texttt":baseFontName="Typewriter";break;default:baseFontName=fontFamily;// use fonts added by a plugin
    }let fontStylesName;if(fontWeight==="textbf"&&fontShape==="textit"){fontStylesName="BoldItalic";}else if(fontWeight==="textbf"){fontStylesName="Bold";}else if(fontWeight==="textit"){fontStylesName="Italic";}else {fontStylesName="Regular";}return `${baseFontName}-${fontStylesName}`;};/**
     * Maps TeX font commands to objects containing:
     * - variant: string used for "mathvariant" attribute in buildMathML.js
     * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
     */ // A map between tex font commands an MathML mathvariant attribute values
    const fontMap={// styles
    "mathbf":{variant:"bold",fontName:"Main-Bold"},"mathrm":{variant:"normal",fontName:"Main-Regular"},"textit":{variant:"italic",fontName:"Main-Italic"},"mathit":{variant:"italic",fontName:"Main-Italic"},"mathnormal":{variant:"italic",fontName:"Math-Italic"},// "boldsymbol" is missing because they require the use of multiple fonts:
    // Math-BoldItalic and Main-Bold.  This is handled by a special case in
    // makeOrd which ends up calling boldsymbol.
    // families
    "mathbb":{variant:"double-struck",fontName:"AMS-Regular"},"mathcal":{variant:"script",fontName:"Caligraphic-Regular"},"mathfrak":{variant:"fraktur",fontName:"Fraktur-Regular"},"mathscr":{variant:"script",fontName:"Script-Regular"},"mathsf":{variant:"sans-serif",fontName:"SansSerif-Regular"},"mathtt":{variant:"monospace",fontName:"Typewriter-Regular"}};const svgData={//   path, width, height
    vec:["vec",0.471,0.714],// values from the font glyph
    oiintSize1:["oiintSize1",0.957,0.499],// oval to overlay the integrand
    oiintSize2:["oiintSize2",1.472,0.659],oiiintSize1:["oiiintSize1",1.304,0.499],oiiintSize2:["oiiintSize2",1.98,0.659],leftParenInner:["leftParenInner",0.875,0.3],rightParenInner:["rightParenInner",0.875,0.3]};const staticSvg=function staticSvg(value,options){// Create a span with inline SVG for the element.
    const _svgData$value=svgData[value],pathName=_svgData$value[0],width=_svgData$value[1],height=_svgData$value[2];const path=new PathNode(pathName);const svgNode=new SvgNode([path],{"width":width+"em","height":height+"em",// Override CSS rule `.katex svg { width: 100% }`
    "style":"width:"+width+"em","viewBox":"0 0 "+1000*width+" "+1000*height,"preserveAspectRatio":"xMinYMin"});const span=makeSvgSpan(["overlay"],[svgNode],options);span.height=height;span.style.height=height+"em";span.style.width=width+"em";return span;};var buildCommon={fontMap,makeSymbol,mathsym,makeSpan,makeSvgSpan,makeLineSpan,makeAnchor,makeFragment,wrapFragment,makeVList,makeOrd,makeGlue,staticSvg,svgData,tryCombineChars};/**
     * Describes spaces between different classes of atoms.
     */const thinspace={number:3,unit:"mu"};const mediumspace={number:4,unit:"mu"};const thickspace={number:5,unit:"mu"};// Making the type below exact with all optional fields doesn't work due to
    // - https://github.com/facebook/flow/issues/4582
    // - https://github.com/facebook/flow/issues/5688
    // However, since *all* fields are optional, $Shape<> works as suggested in 5688
    // above.
    // Spacing relationships for display and text styles
    const spacings={mord:{mop:thinspace,mbin:mediumspace,mrel:thickspace,minner:thinspace},mop:{mord:thinspace,mop:thinspace,mrel:thickspace,minner:thinspace},mbin:{mord:mediumspace,mop:mediumspace,mopen:mediumspace,minner:mediumspace},mrel:{mord:thickspace,mop:thickspace,mopen:thickspace,minner:thickspace},mopen:{},mclose:{mop:thinspace,mbin:mediumspace,mrel:thickspace,minner:thinspace},mpunct:{mord:thinspace,mop:thinspace,mrel:thickspace,mopen:thinspace,mclose:thinspace,mpunct:thinspace,minner:thinspace},minner:{mord:thinspace,mop:thinspace,mbin:mediumspace,mrel:thickspace,mopen:thinspace,mpunct:thinspace,minner:thinspace}};// Spacing relationships for script and scriptscript styles
    const tightSpacings={mord:{mop:thinspace},mop:{mord:thinspace,mop:thinspace},mbin:{},mrel:{},mopen:{},mclose:{mop:thinspace},mpunct:{},minner:{mop:thinspace}};/** Context provided to function handlers for error messages. */ // Note: reverse the order of the return type union will cause a flow error.
    // See https://github.com/facebook/flow/issues/3663.
    // More general version of `HtmlBuilder` for nodes (e.g. \sum, accent types)
    // whose presence impacts super/subscripting. In this case, ParseNode<"supsub">
    // delegates its HTML building to the HtmlBuilder corresponding to these nodes.
    /**
     * Final function spec for use at parse time.
     * This is almost identical to `FunctionPropSpec`, except it
     * 1. includes the function handler, and
     * 2. requires all arguments except argTypes.
     * It is generated by `defineFunction()` below.
     */ /**
     * All registered functions.
     * `functions.js` just exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary.
     */const _functions={};/**
     * All HTML builders. Should be only used in the `define*` and the `build*ML`
     * functions.
     */const _htmlGroupBuilders={};/**
     * All MathML builders. Should be only used in the `define*` and the `build*ML`
     * functions.
     */const _mathmlGroupBuilders={};function defineFunction(_ref){let type=_ref.type,names=_ref.names,props=_ref.props,handler=_ref.handler,htmlBuilder=_ref.htmlBuilder,mathmlBuilder=_ref.mathmlBuilder;// Set default values of functions
    const data={type,numArgs:props.numArgs,argTypes:props.argTypes,greediness:props.greediness===undefined?1:props.greediness,allowedInText:!!props.allowedInText,allowedInMath:props.allowedInMath===undefined?true:props.allowedInMath,numOptionalArgs:props.numOptionalArgs||0,infix:!!props.infix,handler:handler};for(let i=0;i<names.length;++i){_functions[names[i]]=data;}if(type){if(htmlBuilder){_htmlGroupBuilders[type]=htmlBuilder;}if(mathmlBuilder){_mathmlGroupBuilders[type]=mathmlBuilder;}}}/**
     * Use this to register only the HTML and MathML builders for a function (e.g.
     * if the function's ParseNode is generated in Parser.js rather than via a
     * stand-alone handler provided to `defineFunction`).
     */function defineFunctionBuilders(_ref2){let type=_ref2.type,htmlBuilder=_ref2.htmlBuilder,mathmlBuilder=_ref2.mathmlBuilder;defineFunction({type,names:[],props:{numArgs:0},handler(){throw new Error('Should never be called.');},htmlBuilder,mathmlBuilder});}// Since the corresponding buildHTML/buildMathML function expects a
    // list of elements, we normalize for different kinds of arguments
    const ordargument=function ordargument(arg){return arg.type==="ordgroup"?arg.body:[arg];};/**
     * This file does the main work of building a domTree structure from a parse
     * tree. The entry point is the `buildHTML` function, which takes a parse tree.
     * Then, the buildExpression, buildGroup, and various groupBuilders functions
     * are called, to produce a final HTML tree.
     */const makeSpan$1=buildCommon.makeSpan;// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
    // depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
    // and the text before Rule 19.
    const binLeftCanceller=["leftmost","mbin","mopen","mrel","mop","mpunct"];const binRightCanceller=["rightmost","mrel","mclose","mpunct"];const styleMap={"display":Style$1.DISPLAY,"text":Style$1.TEXT,"script":Style$1.SCRIPT,"scriptscript":Style$1.SCRIPTSCRIPT};const DomEnum={mord:"mord",mop:"mop",mbin:"mbin",mrel:"mrel",mopen:"mopen",mclose:"mclose",mpunct:"mpunct",minner:"minner"};/**
     * Take a list of nodes, build them in order, and return a list of the built
     * nodes. documentFragments are flattened into their contents, so the
     * returned list contains no fragments. `isRealGroup` is true if `expression`
     * is a real group (no atoms will be added on either side), as opposed to
     * a partial group (e.g. one created by \color). `surrounding` is an array
     * consisting type of nodes that will be added to the left and right.
     */const buildExpression=function buildExpression(expression,options,isRealGroup,surrounding){if(surrounding===void 0){surrounding=[null,null];}// Parse expressions into `groups`.
    const groups=[];for(let i=0;i<expression.length;i++){const output=buildGroup(expression[i],options);if(output instanceof DocumentFragment){const children=output.children;groups.push(...children);}else {groups.push(output);}}// If `expression` is a partial group, let the parent handle spacings
    // to avoid processing groups multiple times.
    if(!isRealGroup){return groups;}let glueOptions=options;if(expression.length===1){const node=expression[0];if(node.type==="sizing"){glueOptions=options.havingSize(node.size);}else if(node.type==="styling"){glueOptions=options.havingStyle(styleMap[node.style]);}}// Dummy spans for determining spacings between surrounding atoms.
    // If `expression` has no atoms on the left or right, class "leftmost"
    // or "rightmost", respectively, is used to indicate it.
    const dummyPrev=makeSpan$1([surrounding[0]||"leftmost"],[],options);const dummyNext=makeSpan$1([surrounding[1]||"rightmost"],[],options);// TODO: These code assumes that a node's math class is the first element
    // of its `classes` array. A later cleanup should ensure this, for
    // instance by changing the signature of `makeSpan`.
    // Before determining what spaces to insert, perform bin cancellation.
    // Binary operators change to ordinary symbols in some contexts.
    const isRoot=isRealGroup==="root";traverseNonSpaceNodes(groups,(node,prev)=>{const prevType=prev.classes[0];const type=node.classes[0];if(prevType==="mbin"&&utils.contains(binRightCanceller,type)){prev.classes[0]="mord";}else if(type==="mbin"&&utils.contains(binLeftCanceller,prevType)){node.classes[0]="mord";}},{node:dummyPrev},dummyNext,isRoot);traverseNonSpaceNodes(groups,(node,prev)=>{const prevType=getTypeOfDomTree(prev);const type=getTypeOfDomTree(node);// 'mtight' indicates that the node is script or scriptscript style.
    const space=prevType&&type?node.hasClass("mtight")?tightSpacings[prevType][type]:spacings[prevType][type]:null;if(space){// Insert glue (spacing) after the `prev`.
    return buildCommon.makeGlue(space,glueOptions);}},{node:dummyPrev},dummyNext,isRoot);return groups;};// Depth-first traverse non-space `nodes`, calling `callback` with the current and
    // previous node as arguments, optionally returning a node to insert after the
    // previous node. `prev` is an object with the previous node and `insertAfter`
    // function to insert after it. `next` is a node that will be added to the right.
    // Used for bin cancellation and inserting spacings.
    const traverseNonSpaceNodes=function traverseNonSpaceNodes(nodes,callback,prev,next,isRoot){if(next){// temporarily append the right node, if exists
    nodes.push(next);}let i=0;for(;i<nodes.length;i++){const node=nodes[i];const partialGroup=checkPartialGroup(node);if(partialGroup){// Recursive DFS
    // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array
    traverseNonSpaceNodes(partialGroup.children,callback,prev,null,isRoot);continue;}// Ignore explicit spaces (e.g., \;, \,) when determining what implicit
    // spacing should go between atoms of different classes
    const nonspace=!node.hasClass("mspace");if(nonspace){const result=callback(node,prev.node);if(result){if(prev.insertAfter){prev.insertAfter(result);}else {// insert at front
    nodes.unshift(result);i++;}}}if(nonspace){prev.node=node;}else if(isRoot&&node.hasClass("newline")){prev.node=makeSpan$1(["leftmost"]);// treat like beginning of line
    }prev.insertAfter=(index=>n=>{nodes.splice(index+1,0,n);i++;})(i);}if(next){nodes.pop();}};// Check if given node is a partial group, i.e., does not affect spacing around.
    const checkPartialGroup=function checkPartialGroup(node){if(node instanceof DocumentFragment||node instanceof Anchor||node instanceof Span&&node.hasClass("enclosing")){return node;}return null;};// Return the outermost node of a domTree.
    const getOutermostNode=function getOutermostNode(node,side){const partialGroup=checkPartialGroup(node);if(partialGroup){const children=partialGroup.children;if(children.length){if(side==="right"){return getOutermostNode(children[children.length-1],"right");}else if(side==="left"){return getOutermostNode(children[0],"left");}}}return node;};// Return math atom class (mclass) of a domTree.
    // If `side` is given, it will get the type of the outermost node at given side.
    const getTypeOfDomTree=function getTypeOfDomTree(node,side){if(!node){return null;}if(side){node=getOutermostNode(node,side);}// This makes a lot of assumptions as to where the type of atom
    // appears.  We should do a better job of enforcing this.
    return DomEnum[node.classes[0]]||null;};const makeNullDelimiter=function makeNullDelimiter(options,classes){const moreClasses=["nulldelimiter"].concat(options.baseSizingClasses());return makeSpan$1(classes.concat(moreClasses));};/**
     * buildGroup is the function that takes a group and calls the correct groupType
     * function for it. It also handles the interaction of size and style changes
     * between parents and children.
     */const buildGroup=function buildGroup(group,options,baseOptions){if(!group){return makeSpan$1();}if(_htmlGroupBuilders[group.type]){// Call the groupBuilders function
    let groupNode=_htmlGroupBuilders[group.type](group,options);// If the size changed between the parent and the current group, account
    // for that size difference.
    if(baseOptions&&options.size!==baseOptions.size){groupNode=makeSpan$1(options.sizingClasses(baseOptions),[groupNode],options);const multiplier=options.sizeMultiplier/baseOptions.sizeMultiplier;groupNode.height*=multiplier;groupNode.depth*=multiplier;}return groupNode;}else {throw new ParseError("Got group of unknown type: '"+group.type+"'");}};/**
     * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
     * into an unbreakable HTML node of class .base, with proper struts to
     * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
     * make up the entire expression as a sequence of unbreakable units.
     */function buildHTMLUnbreakable(children,options){// Compute height and depth of this chunk.
    const body=makeSpan$1(["base"],children,options);// Add strut, which ensures that the top of the HTML element falls at
    // the height of the expression, and the bottom of the HTML element
    // falls at the depth of the expression.
    const strut=makeSpan$1(["strut"]);strut.style.height=body.height+body.depth+"em";strut.style.verticalAlign=-body.depth+"em";body.children.unshift(strut);return body;}/**
     * Take an entire parse tree, and build it into an appropriate set of HTML
     * nodes.
     */function buildHTML(tree,options){// Strip off outer tag wrapper for processing below.
    let tag=null;if(tree.length===1&&tree[0].type==="tag"){tag=tree[0].tag;tree=tree[0].body;}// Build the expression contained in the tree
    const expression=buildExpression(tree,options,"root");const children=[];// Create one base node for each chunk between potential line breaks.
    // The TeXBook [p.173] says "A formula will be broken only after a
    // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
    // operation symbol like $+$ or $-$ or $\times$, where the relation or
    // binary operation is on the ``outer level'' of the formula (i.e., not
    // enclosed in {...} and not part of an \over construction)."
    let parts=[];for(let i=0;i<expression.length;i++){parts.push(expression[i]);if(expression[i].hasClass("mbin")||expression[i].hasClass("mrel")||expression[i].hasClass("allowbreak")){// Put any post-operator glue on same line as operator.
    // Watch for \nobreak along the way, and stop at \newline.
    let nobreak=false;while(i<expression.length-1&&expression[i+1].hasClass("mspace")&&!expression[i+1].hasClass("newline")){i++;parts.push(expression[i]);if(expression[i].hasClass("nobreak")){nobreak=true;}}// Don't allow break if \nobreak among the post-operator glue.
    if(!nobreak){children.push(buildHTMLUnbreakable(parts,options));parts=[];}}else if(expression[i].hasClass("newline")){// Write the line except the newline
    parts.pop();if(parts.length>0){children.push(buildHTMLUnbreakable(parts,options));parts=[];}// Put the newline at the top level
    children.push(expression[i]);}}if(parts.length>0){children.push(buildHTMLUnbreakable(parts,options));}// Now, if there was a tag, build it too and append it as a final child.
    let tagChild;if(tag){tagChild=buildHTMLUnbreakable(buildExpression(tag,options,true));tagChild.classes=["tag"];children.push(tagChild);}const htmlNode=makeSpan$1(["katex-html"],children);htmlNode.setAttribute("aria-hidden","true");// Adjust the strut of the tag to be the maximum height of all children
    // (the height of the enclosing htmlNode) for proper vertical alignment.
    if(tagChild){const strut=tagChild.children[0];strut.style.height=htmlNode.height+htmlNode.depth+"em";strut.style.verticalAlign=-htmlNode.depth+"em";}return htmlNode;}/**
     * These objects store data about MathML nodes. This is the MathML equivalent
     * of the types in domTree.js. Since MathML handles its own rendering, and
     * since we're mainly using MathML to improve accessibility, we don't manage
     * any of the styling state that the plain DOM nodes do.
     *
     * The `toNode` and `toMarkup` functions work simlarly to how they do in
     * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
     */function newDocumentFragment(children){return new DocumentFragment(children);}/**
     * This node represents a general purpose MathML node of any type. The
     * constructor requires the type of node to create (for example, `"mo"` or
     * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
     */class MathNode{constructor(type,children){this.type=void 0;this.attributes=void 0;this.children=void 0;this.type=type;this.attributes={};this.children=children||[];}/**
       * Sets an attribute on a MathML node. MathML depends on attributes to convey a
       * semantic content, so this is used heavily.
       */setAttribute(name,value){this.attributes[name]=value;}/**
       * Gets an attribute on a MathML node.
       */getAttribute(name){return this.attributes[name];}/**
       * Converts the math node into a MathML-namespaced DOM element.
       */toNode(){const node=document.createElementNS("http://www.w3.org/1998/Math/MathML",this.type);for(const attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){node.setAttribute(attr,this.attributes[attr]);}}for(let i=0;i<this.children.length;i++){node.appendChild(this.children[i].toNode());}return node;}/**
       * Converts the math node into an HTML markup string.
       */toMarkup(){let markup="<"+this.type;// Add the attributes
    for(const attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){markup+=" "+attr+"=\"";markup+=utils.escape(this.attributes[attr]);markup+="\"";}}markup+=">";for(let i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}markup+="</"+this.type+">";return markup;}/**
       * Converts the math node into a string, similar to innerText, but escaped.
       */toText(){return this.children.map(child=>child.toText()).join("");}}/**
     * This node represents a piece of text.
     */class TextNode{constructor(text){this.text=void 0;this.text=text;}/**
       * Converts the text node into a DOM text node.
       */toNode(){return document.createTextNode(this.text);}/**
       * Converts the text node into escaped HTML markup
       * (representing the text itself).
       */toMarkup(){return utils.escape(this.toText());}/**
       * Converts the text node into a string
       * (representing the text iteself).
       */toText(){return this.text;}}/**
     * This node represents a space, but may render as <mspace.../> or as text,
     * depending on the width.
     */class SpaceNode{/**
       * Create a Space node with width given in CSS ems.
       */constructor(width){this.width=void 0;this.character=void 0;this.width=width;// See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
    // for a table of space-like characters.  We use Unicode
    // representations instead of &LongNames; as it's not clear how to
    // make the latter via document.createTextNode.
    if(width>=0.05555&&width<=0.05556){this.character="\u200a";// &VeryThinSpace;
    }else if(width>=0.1666&&width<=0.1667){this.character="\u2009";// &ThinSpace;
    }else if(width>=0.2222&&width<=0.2223){this.character="\u2005";// &MediumSpace;
    }else if(width>=0.2777&&width<=0.2778){this.character="\u2005\u200a";// &ThickSpace;
    }else if(width>=-0.05556&&width<=-0.05555){this.character="\u200a\u2063";// &NegativeVeryThinSpace;
    }else if(width>=-0.1667&&width<=-0.1666){this.character="\u2009\u2063";// &NegativeThinSpace;
    }else if(width>=-0.2223&&width<=-0.2222){this.character="\u205f\u2063";// &NegativeMediumSpace;
    }else if(width>=-0.2778&&width<=-0.2777){this.character="\u2005\u2063";// &NegativeThickSpace;
    }else {this.character=null;}}/**
       * Converts the math node into a MathML-namespaced DOM element.
       */toNode(){if(this.character){return document.createTextNode(this.character);}else {const node=document.createElementNS("http://www.w3.org/1998/Math/MathML","mspace");node.setAttribute("width",this.width+"em");return node;}}/**
       * Converts the math node into an HTML markup string.
       */toMarkup(){if(this.character){return `<mtext>${this.character}</mtext>`;}else {return `<mspace width="${this.width}em"/>`;}}/**
       * Converts the math node into a string, similar to innerText.
       */toText(){if(this.character){return this.character;}else {return " ";}}}var mathMLTree={MathNode,TextNode,SpaceNode,newDocumentFragment};/**
     * This file converts a parse tree into a cooresponding MathML tree. The main
     * entry point is the `buildMathML` function, which takes a parse tree from the
     * parser.
     */ /**
     * Takes a symbol and converts it into a MathML text node after performing
     * optional replacement from symbols.js.
     */const makeText=function makeText(text,mode,options){if(symbols[mode][text]&&symbols[mode][text].replace&&text.charCodeAt(0)!==0xD835&&!(ligatures.hasOwnProperty(text)&&options&&(options.fontFamily&&options.fontFamily.substr(4,2)==="tt"||options.font&&options.font.substr(4,2)==="tt"))){text=symbols[mode][text].replace;}return new mathMLTree.TextNode(text);};/**
     * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
     * unless the array has length 1.  Always returns a single node.
     */const makeRow=function makeRow(body){if(body.length===1){return body[0];}else {return new mathMLTree.MathNode("mrow",body);}};/**
     * Returns the math variant as a string or null if none is required.
     */const getVariant=function getVariant(group,options){// Handle \text... font specifiers as best we can.
    // MathML has a limited list of allowable mathvariant specifiers; see
    // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
    if(options.fontFamily==="texttt"){return "monospace";}else if(options.fontFamily==="textsf"){if(options.fontShape==="textit"&&options.fontWeight==="textbf"){return "sans-serif-bold-italic";}else if(options.fontShape==="textit"){return "sans-serif-italic";}else if(options.fontWeight==="textbf"){return "bold-sans-serif";}else {return "sans-serif";}}else if(options.fontShape==="textit"&&options.fontWeight==="textbf"){return "bold-italic";}else if(options.fontShape==="textit"){return "italic";}else if(options.fontWeight==="textbf"){return "bold";}const font=options.font;if(!font||font==="mathnormal"){return null;}const mode=group.mode;if(font==="mathit"){return "italic";}else if(font==="boldsymbol"){return group.type==="textord"?"bold":"bold-italic";}else if(font==="mathbf"){return "bold";}else if(font==="mathbb"){return "double-struck";}else if(font==="mathfrak"){return "fraktur";}else if(font==="mathscr"||font==="mathcal"){// MathML makes no distinction between script and caligrahpic
    return "script";}else if(font==="mathsf"){return "sans-serif";}else if(font==="mathtt"){return "monospace";}let text=group.text;if(utils.contains(["\\imath","\\jmath"],text)){return null;}if(symbols[mode][text]&&symbols[mode][text].replace){text=symbols[mode][text].replace;}const fontName=buildCommon.fontMap[font].fontName;if(getCharacterMetrics(text,fontName,mode)){return buildCommon.fontMap[font].variant;}return null;};/**
     * Takes a list of nodes, builds them, and returns a list of the generated
     * MathML nodes.  Also combine consecutive <mtext> outputs into a single
     * <mtext> tag.
     */const buildExpression$1=function buildExpression(expression,options,isOrdgroup){if(expression.length===1){const group=buildGroup$1(expression[0],options);if(isOrdgroup&&group instanceof MathNode&&group.type==="mo"){// When TeX writers want to suppress spacing on an operator,
    // they often put the operator by itself inside braces.
    group.setAttribute("lspace","0em");group.setAttribute("rspace","0em");}return [group];}const groups=[];let lastGroup;for(let i=0;i<expression.length;i++){const group=buildGroup$1(expression[i],options);if(group instanceof MathNode&&lastGroup instanceof MathNode){// Concatenate adjacent <mtext>s
    if(group.type==='mtext'&&lastGroup.type==='mtext'&&group.getAttribute('mathvariant')===lastGroup.getAttribute('mathvariant')){lastGroup.children.push(...group.children);continue;// Concatenate adjacent <mn>s
    }else if(group.type==='mn'&&lastGroup.type==='mn'){lastGroup.children.push(...group.children);continue;// Concatenate <mn>...</mn> followed by <mi>.</mi>
    }else if(group.type==='mi'&&group.children.length===1&&lastGroup.type==='mn'){const child=group.children[0];if(child instanceof TextNode&&child.text==='.'){lastGroup.children.push(...group.children);continue;}}else if(lastGroup.type==='mi'&&lastGroup.children.length===1){const lastChild=lastGroup.children[0];if(lastChild instanceof TextNode&&lastChild.text==='\u0338'&&(group.type==='mo'||group.type==='mi'||group.type==='mn')){const child=group.children[0];if(child instanceof TextNode&&child.text.length>0){// Overlay with combining character long solidus
    child.text=child.text.slice(0,1)+"\u0338"+child.text.slice(1);groups.pop();}}}}groups.push(group);lastGroup=group;}return groups;};/**
     * Equivalent to buildExpression, but wraps the elements in an <mrow>
     * if there's more than one.  Returns a single node instead of an array.
     */const buildExpressionRow=function buildExpressionRow(expression,options,isOrdgroup){return makeRow(buildExpression$1(expression,options,isOrdgroup));};/**
     * Takes a group from the parser and calls the appropriate groupBuilders function
     * on it to produce a MathML node.
     */const buildGroup$1=function buildGroup(group,options){if(!group){return new mathMLTree.MathNode("mrow");}if(_mathmlGroupBuilders[group.type]){// Call the groupBuilders function
    const result=_mathmlGroupBuilders[group.type](group,options);return result;}else {throw new ParseError("Got group of unknown type: '"+group.type+"'");}};/**
     * Takes a full parse tree and settings and builds a MathML representation of
     * it. In particular, we put the elements from building the parse tree into a
     * <semantics> tag so we can also include that TeX source as an annotation.
     *
     * Note that we actually return a domTree element with a `<math>` inside it so
     * we can do appropriate styling.
     */function buildMathML(tree,texExpression,options,isDisplayMode,forMathmlOnly){const expression=buildExpression$1(tree,options);// Wrap up the expression in an mrow so it is presented in the semantics
    // tag correctly, unless it's a single <mrow> or <mtable>.
    let wrapper;if(expression.length===1&&expression[0]instanceof MathNode&&utils.contains(["mrow","mtable"],expression[0].type)){wrapper=expression[0];}else {wrapper=new mathMLTree.MathNode("mrow",expression);}// Build a TeX annotation of the source
    const annotation=new mathMLTree.MathNode("annotation",[new mathMLTree.TextNode(texExpression)]);annotation.setAttribute("encoding","application/x-tex");const semantics=new mathMLTree.MathNode("semantics",[wrapper,annotation]);const math=new mathMLTree.MathNode("math",[semantics]);math.setAttribute("xmlns","http://www.w3.org/1998/Math/MathML");if(isDisplayMode){math.setAttribute("display","block");}// You can't style <math> nodes, so we wrap the node in a span.
    // NOTE: The span class is not typed to have <math> nodes as children, and
    // we don't want to make the children type more generic since the children
    // of span are expected to have more fields in `buildHtml` contexts.
    const wrapperClass=forMathmlOnly?"katex":"katex-mathml";// $FlowFixMe
    return buildCommon.makeSpan([wrapperClass],[math]);}const optionsFromSettings=function optionsFromSettings(settings){return new Options$1({style:settings.displayMode?Style$1.DISPLAY:Style$1.TEXT,maxSize:settings.maxSize,minRuleThickness:settings.minRuleThickness});};const displayWrap=function displayWrap(node,settings){if(settings.displayMode){const classes=["katex-display"];if(settings.leqno){classes.push("leqno");}if(settings.fleqn){classes.push("fleqn");}node=buildCommon.makeSpan(classes,[node]);}return node;};const buildTree=function buildTree(tree,expression,settings){const options=optionsFromSettings(settings);let katexNode;if(settings.output==="mathml"){return buildMathML(tree,expression,options,settings.displayMode,true);}else if(settings.output==="html"){const htmlNode=buildHTML(tree,options);katexNode=buildCommon.makeSpan(["katex"],[htmlNode]);}else {const mathMLNode=buildMathML(tree,expression,options,settings.displayMode,false);const htmlNode=buildHTML(tree,options);katexNode=buildCommon.makeSpan(["katex"],[mathMLNode,htmlNode]);}return displayWrap(katexNode,settings);};const buildHTMLTree=function buildHTMLTree(tree,expression,settings){const options=optionsFromSettings(settings);const htmlNode=buildHTML(tree,options);const katexNode=buildCommon.makeSpan(["katex"],[htmlNode]);return displayWrap(katexNode,settings);};/**
     * This file provides support to buildMathML.js and buildHTML.js
     * for stretchy wide elements rendered from SVG files
     * and other CSS trickery.
     */const stretchyCodePoint={widehat:"^",widecheck:"",widetilde:"~",utilde:"~",overleftarrow:"\u2190",underleftarrow:"\u2190",xleftarrow:"\u2190",overrightarrow:"\u2192",underrightarrow:"\u2192",xrightarrow:"\u2192",underbrace:"\u23df",overbrace:"\u23de",overgroup:"\u23e0",undergroup:"\u23e1",overleftrightarrow:"\u2194",underleftrightarrow:"\u2194",xleftrightarrow:"\u2194",Overrightarrow:"\u21d2",xRightarrow:"\u21d2",overleftharpoon:"\u21bc",xleftharpoonup:"\u21bc",overrightharpoon:"\u21c0",xrightharpoonup:"\u21c0",xLeftarrow:"\u21d0",xLeftrightarrow:"\u21d4",xhookleftarrow:"\u21a9",xhookrightarrow:"\u21aa",xmapsto:"\u21a6",xrightharpoondown:"\u21c1",xleftharpoondown:"\u21bd",xrightleftharpoons:"\u21cc",xleftrightharpoons:"\u21cb",xtwoheadleftarrow:"\u219e",xtwoheadrightarrow:"\u21a0",xlongequal:"=",xtofrom:"\u21c4",xrightleftarrows:"\u21c4",xrightequilibrium:"\u21cc",// Not a perfect match.
    xleftequilibrium:"\u21cb"// None better available.
    };const mathMLnode=function mathMLnode(label){const node=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);node.setAttribute("stretchy","true");return node;};// Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
    // Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
    // Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
    // Licensed under the SIL Open Font License, Version 1.1.
    // See \nhttp://scripts.sil.org/OFL
    // Very Long SVGs
    //    Many of the KaTeX stretchy wide elements use a long SVG image and an
    //    overflow: hidden tactic to achieve a stretchy image while avoiding
    //    distortion of arrowheads or brace corners.
    //    The SVG typically contains a very long (400 em) arrow.
    //    The SVG is in a container span that has overflow: hidden, so the span
    //    acts like a window that exposes only part of the  SVG.
    //    The SVG always has a longer, thinner aspect ratio than the container span.
    //    After the SVG fills 100% of the height of the container span,
    //    there is a long arrow shaft left over. That left-over shaft is not shown.
    //    Instead, it is sliced off because the span's CSS has overflow: hidden.
    //    Thus, the reader sees an arrow that matches the subject matter width
    //    without distortion.
    //    Some functions, such as \cancel, need to vary their aspect ratio. These
    //    functions do not get the overflow SVG treatment.
    // Second Brush Stroke
    //    Low resolution monitors struggle to display images in fine detail.
    //    So browsers apply anti-aliasing. A long straight arrow shaft therefore
    //    will sometimes appear as if it has a blurred edge.
    //    To mitigate this, these SVG files contain a second "brush-stroke" on the
    //    arrow shafts. That is, a second long thin rectangular SVG path has been
    //    written directly on top of each arrow shaft. This reinforcement causes
    //    some of the screen pixels to display as black instead of the anti-aliased
    //    gray pixel that a  single path would generate. So we get arrow shafts
    //    whose edges appear to be sharper.
    // In the katexImagesData object just below, the dimensions all
    // correspond to path geometry inside the relevant SVG.
    // For example, \overrightarrow uses the same arrowhead as glyph U+2192
    // from the KaTeX Main font. The scaling factor is 1000.
    // That is, inside the font, that arrowhead is 522 units tall, which
    // corresponds to 0.522 em inside the document.
    const katexImagesData={//   path(s), minWidth, height, align
    overrightarrow:[["rightarrow"],0.888,522,"xMaxYMin"],overleftarrow:[["leftarrow"],0.888,522,"xMinYMin"],underrightarrow:[["rightarrow"],0.888,522,"xMaxYMin"],underleftarrow:[["leftarrow"],0.888,522,"xMinYMin"],xrightarrow:[["rightarrow"],1.469,522,"xMaxYMin"],xleftarrow:[["leftarrow"],1.469,522,"xMinYMin"],Overrightarrow:[["doublerightarrow"],0.888,560,"xMaxYMin"],xRightarrow:[["doublerightarrow"],1.526,560,"xMaxYMin"],xLeftarrow:[["doubleleftarrow"],1.526,560,"xMinYMin"],overleftharpoon:[["leftharpoon"],0.888,522,"xMinYMin"],xleftharpoonup:[["leftharpoon"],0.888,522,"xMinYMin"],xleftharpoondown:[["leftharpoondown"],0.888,522,"xMinYMin"],overrightharpoon:[["rightharpoon"],0.888,522,"xMaxYMin"],xrightharpoonup:[["rightharpoon"],0.888,522,"xMaxYMin"],xrightharpoondown:[["rightharpoondown"],0.888,522,"xMaxYMin"],xlongequal:[["longequal"],0.888,334,"xMinYMin"],xtwoheadleftarrow:[["twoheadleftarrow"],0.888,334,"xMinYMin"],xtwoheadrightarrow:[["twoheadrightarrow"],0.888,334,"xMaxYMin"],overleftrightarrow:[["leftarrow","rightarrow"],0.888,522],overbrace:[["leftbrace","midbrace","rightbrace"],1.6,548],underbrace:[["leftbraceunder","midbraceunder","rightbraceunder"],1.6,548],underleftrightarrow:[["leftarrow","rightarrow"],0.888,522],xleftrightarrow:[["leftarrow","rightarrow"],1.75,522],xLeftrightarrow:[["doubleleftarrow","doublerightarrow"],1.75,560],xrightleftharpoons:[["leftharpoondownplus","rightharpoonplus"],1.75,716],xleftrightharpoons:[["leftharpoonplus","rightharpoondownplus"],1.75,716],xhookleftarrow:[["leftarrow","righthook"],1.08,522],xhookrightarrow:[["lefthook","rightarrow"],1.08,522],overlinesegment:[["leftlinesegment","rightlinesegment"],0.888,522],underlinesegment:[["leftlinesegment","rightlinesegment"],0.888,522],overgroup:[["leftgroup","rightgroup"],0.888,342],undergroup:[["leftgroupunder","rightgroupunder"],0.888,342],xmapsto:[["leftmapsto","rightarrow"],1.5,522],xtofrom:[["leftToFrom","rightToFrom"],1.75,528],// The next three arrows are from the mhchem package.
    // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
    // document as \xrightarrow or \xrightleftharpoons. Those have
    // min-length = 1.75em, so we set min-length on these next three to match.
    xrightleftarrows:[["baraboveleftarrow","rightarrowabovebar"],1.75,901],xrightequilibrium:[["baraboveshortleftharpoon","rightharpoonaboveshortbar"],1.75,716],xleftequilibrium:[["shortbaraboveleftharpoon","shortrightharpoonabovebar"],1.75,716]};const groupLength=function groupLength(arg){if(arg.type==="ordgroup"){return arg.body.length;}else {return 1;}};const svgSpan=function svgSpan(group,options){// Create a span with inline SVG for the element.
    function buildSvgSpan_(){let viewBoxWidth=400000;// default
    const label=group.label.substr(1);if(utils.contains(["widehat","widecheck","widetilde","utilde"],label)){// Each type in the `if` statement corresponds to one of the ParseNode
    // types below. This narrowing is required to access `grp.base`.
    const grp=group;// There are four SVG images available for each function.
    // Choose a taller image when there are more characters.
    const numChars=groupLength(grp.base);let viewBoxHeight;let pathName;let height;if(numChars>5){if(label==="widehat"||label==="widecheck"){viewBoxHeight=420;viewBoxWidth=2364;height=0.42;pathName=label+"4";}else {viewBoxHeight=312;viewBoxWidth=2340;height=0.34;pathName="tilde4";}}else {const imgIndex=[1,1,2,2,3,3][numChars];if(label==="widehat"||label==="widecheck"){viewBoxWidth=[0,1062,2364,2364,2364][imgIndex];viewBoxHeight=[0,239,300,360,420][imgIndex];height=[0,0.24,0.3,0.3,0.36,0.42][imgIndex];pathName=label+imgIndex;}else {viewBoxWidth=[0,600,1033,2339,2340][imgIndex];viewBoxHeight=[0,260,286,306,312][imgIndex];height=[0,0.26,0.286,0.3,0.306,0.34][imgIndex];pathName="tilde"+imgIndex;}}const path=new PathNode(pathName);const svgNode=new SvgNode([path],{"width":"100%","height":height+"em","viewBox":`0 0 ${viewBoxWidth} ${viewBoxHeight}`,"preserveAspectRatio":"none"});return {span:buildCommon.makeSvgSpan([],[svgNode],options),minWidth:0,height};}else {const spans=[];const data=katexImagesData[label];const paths=data[0],minWidth=data[1],viewBoxHeight=data[2];const height=viewBoxHeight/1000;const numSvgChildren=paths.length;let widthClasses;let aligns;if(numSvgChildren===1){// $FlowFixMe: All these cases must be of the 4-tuple type.
    const align1=data[3];widthClasses=["hide-tail"];aligns=[align1];}else if(numSvgChildren===2){widthClasses=["halfarrow-left","halfarrow-right"];aligns=["xMinYMin","xMaxYMin"];}else if(numSvgChildren===3){widthClasses=["brace-left","brace-center","brace-right"];aligns=["xMinYMin","xMidYMin","xMaxYMin"];}else {throw new Error(`Correct katexImagesData or update code here to support
                    ${numSvgChildren} children.`);}for(let i=0;i<numSvgChildren;i++){const path=new PathNode(paths[i]);const svgNode=new SvgNode([path],{"width":"400em","height":height+"em","viewBox":`0 0 ${viewBoxWidth} ${viewBoxHeight}`,"preserveAspectRatio":aligns[i]+" slice"});const span=buildCommon.makeSvgSpan([widthClasses[i]],[svgNode],options);if(numSvgChildren===1){return {span,minWidth,height};}else {span.style.height=height+"em";spans.push(span);}}return {span:buildCommon.makeSpan(["stretchy"],spans,options),minWidth,height};}}// buildSvgSpan_()
    const _buildSvgSpan_=buildSvgSpan_(),span=_buildSvgSpan_.span,minWidth=_buildSvgSpan_.minWidth,height=_buildSvgSpan_.height;// Note that we are returning span.depth = 0.
    // Any adjustments relative to the baseline must be done in buildHTML.
    span.height=height;span.style.height=height+"em";if(minWidth>0){span.style.minWidth=minWidth+"em";}return span;};const encloseSpan=function encloseSpan(inner,label,pad,options){// Return an image span for \cancel, \bcancel, \xcancel, or \fbox
    let img;const totalHeight=inner.height+inner.depth+2*pad;if(/fbox|color/.test(label)){img=buildCommon.makeSpan(["stretchy",label],[],options);if(label==="fbox"){const color=options.color&&options.getColor();if(color){img.style.borderColor=color;}}}else {// \cancel, \bcancel, or \xcancel
    // Since \cancel's SVG is inline and it omits the viewBox attribute,
    // its stroke-width will not vary with span area.
    const lines=[];if(/^[bx]cancel$/.test(label)){lines.push(new LineNode({"x1":"0","y1":"0","x2":"100%","y2":"100%","stroke-width":"0.046em"}));}if(/^x?cancel$/.test(label)){lines.push(new LineNode({"x1":"0","y1":"100%","x2":"100%","y2":"0","stroke-width":"0.046em"}));}const svgNode=new SvgNode(lines,{"width":"100%","height":totalHeight+"em"});img=buildCommon.makeSvgSpan([],[svgNode],options);}img.height=totalHeight;img.style.height=totalHeight+"em";return img;};var stretchy={encloseSpan,mathMLnode,svgSpan};/**
     * Asserts that the node is of the given type and returns it with stricter
     * typing. Throws if the node's type does not match.
     */function assertNodeType(node,type){if(!node||node.type!==type){throw new Error(`Expected node of type ${type}, but got `+(node?`node of type ${node.type}`:String(node)));}return node;}/**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */function assertSymbolNodeType(node){const typedNode=checkSymbolNodeType(node);if(!typedNode){throw new Error(`Expected node of symbol group type, but got `+(node?`node of type ${node.type}`:String(node)));}return typedNode;}/**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */function checkSymbolNodeType(node){if(node&&(node.type==="atom"||NON_ATOMS.hasOwnProperty(node.type))){// $FlowFixMe
    return node;}return null;}// NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
    const htmlBuilder=(grp,options)=>{// Accents are handled in the TeXbook pg. 443, rule 12.
    let base;let group;let supSubGroup;if(grp&&grp.type==="supsub"){// If our base is a character box, and we have superscripts and
    // subscripts, the supsub will defer to us. In particular, we want
    // to attach the superscripts and subscripts to the inner body (so
    // that the position of the superscripts and subscripts won't be
    // affected by the height of the accent). We accomplish this by
    // sticking the base of the accent into the base of the supsub, and
    // rendering that, while keeping track of where the accent is.
    // The real accent group is the base of the supsub group
    group=assertNodeType(grp.base,"accent");// The character box is the base of the accent group
    base=group.base;// Stick the character box into the base of the supsub group
    grp.base=base;// Rerender the supsub group with its new base, and store that
    // result.
    supSubGroup=assertSpan(buildGroup(grp,options));// reset original base
    grp.base=group;}else {group=assertNodeType(grp,"accent");base=group.base;}// Build the base group
    const body=buildGroup(base,options.havingCrampedStyle());// Does the accent need to shift for the skew of a character?
    const mustShift=group.isShifty&&utils.isCharacterBox(base);// Calculate the skew of the accent. This is based on the line "If the
    // nucleus is not a single character, let s = 0; otherwise set s to the
    // kern amount for the nucleus followed by the \skewchar of its font."
    // Note that our skew metrics are just the kern between each character
    // and the skewchar.
    let skew=0;if(mustShift){// If the base is a character box, then we want the skew of the
    // innermost character. To do that, we find the innermost character:
    const baseChar=utils.getBaseElem(base);// Then, we render its group to get the symbol inside it
    const baseGroup=buildGroup(baseChar,options.havingCrampedStyle());// Finally, we pull the skew off of the symbol.
    skew=assertSymbolDomNode(baseGroup).skew;// Note that we now throw away baseGroup, because the layers we
    // removed with getBaseElem might contain things like \color which
    // we can't get rid of.
    // TODO(emily): Find a better way to get the skew
    }// calculate the amount of space between the body and the accent
    let clearance=Math.min(body.height,options.fontMetrics().xHeight);// Build the accent
    let accentBody;if(!group.isStretchy){let accent;let width;if(group.label==="\\vec"){// Before version 0.9, \vec used the combining font glyph U+20D7.
    // But browsers, especially Safari, are not consistent in how they
    // render combining characters when not preceded by a character.
    // So now we use an SVG.
    // If Safari reforms, we should consider reverting to the glyph.
    accent=buildCommon.staticSvg("vec",options);width=buildCommon.svgData.vec[1];}else {accent=buildCommon.makeOrd({mode:group.mode,text:group.label},options,"textord");accent=assertSymbolDomNode(accent);// Remove the italic correction of the accent, because it only serves to
    // shift the accent over to a place we don't want.
    accent.italic=0;width=accent.width;}accentBody=buildCommon.makeSpan(["accent-body"],[accent]);// "Full" accents expand the width of the resulting symbol to be
    // at least the width of the accent, and overlap directly onto the
    // character without any vertical offset.
    const accentFull=group.label==="\\textcircled";if(accentFull){accentBody.classes.push('accent-full');clearance=body.height;}// Shift the accent over by the skew.
    let left=skew;// CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
    // so that the accent doesn't contribute to the bounding box.
    // We need to shift the character by its width (effectively half
    // its width) to compensate.
    if(!accentFull){left-=width/2;}accentBody.style.left=left+"em";// \textcircled uses the \bigcirc glyph, so it needs some
    // vertical adjustment to match LaTeX.
    if(group.label==="\\textcircled"){accentBody.style.top=".2em";}accentBody=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:body},{type:"kern",size:-clearance},{type:"elem",elem:accentBody}]},options);}else {accentBody=stretchy.svgSpan(group,options);accentBody=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:body},{type:"elem",elem:accentBody,wrapperClasses:["svg-align"],wrapperStyle:skew>0?{width:`calc(100% - ${2*skew}em)`,marginLeft:`${2*skew}em`}:undefined}]},options);}const accentWrap=buildCommon.makeSpan(["mord","accent"],[accentBody],options);if(supSubGroup){// Here, we replace the "base" child of the supsub with our newly
    // generated accent.
    supSubGroup.children[0]=accentWrap;// Since we don't rerun the height calculation after replacing the
    // accent, we manually recalculate height.
    supSubGroup.height=Math.max(accentWrap.height,supSubGroup.height);// Accents should always be ords, even when their innards are not.
    supSubGroup.classes[0]="mord";return supSubGroup;}else {return accentWrap;}};const mathmlBuilder=(group,options)=>{const accentNode=group.isStretchy?stretchy.mathMLnode(group.label):new mathMLTree.MathNode("mo",[makeText(group.label,group.mode)]);const node=new mathMLTree.MathNode("mover",[buildGroup$1(group.base,options),accentNode]);node.setAttribute("accent","true");return node;};const NON_STRETCHY_ACCENT_REGEX=new RegExp(["\\acute","\\grave","\\ddot","\\tilde","\\bar","\\breve","\\check","\\hat","\\vec","\\dot","\\mathring"].map(accent=>`\\${accent}`).join("|"));// Accents
    defineFunction({type:"accent",names:["\\acute","\\grave","\\ddot","\\tilde","\\bar","\\breve","\\check","\\hat","\\vec","\\dot","\\mathring","\\widecheck","\\widehat","\\widetilde","\\overrightarrow","\\overleftarrow","\\Overrightarrow","\\overleftrightarrow","\\overgroup","\\overlinesegment","\\overleftharpoon","\\overrightharpoon"],props:{numArgs:1},handler:(context,args)=>{const base=args[0];const isStretchy=!NON_STRETCHY_ACCENT_REGEX.test(context.funcName);const isShifty=!isStretchy||context.funcName==="\\widehat"||context.funcName==="\\widetilde"||context.funcName==="\\widecheck";return {type:"accent",mode:context.parser.mode,label:context.funcName,isStretchy:isStretchy,isShifty:isShifty,base:base};},htmlBuilder,mathmlBuilder});// Text-mode accents
    defineFunction({type:"accent",names:["\\'","\\`","\\^","\\~","\\=","\\u","\\.",'\\"',"\\r","\\H","\\v","\\textcircled"],props:{numArgs:1,allowedInText:true,allowedInMath:false},handler:(context,args)=>{const base=args[0];return {type:"accent",mode:context.parser.mode,label:context.funcName,isStretchy:false,isShifty:true,base:base};},htmlBuilder,mathmlBuilder});// Horizontal overlap functions
    defineFunction({type:"accentUnder",names:["\\underleftarrow","\\underrightarrow","\\underleftrightarrow","\\undergroup","\\underlinesegment","\\utilde"],props:{numArgs:1},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;const base=args[0];return {type:"accentUnder",mode:parser.mode,label:funcName,base:base};},htmlBuilder:(group,options)=>{// Treat under accents much like underlines.
    const innerGroup=buildGroup(group.base,options);const accentBody=stretchy.svgSpan(group,options);const kern=group.label==="\\utilde"?0.12:0;// Generate the vlist, with the appropriate kerns
    const vlist=buildCommon.makeVList({positionType:"top",positionData:innerGroup.height,children:[{type:"elem",elem:accentBody,wrapperClasses:["svg-align"]},{type:"kern",size:kern},{type:"elem",elem:innerGroup}]},options);return buildCommon.makeSpan(["mord","accentunder"],[vlist],options);},mathmlBuilder:(group,options)=>{const accentNode=stretchy.mathMLnode(group.label);const node=new mathMLTree.MathNode("munder",[buildGroup$1(group.base,options),accentNode]);node.setAttribute("accentunder","true");return node;}});// Helper function
    const paddedNode=group=>{const node=new mathMLTree.MathNode("mpadded",group?[group]:[]);node.setAttribute("width","+0.6em");node.setAttribute("lspace","0.3em");return node;};// Stretchy arrows with an optional argument
    defineFunction({type:"xArrow",names:["\\xleftarrow","\\xrightarrow","\\xLeftarrow","\\xRightarrow","\\xleftrightarrow","\\xLeftrightarrow","\\xhookleftarrow","\\xhookrightarrow","\\xmapsto","\\xrightharpoondown","\\xrightharpoonup","\\xleftharpoondown","\\xleftharpoonup","\\xrightleftharpoons","\\xleftrightharpoons","\\xlongequal","\\xtwoheadrightarrow","\\xtwoheadleftarrow","\\xtofrom",// The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows","\\xrightequilibrium","\\xleftequilibrium"],props:{numArgs:1,numOptionalArgs:1},handler(_ref,args,optArgs){let parser=_ref.parser,funcName=_ref.funcName;return {type:"xArrow",mode:parser.mode,label:funcName,body:args[0],below:optArgs[0]};},// Flow is unable to correctly infer the type of `group`, even though it's
    // unamibiguously determined from the passed-in `type` above.
    htmlBuilder(group,options){const style=options.style;// Build the argument groups in the appropriate style.
    // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
    // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.
    let newOptions=options.havingStyle(style.sup());const upperGroup=buildCommon.wrapFragment(buildGroup(group.body,newOptions,options),options);upperGroup.classes.push("x-arrow-pad");let lowerGroup;if(group.below){// Build the lower group
    newOptions=options.havingStyle(style.sub());lowerGroup=buildCommon.wrapFragment(buildGroup(group.below,newOptions,options),options);lowerGroup.classes.push("x-arrow-pad");}const arrowBody=stretchy.svgSpan(group,options);// Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
    // The point we want on the math axis is at 0.5 * arrowBody.height.
    const arrowShift=-options.fontMetrics().axisHeight+0.5*arrowBody.height;// 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi
    let upperShift=-options.fontMetrics().axisHeight-0.5*arrowBody.height-0.111;// 0.111 em = 2 mu
    if(upperGroup.depth>0.25||group.label==="\\xleftequilibrium"){upperShift-=upperGroup.depth;// shift up if depth encroaches
    }// Generate the vlist
    let vlist;if(lowerGroup){const lowerShift=-options.fontMetrics().axisHeight+lowerGroup.height+0.5*arrowBody.height+0.111;vlist=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:upperGroup,shift:upperShift},{type:"elem",elem:arrowBody,shift:arrowShift},{type:"elem",elem:lowerGroup,shift:lowerShift}]},options);}else {vlist=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:upperGroup,shift:upperShift},{type:"elem",elem:arrowBody,shift:arrowShift}]},options);}// $FlowFixMe: Replace this with passing "svg-align" into makeVList.
    vlist.children[0].children[0].children[1].classes.push("svg-align");return buildCommon.makeSpan(["mrel","x-arrow"],[vlist],options);},mathmlBuilder(group,options){const arrowNode=stretchy.mathMLnode(group.label);let node;if(group.body){const upperNode=paddedNode(buildGroup$1(group.body,options));if(group.below){const lowerNode=paddedNode(buildGroup$1(group.below,options));node=new mathMLTree.MathNode("munderover",[arrowNode,lowerNode,upperNode]);}else {node=new mathMLTree.MathNode("mover",[arrowNode,upperNode]);}}else if(group.below){const lowerNode=paddedNode(buildGroup$1(group.below,options));node=new mathMLTree.MathNode("munder",[arrowNode,lowerNode]);}else {// This should never happen.
    // Parser.js throws an error if there is no argument.
    node=paddedNode();node=new mathMLTree.MathNode("mover",[arrowNode,node]);}return node;}});// {123} and converts into symbol with code 123.  It is used by the *macro*
    // \char defined in macros.js.
    defineFunction({type:"textord",names:["\\@char"],props:{numArgs:1,allowedInText:true},handler(_ref,args){let parser=_ref.parser;const arg=assertNodeType(args[0],"ordgroup");const group=arg.body;let number="";for(let i=0;i<group.length;i++){const node=assertNodeType(group[i],"textord");number+=node.text;}const code=parseInt(number);if(isNaN(code)){throw new ParseError(`\\@char has non-numeric argument ${number}`);}return {type:"textord",mode:parser.mode,text:String.fromCharCode(code)};}});const htmlBuilder$1=(group,options)=>{const elements=buildExpression(group.body,options.withColor(group.color),false);// \color isn't supposed to affect the type of the elements it contains.
    // To accomplish this, we wrap the results in a fragment, so the inner
    // elements will be able to directly interact with their neighbors. For
    // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
    return buildCommon.makeFragment(elements);};const mathmlBuilder$1=(group,options)=>{const inner=buildExpression$1(group.body,options.withColor(group.color));const node=new mathMLTree.MathNode("mstyle",inner);node.setAttribute("mathcolor",group.color);return node;};defineFunction({type:"color",names:["\\textcolor"],props:{numArgs:2,allowedInText:true,greediness:3,argTypes:["color","original"]},handler(_ref,args){let parser=_ref.parser;const color=assertNodeType(args[0],"color-token").color;const body=args[1];return {type:"color",mode:parser.mode,color,body:ordargument(body)};},htmlBuilder:htmlBuilder$1,mathmlBuilder:mathmlBuilder$1});defineFunction({type:"color",names:["\\color"],props:{numArgs:1,allowedInText:true,greediness:3,argTypes:["color"]},handler(_ref2,args){let parser=_ref2.parser,breakOnTokenText=_ref2.breakOnTokenText;const color=assertNodeType(args[0],"color-token").color;// Set macro \current@color in current namespace to store the current
    // color, mimicking the behavior of color.sty.
    // This is currently used just to correctly color a \right
    // that follows a \color command.
    parser.gullet.macros.set("\\current@color",color);// Parse out the implicit body that should be colored.
    const body=parser.parseExpression(true,breakOnTokenText);return {type:"color",mode:parser.mode,color,body};},htmlBuilder:htmlBuilder$1,mathmlBuilder:mathmlBuilder$1});// Row breaks within tabular environments, and line breaks at top level
    // same signature, we implement them as one megafunction, with newRow
    // indicating whether we're in the \cr case, and newLine indicating whether
    // to break the line in the \newline case.
    defineFunction({type:"cr",names:["\\cr","\\newline"],props:{numArgs:0,numOptionalArgs:1,argTypes:["size"],allowedInText:true},handler(_ref,args,optArgs){let parser=_ref.parser,funcName=_ref.funcName;const size=optArgs[0];const newRow=funcName==="\\cr";let newLine=false;if(!newRow){if(parser.settings.displayMode&&parser.settings.useStrictBehavior("newLineInDisplayMode","In LaTeX, \\\\ or \\newline "+"does nothing in display mode")){newLine=false;}else {newLine=true;}}return {type:"cr",mode:parser.mode,newLine,newRow,size:size&&assertNodeType(size,"size").value};},// The following builders are called only at the top level,
    // not within tabular/array environments.
    htmlBuilder(group,options){if(group.newRow){throw new ParseError("\\cr valid only within a tabular/array environment");}const span=buildCommon.makeSpan(["mspace"],[],options);if(group.newLine){span.classes.push("newline");if(group.size){span.style.marginTop=calculateSize(group.size,options)+"em";}}return span;},mathmlBuilder(group,options){const node=new mathMLTree.MathNode("mspace");if(group.newLine){node.setAttribute("linebreak","newline");if(group.size){node.setAttribute("height",calculateSize(group.size,options)+"em");}}return node;}});const globalMap={"\\global":"\\global","\\long":"\\\\globallong","\\\\globallong":"\\\\globallong","\\def":"\\gdef","\\gdef":"\\gdef","\\edef":"\\xdef","\\xdef":"\\xdef","\\let":"\\\\globallet","\\futurelet":"\\\\globalfuture"};const checkControlSequence=tok=>{const name=tok.text;if(/^(?:[\\{}$&#^_]|EOF)$/.test(name)){throw new ParseError("Expected a control sequence",tok);}return name;};const getRHS=parser=>{let tok=parser.gullet.popToken();if(tok.text==="="){// consume optional equals
    tok=parser.gullet.popToken();if(tok.text===" "){// consume one optional space
    tok=parser.gullet.popToken();}}return tok;};const letCommand=(parser,name,tok,global)=>{let macro=parser.gullet.macros.get(tok.text);if(macro==null){// don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand=true;macro={tokens:[tok],numArgs:0,// reproduce the same behavior in expansion
    unexpandable:!parser.gullet.isExpandable(tok.text)};}parser.gullet.macros.set(name,macro,global);};// <assignment> -> <non-macro assignment>|<macro assignment>
    // <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
    // <macro assignment> -> <definition>|<prefix><macro assignment>
    // <prefix> -> \global|\long|\outer
    defineFunction({type:"internal",names:["\\global","\\long","\\\\globallong"],props:{numArgs:0,allowedInText:true},handler(_ref){let parser=_ref.parser,funcName=_ref.funcName;parser.consumeSpaces();const token=parser.fetch();if(globalMap[token.text]){// KaTeX doesn't have \par, so ignore \long
    if(funcName==="\\global"||funcName==="\\\\globallong"){token.text=globalMap[token.text];}return assertNodeType(parser.parseFunction(),"internal");}throw new ParseError(`Invalid token after macro prefix`,token);}});// Basic support for macro definitions: \def, \gdef, \edef, \xdef
    // <definition> -> <def><control sequence><definition text>
    // <def> -> \def|\gdef|\edef|\xdef
    // <definition text> -> <parameter text><left brace><balanced text><right brace>
    defineFunction({type:"internal",names:["\\def","\\gdef","\\edef","\\xdef"],props:{numArgs:0,allowedInText:true},handler(_ref2){let parser=_ref2.parser,funcName=_ref2.funcName;let arg=parser.gullet.consumeArgs(1)[0];if(arg.length!==1){throw new ParseError("\\gdef's first argument must be a macro name");}const name=arg[0].text;// Count argument specifiers, and check they are in the order #1 #2 ...
    let numArgs=0;arg=parser.gullet.consumeArgs(1)[0];while(arg.length===1&&arg[0].text==="#"){arg=parser.gullet.consumeArgs(1)[0];if(arg.length!==1){throw new ParseError(`Invalid argument number length "${arg.length}"`);}if(!/^[1-9]$/.test(arg[0].text)){throw new ParseError(`Invalid argument number "${arg[0].text}"`);}numArgs++;if(parseInt(arg[0].text)!==numArgs){throw new ParseError(`Argument number "${arg[0].text}" out of order`);}arg=parser.gullet.consumeArgs(1)[0];}if(funcName==="\\edef"||funcName==="\\xdef"){arg=parser.gullet.expandTokens(arg);arg.reverse();// to fit in with stack order
    }// Final arg is the expansion of the macro
    parser.gullet.macros.set(name,{tokens:arg,numArgs},funcName===globalMap[funcName]);return {type:"internal",mode:parser.mode};}});// <simple assignment> -> <let assignment>
    // <let assignment> -> \futurelet<control sequence><token><token>
    //     | \let<control sequence><equals><one optional space><token>
    // <equals> -> <optional spaces>|<optional spaces>=
    defineFunction({type:"internal",names:["\\let","\\\\globallet"],props:{numArgs:0,allowedInText:true},handler(_ref3){let parser=_ref3.parser,funcName=_ref3.funcName;const name=checkControlSequence(parser.gullet.popToken());parser.gullet.consumeSpaces();const tok=getRHS(parser);letCommand(parser,name,tok,funcName==="\\\\globallet");return {type:"internal",mode:parser.mode};}});// ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf
    defineFunction({type:"internal",names:["\\futurelet","\\\\globalfuture"],props:{numArgs:0,allowedInText:true},handler(_ref4){let parser=_ref4.parser,funcName=_ref4.funcName;const name=checkControlSequence(parser.gullet.popToken());const middle=parser.gullet.popToken();const tok=parser.gullet.popToken();letCommand(parser,name,tok,funcName==="\\\\globalfuture");parser.gullet.pushToken(tok);parser.gullet.pushToken(middle);return {type:"internal",mode:parser.mode};}});/**
     * This file deals with creating delimiters of various sizes. The TeXbook
     * discusses these routines on page 441-442, in the "Another subroutine sets box
     * x to a specified variable delimiter" paragraph.
     *
     * There are three main routines here. `makeSmallDelim` makes a delimiter in the
     * normal font, but in either text, script, or scriptscript style.
     * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
     * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
     * smaller pieces that are stacked on top of one another.
     *
     * The functions take a parameter `center`, which determines if the delimiter
     * should be centered around the axis.
     *
     * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
     * one of the given sizes. This is used for things like `\bigl`.
     * `customSizedDelim` makes a delimiter with a given total height+depth. It is
     * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
     * delimiter which surrounds an expression of a given height an depth. It is
     * used in `\left` and `\right`.
     */ /**
     * Get the metrics for a given symbol and font, after transformation (i.e.
     * after following replacement from symbols.js)
     */const getMetrics=function getMetrics(symbol,font,mode){const replace=symbols.math[symbol]&&symbols.math[symbol].replace;const metrics=getCharacterMetrics(replace||symbol,font,mode);if(!metrics){throw new Error(`Unsupported symbol ${symbol} and font size ${font}.`);}return metrics;};/**
     * Puts a delimiter span in a given style, and adds appropriate height, depth,
     * and maxFontSizes.
     */const styleWrap=function styleWrap(delim,toStyle,options,classes){const newOptions=options.havingBaseStyle(toStyle);const span=buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)),[delim],options);const delimSizeMultiplier=newOptions.sizeMultiplier/options.sizeMultiplier;span.height*=delimSizeMultiplier;span.depth*=delimSizeMultiplier;span.maxFontSize=newOptions.sizeMultiplier;return span;};const centerSpan=function centerSpan(span,options,style){const newOptions=options.havingBaseStyle(style);const shift=(1-options.sizeMultiplier/newOptions.sizeMultiplier)*options.fontMetrics().axisHeight;span.classes.push("delimcenter");span.style.top=shift+"em";span.height-=shift;span.depth+=shift;};/**
     * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
     * font, but is restyled to either be in textstyle, scriptstyle, or
     * scriptscriptstyle.
     */const makeSmallDelim=function makeSmallDelim(delim,style,center,options,mode,classes){const text=buildCommon.makeSymbol(delim,"Main-Regular",mode,options);const span=styleWrap(text,style,options,classes);if(center){centerSpan(span,options,style);}return span;};/**
     * Builds a symbol in the given font size (note size is an integer)
     */const mathrmSize=function mathrmSize(value,size,mode,options){return buildCommon.makeSymbol(value,"Size"+size+"-Regular",mode,options);};/**
     * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
     * Size3, or Size4 fonts. It is always rendered in textstyle.
     */const makeLargeDelim=function makeLargeDelim(delim,size,center,options,mode,classes){const inner=mathrmSize(delim,size,mode,options);const span=styleWrap(buildCommon.makeSpan(["delimsizing","size"+size],[inner],options),Style$1.TEXT,options,classes);if(center){centerSpan(span,options,Style$1.TEXT);}return span;};/**
     * Make an inner span with the given offset and in the given font. This is used
     * in `makeStackedDelim` to make the stacking pieces for the delimiter.
     */const makeInner=function makeInner(symbol,font,mode){let sizeClass;// Apply the correct CSS class to choose the right font.
    if(font==="Size1-Regular"){sizeClass="delim-size1";}else/* if (font === "Size4-Regular") */{sizeClass="delim-size4";}const inner=buildCommon.makeSpan(["delimsizinginner",sizeClass],[buildCommon.makeSpan([],[buildCommon.makeSymbol(symbol,font,mode)])]);// Since this will be passed into `makeVList` in the end, wrap the element
    // in the appropriate tag that VList uses.
    return {type:"elem",elem:inner};};// Helper for makeStackedDelim
    const lap={type:"kern",size:-0.005};/**
     * Make a stacked delimiter out of a given delimiter, with the total height at
     * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
     */const makeStackedDelim=function makeStackedDelim(delim,heightTotal,center,options,mode,classes){// There are four parts, the top, an optional middle, a repeated part, and a
    // bottom.
    let top;let middle;let repeat;let bottom;top=repeat=bottom=delim;middle=null;// Also keep track of what font the delimiters are in
    let font="Size1-Regular";// We set the parts and font based on the symbol. Note that we use
    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
    // repeats of the arrows
    if(delim==="\\uparrow"){repeat=bottom="\u23d0";}else if(delim==="\\Uparrow"){repeat=bottom="\u2016";}else if(delim==="\\downarrow"){top=repeat="\u23d0";}else if(delim==="\\Downarrow"){top=repeat="\u2016";}else if(delim==="\\updownarrow"){top="\\uparrow";repeat="\u23d0";bottom="\\downarrow";}else if(delim==="\\Updownarrow"){top="\\Uparrow";repeat="\u2016";bottom="\\Downarrow";}else if(delim==="["||delim==="\\lbrack"){top="\u23a1";repeat="\u23a2";bottom="\u23a3";font="Size4-Regular";}else if(delim==="]"||delim==="\\rbrack"){top="\u23a4";repeat="\u23a5";bottom="\u23a6";font="Size4-Regular";}else if(delim==="\\lfloor"||delim==="\u230a"){repeat=top="\u23a2";bottom="\u23a3";font="Size4-Regular";}else if(delim==="\\lceil"||delim==="\u2308"){top="\u23a1";repeat=bottom="\u23a2";font="Size4-Regular";}else if(delim==="\\rfloor"||delim==="\u230b"){repeat=top="\u23a5";bottom="\u23a6";font="Size4-Regular";}else if(delim==="\\rceil"||delim==="\u2309"){top="\u23a4";repeat=bottom="\u23a5";font="Size4-Regular";}else if(delim==="("||delim==="\\lparen"){top="\u239b";repeat="\u239c";bottom="\u239d";font="Size4-Regular";}else if(delim===")"||delim==="\\rparen"){top="\u239e";repeat="\u239f";bottom="\u23a0";font="Size4-Regular";}else if(delim==="\\{"||delim==="\\lbrace"){top="\u23a7";middle="\u23a8";bottom="\u23a9";repeat="\u23aa";font="Size4-Regular";}else if(delim==="\\}"||delim==="\\rbrace"){top="\u23ab";middle="\u23ac";bottom="\u23ad";repeat="\u23aa";font="Size4-Regular";}else if(delim==="\\lgroup"||delim==="\u27ee"){top="\u23a7";bottom="\u23a9";repeat="\u23aa";font="Size4-Regular";}else if(delim==="\\rgroup"||delim==="\u27ef"){top="\u23ab";bottom="\u23ad";repeat="\u23aa";font="Size4-Regular";}else if(delim==="\\lmoustache"||delim==="\u23b0"){top="\u23a7";bottom="\u23ad";repeat="\u23aa";font="Size4-Regular";}else if(delim==="\\rmoustache"||delim==="\u23b1"){top="\u23ab";bottom="\u23a9";repeat="\u23aa";font="Size4-Regular";}// Get the metrics of the four sections
    const topMetrics=getMetrics(top,font,mode);const topHeightTotal=topMetrics.height+topMetrics.depth;const repeatMetrics=getMetrics(repeat,font,mode);const repeatHeightTotal=repeatMetrics.height+repeatMetrics.depth;const bottomMetrics=getMetrics(bottom,font,mode);const bottomHeightTotal=bottomMetrics.height+bottomMetrics.depth;let middleHeightTotal=0;let middleFactor=1;if(middle!==null){const middleMetrics=getMetrics(middle,font,mode);middleHeightTotal=middleMetrics.height+middleMetrics.depth;middleFactor=2;// repeat symmetrically above and below middle
    }// Calcuate the minimal height that the delimiter can have.
    // It is at least the size of the top, bottom, and optional middle combined.
    const minHeight=topHeightTotal+bottomHeightTotal+middleHeightTotal;// Compute the number of copies of the repeat symbol we will need
    const repeatCount=Math.max(0,Math.ceil((heightTotal-minHeight)/(middleFactor*repeatHeightTotal)));// Compute the total height of the delimiter including all the symbols
    const realHeightTotal=minHeight+repeatCount*middleFactor*repeatHeightTotal;// The center of the delimiter is placed at the center of the axis. Note
    // that in this context, "center" means that the delimiter should be
    // centered around the axis in the current style, while normally it is
    // centered around the axis in textstyle.
    let axisHeight=options.fontMetrics().axisHeight;if(center){axisHeight*=options.sizeMultiplier;}// Calculate the depth
    const depth=realHeightTotal/2-axisHeight;// This function differs from the TeX procedure in one way.
    // We shift each repeat element downwards by 0.005em, to prevent a gap
    // due to browser floating point rounding error.
    // Then, at the last element-to element joint, we add one extra repeat
    // element to cover the gap created by the shifts.
    // Find the shift needed to align the upper end of the extra element at a point
    // 0.005em above the lower end of the top element.
    const shiftOfExtraElement=(repeatCount+1)*0.005-repeatHeightTotal;// Now, we start building the pieces that will go into the vlist
    // Keep a list of the inner pieces
    const inners=[];// Add the bottom symbol
    inners.push(makeInner(bottom,font,mode));if(middle===null){// Add that many symbols
    for(let i=0;i<repeatCount;i++){inners.push(lap);// overlap
    inners.push(makeInner(repeat,font,mode));}}else {// When there is a middle bit, we need the middle part and two repeated
    // sections
    for(let i=0;i<repeatCount;i++){inners.push(lap);inners.push(makeInner(repeat,font,mode));}// Insert one extra repeat element.
    inners.push({type:"kern",size:shiftOfExtraElement});inners.push(makeInner(repeat,font,mode));inners.push(lap);// Now insert the middle of the brace.
    inners.push(makeInner(middle,font,mode));for(let i=0;i<repeatCount;i++){inners.push(lap);inners.push(makeInner(repeat,font,mode));}}// To cover the gap create by the overlaps, insert one more repeat element,
    // at a position that juts 0.005 above the bottom of the top element.
    if((repeat==="\u239c"||repeat==="\u239f")&&repeatCount===0){// Parentheses need a short repeat element in order to avoid an overrun.
    // We'll make a 0.3em tall element from a SVG.
    const overlap=buildCommon.svgData.leftParenInner[2]/2;inners.push({type:"kern",size:-overlap});const pathName=repeat==="\u239c"?"leftParenInner":"rightParenInner";const innerSpan=buildCommon.staticSvg(pathName,options);inners.push({type:"elem",elem:innerSpan});inners.push({type:"kern",size:-overlap});}else {inners.push({type:"kern",size:shiftOfExtraElement});inners.push(makeInner(repeat,font,mode));inners.push(lap);}// Add the top symbol
    inners.push(makeInner(top,font,mode));// Finally, build the vlist
    const newOptions=options.havingBaseStyle(Style$1.TEXT);const inner=buildCommon.makeVList({positionType:"bottom",positionData:depth,children:inners},newOptions);return styleWrap(buildCommon.makeSpan(["delimsizing","mult"],[inner],newOptions),Style$1.TEXT,options,classes);};// All surds have 0.08em padding above the viniculum inside the SVG.
    // That keeps browser span height rounding error from pinching the line.
    const vbPad=80;// padding above the surd, measured inside the viewBox.
    const emPad=0.08;// padding, in ems, measured in the document.
    const sqrtSvg=function sqrtSvg(sqrtName,height,viewBoxHeight,extraViniculum,options){const path=sqrtPath(sqrtName,extraViniculum,viewBoxHeight);const pathNode=new PathNode(sqrtName,path);const svg=new SvgNode([pathNode],{// Note: 1000:1 ratio of viewBox to document em width.
    "width":"400em","height":height+"em","viewBox":"0 0 400000 "+viewBoxHeight,"preserveAspectRatio":"xMinYMin slice"});return buildCommon.makeSvgSpan(["hide-tail"],[svg],options);};/**
     * Make a sqrt image of the given height,
     */const makeSqrtImage=function makeSqrtImage(height,options){// Define a newOptions that removes the effect of size changes such as \Huge.
    // We don't pick different a height surd for \Huge. For it, we scale up.
    const newOptions=options.havingBaseSizing();// Pick the desired surd glyph from a sequence of surds.
    const delim=traverseSequence("\\surd",height*newOptions.sizeMultiplier,stackLargeDelimiterSequence,newOptions);let sizeMultiplier=newOptions.sizeMultiplier;// default
    // The standard sqrt SVGs each have a 0.04em thick viniculum.
    // If Settings.minRuleThickness is larger than that, we add extraViniculum.
    const extraViniculum=Math.max(0,options.minRuleThickness-options.fontMetrics().sqrtRuleThickness);// Create a span containing an SVG image of a sqrt symbol.
    let span;let spanHeight=0;let texHeight=0;let viewBoxHeight=0;let advanceWidth;// We create viewBoxes with 80 units of "padding" above each surd.
    // Then browser rounding error on the parent span height will not
    // encroach on the ink of the viniculum. But that padding is not
    // included in the TeX-like `height` used for calculation of
    // vertical alignment. So texHeight = span.height < span.style.height.
    if(delim.type==="small"){// Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
    // 1000 unit normal glyph height.
    viewBoxHeight=1000+1000*extraViniculum+vbPad;if(height<1.0){sizeMultiplier=1.0;// mimic a \textfont radical
    }else if(height<1.4){sizeMultiplier=0.7;// mimic a \scriptfont radical
    }spanHeight=(1.0+extraViniculum+emPad)/sizeMultiplier;texHeight=(1.00+extraViniculum)/sizeMultiplier;span=sqrtSvg("sqrtMain",spanHeight,viewBoxHeight,extraViniculum,options);span.style.minWidth="0.853em";advanceWidth=0.833/sizeMultiplier;// from the font.
    }else if(delim.type==="large"){// These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
    viewBoxHeight=(1000+vbPad)*sizeToMaxHeight[delim.size];texHeight=(sizeToMaxHeight[delim.size]+extraViniculum)/sizeMultiplier;spanHeight=(sizeToMaxHeight[delim.size]+extraViniculum+emPad)/sizeMultiplier;span=sqrtSvg("sqrtSize"+delim.size,spanHeight,viewBoxHeight,extraViniculum,options);span.style.minWidth="1.02em";advanceWidth=1.0/sizeMultiplier;// 1.0 from the font.
    }else {// Tall sqrt. In TeX, this would be stacked using multiple glyphs.
    // We'll use a single SVG to accomplish the same thing.
    spanHeight=height+extraViniculum+emPad;texHeight=height+extraViniculum;viewBoxHeight=Math.floor(1000*height+extraViniculum)+vbPad;span=sqrtSvg("sqrtTall",spanHeight,viewBoxHeight,extraViniculum,options);span.style.minWidth="0.742em";advanceWidth=1.056;}span.height=texHeight;span.style.height=spanHeight+"em";return {span,advanceWidth,// Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth:(options.fontMetrics().sqrtRuleThickness+extraViniculum)*sizeMultiplier};};// There are three kinds of delimiters, delimiters that stack when they become
    // too large
    const stackLargeDelimiters=["(","\\lparen",")","\\rparen","[","\\lbrack","]","\\rbrack","\\{","\\lbrace","\\}","\\rbrace","\\lfloor","\\rfloor","\u230a","\u230b","\\lceil","\\rceil","\u2308","\u2309","\\surd"];// delimiters that always stack
    const stackAlwaysDelimiters=["\\uparrow","\\downarrow","\\updownarrow","\\Uparrow","\\Downarrow","\\Updownarrow","|","\\|","\\vert","\\Vert","\\lvert","\\rvert","\\lVert","\\rVert","\\lgroup","\\rgroup","\u27ee","\u27ef","\\lmoustache","\\rmoustache","\u23b0","\u23b1"];// and delimiters that never stack
    const stackNeverDelimiters=["<",">","\\langle","\\rangle","/","\\backslash","\\lt","\\gt"];// Metrics of the different sizes. Found by looking at TeX's output of
    // $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
    // Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
    const sizeToMaxHeight=[0,1.2,1.8,2.4,3.0];/**
     * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
     */const makeSizedDelim=function makeSizedDelim(delim,size,options,mode,classes){// < and > turn into \langle and \rangle in delimiters
    if(delim==="<"||delim==="\\lt"||delim==="\u27e8"){delim="\\langle";}else if(delim===">"||delim==="\\gt"||delim==="\u27e9"){delim="\\rangle";}// Sized delimiters are never centered.
    if(utils.contains(stackLargeDelimiters,delim)||utils.contains(stackNeverDelimiters,delim)){return makeLargeDelim(delim,size,false,options,mode,classes);}else if(utils.contains(stackAlwaysDelimiters,delim)){return makeStackedDelim(delim,sizeToMaxHeight[size],false,options,mode,classes);}else {throw new ParseError("Illegal delimiter: '"+delim+"'");}};/**
     * There are three different sequences of delimiter sizes that the delimiters
     * follow depending on the kind of delimiter. This is used when creating custom
     * sized delimiters to decide whether to create a small, large, or stacked
     * delimiter.
     *
     * In real TeX, these sequences aren't explicitly defined, but are instead
     * defined inside the font metrics. Since there are only three sequences that
     * are possible for the delimiters that TeX defines, it is easier to just encode
     * them explicitly here.
     */ // Delimiters that never stack try small delimiters and large delimiters only
    const stackNeverDelimiterSequence=[{type:"small",style:Style$1.SCRIPTSCRIPT},{type:"small",style:Style$1.SCRIPT},{type:"small",style:Style$1.TEXT},{type:"large",size:1},{type:"large",size:2},{type:"large",size:3},{type:"large",size:4}];// Delimiters that always stack try the small delimiters first, then stack
    const stackAlwaysDelimiterSequence=[{type:"small",style:Style$1.SCRIPTSCRIPT},{type:"small",style:Style$1.SCRIPT},{type:"small",style:Style$1.TEXT},{type:"stack"}];// Delimiters that stack when large try the small and then large delimiters, and
    // stack afterwards
    const stackLargeDelimiterSequence=[{type:"small",style:Style$1.SCRIPTSCRIPT},{type:"small",style:Style$1.SCRIPT},{type:"small",style:Style$1.TEXT},{type:"large",size:1},{type:"large",size:2},{type:"large",size:3},{type:"large",size:4},{type:"stack"}];/**
     * Get the font used in a delimiter based on what kind of delimiter it is.
     * TODO(#963) Use more specific font family return type once that is introduced.
     */const delimTypeToFont=function delimTypeToFont(type){if(type.type==="small"){return "Main-Regular";}else if(type.type==="large"){return "Size"+type.size+"-Regular";}else if(type.type==="stack"){return "Size4-Regular";}else {throw new Error(`Add support for delim type '${type.type}' here.`);}};/**
     * Traverse a sequence of types of delimiters to decide what kind of delimiter
     * should be used to create a delimiter of the given height+depth.
     */const traverseSequence=function traverseSequence(delim,height,sequence,options){// Here, we choose the index we should start at in the sequences. In smaller
    // sizes (which correspond to larger numbers in style.size) we start earlier
    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
    const start=Math.min(2,3-options.style.size);for(let i=start;i<sequence.length;i++){if(sequence[i].type==="stack"){// This is always the last delimiter, so we just break the loop now.
    break;}const metrics=getMetrics(delim,delimTypeToFont(sequence[i]),"math");let heightDepth=metrics.height+metrics.depth;// Small delimiters are scaled down versions of the same font, so we
    // account for the style change size.
    if(sequence[i].type==="small"){const newOptions=options.havingBaseStyle(sequence[i].style);heightDepth*=newOptions.sizeMultiplier;}// Check if the delimiter at this size works for the given height.
    if(heightDepth>height){return sequence[i];}}// If we reached the end of the sequence, return the last sequence element.
    return sequence[sequence.length-1];};/**
     * Make a delimiter of a given height+depth, with optional centering. Here, we
     * traverse the sequences, and create a delimiter that the sequence tells us to.
     */const makeCustomSizedDelim=function makeCustomSizedDelim(delim,height,center,options,mode,classes){if(delim==="<"||delim==="\\lt"||delim==="\u27e8"){delim="\\langle";}else if(delim===">"||delim==="\\gt"||delim==="\u27e9"){delim="\\rangle";}// Decide what sequence to use
    let sequence;if(utils.contains(stackNeverDelimiters,delim)){sequence=stackNeverDelimiterSequence;}else if(utils.contains(stackLargeDelimiters,delim)){sequence=stackLargeDelimiterSequence;}else {sequence=stackAlwaysDelimiterSequence;}// Look through the sequence
    const delimType=traverseSequence(delim,height,sequence,options);// Get the delimiter from font glyphs.
    // Depending on the sequence element we decided on, call the
    // appropriate function.
    if(delimType.type==="small"){return makeSmallDelim(delim,delimType.style,center,options,mode,classes);}else if(delimType.type==="large"){return makeLargeDelim(delim,delimType.size,center,options,mode,classes);}else/* if (delimType.type === "stack") */{return makeStackedDelim(delim,height,center,options,mode,classes);}};/**
     * Make a delimiter for use with `\left` and `\right`, given a height and depth
     * of an expression that the delimiters surround.
     */const makeLeftRightDelim=function makeLeftRightDelim(delim,height,depth,options,mode,classes){// We always center \left/\right delimiters, so the axis is always shifted
    const axisHeight=options.fontMetrics().axisHeight*options.sizeMultiplier;// Taken from TeX source, tex.web, function make_left_right
    const delimiterFactor=901;const delimiterExtend=5.0/options.fontMetrics().ptPerEm;const maxDistFromAxis=Math.max(height-axisHeight,depth+axisHeight);const totalHeight=Math.max(// In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis/500*delimiterFactor,2*maxDistFromAxis-delimiterExtend);// Finally, we defer to `makeCustomSizedDelim` with our calculated total
    // height
    return makeCustomSizedDelim(delim,totalHeight,true,options,mode,classes);};var delimiter={sqrtImage:makeSqrtImage,sizedDelim:makeSizedDelim,customSizedDelim:makeCustomSizedDelim,leftRightDelim:makeLeftRightDelim};// Extra data needed for the delimiter handler down below
    const delimiterSizes={"\\bigl":{mclass:"mopen",size:1},"\\Bigl":{mclass:"mopen",size:2},"\\biggl":{mclass:"mopen",size:3},"\\Biggl":{mclass:"mopen",size:4},"\\bigr":{mclass:"mclose",size:1},"\\Bigr":{mclass:"mclose",size:2},"\\biggr":{mclass:"mclose",size:3},"\\Biggr":{mclass:"mclose",size:4},"\\bigm":{mclass:"mrel",size:1},"\\Bigm":{mclass:"mrel",size:2},"\\biggm":{mclass:"mrel",size:3},"\\Biggm":{mclass:"mrel",size:4},"\\big":{mclass:"mord",size:1},"\\Big":{mclass:"mord",size:2},"\\bigg":{mclass:"mord",size:3},"\\Bigg":{mclass:"mord",size:4}};const delimiters=["(","\\lparen",")","\\rparen","[","\\lbrack","]","\\rbrack","\\{","\\lbrace","\\}","\\rbrace","\\lfloor","\\rfloor","\u230a","\u230b","\\lceil","\\rceil","\u2308","\u2309","<",">","\\langle","\u27e8","\\rangle","\u27e9","\\lt","\\gt","\\lvert","\\rvert","\\lVert","\\rVert","\\lgroup","\\rgroup","\u27ee","\u27ef","\\lmoustache","\\rmoustache","\u23b0","\u23b1","/","\\backslash","|","\\vert","\\|","\\Vert","\\uparrow","\\Uparrow","\\downarrow","\\Downarrow","\\updownarrow","\\Updownarrow","."];// Delimiter functions
    function checkDelimiter(delim,context){const symDelim=checkSymbolNodeType(delim);if(symDelim&&utils.contains(delimiters,symDelim.text)){return symDelim;}else if(symDelim){throw new ParseError(`Invalid delimiter '${symDelim.text}' after '${context.funcName}'`,delim);}else {throw new ParseError(`Invalid delimiter type '${delim.type}'`,delim);}}defineFunction({type:"delimsizing",names:["\\bigl","\\Bigl","\\biggl","\\Biggl","\\bigr","\\Bigr","\\biggr","\\Biggr","\\bigm","\\Bigm","\\biggm","\\Biggm","\\big","\\Big","\\bigg","\\Bigg"],props:{numArgs:1},handler:(context,args)=>{const delim=checkDelimiter(args[0],context);return {type:"delimsizing",mode:context.parser.mode,size:delimiterSizes[context.funcName].size,mclass:delimiterSizes[context.funcName].mclass,delim:delim.text};},htmlBuilder:(group,options)=>{if(group.delim==="."){// Empty delimiters still count as elements, even though they don't
    // show anything.
    return buildCommon.makeSpan([group.mclass]);}// Use delimiter.sizedDelim to generate the delimiter.
    return delimiter.sizedDelim(group.delim,group.size,options,group.mode,[group.mclass]);},mathmlBuilder:group=>{const children=[];if(group.delim!=="."){children.push(makeText(group.delim,group.mode));}const node=new mathMLTree.MathNode("mo",children);if(group.mclass==="mopen"||group.mclass==="mclose"){// Only some of the delimsizing functions act as fences, and they
    // return "mopen" or "mclose" mclass.
    node.setAttribute("fence","true");}else {// Explicitly disable fencing if it's not a fence, to override the
    // defaults.
    node.setAttribute("fence","false");}return node;}});function assertParsed(group){if(!group.body){throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");}}defineFunction({type:"leftright-right",names:["\\right"],props:{numArgs:1},handler:(context,args)=>{// \left case below triggers parsing of \right in
    //   `const right = parser.parseFunction();`
    // uses this return value.
    const color=context.parser.gullet.macros.get("\\current@color");if(color&&typeof color!=="string"){throw new ParseError("\\current@color set to non-string in \\right");}return {type:"leftright-right",mode:context.parser.mode,delim:checkDelimiter(args[0],context).text,color// undefined if not set via \color
    };}});defineFunction({type:"leftright",names:["\\left"],props:{numArgs:1},handler:(context,args)=>{const delim=checkDelimiter(args[0],context);const parser=context.parser;// Parse out the implicit body
    ++parser.leftrightDepth;// parseExpression stops before '\\right'
    const body=parser.parseExpression(false);--parser.leftrightDepth;// Check the next token
    parser.expect("\\right",false);const right=assertNodeType(parser.parseFunction(),"leftright-right");return {type:"leftright",mode:parser.mode,body,left:delim.text,right:right.delim,rightColor:right.color};},htmlBuilder:(group,options)=>{assertParsed(group);// Build the inner expression
    const inner=buildExpression(group.body,options,true,["mopen","mclose"]);let innerHeight=0;let innerDepth=0;let hadMiddle=false;// Calculate its height and depth
    for(let i=0;i<inner.length;i++){// Property `isMiddle` not defined on `span`. See comment in
    // "middle"'s htmlBuilder.
    // $FlowFixMe
    if(inner[i].isMiddle){hadMiddle=true;}else {innerHeight=Math.max(inner[i].height,innerHeight);innerDepth=Math.max(inner[i].depth,innerDepth);}}// The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.
    innerHeight*=options.sizeMultiplier;innerDepth*=options.sizeMultiplier;let leftDelim;if(group.left==="."){// Empty delimiters in \left and \right make null delimiter spaces.
    leftDelim=makeNullDelimiter(options,["mopen"]);}else {// Otherwise, use leftRightDelim to generate the correct sized
    // delimiter.
    leftDelim=delimiter.leftRightDelim(group.left,innerHeight,innerDepth,options,group.mode,["mopen"]);}// Add it to the beginning of the expression
    inner.unshift(leftDelim);// Handle middle delimiters
    if(hadMiddle){for(let i=1;i<inner.length;i++){const middleDelim=inner[i];// Property `isMiddle` not defined on `span`. See comment in
    // "middle"'s htmlBuilder.
    // $FlowFixMe
    const isMiddle=middleDelim.isMiddle;if(isMiddle){// Apply the options that were active when \middle was called
    inner[i]=delimiter.leftRightDelim(isMiddle.delim,innerHeight,innerDepth,isMiddle.options,group.mode,[]);}}}let rightDelim;// Same for the right delimiter, but using color specified by \color
    if(group.right==="."){rightDelim=makeNullDelimiter(options,["mclose"]);}else {const colorOptions=group.rightColor?options.withColor(group.rightColor):options;rightDelim=delimiter.leftRightDelim(group.right,innerHeight,innerDepth,colorOptions,group.mode,["mclose"]);}// Add it to the end of the expression.
    inner.push(rightDelim);return buildCommon.makeSpan(["minner"],inner,options);},mathmlBuilder:(group,options)=>{assertParsed(group);const inner=buildExpression$1(group.body,options);if(group.left!=="."){const leftNode=new mathMLTree.MathNode("mo",[makeText(group.left,group.mode)]);leftNode.setAttribute("fence","true");inner.unshift(leftNode);}if(group.right!=="."){const rightNode=new mathMLTree.MathNode("mo",[makeText(group.right,group.mode)]);rightNode.setAttribute("fence","true");if(group.rightColor){rightNode.setAttribute("mathcolor",group.rightColor);}inner.push(rightNode);}return makeRow(inner);}});defineFunction({type:"middle",names:["\\middle"],props:{numArgs:1},handler:(context,args)=>{const delim=checkDelimiter(args[0],context);if(!context.parser.leftrightDepth){throw new ParseError("\\middle without preceding \\left",delim);}return {type:"middle",mode:context.parser.mode,delim:delim.text};},htmlBuilder:(group,options)=>{let middleDelim;if(group.delim==="."){middleDelim=makeNullDelimiter(options,[]);}else {middleDelim=delimiter.sizedDelim(group.delim,1,options,group.mode,[]);const isMiddle={delim:group.delim,options};// Property `isMiddle` not defined on `span`. It is only used in
    // this file above.
    // TODO: Fix this violation of the `span` type and possibly rename
    // things since `isMiddle` sounds like a boolean, but is a struct.
    // $FlowFixMe
    middleDelim.isMiddle=isMiddle;}return middleDelim;},mathmlBuilder:(group,options)=>{// A Firefox \middle will strech a character vertically only if it
    // is in the fence part of the operator dictionary at:
    // https://www.w3.org/TR/MathML3/appendixc.html.
    // So we need to avoid U+2223 and use plain "|" instead.
    const textNode=group.delim==="\\vert"||group.delim==="|"?makeText("|","text"):makeText(group.delim,group.mode);const middleNode=new mathMLTree.MathNode("mo",[textNode]);middleNode.setAttribute("fence","true");// MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.
    middleNode.setAttribute("lspace","0.05em");middleNode.setAttribute("rspace","0.05em");return middleNode;}});const htmlBuilder$2=(group,options)=>{// \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox
    // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.
    const inner=buildCommon.wrapFragment(buildGroup(group.body,options),options);const label=group.label.substr(1);const scale=options.sizeMultiplier;let img;let imgShift=0;// In the LaTeX cancel package, line geometry is slightly different
    // depending on whether the subject is wider than it is tall, or vice versa.
    // We don't know the width of a group, so as a proxy, we test if
    // the subject is a single character. This captures most of the
    // subjects that should get the "tall" treatment.
    const isSingleChar=utils.isCharacterBox(group.body);if(label==="sout"){img=buildCommon.makeSpan(["stretchy","sout"]);img.height=options.fontMetrics().defaultRuleThickness/scale;imgShift=-0.5*options.fontMetrics().xHeight;}else {// Add horizontal padding
    if(/cancel/.test(label)){if(!isSingleChar){inner.classes.push("cancel-pad");}}else {inner.classes.push("boxpad");}// Add vertical padding
    let vertPad=0;let ruleThickness=0;// ref: cancel package: \advance\totalheight2\p@ % "+2"
    if(/box/.test(label)){ruleThickness=Math.max(options.fontMetrics().fboxrule,// default
    options.minRuleThickness// User override.
    );vertPad=options.fontMetrics().fboxsep+(label==="colorbox"?0:ruleThickness);}else {vertPad=isSingleChar?0.2:0;}img=stretchy.encloseSpan(inner,label,vertPad,options);if(/fbox|boxed|fcolorbox/.test(label)){img.style.borderStyle="solid";img.style.borderWidth=`${ruleThickness}em`;}imgShift=inner.depth+vertPad;if(group.backgroundColor){img.style.backgroundColor=group.backgroundColor;if(group.borderColor){img.style.borderColor=group.borderColor;}}}let vlist;if(group.backgroundColor){vlist=buildCommon.makeVList({positionType:"individualShift",children:[// Put the color background behind inner;
    {type:"elem",elem:img,shift:imgShift},{type:"elem",elem:inner,shift:0}]},options);}else {vlist=buildCommon.makeVList({positionType:"individualShift",children:[// Write the \cancel stroke on top of inner.
    {type:"elem",elem:inner,shift:0},{type:"elem",elem:img,shift:imgShift,wrapperClasses:/cancel/.test(label)?["svg-align"]:[]}]},options);}if(/cancel/.test(label)){// The cancel package documentation says that cancel lines add their height
    // to the expression, but tests show that isn't how it actually works.
    vlist.height=inner.height;vlist.depth=inner.depth;}if(/cancel/.test(label)&&!isSingleChar){// cancel does not create horiz space for its line extension.
    return buildCommon.makeSpan(["mord","cancel-lap"],[vlist],options);}else {return buildCommon.makeSpan(["mord"],[vlist],options);}};const mathmlBuilder$2=(group,options)=>{let fboxsep=0;const node=new mathMLTree.MathNode(group.label.indexOf("colorbox")>-1?"mpadded":"menclose",[buildGroup$1(group.body,options)]);switch(group.label){case"\\cancel":node.setAttribute("notation","updiagonalstrike");break;case"\\bcancel":node.setAttribute("notation","downdiagonalstrike");break;case"\\sout":node.setAttribute("notation","horizontalstrike");break;case"\\fbox":node.setAttribute("notation","box");break;case"\\fcolorbox":case"\\colorbox":// <menclose> doesn't have a good notation option. So use <mpadded>
    // instead. Set some attributes that come included with <menclose>.
    fboxsep=options.fontMetrics().fboxsep*options.fontMetrics().ptPerEm;node.setAttribute("width",`+${2*fboxsep}pt`);node.setAttribute("height",`+${2*fboxsep}pt`);node.setAttribute("lspace",`${fboxsep}pt`);//
    node.setAttribute("voffset",`${fboxsep}pt`);if(group.label==="\\fcolorbox"){const thk=Math.max(options.fontMetrics().fboxrule,// default
    options.minRuleThickness// user override
    );node.setAttribute("style","border: "+thk+"em solid "+String(group.borderColor));}break;case"\\xcancel":node.setAttribute("notation","updiagonalstrike downdiagonalstrike");break;}if(group.backgroundColor){node.setAttribute("mathbackground",group.backgroundColor);}return node;};defineFunction({type:"enclose",names:["\\colorbox"],props:{numArgs:2,allowedInText:true,greediness:3,argTypes:["color","text"]},handler(_ref,args,optArgs){let parser=_ref.parser,funcName=_ref.funcName;const color=assertNodeType(args[0],"color-token").color;const body=args[1];return {type:"enclose",mode:parser.mode,label:funcName,backgroundColor:color,body};},htmlBuilder:htmlBuilder$2,mathmlBuilder:mathmlBuilder$2});defineFunction({type:"enclose",names:["\\fcolorbox"],props:{numArgs:3,allowedInText:true,greediness:3,argTypes:["color","color","text"]},handler(_ref2,args,optArgs){let parser=_ref2.parser,funcName=_ref2.funcName;const borderColor=assertNodeType(args[0],"color-token").color;const backgroundColor=assertNodeType(args[1],"color-token").color;const body=args[2];return {type:"enclose",mode:parser.mode,label:funcName,backgroundColor,borderColor,body};},htmlBuilder:htmlBuilder$2,mathmlBuilder:mathmlBuilder$2});defineFunction({type:"enclose",names:["\\fbox"],props:{numArgs:1,argTypes:["hbox"],allowedInText:true},handler(_ref3,args){let parser=_ref3.parser;return {type:"enclose",mode:parser.mode,label:"\\fbox",body:args[0]};}});defineFunction({type:"enclose",names:["\\cancel","\\bcancel","\\xcancel","\\sout"],props:{numArgs:1},handler(_ref4,args,optArgs){let parser=_ref4.parser,funcName=_ref4.funcName;const body=args[0];return {type:"enclose",mode:parser.mode,label:funcName,body};},htmlBuilder:htmlBuilder$2,mathmlBuilder:mathmlBuilder$2});/**
     * All registered environments.
     * `environments.js` exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary via `environments.js`.
     */const _environments={};function defineEnvironment(_ref){let type=_ref.type,names=_ref.names,props=_ref.props,handler=_ref.handler,htmlBuilder=_ref.htmlBuilder,mathmlBuilder=_ref.mathmlBuilder;// Set default values of environments.
    const data={type,numArgs:props.numArgs||0,greediness:1,allowedInText:false,numOptionalArgs:0,handler};for(let i=0;i<names.length;++i){// TODO: The value type of _environments should be a type union of all
    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
    // an existential type.
    // $FlowFixMe
    _environments[names[i]]=data;}if(htmlBuilder){_htmlGroupBuilders[type]=htmlBuilder;}if(mathmlBuilder){_mathmlGroupBuilders[type]=mathmlBuilder;}}function getHLines(parser){// Return an array. The array length = number of hlines.
    // Each element in the array tells if the line is dashed.
    const hlineInfo=[];parser.consumeSpaces();let nxt=parser.fetch().text;while(nxt==="\\hline"||nxt==="\\hdashline"){parser.consume();hlineInfo.push(nxt==="\\hdashline");parser.consumeSpaces();nxt=parser.fetch().text;}return hlineInfo;}/**
     * Parse the body of the environment, with rows delimited by \\ and
     * columns delimited by &, and create a nested list in row-major order
     * with one group per cell.  If given an optional argument style
     * ("text", "display", etc.), then each cell is cast into that style.
     */function parseArray(parser,_ref,style){let hskipBeforeAndAfter=_ref.hskipBeforeAndAfter,addJot=_ref.addJot,cols=_ref.cols,arraystretch=_ref.arraystretch,colSeparationType=_ref.colSeparationType;// Parse body of array with \\ temporarily mapped to \cr
    parser.gullet.beginGroup();parser.gullet.macros.set("\\\\","\\cr");// Get current arraystretch if it's not set by the environment
    if(!arraystretch){const stretch=parser.gullet.expandMacroAsText("\\arraystretch");if(stretch==null){// Default \arraystretch from lttab.dtx
    arraystretch=1;}else {arraystretch=parseFloat(stretch);if(!arraystretch||arraystretch<0){throw new ParseError(`Invalid \\arraystretch: ${stretch}`);}}}// Start group for first cell
    parser.gullet.beginGroup();let row=[];const body=[row];const rowGaps=[];const hLinesBeforeRow=[];// Test for \hline at the top of the array.
    hLinesBeforeRow.push(getHLines(parser));while(true){// eslint-disable-line no-constant-condition
    // Parse each cell in its own group (namespace)
    let cell=parser.parseExpression(false,"\\cr");parser.gullet.endGroup();parser.gullet.beginGroup();cell={type:"ordgroup",mode:parser.mode,body:cell};if(style){cell={type:"styling",mode:parser.mode,style,body:[cell]};}row.push(cell);const next=parser.fetch().text;if(next==="&"){parser.consume();}else if(next==="\\end"){// Arrays terminate newlines with `\crcr` which consumes a `\cr` if
    // the last line is empty.
    // NOTE: Currently, `cell` is the last item added into `row`.
    if(row.length===1&&cell.type==="styling"&&cell.body[0].body.length===0){body.pop();}if(hLinesBeforeRow.length<body.length+1){hLinesBeforeRow.push([]);}break;}else if(next==="\\cr"){const cr=assertNodeType(parser.parseFunction(),"cr");rowGaps.push(cr.size);// check for \hline(s) following the row separator
    hLinesBeforeRow.push(getHLines(parser));row=[];body.push(row);}else {throw new ParseError("Expected & or \\\\ or \\cr or \\end",parser.nextToken);}}// End cell group
    parser.gullet.endGroup();// End array group defining \\
    parser.gullet.endGroup();return {type:"array",mode:parser.mode,addJot,arraystretch,body,cols,rowGaps,hskipBeforeAndAfter,hLinesBeforeRow,colSeparationType};}// Decides on a style for cells in an array according to whether the given
    // environment name starts with the letter 'd'.
    function dCellStyle(envName){if(envName.substr(0,1)==="d"){return "display";}else {return "text";}}const htmlBuilder$3=function htmlBuilder(group,options){let r;let c;const nr=group.body.length;const hLinesBeforeRow=group.hLinesBeforeRow;let nc=0;let body=new Array(nr);const hlines=[];const ruleThickness=Math.max(// From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options.fontMetrics().arrayRuleWidth,options.minRuleThickness// User override.
    );// Horizontal spacing
    const pt=1/options.fontMetrics().ptPerEm;let arraycolsep=5*pt;// default value, i.e. \arraycolsep in article.cls
    if(group.colSeparationType&&group.colSeparationType==="small"){// We're in a {smallmatrix}. Default column space is \thickspace,
    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.
    // But that needs adjustment because LaTeX applies \scriptstyle to the
    // entire array, including the colspace, but this function applies
    // \scriptstyle only inside each element.
    const localMultiplier=options.havingStyle(Style$1.SCRIPT).sizeMultiplier;arraycolsep=0.2778*(localMultiplier/options.sizeMultiplier);}// Vertical spacing
    const baselineskip=12*pt;// see size10.clo
    // Default \jot from ltmath.dtx
    // TODO(edemaine): allow overriding \jot via \setlength (#687)
    const jot=3*pt;const arrayskip=group.arraystretch*baselineskip;const arstrutHeight=0.7*arrayskip;// \strutbox in ltfsstrc.dtx and
    const arstrutDepth=0.3*arrayskip;// \@arstrutbox in lttab.dtx
    let totalHeight=0;// Set a position for \hline(s) at the top of the array, if any.
    function setHLinePos(hlinesInGap){for(let i=0;i<hlinesInGap.length;++i){if(i>0){totalHeight+=0.25;}hlines.push({pos:totalHeight,isDashed:hlinesInGap[i]});}}setHLinePos(hLinesBeforeRow[0]);for(r=0;r<group.body.length;++r){const inrow=group.body[r];let height=arstrutHeight;// \@array adds an \@arstrut
    let depth=arstrutDepth;// to each tow (via the template)
    if(nc<inrow.length){nc=inrow.length;}const outrow=new Array(inrow.length);for(c=0;c<inrow.length;++c){const elt=buildGroup(inrow[c],options);if(depth<elt.depth){depth=elt.depth;}if(height<elt.height){height=elt.height;}outrow[c]=elt;}const rowGap=group.rowGaps[r];let gap=0;if(rowGap){gap=calculateSize(rowGap,options);if(gap>0){// \@argarraycr
    gap+=arstrutDepth;if(depth<gap){depth=gap;// \@xargarraycr
    }gap=0;}}// In AMS multiline environments such as aligned and gathered, rows
    // correspond to lines that have additional \jot added to the
    // \baselineskip via \openup.
    if(group.addJot){depth+=jot;}outrow.height=height;outrow.depth=depth;totalHeight+=height;outrow.pos=totalHeight;totalHeight+=depth+gap;// \@yargarraycr
    body[r]=outrow;// Set a position for \hline(s), if any.
    setHLinePos(hLinesBeforeRow[r+1]);}const offset=totalHeight/2+options.fontMetrics().axisHeight;const colDescriptions=group.cols||[];const cols=[];let colSep;let colDescrNum;for(c=0,colDescrNum=0;// Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c<nc||colDescrNum<colDescriptions.length;++c,++colDescrNum){let colDescr=colDescriptions[colDescrNum]||{};let firstSeparator=true;while(colDescr.type==="separator"){// If there is more than one separator in a row, add a space
    // between them.
    if(!firstSeparator){colSep=buildCommon.makeSpan(["arraycolsep"],[]);colSep.style.width=options.fontMetrics().doubleRuleSep+"em";cols.push(colSep);}if(colDescr.separator==="|"||colDescr.separator===":"){const lineType=colDescr.separator==="|"?"solid":"dashed";const separator=buildCommon.makeSpan(["vertical-separator"],[],options);separator.style.height=totalHeight+"em";separator.style.borderRightWidth=`${ruleThickness}em`;separator.style.borderRightStyle=lineType;separator.style.margin=`0 -${ruleThickness/2}em`;separator.style.verticalAlign=-(totalHeight-offset)+"em";cols.push(separator);}else {throw new ParseError("Invalid separator type: "+colDescr.separator);}colDescrNum++;colDescr=colDescriptions[colDescrNum]||{};firstSeparator=false;}if(c>=nc){continue;}let sepwidth;if(c>0||group.hskipBeforeAndAfter){sepwidth=utils.deflt(colDescr.pregap,arraycolsep);if(sepwidth!==0){colSep=buildCommon.makeSpan(["arraycolsep"],[]);colSep.style.width=sepwidth+"em";cols.push(colSep);}}let col=[];for(r=0;r<nr;++r){const row=body[r];const elem=row[c];if(!elem){continue;}const shift=row.pos-offset;elem.depth=row.depth;elem.height=row.height;col.push({type:"elem",elem:elem,shift:shift});}col=buildCommon.makeVList({positionType:"individualShift",children:col},options);col=buildCommon.makeSpan(["col-align-"+(colDescr.align||"c")],[col]);cols.push(col);if(c<nc-1||group.hskipBeforeAndAfter){sepwidth=utils.deflt(colDescr.postgap,arraycolsep);if(sepwidth!==0){colSep=buildCommon.makeSpan(["arraycolsep"],[]);colSep.style.width=sepwidth+"em";cols.push(colSep);}}}body=buildCommon.makeSpan(["mtable"],cols);// Add \hline(s), if any.
    if(hlines.length>0){const line=buildCommon.makeLineSpan("hline",options,ruleThickness);const dashes=buildCommon.makeLineSpan("hdashline",options,ruleThickness);const vListElems=[{type:"elem",elem:body,shift:0}];while(hlines.length>0){const hline=hlines.pop();const lineShift=hline.pos-offset;if(hline.isDashed){vListElems.push({type:"elem",elem:dashes,shift:lineShift});}else {vListElems.push({type:"elem",elem:line,shift:lineShift});}}body=buildCommon.makeVList({positionType:"individualShift",children:vListElems},options);}return buildCommon.makeSpan(["mord"],[body],options);};const alignMap={c:"center ",l:"left ",r:"right "};const mathmlBuilder$3=function mathmlBuilder(group,options){let table=new mathMLTree.MathNode("mtable",group.body.map(function(row){return new mathMLTree.MathNode("mtr",row.map(function(cell){return new mathMLTree.MathNode("mtd",[buildGroup$1(cell,options)]);}));}));// Set column alignment, row spacing, column spacing, and
    // array lines by setting attributes on the table element.
    // Set the row spacing. In MathML, we specify a gap distance.
    // We do not use rowGap[] because MathML automatically increases
    // cell height with the height/depth of the element content.
    // LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
    // We simulate this by adding (arraystretch - 1)em to the gap. This
    // does a reasonable job of adjusting arrays containing 1 em tall content.
    // The 0.16 and 0.09 values are found emprically. They produce an array
    // similar to LaTeX and in which content does not interfere with \hines.
    const gap=group.arraystretch===0.5?0.1// {smallmatrix}, {subarray}
    :0.16+group.arraystretch-1+(group.addJot?0.09:0);table.setAttribute("rowspacing",gap+"em");// MathML table lines go only between cells.
    // To place a line on an edge we'll use <menclose>, if necessary.
    let menclose="";let align="";if(group.cols&&group.cols.length>0){// Find column alignment, column spacing, and  vertical lines.
    const cols=group.cols;let columnLines="";let prevTypeWasAlign=false;let iStart=0;let iEnd=cols.length;if(cols[0].type==="separator"){menclose+="top ";iStart=1;}if(cols[cols.length-1].type==="separator"){menclose+="bottom ";iEnd-=1;}for(let i=iStart;i<iEnd;i++){if(cols[i].type==="align"){align+=alignMap[cols[i].align];if(prevTypeWasAlign){columnLines+="none ";}prevTypeWasAlign=true;}else if(cols[i].type==="separator"){// MathML accepts only single lines between cells.
    // So we read only the first of consecutive separators.
    if(prevTypeWasAlign){columnLines+=cols[i].separator==="|"?"solid ":"dashed ";prevTypeWasAlign=false;}}}table.setAttribute("columnalign",align.trim());if(/[sd]/.test(columnLines)){table.setAttribute("columnlines",columnLines.trim());}}// Set column spacing.
    if(group.colSeparationType==="align"){const cols=group.cols||[];let spacing="";for(let i=1;i<cols.length;i++){spacing+=i%2?"0em ":"1em ";}table.setAttribute("columnspacing",spacing.trim());}else if(group.colSeparationType==="alignat"){table.setAttribute("columnspacing","0em");}else if(group.colSeparationType==="small"){table.setAttribute("columnspacing","0.2778em");}else {table.setAttribute("columnspacing","1em");}// Address \hline and \hdashline
    let rowLines="";const hlines=group.hLinesBeforeRow;menclose+=hlines[0].length>0?"left ":"";menclose+=hlines[hlines.length-1].length>0?"right ":"";for(let i=1;i<hlines.length-1;i++){rowLines+=hlines[i].length===0?"none "// MathML accepts only a single line between rows. Read one element.
    :hlines[i][0]?"dashed ":"solid ";}if(/[sd]/.test(rowLines)){table.setAttribute("rowlines",rowLines.trim());}if(menclose!==""){table=new mathMLTree.MathNode("menclose",[table]);table.setAttribute("notation",menclose.trim());}if(group.arraystretch&&group.arraystretch<1){// A small array. Wrap in scriptstyle so row gap is not too large.
    table=new mathMLTree.MathNode("mstyle",[table]);table.setAttribute("scriptlevel","1");}return table;};// Convenience function for aligned and alignedat environments.
    const alignedHandler=function alignedHandler(context,args){const cols=[];const res=parseArray(context.parser,{cols,addJot:true},"display");// Determining number of columns.
    // 1. If the first argument is given, we use it as a number of columns,
    //    and makes sure that each row doesn't exceed that number.
    // 2. Otherwise, just count number of columns = maximum number
    //    of cells in each row ("aligned" mode -- isAligned will be true).
    //
    // At the same time, prepend empty group {} at beginning of every second
    // cell in each row (starting with second cell) so that operators become
    // binary.  This behavior is implemented in amsmath's \start@aligned.
    let numMaths;let numCols=0;const emptyGroup={type:"ordgroup",mode:context.mode,body:[]};if(args[0]&&args[0].type==="ordgroup"){let arg0="";for(let i=0;i<args[0].body.length;i++){const textord=assertNodeType(args[0].body[i],"textord");arg0+=textord.text;}numMaths=Number(arg0);numCols=numMaths*2;}const isAligned=!numCols;res.body.forEach(function(row){for(let i=1;i<row.length;i+=2){// Modify ordgroup node within styling node
    const styling=assertNodeType(row[i],"styling");const ordgroup=assertNodeType(styling.body[0],"ordgroup");ordgroup.body.unshift(emptyGroup);}if(!isAligned){// Case 1
    const curMaths=row.length/2;if(numMaths<curMaths){throw new ParseError("Too many math in a row: "+`expected ${numMaths}, but got ${curMaths}`,row[0]);}}else if(numCols<row.length){// Case 2
    numCols=row.length;}});// Adjusting alignment.
    // In aligned mode, we add one \qquad between columns;
    // otherwise we add nothing.
    for(let i=0;i<numCols;++i){let align="r";let pregap=0;if(i%2===1){align="l";}else if(i>0&&isAligned){// "aligned" mode.
    pregap=1;// add one \quad
    }cols[i]={type:"align",align:align,pregap:pregap,postgap:0};}res.colSeparationType=isAligned?"align":"alignat";return res;};// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
    // is part of the source2e.pdf file of LaTeX2e source documentation.
    // {darray} is an {array} environment where cells are set in \displaystyle,
    // as defined in nccmath.sty.
    defineEnvironment({type:"array",names:["array","darray"],props:{numArgs:1},handler(context,args){// Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    const symNode=checkSymbolNodeType(args[0]);const colalign=symNode?[args[0]]:assertNodeType(args[0],"ordgroup").body;const cols=colalign.map(function(nde){const node=assertSymbolNodeType(nde);const ca=node.text;if("lcr".indexOf(ca)!==-1){return {type:"align",align:ca};}else if(ca==="|"){return {type:"separator",separator:"|"};}else if(ca===":"){return {type:"separator",separator:":"};}throw new ParseError("Unknown column alignment: "+ca,nde);});const res={cols,hskipBeforeAndAfter:true// \@preamble in lttab.dtx
    };return parseArray(context.parser,res,dCellStyle(context.envName));},htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});// The matrix environments of amsmath builds on the array environment
    // of LaTeX, which is discussed above.
    defineEnvironment({type:"array",names:["matrix","pmatrix","bmatrix","Bmatrix","vmatrix","Vmatrix"],props:{numArgs:0},handler(context){const delimiters={"matrix":null,"pmatrix":["(",")"],"bmatrix":["[","]"],"Bmatrix":["\\{","\\}"],"vmatrix":["|","|"],"Vmatrix":["\\Vert","\\Vert"]}[context.envName];// \hskip -\arraycolsep in amsmath
    const payload={hskipBeforeAndAfter:false};const res=parseArray(context.parser,payload,dCellStyle(context.envName));return delimiters?{type:"leftright",mode:context.mode,body:[res],left:delimiters[0],right:delimiters[1],rightColor:undefined// \right uninfluenced by \color in array
    }:res;},htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});defineEnvironment({type:"array",names:["smallmatrix"],props:{numArgs:0},handler(context){const payload={arraystretch:0.5};const res=parseArray(context.parser,payload,"script");res.colSeparationType="small";return res;},htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});defineEnvironment({type:"array",names:["subarray"],props:{numArgs:1},handler(context,args){// Parsing of {subarray} is similar to {array}
    const symNode=checkSymbolNodeType(args[0]);const colalign=symNode?[args[0]]:assertNodeType(args[0],"ordgroup").body;const cols=colalign.map(function(nde){const node=assertSymbolNodeType(nde);const ca=node.text;// {subarray} only recognizes "l" & "c"
    if("lc".indexOf(ca)!==-1){return {type:"align",align:ca};}throw new ParseError("Unknown column alignment: "+ca,nde);});if(cols.length>1){throw new ParseError("{subarray} can contain only one column");}let res={cols,hskipBeforeAndAfter:false,arraystretch:0.5};res=parseArray(context.parser,res,"script");if(res.body.length>0&&res.body[0].length>1){throw new ParseError("{subarray} can contain only one column");}return res;},htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});// A cases environment (in amsmath.sty) is almost equivalent to
    // \def\arraystretch{1.2}%
    // \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
    // {dcases} is a {cases} environment where cells are set in \displaystyle,
    // as defined in mathtools.sty.
    // {rcases} is another mathtools environment. It's brace is on the right side.
    defineEnvironment({type:"array",names:["cases","dcases","rcases","drcases"],props:{numArgs:0},handler(context){const payload={arraystretch:1.2,cols:[{type:"align",align:"l",pregap:0,// TODO(kevinb) get the current style.
    // For now we use the metrics for TEXT style which is what we were
    // doing before.  Before attempting to get the current style we
    // should look at TeX's behavior especially for \over and matrices.
    postgap:1.0/* 1em quad */},{type:"align",align:"l",pregap:0,postgap:0}]};const res=parseArray(context.parser,payload,dCellStyle(context.envName));return {type:"leftright",mode:context.mode,body:[res],left:context.envName.indexOf("r")>-1?".":"\\{",right:context.envName.indexOf("r")>-1?"\\}":".",rightColor:undefined};},htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});// An aligned environment is like the align* environment
    // except it operates within math mode.
    // Note that we assume \nomallineskiplimit to be zero,
    // so that \strut@ is the same as \strut.
    defineEnvironment({type:"array",names:["aligned"],props:{numArgs:0},handler:alignedHandler,htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});// A gathered environment is like an array environment with one centered
    // column, but where rows are considered lines so get \jot line spacing
    // and contents are set in \displaystyle.
    defineEnvironment({type:"array",names:["gathered"],props:{numArgs:0},handler(context){const res={cols:[{type:"align",align:"c"}],addJot:true};return parseArray(context.parser,res,"display");},htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});// alignat environment is like an align environment, but one must explicitly
    // specify maximum number of columns in each row, and can adjust spacing between
    // each columns.
    defineEnvironment({type:"array",names:["alignedat"],// One for numbered and for unnumbered;
    // but, KaTeX doesn't supports math numbering yet,
    // they make no difference for now.
    props:{numArgs:1},handler:alignedHandler,htmlBuilder:htmlBuilder$3,mathmlBuilder:mathmlBuilder$3});// Catch \hline outside array environment
    defineFunction({type:"text",// Doesn't matter what this is.
    names:["\\hline","\\hdashline"],props:{numArgs:0,allowedInText:true,allowedInMath:true},handler(context,args){throw new ParseError(`${context.funcName} valid only within array environment`);}});const environments=_environments;// defineEnvironment definitions.
    // $FlowFixMe, "environment" handler returns an environment ParseNode
    defineFunction({type:"environment",names:["\\begin","\\end"],props:{numArgs:1,argTypes:["text"]},handler(_ref,args){let parser=_ref.parser,funcName=_ref.funcName;const nameGroup=args[0];if(nameGroup.type!=="ordgroup"){throw new ParseError("Invalid environment name",nameGroup);}let envName="";for(let i=0;i<nameGroup.body.length;++i){envName+=assertNodeType(nameGroup.body[i],"textord").text;}if(funcName==="\\begin"){// begin...end is similar to left...right
    if(!environments.hasOwnProperty(envName)){throw new ParseError("No such environment: "+envName,nameGroup);}// Build the environment object. Arguments and other information will
    // be made available to the begin and end methods using properties.
    const env=environments[envName];const _parser$parseArgument=parser.parseArguments("\\begin{"+envName+"}",env),args=_parser$parseArgument.args,optArgs=_parser$parseArgument.optArgs;const context={mode:parser.mode,envName,parser};const result=env.handler(context,args,optArgs);parser.expect("\\end",false);const endNameToken=parser.nextToken;const end=assertNodeType(parser.parseFunction(),"environment");if(end.name!==envName){throw new ParseError(`Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`,endNameToken);}return result;}return {type:"environment",mode:parser.mode,name:envName,nameGroup};}});const makeSpan$2=buildCommon.makeSpan;function htmlBuilder$4(group,options){const elements=buildExpression(group.body,options,true);return makeSpan$2([group.mclass],elements,options);}function mathmlBuilder$4(group,options){let node;const inner=buildExpression$1(group.body,options);if(group.mclass==="minner"){return mathMLTree.newDocumentFragment(inner);}else if(group.mclass==="mord"){if(group.isCharacterBox){node=inner[0];node.type="mi";}else {node=new mathMLTree.MathNode("mi",inner);}}else {if(group.isCharacterBox){node=inner[0];node.type="mo";}else {node=new mathMLTree.MathNode("mo",inner);}// Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.
    if(group.mclass==="mbin"){node.attributes.lspace="0.22em";// medium space
    node.attributes.rspace="0.22em";}else if(group.mclass==="mpunct"){node.attributes.lspace="0em";node.attributes.rspace="0.17em";// thinspace
    }else if(group.mclass==="mopen"||group.mclass==="mclose"){node.attributes.lspace="0em";node.attributes.rspace="0em";}// MathML <mo> default space is 5/18 em, so <mrel> needs no action.
    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo
    }return node;}// Math class commands except \mathop
    defineFunction({type:"mclass",names:["\\mathord","\\mathbin","\\mathrel","\\mathopen","\\mathclose","\\mathpunct","\\mathinner"],props:{numArgs:1},handler(_ref,args){let parser=_ref.parser,funcName=_ref.funcName;const body=args[0];return {type:"mclass",mode:parser.mode,mclass:"m"+funcName.substr(5),// TODO(kevinb): don't prefix with 'm'
    body:ordargument(body),isCharacterBox:utils.isCharacterBox(body)};},htmlBuilder:htmlBuilder$4,mathmlBuilder:mathmlBuilder$4});const binrelClass=arg=>{// \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
    // (by rendering separately and with {}s before and after, and measuring
    // the change in spacing).  We'll do roughly the same by detecting the
    // atom type directly.
    const atom=arg.type==="ordgroup"&&arg.body.length?arg.body[0]:arg;if(atom.type==="atom"&&(atom.family==="bin"||atom.family==="rel")){return "m"+atom.family;}else {return "mord";}};// \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
    // This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
    defineFunction({type:"mclass",names:["\\@binrel"],props:{numArgs:2},handler(_ref2,args){let parser=_ref2.parser;return {type:"mclass",mode:parser.mode,mclass:binrelClass(args[0]),body:[args[1]],isCharacterBox:utils.isCharacterBox(args[1])};}});// Build a relation or stacked op by placing one symbol on top of another
    defineFunction({type:"mclass",names:["\\stackrel","\\overset","\\underset"],props:{numArgs:2},handler(_ref3,args){let parser=_ref3.parser,funcName=_ref3.funcName;const baseArg=args[1];const shiftedArg=args[0];let mclass;if(funcName!=="\\stackrel"){// LaTeX applies \binrel spacing to \overset and \underset.
    mclass=binrelClass(baseArg);}else {mclass="mrel";// for \stackrel
    }const baseOp={type:"op",mode:baseArg.mode,limits:true,alwaysHandleSupSub:true,parentIsSupSub:false,symbol:false,suppressBaseShift:funcName!=="\\stackrel",body:ordargument(baseArg)};const supsub={type:"supsub",mode:shiftedArg.mode,base:baseOp,sup:funcName==="\\underset"?null:shiftedArg,sub:funcName==="\\underset"?shiftedArg:null};return {type:"mclass",mode:parser.mode,mclass,body:[supsub],isCharacterBox:utils.isCharacterBox(supsub)};},htmlBuilder:htmlBuilder$4,mathmlBuilder:mathmlBuilder$4});// TODO(kevinb): implement \\sl and \\sc
    const htmlBuilder$5=(group,options)=>{const font=group.font;const newOptions=options.withFont(font);return buildGroup(group.body,newOptions);};const mathmlBuilder$5=(group,options)=>{const font=group.font;const newOptions=options.withFont(font);return buildGroup$1(group.body,newOptions);};const fontAliases={"\\Bbb":"\\mathbb","\\bold":"\\mathbf","\\frak":"\\mathfrak","\\bm":"\\boldsymbol"};defineFunction({type:"font",names:[// styles, except \boldsymbol defined below
    "\\mathrm","\\mathit","\\mathbf","\\mathnormal",// families
    "\\mathbb","\\mathcal","\\mathfrak","\\mathscr","\\mathsf","\\mathtt",// aliases, except \bm defined below
    "\\Bbb","\\bold","\\frak"],props:{numArgs:1,greediness:2},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;const body=args[0];let func=funcName;if(func in fontAliases){func=fontAliases[func];}return {type:"font",mode:parser.mode,font:func.slice(1),body};},htmlBuilder:htmlBuilder$5,mathmlBuilder:mathmlBuilder$5});defineFunction({type:"mclass",names:["\\boldsymbol","\\bm"],props:{numArgs:1,greediness:2},handler:(_ref2,args)=>{let parser=_ref2.parser;const body=args[0];const isCharacterBox=utils.isCharacterBox(body);// amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
    // argument's bin|rel|ord status
    return {type:"mclass",mode:parser.mode,mclass:binrelClass(body),body:[{type:"font",mode:parser.mode,font:"boldsymbol",body}],isCharacterBox:isCharacterBox};}});// Old font changing functions
    defineFunction({type:"font",names:["\\rm","\\sf","\\tt","\\bf","\\it","\\cal"],props:{numArgs:0,allowedInText:true},handler:(_ref3,args)=>{let parser=_ref3.parser,funcName=_ref3.funcName,breakOnTokenText=_ref3.breakOnTokenText;const mode=parser.mode;const body=parser.parseExpression(true,breakOnTokenText);const style=`math${funcName.slice(1)}`;return {type:"font",mode:mode,font:style,body:{type:"ordgroup",mode:parser.mode,body}};},htmlBuilder:htmlBuilder$5,mathmlBuilder:mathmlBuilder$5});const adjustStyle=(size,originalStyle)=>{// Figure out what style this fraction should be in based on the
    // function used
    let style=originalStyle;if(size==="display"){// Get display style as a default.
    // If incoming style is sub/sup, use style.text() to get correct size.
    style=style.id>=Style$1.SCRIPT.id?style.text():Style$1.DISPLAY;}else if(size==="text"&&style.size===Style$1.DISPLAY.size){// We're in a \tfrac but incoming style is displaystyle, so:
    style=Style$1.TEXT;}else if(size==="script"){style=Style$1.SCRIPT;}else if(size==="scriptscript"){style=Style$1.SCRIPTSCRIPT;}return style;};const htmlBuilder$6=(group,options)=>{// Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
    const style=adjustStyle(group.size,options.style);const nstyle=style.fracNum();const dstyle=style.fracDen();let newOptions;newOptions=options.havingStyle(nstyle);const numerm=buildGroup(group.numer,newOptions,options);if(group.continued){// \cfrac inserts a \strut into the numerator.
    // Get \strut dimensions from TeXbook page 353.
    const hStrut=8.5/options.fontMetrics().ptPerEm;const dStrut=3.5/options.fontMetrics().ptPerEm;numerm.height=numerm.height<hStrut?hStrut:numerm.height;numerm.depth=numerm.depth<dStrut?dStrut:numerm.depth;}newOptions=options.havingStyle(dstyle);const denomm=buildGroup(group.denom,newOptions,options);let rule;let ruleWidth;let ruleSpacing;if(group.hasBarLine){if(group.barSize){ruleWidth=calculateSize(group.barSize,options);rule=buildCommon.makeLineSpan("frac-line",options,ruleWidth);}else {rule=buildCommon.makeLineSpan("frac-line",options);}ruleWidth=rule.height;ruleSpacing=rule.height;}else {rule=null;ruleWidth=0;ruleSpacing=options.fontMetrics().defaultRuleThickness;}// Rule 15b
    let numShift;let clearance;let denomShift;if(style.size===Style$1.DISPLAY.size||group.size==="display"){numShift=options.fontMetrics().num1;if(ruleWidth>0){clearance=3*ruleSpacing;}else {clearance=7*ruleSpacing;}denomShift=options.fontMetrics().denom1;}else {if(ruleWidth>0){numShift=options.fontMetrics().num2;clearance=ruleSpacing;}else {numShift=options.fontMetrics().num3;clearance=3*ruleSpacing;}denomShift=options.fontMetrics().denom2;}let frac;if(!rule){// Rule 15c
    const candidateClearance=numShift-numerm.depth-(denomm.height-denomShift);if(candidateClearance<clearance){numShift+=0.5*(clearance-candidateClearance);denomShift+=0.5*(clearance-candidateClearance);}frac=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:denomm,shift:denomShift},{type:"elem",elem:numerm,shift:-numShift}]},options);}else {// Rule 15d
    const axisHeight=options.fontMetrics().axisHeight;if(numShift-numerm.depth-(axisHeight+0.5*ruleWidth)<clearance){numShift+=clearance-(numShift-numerm.depth-(axisHeight+0.5*ruleWidth));}if(axisHeight-0.5*ruleWidth-(denomm.height-denomShift)<clearance){denomShift+=clearance-(axisHeight-0.5*ruleWidth-(denomm.height-denomShift));}const midShift=-(axisHeight-0.5*ruleWidth);frac=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:denomm,shift:denomShift},{type:"elem",elem:rule,shift:midShift},{type:"elem",elem:numerm,shift:-numShift}]},options);}// Since we manually change the style sometimes (with \dfrac or \tfrac),
    // account for the possible size change here.
    newOptions=options.havingStyle(style);frac.height*=newOptions.sizeMultiplier/options.sizeMultiplier;frac.depth*=newOptions.sizeMultiplier/options.sizeMultiplier;// Rule 15e
    let delimSize;if(style.size===Style$1.DISPLAY.size){delimSize=options.fontMetrics().delim1;}else {delimSize=options.fontMetrics().delim2;}let leftDelim;let rightDelim;if(group.leftDelim==null){leftDelim=makeNullDelimiter(options,["mopen"]);}else {leftDelim=delimiter.customSizedDelim(group.leftDelim,delimSize,true,options.havingStyle(style),group.mode,["mopen"]);}if(group.continued){rightDelim=buildCommon.makeSpan([]);// zero width for \cfrac
    }else if(group.rightDelim==null){rightDelim=makeNullDelimiter(options,["mclose"]);}else {rightDelim=delimiter.customSizedDelim(group.rightDelim,delimSize,true,options.havingStyle(style),group.mode,["mclose"]);}return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)),[leftDelim,buildCommon.makeSpan(["mfrac"],[frac]),rightDelim],options);};const mathmlBuilder$6=(group,options)=>{let node=new mathMLTree.MathNode("mfrac",[buildGroup$1(group.numer,options),buildGroup$1(group.denom,options)]);if(!group.hasBarLine){node.setAttribute("linethickness","0px");}else if(group.barSize){const ruleWidth=calculateSize(group.barSize,options);node.setAttribute("linethickness",ruleWidth+"em");}const style=adjustStyle(group.size,options.style);if(style.size!==options.style.size){node=new mathMLTree.MathNode("mstyle",[node]);const isDisplay=style.size===Style$1.DISPLAY.size?"true":"false";node.setAttribute("displaystyle",isDisplay);node.setAttribute("scriptlevel","0");}if(group.leftDelim!=null||group.rightDelim!=null){const withDelims=[];if(group.leftDelim!=null){const leftOp=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(group.leftDelim.replace("\\",""))]);leftOp.setAttribute("fence","true");withDelims.push(leftOp);}withDelims.push(node);if(group.rightDelim!=null){const rightOp=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(group.rightDelim.replace("\\",""))]);rightOp.setAttribute("fence","true");withDelims.push(rightOp);}return makeRow(withDelims);}return node;};defineFunction({type:"genfrac",names:["\\cfrac","\\dfrac","\\frac","\\tfrac","\\dbinom","\\binom","\\tbinom","\\\\atopfrac",// cant be entered directly
    "\\\\bracefrac","\\\\brackfrac"],props:{numArgs:2,greediness:2},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;const numer=args[0];const denom=args[1];let hasBarLine;let leftDelim=null;let rightDelim=null;let size="auto";switch(funcName){case"\\cfrac":case"\\dfrac":case"\\frac":case"\\tfrac":hasBarLine=true;break;case"\\\\atopfrac":hasBarLine=false;break;case"\\dbinom":case"\\binom":case"\\tbinom":hasBarLine=false;leftDelim="(";rightDelim=")";break;case"\\\\bracefrac":hasBarLine=false;leftDelim="\\{";rightDelim="\\}";break;case"\\\\brackfrac":hasBarLine=false;leftDelim="[";rightDelim="]";break;default:throw new Error("Unrecognized genfrac command");}switch(funcName){case"\\cfrac":case"\\dfrac":case"\\dbinom":size="display";break;case"\\tfrac":case"\\tbinom":size="text";break;}return {type:"genfrac",mode:parser.mode,continued:funcName==="\\cfrac",numer,denom,hasBarLine,leftDelim,rightDelim,size,barSize:null};},htmlBuilder:htmlBuilder$6,mathmlBuilder:mathmlBuilder$6});// Infix generalized fractions -- these are not rendered directly, but replaced
    // immediately by one of the variants above.
    defineFunction({type:"infix",names:["\\over","\\choose","\\atop","\\brace","\\brack"],props:{numArgs:0,infix:true},handler(_ref2){let parser=_ref2.parser,funcName=_ref2.funcName,token=_ref2.token;let replaceWith;switch(funcName){case"\\over":replaceWith="\\frac";break;case"\\choose":replaceWith="\\binom";break;case"\\atop":replaceWith="\\\\atopfrac";break;case"\\brace":replaceWith="\\\\bracefrac";break;case"\\brack":replaceWith="\\\\brackfrac";break;default:throw new Error("Unrecognized infix genfrac command");}return {type:"infix",mode:parser.mode,replaceWith,token};}});const stylArray=["display","text","script","scriptscript"];const delimFromValue=function delimFromValue(delimString){let delim=null;if(delimString.length>0){delim=delimString;delim=delim==="."?null:delim;}return delim;};defineFunction({type:"genfrac",names:["\\genfrac"],props:{numArgs:6,greediness:6,argTypes:["math","math","size","text","math","math"]},handler(_ref3,args){let parser=_ref3.parser;const numer=args[4];const denom=args[5];// Look into the parse nodes to get the desired delimiters.
    const leftDelim=args[0].type==="atom"&&args[0].family==="open"?delimFromValue(args[0].text):null;const rightDelim=args[1].type==="atom"&&args[1].family==="close"?delimFromValue(args[1].text):null;const barNode=assertNodeType(args[2],"size");let hasBarLine;let barSize=null;if(barNode.isBlank){// \genfrac acts differently than \above.
    // \genfrac treats an empty size group as a signal to use a
    // standard bar size. \above would see size = 0 and omit the bar.
    hasBarLine=true;}else {barSize=barNode.value;hasBarLine=barSize.number>0;}// Find out if we want displaystyle, textstyle, etc.
    let size="auto";let styl=args[3];if(styl.type==="ordgroup"){if(styl.body.length>0){const textOrd=assertNodeType(styl.body[0],"textord");size=stylArray[Number(textOrd.text)];}}else {styl=assertNodeType(styl,"textord");size=stylArray[Number(styl.text)];}return {type:"genfrac",mode:parser.mode,numer,denom,continued:false,hasBarLine,barSize,leftDelim,rightDelim,size};},htmlBuilder:htmlBuilder$6,mathmlBuilder:mathmlBuilder$6});// \above is an infix fraction that also defines a fraction bar size.
    defineFunction({type:"infix",names:["\\above"],props:{numArgs:1,argTypes:["size"],infix:true},handler(_ref4,args){let parser=_ref4.parser;_ref4.funcName;let token=_ref4.token;return {type:"infix",mode:parser.mode,replaceWith:"\\\\abovefrac",size:assertNodeType(args[0],"size").value,token};}});defineFunction({type:"genfrac",names:["\\\\abovefrac"],props:{numArgs:3,argTypes:["math","size","math"]},handler:(_ref5,args)=>{let parser=_ref5.parser;_ref5.funcName;const numer=args[0];const barSize=assert(assertNodeType(args[1],"infix").size);const denom=args[2];const hasBarLine=barSize.number>0;return {type:"genfrac",mode:parser.mode,numer,denom,continued:false,hasBarLine,barSize,leftDelim:null,rightDelim:null,size:"auto"};},htmlBuilder:htmlBuilder$6,mathmlBuilder:mathmlBuilder$6});// NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
    const htmlBuilder$7=(grp,options)=>{const style=options.style;// Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.
    let supSubGroup;let group;if(grp.type==="supsub"){// Ref: LaTeX source2e: }}}}\limits}
    // i.e. LaTeX treats the brace similar to an op and passes it
    // with \limits, so we need to assign supsub style.
    supSubGroup=grp.sup?buildGroup(grp.sup,options.havingStyle(style.sup()),options):buildGroup(grp.sub,options.havingStyle(style.sub()),options);group=assertNodeType(grp.base,"horizBrace");}else {group=assertNodeType(grp,"horizBrace");}// Build the base group
    const body=buildGroup(group.base,options.havingBaseStyle(Style$1.DISPLAY));// Create the stretchy element
    const braceBody=stretchy.svgSpan(group,options);// Generate the vlist, with the appropriate kerns        
    // This first vlist contains the content and the brace:   equation
    let vlist;if(group.isOver){vlist=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:body},{type:"kern",size:0.1},{type:"elem",elem:braceBody}]},options);// $FlowFixMe: Replace this with passing "svg-align" into makeVList.
    vlist.children[0].children[0].children[1].classes.push("svg-align");}else {vlist=buildCommon.makeVList({positionType:"bottom",positionData:body.depth+0.1+braceBody.height,children:[{type:"elem",elem:braceBody},{type:"kern",size:0.1},{type:"elem",elem:body}]},options);// $FlowFixMe: Replace this with passing "svg-align" into makeVList.
    vlist.children[0].children[0].children[0].classes.push("svg-align");}if(supSubGroup){// To write the supsub, wrap the first vlist in another vlist:
    // They can't all go in the same vlist, because the note might be
    // wider than the equation. We want the equation to control the
    // brace width.
    //      note          long note           long note
    //      or         not    
    //    equation           eqn                 eqn
    const vSpan=buildCommon.makeSpan(["mord",group.isOver?"mover":"munder"],[vlist],options);if(group.isOver){vlist=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:vSpan},{type:"kern",size:0.2},{type:"elem",elem:supSubGroup}]},options);}else {vlist=buildCommon.makeVList({positionType:"bottom",positionData:vSpan.depth+0.2+supSubGroup.height+supSubGroup.depth,children:[{type:"elem",elem:supSubGroup},{type:"kern",size:0.2},{type:"elem",elem:vSpan}]},options);}}return buildCommon.makeSpan(["mord",group.isOver?"mover":"munder"],[vlist],options);};const mathmlBuilder$7=(group,options)=>{const accentNode=stretchy.mathMLnode(group.label);return new mathMLTree.MathNode(group.isOver?"mover":"munder",[buildGroup$1(group.base,options),accentNode]);};// Horizontal stretchy braces
    defineFunction({type:"horizBrace",names:["\\overbrace","\\underbrace"],props:{numArgs:1},handler(_ref,args){let parser=_ref.parser,funcName=_ref.funcName;return {type:"horizBrace",mode:parser.mode,label:funcName,isOver:/^\\over/.test(funcName),base:args[0]};},htmlBuilder:htmlBuilder$7,mathmlBuilder:mathmlBuilder$7});defineFunction({type:"href",names:["\\href"],props:{numArgs:2,argTypes:["url","original"],allowedInText:true},handler:(_ref,args)=>{let parser=_ref.parser;const body=args[1];const href=assertNodeType(args[0],"url").url;if(!parser.settings.isTrusted({command:"\\href",url:href})){return parser.formatUnsupportedCmd("\\href");}return {type:"href",mode:parser.mode,href,body:ordargument(body)};},htmlBuilder:(group,options)=>{const elements=buildExpression(group.body,options,false);return buildCommon.makeAnchor(group.href,[],elements,options);},mathmlBuilder:(group,options)=>{let math=buildExpressionRow(group.body,options);if(!(math instanceof MathNode)){math=new MathNode("mrow",[math]);}math.setAttribute("href",group.href);return math;}});defineFunction({type:"href",names:["\\url"],props:{numArgs:1,argTypes:["url"],allowedInText:true},handler:(_ref2,args)=>{let parser=_ref2.parser;const href=assertNodeType(args[0],"url").url;if(!parser.settings.isTrusted({command:"\\url",url:href})){return parser.formatUnsupportedCmd("\\url");}const chars=[];for(let i=0;i<href.length;i++){let c=href[i];if(c==="~"){c="\\textasciitilde";}chars.push({type:"textord",mode:"text",text:c});}const body={type:"text",mode:parser.mode,font:"\\texttt",body:chars};return {type:"href",mode:parser.mode,href,body:ordargument(body)};}});defineFunction({type:"html",names:["\\htmlClass","\\htmlId","\\htmlStyle","\\htmlData"],props:{numArgs:2,argTypes:["raw","original"],allowedInText:true},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;_ref.token;const value=assertNodeType(args[0],"raw").string;const body=args[1];if(parser.settings.strict){parser.settings.reportNonstrict("htmlExtension","HTML extension is disabled on strict mode");}let trustContext;const attributes={};switch(funcName){case"\\htmlClass":attributes.class=value;trustContext={command:"\\htmlClass",class:value};break;case"\\htmlId":attributes.id=value;trustContext={command:"\\htmlId",id:value};break;case"\\htmlStyle":attributes.style=value;trustContext={command:"\\htmlStyle",style:value};break;case"\\htmlData":{const data=value.split(",");for(let i=0;i<data.length;i++){const keyVal=data[i].split("=");if(keyVal.length!==2){throw new ParseError("Error parsing key-value for \\htmlData");}attributes["data-"+keyVal[0].trim()]=keyVal[1].trim();}trustContext={command:"\\htmlData",attributes};break;}default:throw new Error("Unrecognized html command");}if(!parser.settings.isTrusted(trustContext)){return parser.formatUnsupportedCmd(funcName);}return {type:"html",mode:parser.mode,attributes,body:ordargument(body)};},htmlBuilder:(group,options)=>{const elements=buildExpression(group.body,options,false);const classes=["enclosing"];if(group.attributes.class){classes.push(...group.attributes.class.trim().split(/\s+/));}const span=buildCommon.makeSpan(classes,elements,options);for(const attr in group.attributes){if(attr!=="class"&&group.attributes.hasOwnProperty(attr)){span.setAttribute(attr,group.attributes[attr]);}}return span;},mathmlBuilder:(group,options)=>{return buildExpressionRow(group.body,options);}});defineFunction({type:"htmlmathml",names:["\\html@mathml"],props:{numArgs:2,allowedInText:true},handler:(_ref,args)=>{let parser=_ref.parser;return {type:"htmlmathml",mode:parser.mode,html:ordargument(args[0]),mathml:ordargument(args[1])};},htmlBuilder:(group,options)=>{const elements=buildExpression(group.html,options,false);return buildCommon.makeFragment(elements);},mathmlBuilder:(group,options)=>{return buildExpressionRow(group.mathml,options);}});const sizeData=function sizeData(str){if(/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)){// str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return {number:+str,unit:"bp"};}else {const match=/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);if(!match){throw new ParseError("Invalid size: '"+str+"' in \\includegraphics");}const data={number:+(match[1]+match[2]),// sign + magnitude, cast to number
    unit:match[3]};if(!validUnit(data)){throw new ParseError("Invalid unit: '"+data.unit+"' in \\includegraphics.");}return data;}};defineFunction({type:"includegraphics",names:["\\includegraphics"],props:{numArgs:1,numOptionalArgs:1,argTypes:["raw","url"],allowedInText:false},handler:(_ref,args,optArgs)=>{let parser=_ref.parser;let width={number:0,unit:"em"};let height={number:0.9,unit:"em"};// sorta character sized.
    let totalheight={number:0,unit:"em"};let alt="";if(optArgs[0]){const attributeStr=assertNodeType(optArgs[0],"raw").string;// Parser.js does not parse key/value pairs. We get a string.
    const attributes=attributeStr.split(",");for(let i=0;i<attributes.length;i++){const keyVal=attributes[i].split("=");if(keyVal.length===2){const str=keyVal[1].trim();switch(keyVal[0].trim()){case"alt":alt=str;break;case"width":width=sizeData(str);break;case"height":height=sizeData(str);break;case"totalheight":totalheight=sizeData(str);break;default:throw new ParseError("Invalid key: '"+keyVal[0]+"' in \\includegraphics.");}}}}const src=assertNodeType(args[0],"url").url;if(alt===""){// No alt given. Use the file name. Strip away the path.
    alt=src;alt=alt.replace(/^.*[\\/]/,'');alt=alt.substring(0,alt.lastIndexOf('.'));}if(!parser.settings.isTrusted({command:"\\includegraphics",url:src})){return parser.formatUnsupportedCmd("\\includegraphics");}return {type:"includegraphics",mode:parser.mode,alt:alt,width:width,height:height,totalheight:totalheight,src:src};},htmlBuilder:(group,options)=>{const height=calculateSize(group.height,options);let depth=0;if(group.totalheight.number>0){depth=calculateSize(group.totalheight,options)-height;depth=Number(depth.toFixed(2));}let width=0;if(group.width.number>0){width=calculateSize(group.width,options);}const style={height:height+depth+"em"};if(width>0){style.width=width+"em";}if(depth>0){style.verticalAlign=-depth+"em";}const node=new Img(group.src,group.alt,style);node.height=height;node.depth=depth;return node;},mathmlBuilder:(group,options)=>{const node=new mathMLTree.MathNode("mglyph",[]);node.setAttribute("alt",group.alt);const height=calculateSize(group.height,options);let depth=0;if(group.totalheight.number>0){depth=calculateSize(group.totalheight,options)-height;depth=depth.toFixed(2);node.setAttribute("valign","-"+depth+"em");}node.setAttribute("height",height+depth+"em");if(group.width.number>0){const width=calculateSize(group.width,options);node.setAttribute("width",width+"em");}node.setAttribute("src",group.src);return node;}});// Horizontal spacing commands
    defineFunction({type:"kern",names:["\\kern","\\mkern","\\hskip","\\mskip"],props:{numArgs:1,argTypes:["size"],allowedInText:true},handler(_ref,args){let parser=_ref.parser,funcName=_ref.funcName;const size=assertNodeType(args[0],"size");if(parser.settings.strict){const mathFunction=funcName[1]==='m';// \mkern, \mskip
    const muUnit=size.value.unit==='mu';if(mathFunction){if(!muUnit){parser.settings.reportNonstrict("mathVsTextUnits",`LaTeX's ${funcName} supports only mu units, `+`not ${size.value.unit} units`);}if(parser.mode!=="math"){parser.settings.reportNonstrict("mathVsTextUnits",`LaTeX's ${funcName} works only in math mode`);}}else {// !mathFunction
    if(muUnit){parser.settings.reportNonstrict("mathVsTextUnits",`LaTeX's ${funcName} doesn't support mu units`);}}}return {type:"kern",mode:parser.mode,dimension:size.value};},htmlBuilder(group,options){return buildCommon.makeGlue(group.dimension,options);},mathmlBuilder(group,options){const dimension=calculateSize(group.dimension,options);return new mathMLTree.SpaceNode(dimension);}});// Horizontal overlap functions
    defineFunction({type:"lap",names:["\\mathllap","\\mathrlap","\\mathclap"],props:{numArgs:1,allowedInText:true},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;const body=args[0];return {type:"lap",mode:parser.mode,alignment:funcName.slice(5),body};},htmlBuilder:(group,options)=>{// mathllap, mathrlap, mathclap
    let inner;if(group.alignment==="clap"){// ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
    inner=buildCommon.makeSpan([],[buildGroup(group.body,options)]);// wrap, since CSS will center a .clap > .inner > span
    inner=buildCommon.makeSpan(["inner"],[inner],options);}else {inner=buildCommon.makeSpan(["inner"],[buildGroup(group.body,options)]);}const fix=buildCommon.makeSpan(["fix"],[]);let node=buildCommon.makeSpan([group.alignment],[inner,fix],options);// At this point, we have correctly set horizontal alignment of the
    // two items involved in the lap.
    // Next, use a strut to set the height of the HTML bounding box.
    // Otherwise, a tall argument may be misplaced.
    // This code resolved issue #1153
    const strut=buildCommon.makeSpan(["strut"]);strut.style.height=node.height+node.depth+"em";strut.style.verticalAlign=-node.depth+"em";node.children.unshift(strut);// Next, prevent vertical misplacement when next to something tall.
    // This code resolves issue #1234
    node=buildCommon.makeSpan(["thinbox"],[node],options);return buildCommon.makeSpan(["mord","vbox"],[node],options);},mathmlBuilder:(group,options)=>{// mathllap, mathrlap, mathclap
    const node=new mathMLTree.MathNode("mpadded",[buildGroup$1(group.body,options)]);if(group.alignment!=="rlap"){const offset=group.alignment==="llap"?"-1":"-0.5";node.setAttribute("lspace",offset+"width");}node.setAttribute("width","0px");return node;}});defineFunction({type:"styling",names:["\\(","$"],props:{numArgs:0,allowedInText:true,allowedInMath:false},handler(_ref,args){let funcName=_ref.funcName,parser=_ref.parser;const outerMode=parser.mode;parser.switchMode("math");const close=funcName==="\\("?"\\)":"$";const body=parser.parseExpression(false,close);parser.expect(close);parser.switchMode(outerMode);return {type:"styling",mode:parser.mode,style:"text",body};}});// Check for extra closing math delimiters
    defineFunction({type:"text",// Doesn't matter what this is.
    names:["\\)","\\]"],props:{numArgs:0,allowedInText:true,allowedInMath:false},handler(context,args){throw new ParseError(`Mismatched ${context.funcName}`);}});const chooseMathStyle=(group,options)=>{switch(options.style.size){case Style$1.DISPLAY.size:return group.display;case Style$1.TEXT.size:return group.text;case Style$1.SCRIPT.size:return group.script;case Style$1.SCRIPTSCRIPT.size:return group.scriptscript;default:return group.text;}};defineFunction({type:"mathchoice",names:["\\mathchoice"],props:{numArgs:4},handler:(_ref,args)=>{let parser=_ref.parser;return {type:"mathchoice",mode:parser.mode,display:ordargument(args[0]),text:ordargument(args[1]),script:ordargument(args[2]),scriptscript:ordargument(args[3])};},htmlBuilder:(group,options)=>{const body=chooseMathStyle(group,options);const elements=buildExpression(body,options,false);return buildCommon.makeFragment(elements);},mathmlBuilder:(group,options)=>{const body=chooseMathStyle(group,options);return buildExpressionRow(body,options);}});// For an operator with limits, assemble the base, sup, and sub into a span.
    const assembleSupSub=(base,supGroup,subGroup,options,style,slant,baseShift)=>{base=buildCommon.makeSpan([],[base]);let sub;let sup;// We manually have to handle the superscripts and subscripts. This,
    // aside from the kern calculations, is copied from supsub.
    if(supGroup){const elem=buildGroup(supGroup,options.havingStyle(style.sup()),options);sup={elem,kern:Math.max(options.fontMetrics().bigOpSpacing1,options.fontMetrics().bigOpSpacing3-elem.depth)};}if(subGroup){const elem=buildGroup(subGroup,options.havingStyle(style.sub()),options);sub={elem,kern:Math.max(options.fontMetrics().bigOpSpacing2,options.fontMetrics().bigOpSpacing4-elem.height)};}// Build the final group as a vlist of the possible subscript, base,
    // and possible superscript.
    let finalGroup;if(sup&&sub){const bottom=options.fontMetrics().bigOpSpacing5+sub.elem.height+sub.elem.depth+sub.kern+base.depth+baseShift;finalGroup=buildCommon.makeVList({positionType:"bottom",positionData:bottom,children:[{type:"kern",size:options.fontMetrics().bigOpSpacing5},{type:"elem",elem:sub.elem,marginLeft:-slant+"em"},{type:"kern",size:sub.kern},{type:"elem",elem:base},{type:"kern",size:sup.kern},{type:"elem",elem:sup.elem,marginLeft:slant+"em"},{type:"kern",size:options.fontMetrics().bigOpSpacing5}]},options);}else if(sub){const top=base.height-baseShift;// Shift the limits by the slant of the symbol. Note
    // that we are supposed to shift the limits by 1/2 of the slant,
    // but since we are centering the limits adding a full slant of
    // margin will shift by 1/2 that.
    finalGroup=buildCommon.makeVList({positionType:"top",positionData:top,children:[{type:"kern",size:options.fontMetrics().bigOpSpacing5},{type:"elem",elem:sub.elem,marginLeft:-slant+"em"},{type:"kern",size:sub.kern},{type:"elem",elem:base}]},options);}else if(sup){const bottom=base.depth+baseShift;finalGroup=buildCommon.makeVList({positionType:"bottom",positionData:bottom,children:[{type:"elem",elem:base},{type:"kern",size:sup.kern},{type:"elem",elem:sup.elem,marginLeft:slant+"em"},{type:"kern",size:options.fontMetrics().bigOpSpacing5}]},options);}else {// This case probably shouldn't occur (this would mean the
    // supsub was sending us a group with no superscript or
    // subscript) but be safe.
    return base;}return buildCommon.makeSpan(["mop","op-limits"],[finalGroup],options);};// Limits, symbols
    // Most operators have a large successor symbol, but these don't.
    const noSuccessor=["\\smallint"];// NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
    // "supsub" since some of them (like \int) can affect super/subscripting.
    const htmlBuilder$8=(grp,options)=>{// Operators are handled in the TeXbook pg. 443-444, rule 13(a).
    let supGroup;let subGroup;let hasLimits=false;let group;if(grp.type==="supsub"){// If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup=grp.sup;subGroup=grp.sub;group=assertNodeType(grp.base,"op");hasLimits=true;}else {group=assertNodeType(grp,"op");}const style=options.style;let large=false;if(style.size===Style$1.DISPLAY.size&&group.symbol&&!utils.contains(noSuccessor,group.name)){// Most symbol operators get larger in displaystyle (rule 13)
    large=true;}let base;if(group.symbol){// If this is a symbol, create the symbol.
    const fontName=large?"Size2-Regular":"Size1-Regular";let stash="";if(group.name==="\\oiint"||group.name==="\\oiiint"){// No font glyphs yet, so use a glyph w/o the oval.
    // TODO: When font glyphs are available, delete this code.
    stash=group.name.substr(1);// $FlowFixMe
    group.name=stash==="oiint"?"\\iint":"\\iiint";}base=buildCommon.makeSymbol(group.name,fontName,"math",options,["mop","op-symbol",large?"large-op":"small-op"]);if(stash.length>0){// We're in \oiint or \oiiint. Overlay the oval.
    // TODO: When font glyphs are available, delete this code.
    const italic=base.italic;const oval=buildCommon.staticSvg(stash+"Size"+(large?"2":"1"),options);base=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:base,shift:0},{type:"elem",elem:oval,shift:large?0.08:0}]},options);// $FlowFixMe
    group.name="\\"+stash;base.classes.unshift("mop");// $FlowFixMe
    base.italic=italic;}}else if(group.body){// If this is a list, compose that list.
    const inner=buildExpression(group.body,options,true);if(inner.length===1&&inner[0]instanceof SymbolNode){base=inner[0];base.classes[0]="mop";// replace old mclass
    }else {base=buildCommon.makeSpan(["mop"],buildCommon.tryCombineChars(inner),options);}}else {// Otherwise, this is a text operator. Build the text from the
    // operator's name.
    // TODO(emily): Add a space in the middle of some of these
    // operators, like \limsup
    const output=[];for(let i=1;i<group.name.length;i++){output.push(buildCommon.mathsym(group.name[i],group.mode,options));}base=buildCommon.makeSpan(["mop"],output,options);}// If content of op is a single symbol, shift it vertically.
    let baseShift=0;let slant=0;if((base instanceof SymbolNode||group.name==="\\oiint"||group.name==="\\oiiint")&&!group.suppressBaseShift){// We suppress the shift of the base of \overset and \underset. Otherwise,
    // shift the symbol so its center lies on the axis (rule 13). It
    // appears that our fonts have the centers of the symbols already
    // almost on the axis, so these numbers are very small. Note we
    // don't actually apply this here, but instead it is used either in
    // the vlist creation or separately when there are no limits.
    baseShift=(base.height-base.depth)/2-options.fontMetrics().axisHeight;// The slant of the symbol is just its italic correction.
    // $FlowFixMe
    slant=base.italic;}if(hasLimits){return assembleSupSub(base,supGroup,subGroup,options,style,slant,baseShift);}else {if(baseShift){base.style.position="relative";base.style.top=baseShift+"em";}return base;}};const mathmlBuilder$8=(group,options)=>{let node;if(group.symbol){// This is a symbol. Just add the symbol.
    node=new MathNode("mo",[makeText(group.name,group.mode)]);if(utils.contains(noSuccessor,group.name)){node.setAttribute("largeop","false");}}else if(group.body){// This is an operator with children. Add them.
    node=new MathNode("mo",buildExpression$1(group.body,options));}else {// This is a text operator. Add all of the characters from the
    // operator's name.
    node=new MathNode("mi",[new TextNode(group.name.slice(1))]);// Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
    const operator=new MathNode("mo",[makeText("\u2061","text")]);if(group.parentIsSupSub){node=new MathNode("mo",[node,operator]);}else {node=newDocumentFragment([node,operator]);}}return node;};const singleCharBigOps={"\u220F":"\\prod","\u2210":"\\coprod","\u2211":"\\sum","\u22c0":"\\bigwedge","\u22c1":"\\bigvee","\u22c2":"\\bigcap","\u22c3":"\\bigcup","\u2a00":"\\bigodot","\u2a01":"\\bigoplus","\u2a02":"\\bigotimes","\u2a04":"\\biguplus","\u2a06":"\\bigsqcup"};defineFunction({type:"op",names:["\\coprod","\\bigvee","\\bigwedge","\\biguplus","\\bigcap","\\bigcup","\\intop","\\prod","\\sum","\\bigotimes","\\bigoplus","\\bigodot","\\bigsqcup","\\smallint","\u220F","\u2210","\u2211","\u22c0","\u22c1","\u22c2","\u22c3","\u2a00","\u2a01","\u2a02","\u2a04","\u2a06"],props:{numArgs:0},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;let fName=funcName;if(fName.length===1){fName=singleCharBigOps[fName];}return {type:"op",mode:parser.mode,limits:true,parentIsSupSub:false,symbol:true,name:fName};},htmlBuilder:htmlBuilder$8,mathmlBuilder:mathmlBuilder$8});// Note: calling defineFunction with a type that's already been defined only
    // works because the same htmlBuilder and mathmlBuilder are being used.
    defineFunction({type:"op",names:["\\mathop"],props:{numArgs:1},handler:(_ref2,args)=>{let parser=_ref2.parser;const body=args[0];return {type:"op",mode:parser.mode,limits:false,parentIsSupSub:false,symbol:false,body:ordargument(body)};},htmlBuilder:htmlBuilder$8,mathmlBuilder:mathmlBuilder$8});// There are 2 flags for operators; whether they produce limits in
    // displaystyle, and whether they are symbols and should grow in
    // displaystyle. These four groups cover the four possible choices.
    const singleCharIntegrals={"\u222b":"\\int","\u222c":"\\iint","\u222d":"\\iiint","\u222e":"\\oint","\u222f":"\\oiint","\u2230":"\\oiiint"};// No limits, not symbols
    defineFunction({type:"op",names:["\\arcsin","\\arccos","\\arctan","\\arctg","\\arcctg","\\arg","\\ch","\\cos","\\cosec","\\cosh","\\cot","\\cotg","\\coth","\\csc","\\ctg","\\cth","\\deg","\\dim","\\exp","\\hom","\\ker","\\lg","\\ln","\\log","\\sec","\\sin","\\sinh","\\sh","\\tan","\\tanh","\\tg","\\th"],props:{numArgs:0},handler(_ref3){let parser=_ref3.parser,funcName=_ref3.funcName;return {type:"op",mode:parser.mode,limits:false,parentIsSupSub:false,symbol:false,name:funcName};},htmlBuilder:htmlBuilder$8,mathmlBuilder:mathmlBuilder$8});// Limits, not symbols
    defineFunction({type:"op",names:["\\det","\\gcd","\\inf","\\lim","\\max","\\min","\\Pr","\\sup"],props:{numArgs:0},handler(_ref4){let parser=_ref4.parser,funcName=_ref4.funcName;return {type:"op",mode:parser.mode,limits:true,parentIsSupSub:false,symbol:false,name:funcName};},htmlBuilder:htmlBuilder$8,mathmlBuilder:mathmlBuilder$8});// No limits, symbols
    defineFunction({type:"op",names:["\\int","\\iint","\\iiint","\\oint","\\oiint","\\oiiint","\u222b","\u222c","\u222d","\u222e","\u222f","\u2230"],props:{numArgs:0},handler(_ref5){let parser=_ref5.parser,funcName=_ref5.funcName;let fName=funcName;if(fName.length===1){fName=singleCharIntegrals[fName];}return {type:"op",mode:parser.mode,limits:false,parentIsSupSub:false,symbol:true,name:fName};},htmlBuilder:htmlBuilder$8,mathmlBuilder:mathmlBuilder$8});// NOTE: Unlike most `htmlBuilder`s, this one handles not only
    // "operatorname", but also  "supsub" since \operatorname* can
    const htmlBuilder$9=(grp,options)=>{// Operators are handled in the TeXbook pg. 443-444, rule 13(a).
    let supGroup;let subGroup;let hasLimits=false;let group;if(grp.type==="supsub"){// If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup=grp.sup;subGroup=grp.sub;group=assertNodeType(grp.base,"operatorname");hasLimits=true;}else {group=assertNodeType(grp,"operatorname");}let base;if(group.body.length>0){const body=group.body.map(child=>{// $FlowFixMe: Check if the node has a string `text` property.
    const childText=child.text;if(typeof childText==="string"){return {type:"textord",mode:child.mode,text:childText};}else {return child;}});// Consolidate function names into symbol characters.
    const expression=buildExpression(body,options.withFont("mathrm"),true);for(let i=0;i<expression.length;i++){const child=expression[i];if(child instanceof SymbolNode){// Per amsopn package,
    // change minus to hyphen and \ast to asterisk
    child.text=child.text.replace(/\u2212/,"-").replace(/\u2217/,"*");}}base=buildCommon.makeSpan(["mop"],expression,options);}else {base=buildCommon.makeSpan(["mop"],[],options);}if(hasLimits){return assembleSupSub(base,supGroup,subGroup,options,options.style,0,0);}else {return base;}};const mathmlBuilder$9=(group,options)=>{// The steps taken here are similar to the html version.
    let expression=buildExpression$1(group.body,options.withFont("mathrm"));// Is expression a string or has it something like a fraction?
    let isAllString=true;// default
    for(let i=0;i<expression.length;i++){const node=expression[i];if(node instanceof mathMLTree.SpaceNode);else if(node instanceof mathMLTree.MathNode){switch(node.type){case"mi":case"mn":case"ms":case"mspace":case"mtext":break;// Do nothing yet.
    case"mo":{const child=node.children[0];if(node.children.length===1&&child instanceof mathMLTree.TextNode){child.text=child.text.replace(/\u2212/,"-").replace(/\u2217/,"*");}else {isAllString=false;}break;}default:isAllString=false;}}else {isAllString=false;}}if(isAllString){// Write a single TextNode instead of multiple nested tags.
    const word=expression.map(node=>node.toText()).join("");expression=[new mathMLTree.TextNode(word)];}const identifier=new mathMLTree.MathNode("mi",expression);identifier.setAttribute("mathvariant","normal");// \u2061 is the same as &ApplyFunction;
    // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp
    const operator=new mathMLTree.MathNode("mo",[makeText("\u2061","text")]);if(group.parentIsSupSub){return new mathMLTree.MathNode("mo",[identifier,operator]);}else {return mathMLTree.newDocumentFragment([identifier,operator]);}};// \operatorname
    // amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
    defineFunction({type:"operatorname",names:["\\operatorname","\\operatorname*"],props:{numArgs:1},handler:(_ref,args)=>{let parser=_ref.parser,funcName=_ref.funcName;const body=args[0];return {type:"operatorname",mode:parser.mode,body:ordargument(body),alwaysHandleSupSub:funcName==="\\operatorname*",limits:false,parentIsSupSub:false};},htmlBuilder:htmlBuilder$9,mathmlBuilder:mathmlBuilder$9});defineFunctionBuilders({type:"ordgroup",htmlBuilder(group,options){if(group.semisimple){return buildCommon.makeFragment(buildExpression(group.body,options,false));}return buildCommon.makeSpan(["mord"],buildExpression(group.body,options,true),options);},mathmlBuilder(group,options){return buildExpressionRow(group.body,options,true);}});defineFunction({type:"overline",names:["\\overline"],props:{numArgs:1},handler(_ref,args){let parser=_ref.parser;const body=args[0];return {type:"overline",mode:parser.mode,body};},htmlBuilder(group,options){// Overlines are handled in the TeXbook pg 443, Rule 9.
    // Build the inner group in the cramped style.
    const innerGroup=buildGroup(group.body,options.havingCrampedStyle());// Create the line above the body
    const line=buildCommon.makeLineSpan("overline-line",options);// Generate the vlist, with the appropriate kerns
    const defaultRuleThickness=options.fontMetrics().defaultRuleThickness;const vlist=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:innerGroup},{type:"kern",size:3*defaultRuleThickness},{type:"elem",elem:line},{type:"kern",size:defaultRuleThickness}]},options);return buildCommon.makeSpan(["mord","overline"],[vlist],options);},mathmlBuilder(group,options){const operator=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode("\u203e")]);operator.setAttribute("stretchy","true");const node=new mathMLTree.MathNode("mover",[buildGroup$1(group.body,options),operator]);node.setAttribute("accent","true");return node;}});defineFunction({type:"phantom",names:["\\phantom"],props:{numArgs:1,allowedInText:true},handler:(_ref,args)=>{let parser=_ref.parser;const body=args[0];return {type:"phantom",mode:parser.mode,body:ordargument(body)};},htmlBuilder:(group,options)=>{const elements=buildExpression(group.body,options.withPhantom(),false);// \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.
    return buildCommon.makeFragment(elements);},mathmlBuilder:(group,options)=>{const inner=buildExpression$1(group.body,options);return new mathMLTree.MathNode("mphantom",inner);}});defineFunction({type:"hphantom",names:["\\hphantom"],props:{numArgs:1,allowedInText:true},handler:(_ref2,args)=>{let parser=_ref2.parser;const body=args[0];return {type:"hphantom",mode:parser.mode,body};},htmlBuilder:(group,options)=>{let node=buildCommon.makeSpan([],[buildGroup(group.body,options.withPhantom())]);node.height=0;node.depth=0;if(node.children){for(let i=0;i<node.children.length;i++){node.children[i].height=0;node.children[i].depth=0;}}// See smash for comment re: use of makeVList
    node=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:node}]},options);// For spacing, TeX treats \smash as a math group (same spacing as ord).
    return buildCommon.makeSpan(["mord"],[node],options);},mathmlBuilder:(group,options)=>{const inner=buildExpression$1(ordargument(group.body),options);const phantom=new mathMLTree.MathNode("mphantom",inner);const node=new mathMLTree.MathNode("mpadded",[phantom]);node.setAttribute("height","0px");node.setAttribute("depth","0px");return node;}});defineFunction({type:"vphantom",names:["\\vphantom"],props:{numArgs:1,allowedInText:true},handler:(_ref3,args)=>{let parser=_ref3.parser;const body=args[0];return {type:"vphantom",mode:parser.mode,body};},htmlBuilder:(group,options)=>{const inner=buildCommon.makeSpan(["inner"],[buildGroup(group.body,options.withPhantom())]);const fix=buildCommon.makeSpan(["fix"],[]);return buildCommon.makeSpan(["mord","rlap"],[inner,fix],options);},mathmlBuilder:(group,options)=>{const inner=buildExpression$1(ordargument(group.body),options);const phantom=new mathMLTree.MathNode("mphantom",inner);const node=new mathMLTree.MathNode("mpadded",[phantom]);node.setAttribute("width","0px");return node;}});defineFunction({type:"raisebox",names:["\\raisebox"],props:{numArgs:2,argTypes:["size","hbox"],allowedInText:true},handler(_ref,args){let parser=_ref.parser;const amount=assertNodeType(args[0],"size").value;const body=args[1];return {type:"raisebox",mode:parser.mode,dy:amount,body};},htmlBuilder(group,options){const body=buildGroup(group.body,options);const dy=calculateSize(group.dy,options);return buildCommon.makeVList({positionType:"shift",positionData:-dy,children:[{type:"elem",elem:body}]},options);},mathmlBuilder(group,options){const node=new mathMLTree.MathNode("mpadded",[buildGroup$1(group.body,options)]);const dy=group.dy.number+group.dy.unit;node.setAttribute("voffset",dy);return node;}});defineFunction({type:"rule",names:["\\rule"],props:{numArgs:2,numOptionalArgs:1,argTypes:["size","size","size"]},handler(_ref,args,optArgs){let parser=_ref.parser;const shift=optArgs[0];const width=assertNodeType(args[0],"size");const height=assertNodeType(args[1],"size");return {type:"rule",mode:parser.mode,shift:shift&&assertNodeType(shift,"size").value,width:width.value,height:height.value};},htmlBuilder(group,options){// Make an empty span for the rule
    const rule=buildCommon.makeSpan(["mord","rule"],[],options);// Calculate the shift, width, and height of the rule, and account for units
    const width=calculateSize(group.width,options);const height=calculateSize(group.height,options);const shift=group.shift?calculateSize(group.shift,options):0;// Style the rule to the right size
    rule.style.borderRightWidth=width+"em";rule.style.borderTopWidth=height+"em";rule.style.bottom=shift+"em";// Record the height and width
    rule.width=width;rule.height=height+shift;rule.depth=-shift;// Font size is the number large enough that the browser will
    // reserve at least `absHeight` space above the baseline.
    // The 1.125 factor was empirically determined
    rule.maxFontSize=height*1.125*options.sizeMultiplier;return rule;},mathmlBuilder(group,options){const width=calculateSize(group.width,options);const height=calculateSize(group.height,options);const shift=group.shift?calculateSize(group.shift,options):0;const color=options.color&&options.getColor()||"black";const rule=new mathMLTree.MathNode("mspace");rule.setAttribute("mathbackground",color);rule.setAttribute("width",width+"em");rule.setAttribute("height",height+"em");const wrapper=new mathMLTree.MathNode("mpadded",[rule]);if(shift>=0){wrapper.setAttribute("height","+"+shift+"em");}else {wrapper.setAttribute("height",shift+"em");wrapper.setAttribute("depth","+"+-shift+"em");}wrapper.setAttribute("voffset",shift+"em");return wrapper;}});function sizingGroup(value,options,baseOptions){const inner=buildExpression(value,options,false);const multiplier=options.sizeMultiplier/baseOptions.sizeMultiplier;// Add size-resetting classes to the inner list and set maxFontSize
    // manually. Handle nested size changes.
    for(let i=0;i<inner.length;i++){const pos=inner[i].classes.indexOf("sizing");if(pos<0){Array.prototype.push.apply(inner[i].classes,options.sizingClasses(baseOptions));}else if(inner[i].classes[pos+1]==="reset-size"+options.size){// This is a nested size change: e.g., inner[i] is the "b" in
    // `\Huge a \small b`. Override the old size (the `reset-` class)
    // but not the new size.
    inner[i].classes[pos+1]="reset-size"+baseOptions.size;}inner[i].height*=multiplier;inner[i].depth*=multiplier;}return buildCommon.makeFragment(inner);}const sizeFuncs=["\\tiny","\\sixptsize","\\scriptsize","\\footnotesize","\\small","\\normalsize","\\large","\\Large","\\LARGE","\\huge","\\Huge"];const htmlBuilder$a=(group,options)=>{// Handle sizing operators like \Huge. Real TeX doesn't actually allow
    // these functions inside of math expressions, so we do some special
    // handling.
    const newOptions=options.havingSize(group.size);return sizingGroup(group.body,newOptions,options);};defineFunction({type:"sizing",names:sizeFuncs,props:{numArgs:0,allowedInText:true},handler:(_ref,args)=>{let breakOnTokenText=_ref.breakOnTokenText,funcName=_ref.funcName,parser=_ref.parser;const body=parser.parseExpression(false,breakOnTokenText);return {type:"sizing",mode:parser.mode,// Figure out what size to use based on the list of functions above
    size:sizeFuncs.indexOf(funcName)+1,body};},htmlBuilder:htmlBuilder$a,mathmlBuilder:(group,options)=>{const newOptions=options.havingSize(group.size);const inner=buildExpression$1(group.body,newOptions);const node=new mathMLTree.MathNode("mstyle",inner);// TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.
    node.setAttribute("mathsize",newOptions.sizeMultiplier+"em");return node;}});// smash, with optional [tb], as in AMS
    defineFunction({type:"smash",names:["\\smash"],props:{numArgs:1,numOptionalArgs:1,allowedInText:true},handler:(_ref,args,optArgs)=>{let parser=_ref.parser;let smashHeight=false;let smashDepth=false;const tbArg=optArgs[0]&&assertNodeType(optArgs[0],"ordgroup");if(tbArg){// Optional [tb] argument is engaged.
    // ref: amsmath: \renewcommand{\smash}[1][tb]{%
    //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
    let letter="";for(let i=0;i<tbArg.body.length;++i){const node=tbArg.body[i];// $FlowFixMe: Not every node type has a `text` property.
    letter=node.text;if(letter==="t"){smashHeight=true;}else if(letter==="b"){smashDepth=true;}else {smashHeight=false;smashDepth=false;break;}}}else {smashHeight=true;smashDepth=true;}const body=args[0];return {type:"smash",mode:parser.mode,body,smashHeight,smashDepth};},htmlBuilder:(group,options)=>{const node=buildCommon.makeSpan([],[buildGroup(group.body,options)]);if(!group.smashHeight&&!group.smashDepth){return node;}if(group.smashHeight){node.height=0;// In order to influence makeVList, we have to reset the children.
    if(node.children){for(let i=0;i<node.children.length;i++){node.children[i].height=0;}}}if(group.smashDepth){node.depth=0;if(node.children){for(let i=0;i<node.children.length;i++){node.children[i].depth=0;}}}// At this point, we've reset the TeX-like height and depth values.
    // But the span still has an HTML line height.
    // makeVList applies "display: table-cell", which prevents the browser
    // from acting on that line height. So we'll call makeVList now.
    const smashedNode=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:node}]},options);// For spacing, TeX treats \hphantom as a math group (same spacing as ord).
    return buildCommon.makeSpan(["mord"],[smashedNode],options);},mathmlBuilder:(group,options)=>{const node=new mathMLTree.MathNode("mpadded",[buildGroup$1(group.body,options)]);if(group.smashHeight){node.setAttribute("height","0px");}if(group.smashDepth){node.setAttribute("depth","0px");}return node;}});defineFunction({type:"sqrt",names:["\\sqrt"],props:{numArgs:1,numOptionalArgs:1},handler(_ref,args,optArgs){let parser=_ref.parser;const index=optArgs[0];const body=args[0];return {type:"sqrt",mode:parser.mode,body,index};},htmlBuilder(group,options){// Square roots are handled in the TeXbook pg. 443, Rule 11.
    // First, we do the same steps as in overline to build the inner group
    // and line
    let inner=buildGroup(group.body,options.havingCrampedStyle());if(inner.height===0){// Render a small surd.
    inner.height=options.fontMetrics().xHeight;}// Some groups can return document fragments.  Handle those by wrapping
    // them in a span.
    inner=buildCommon.wrapFragment(inner,options);// Calculate the minimum size for the \surd delimiter
    const metrics=options.fontMetrics();const theta=metrics.defaultRuleThickness;let phi=theta;if(options.style.id<Style$1.TEXT.id){phi=options.fontMetrics().xHeight;}// Calculate the clearance between the body and line
    let lineClearance=theta+phi/4;const minDelimiterHeight=inner.height+inner.depth+lineClearance+theta;// Create a sqrt SVG of the required minimum size
    const _delimiter$sqrtImage=delimiter.sqrtImage(minDelimiterHeight,options),img=_delimiter$sqrtImage.span,ruleWidth=_delimiter$sqrtImage.ruleWidth,advanceWidth=_delimiter$sqrtImage.advanceWidth;const delimDepth=img.height-ruleWidth;// Adjust the clearance based on the delimiter size
    if(delimDepth>inner.height+inner.depth+lineClearance){lineClearance=(lineClearance+delimDepth-inner.height-inner.depth)/2;}// Shift the sqrt image
    const imgShift=img.height-inner.height-lineClearance-ruleWidth;inner.style.paddingLeft=advanceWidth+"em";// Overlay the image and the argument.
    const body=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:inner,wrapperClasses:["svg-align"]},{type:"kern",size:-(inner.height+imgShift)},{type:"elem",elem:img},{type:"kern",size:ruleWidth}]},options);if(!group.index){return buildCommon.makeSpan(["mord","sqrt"],[body],options);}else {// Handle the optional root index
    // The index is always in scriptscript style
    const newOptions=options.havingStyle(Style$1.SCRIPTSCRIPT);const rootm=buildGroup(group.index,newOptions,options);// The amount the index is shifted by. This is taken from the TeX
    // source, in the definition of `\r@@t`.
    const toShift=0.6*(body.height-body.depth);// Build a VList with the superscript shifted up correctly
    const rootVList=buildCommon.makeVList({positionType:"shift",positionData:-toShift,children:[{type:"elem",elem:rootm}]},options);// Add a class surrounding it so we can add on the appropriate
    // kerning
    const rootVListWrap=buildCommon.makeSpan(["root"],[rootVList]);return buildCommon.makeSpan(["mord","sqrt"],[rootVListWrap,body],options);}},mathmlBuilder(group,options){const body=group.body,index=group.index;return index?new mathMLTree.MathNode("mroot",[buildGroup$1(body,options),buildGroup$1(index,options)]):new mathMLTree.MathNode("msqrt",[buildGroup$1(body,options)]);}});const styleMap$1={"display":Style$1.DISPLAY,"text":Style$1.TEXT,"script":Style$1.SCRIPT,"scriptscript":Style$1.SCRIPTSCRIPT};defineFunction({type:"styling",names:["\\displaystyle","\\textstyle","\\scriptstyle","\\scriptscriptstyle"],props:{numArgs:0,allowedInText:true},handler(_ref,args){let breakOnTokenText=_ref.breakOnTokenText,funcName=_ref.funcName,parser=_ref.parser;// parse out the implicit body
    const body=parser.parseExpression(true,breakOnTokenText);// TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
    // here and in buildHTML and de-dupe the enumeration of all the styles).
    // $FlowFixMe: The names above exactly match the styles.
    const style=funcName.slice(1,funcName.length-5);return {type:"styling",mode:parser.mode,// Figure out what style to use by pulling out the style from
    // the function name
    style,body};},htmlBuilder(group,options){// Style changes are handled in the TeXbook on pg. 442, Rule 3.
    const newStyle=styleMap$1[group.style];const newOptions=options.havingStyle(newStyle).withFont('');return sizingGroup(group.body,newOptions,options);},mathmlBuilder(group,options){// Figure out what style we're changing to.
    const newStyle=styleMap$1[group.style];const newOptions=options.havingStyle(newStyle);const inner=buildExpression$1(group.body,newOptions);const node=new mathMLTree.MathNode("mstyle",inner);const styleAttributes={"display":["0","true"],"text":["0","false"],"script":["1","false"],"scriptscript":["2","false"]};const attr=styleAttributes[group.style];node.setAttribute("scriptlevel",attr[0]);node.setAttribute("displaystyle",attr[1]);return node;}});/**
     * Sometimes, groups perform special rules when they have superscripts or
     * subscripts attached to them. This function lets the `supsub` group know that
     * Sometimes, groups perform special rules when they have superscripts or
     * its inner element should handle the superscripts and subscripts instead of
     * handling them itself.
     */const htmlBuilderDelegate=function htmlBuilderDelegate(group,options){const base=group.base;if(!base){return null;}else if(base.type==="op"){// Operators handle supsubs differently when they have limits
    // (e.g. `\displaystyle\sum_2^3`)
    const delegate=base.limits&&(options.style.size===Style$1.DISPLAY.size||base.alwaysHandleSupSub);return delegate?htmlBuilder$8:null;}else if(base.type==="operatorname"){const delegate=base.alwaysHandleSupSub&&(options.style.size===Style$1.DISPLAY.size||base.limits);return delegate?htmlBuilder$9:null;}else if(base.type==="accent"){return utils.isCharacterBox(base.base)?htmlBuilder:null;}else if(base.type==="horizBrace"){const isSup=!group.sub;return isSup===base.isOver?htmlBuilder$7:null;}else {return null;}};// Super scripts and subscripts, whose precise placement can depend on other
    // functions that precede them.
    defineFunctionBuilders({type:"supsub",htmlBuilder(group,options){// Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).
    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    const builderDelegate=htmlBuilderDelegate(group,options);if(builderDelegate){return builderDelegate(group,options);}const valueBase=group.base,valueSup=group.sup,valueSub=group.sub;const base=buildGroup(valueBase,options);let supm;let subm;const metrics=options.fontMetrics();// Rule 18a
    let supShift=0;let subShift=0;const isCharacterBox=valueBase&&utils.isCharacterBox(valueBase);if(valueSup){const newOptions=options.havingStyle(options.style.sup());supm=buildGroup(valueSup,newOptions,options);if(!isCharacterBox){supShift=base.height-newOptions.fontMetrics().supDrop*newOptions.sizeMultiplier/options.sizeMultiplier;}}if(valueSub){const newOptions=options.havingStyle(options.style.sub());subm=buildGroup(valueSub,newOptions,options);if(!isCharacterBox){subShift=base.depth+newOptions.fontMetrics().subDrop*newOptions.sizeMultiplier/options.sizeMultiplier;}}// Rule 18c
    let minSupShift;if(options.style===Style$1.DISPLAY){minSupShift=metrics.sup1;}else if(options.style.cramped){minSupShift=metrics.sup3;}else {minSupShift=metrics.sup2;}// scriptspace is a font-size-independent size, so scale it
    // appropriately for use as the marginRight.
    const multiplier=options.sizeMultiplier;const marginRight=0.5/metrics.ptPerEm/multiplier+"em";let marginLeft=null;if(subm){// Subscripts shouldn't be shifted by the base's italic correction.
    // Account for that by shifting the subscript back the appropriate
    // amount. Note we only do this when the base is a single symbol.
    const isOiint=group.base&&group.base.type==="op"&&group.base.name&&(group.base.name==="\\oiint"||group.base.name==="\\oiiint");if(base instanceof SymbolNode||isOiint){// $FlowFixMe
    marginLeft=-base.italic+"em";}}let supsub;if(supm&&subm){supShift=Math.max(supShift,minSupShift,supm.depth+0.25*metrics.xHeight);subShift=Math.max(subShift,metrics.sub2);const ruleWidth=metrics.defaultRuleThickness;// Rule 18e
    const maxWidth=4*ruleWidth;if(supShift-supm.depth-(subm.height-subShift)<maxWidth){subShift=maxWidth-(supShift-supm.depth)+subm.height;const psi=0.8*metrics.xHeight-(supShift-supm.depth);if(psi>0){supShift+=psi;subShift-=psi;}}const vlistElem=[{type:"elem",elem:subm,shift:subShift,marginRight,marginLeft},{type:"elem",elem:supm,shift:-supShift,marginRight}];supsub=buildCommon.makeVList({positionType:"individualShift",children:vlistElem},options);}else if(subm){// Rule 18b
    subShift=Math.max(subShift,metrics.sub1,subm.height-0.8*metrics.xHeight);const vlistElem=[{type:"elem",elem:subm,marginLeft,marginRight}];supsub=buildCommon.makeVList({positionType:"shift",positionData:subShift,children:vlistElem},options);}else if(supm){// Rule 18c, d
    supShift=Math.max(supShift,minSupShift,supm.depth+0.25*metrics.xHeight);supsub=buildCommon.makeVList({positionType:"shift",positionData:-supShift,children:[{type:"elem",elem:supm,marginRight}]},options);}else {throw new Error("supsub must have either sup or sub.");}// Wrap the supsub vlist in a span.msupsub to reset text-align.
    const mclass=getTypeOfDomTree(base,"right")||"mord";return buildCommon.makeSpan([mclass],[base,buildCommon.makeSpan(["msupsub"],[supsub])],options);},mathmlBuilder(group,options){// Is the inner group a relevant horizonal brace?
    let isBrace=false;let isOver;let isSup;if(group.base&&group.base.type==="horizBrace"){isSup=!!group.sup;if(isSup===group.base.isOver){isBrace=true;isOver=group.base.isOver;}}if(group.base&&(group.base.type==="op"||group.base.type==="operatorname")){group.base.parentIsSupSub=true;}const children=[buildGroup$1(group.base,options)];if(group.sub){children.push(buildGroup$1(group.sub,options));}if(group.sup){children.push(buildGroup$1(group.sup,options));}let nodeType;if(isBrace){nodeType=isOver?"mover":"munder";}else if(!group.sub){const base=group.base;if(base&&base.type==="op"&&base.limits&&(options.style===Style$1.DISPLAY||base.alwaysHandleSupSub)){nodeType="mover";}else if(base&&base.type==="operatorname"&&base.alwaysHandleSupSub&&(base.limits||options.style===Style$1.DISPLAY)){nodeType="mover";}else {nodeType="msup";}}else if(!group.sup){const base=group.base;if(base&&base.type==="op"&&base.limits&&(options.style===Style$1.DISPLAY||base.alwaysHandleSupSub)){nodeType="munder";}else if(base&&base.type==="operatorname"&&base.alwaysHandleSupSub&&(base.limits||options.style===Style$1.DISPLAY)){nodeType="munder";}else {nodeType="msub";}}else {const base=group.base;if(base&&base.type==="op"&&base.limits&&options.style===Style$1.DISPLAY){nodeType="munderover";}else if(base&&base.type==="operatorname"&&base.alwaysHandleSupSub&&(options.style===Style$1.DISPLAY||base.limits)){nodeType="munderover";}else {nodeType="msubsup";}}const node=new mathMLTree.MathNode(nodeType,children);return node;}});defineFunctionBuilders({type:"atom",htmlBuilder(group,options){return buildCommon.mathsym(group.text,group.mode,options,["m"+group.family]);},mathmlBuilder(group,options){const node=new mathMLTree.MathNode("mo",[makeText(group.text,group.mode)]);if(group.family==="bin"){const variant=getVariant(group,options);if(variant==="bold-italic"){node.setAttribute("mathvariant",variant);}}else if(group.family==="punct"){node.setAttribute("separator","true");}else if(group.family==="open"||group.family==="close"){// Delims built here should not stretch vertically.
    // See delimsizing.js for stretchy delims.
    node.setAttribute("stretchy","false");}return node;}});// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
    const defaultVariant={"mi":"italic","mn":"normal","mtext":"normal"};defineFunctionBuilders({type:"mathord",htmlBuilder(group,options){return buildCommon.makeOrd(group,options,"mathord");},mathmlBuilder(group,options){const node=new mathMLTree.MathNode("mi",[makeText(group.text,group.mode,options)]);const variant=getVariant(group,options)||"italic";if(variant!==defaultVariant[node.type]){node.setAttribute("mathvariant",variant);}return node;}});defineFunctionBuilders({type:"textord",htmlBuilder(group,options){return buildCommon.makeOrd(group,options,"textord");},mathmlBuilder(group,options){const text=makeText(group.text,group.mode,options);const variant=getVariant(group,options)||"normal";let node;if(group.mode==='text'){node=new mathMLTree.MathNode("mtext",[text]);}else if(/[0-9]/.test(group.text)){// TODO(kevinb) merge adjacent <mn> nodes
    // do it as a post processing step
    node=new mathMLTree.MathNode("mn",[text]);}else if(group.text==="\\prime"){node=new mathMLTree.MathNode("mo",[text]);}else {node=new mathMLTree.MathNode("mi",[text]);}if(variant!==defaultVariant[node.type]){node.setAttribute("mathvariant",variant);}return node;}});const cssSpace={"\\nobreak":"nobreak","\\allowbreak":"allowbreak"};// A lookup table to determine whether a spacing function/symbol should be
    // treated like a regular space character.  If a symbol or command is a key
    // in this table, then it should be a regular space character.  Furthermore,
    // the associated value may have a `className` specifying an extra CSS class
    // to add to the created `span`.
    const regularSpace={" ":{},"\\ ":{},"~":{className:"nobreak"},"\\space":{},"\\nobreakspace":{className:"nobreak"}};// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
    // src/symbols.js.
    defineFunctionBuilders({type:"spacing",htmlBuilder(group,options){if(regularSpace.hasOwnProperty(group.text)){const className=regularSpace[group.text].className||"";// Spaces are generated by adding an actual space. Each of these
    // things has an entry in the symbols table, so these will be turned
    // into appropriate outputs.
    if(group.mode==="text"){const ord=buildCommon.makeOrd(group,options,"textord");ord.classes.push(className);return ord;}else {return buildCommon.makeSpan(["mspace",className],[buildCommon.mathsym(group.text,group.mode,options)],options);}}else if(cssSpace.hasOwnProperty(group.text)){// Spaces based on just a CSS class.
    return buildCommon.makeSpan(["mspace",cssSpace[group.text]],[],options);}else {throw new ParseError(`Unknown type of space "${group.text}"`);}},mathmlBuilder(group,options){let node;if(regularSpace.hasOwnProperty(group.text)){node=new mathMLTree.MathNode("mtext",[new mathMLTree.TextNode("\u00a0")]);}else if(cssSpace.hasOwnProperty(group.text)){// CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
    return new mathMLTree.MathNode("mspace");}else {throw new ParseError(`Unknown type of space "${group.text}"`);}return node;}});const pad$1=()=>{const padNode=new mathMLTree.MathNode("mtd",[]);padNode.setAttribute("width","50%");return padNode;};defineFunctionBuilders({type:"tag",mathmlBuilder(group,options){const table=new mathMLTree.MathNode("mtable",[new mathMLTree.MathNode("mtr",[pad$1(),new mathMLTree.MathNode("mtd",[buildExpressionRow(group.body,options)]),pad$1(),new mathMLTree.MathNode("mtd",[buildExpressionRow(group.tag,options)])])]);table.setAttribute("width","100%");return table;// TODO: Left-aligned tags.
    // Currently, the group and options passed here do not contain
    // enough info to set tag alignment. `leqno` is in Settings but it is
    // not passed to Options. On the HTML side, leqno is
    // set by a CSS class applied in buildTree.js. That would have worked
    // in MathML if browsers supported <mlabeledtr>. Since they don't, we
    // need to rewrite the way this function is called.
    }});const textFontFamilies={"\\text":undefined,"\\textrm":"textrm","\\textsf":"textsf","\\texttt":"texttt","\\textnormal":"textrm"};const textFontWeights={"\\textbf":"textbf","\\textmd":"textmd"};const textFontShapes={"\\textit":"textit","\\textup":"textup"};const optionsWithFont=(group,options)=>{const font=group.font;// Checks if the argument is a font family or a font style.
    if(!font){return options;}else if(textFontFamilies[font]){return options.withTextFontFamily(textFontFamilies[font]);}else if(textFontWeights[font]){return options.withTextFontWeight(textFontWeights[font]);}else {return options.withTextFontShape(textFontShapes[font]);}};defineFunction({type:"text",names:[// Font families
    "\\text","\\textrm","\\textsf","\\texttt","\\textnormal",// Font weights
    "\\textbf","\\textmd",// Font Shapes
    "\\textit","\\textup"],props:{numArgs:1,argTypes:["text"],greediness:2,allowedInText:true},handler(_ref,args){let parser=_ref.parser,funcName=_ref.funcName;const body=args[0];return {type:"text",mode:parser.mode,body:ordargument(body),font:funcName};},htmlBuilder(group,options){const newOptions=optionsWithFont(group,options);const inner=buildExpression(group.body,newOptions,true);return buildCommon.makeSpan(["mord","text"],buildCommon.tryCombineChars(inner),newOptions);},mathmlBuilder(group,options){const newOptions=optionsWithFont(group,options);return buildExpressionRow(group.body,newOptions);}});defineFunction({type:"underline",names:["\\underline"],props:{numArgs:1,allowedInText:true},handler(_ref,args){let parser=_ref.parser;return {type:"underline",mode:parser.mode,body:args[0]};},htmlBuilder(group,options){// Underlines are handled in the TeXbook pg 443, Rule 10.
    // Build the inner group.
    const innerGroup=buildGroup(group.body,options);// Create the line to go below the body
    const line=buildCommon.makeLineSpan("underline-line",options);// Generate the vlist, with the appropriate kerns
    const defaultRuleThickness=options.fontMetrics().defaultRuleThickness;const vlist=buildCommon.makeVList({positionType:"top",positionData:innerGroup.height,children:[{type:"kern",size:defaultRuleThickness},{type:"elem",elem:line},{type:"kern",size:3*defaultRuleThickness},{type:"elem",elem:innerGroup}]},options);return buildCommon.makeSpan(["mord","underline"],[vlist],options);},mathmlBuilder(group,options){const operator=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode("\u203e")]);operator.setAttribute("stretchy","true");const node=new mathMLTree.MathNode("munder",[buildGroup$1(group.body,options),operator]);node.setAttribute("accentunder","true");return node;}});defineFunction({type:"verb",names:["\\verb"],props:{numArgs:0,allowedInText:true},handler(context,args,optArgs){// \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");},htmlBuilder(group,options){const text=makeVerb(group);const body=[];// \verb enters text mode and therefore is sized like \textstyle
    const newOptions=options.havingStyle(options.style.text());for(let i=0;i<text.length;i++){let c=text[i];if(c==='~'){c='\\textasciitilde';}body.push(buildCommon.makeSymbol(c,"Typewriter-Regular",group.mode,newOptions,["mord","texttt"]));}return buildCommon.makeSpan(["mord","text"].concat(newOptions.sizingClasses(options)),buildCommon.tryCombineChars(body),newOptions);},mathmlBuilder(group,options){const text=new mathMLTree.TextNode(makeVerb(group));const node=new mathMLTree.MathNode("mtext",[text]);node.setAttribute("mathvariant","monospace");return node;}});/**
     * Converts verb group into body string.
     *
     * \verb* replaces each space with an open box \u2423
     * \verb replaces each space with a no-break space \xA0
     */const makeVerb=group=>group.body.replace(/ /g,group.star?'\u2423':'\xA0');/** Include this to ensure that all functions are defined. */const functions=_functions;/**
     * The Lexer class handles tokenizing the input in various ways. Since our
     * parser expects us to be able to backtrack, the lexer allows lexing from any
     * given starting point.
     *
     * Its main exposed function is the `lex` function, which takes a position to
     * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
     * function.
     *
     * The various `_innerLex` functions perform the actual lexing of different
     * kinds.
     */ /* The following tokenRegex
     * - matches typical whitespace (but not NBSP etc.) using its first group
     * - does not match any control character \x00-\x1f except whitespace
     * - does not match a bare backslash
     * - matches any ASCII character except those just mentioned
     * - does not match the BMP private use area \uE000-\uF8FF
     * - does not match bare surrogate code units
     * - matches any BMP character except for those just described
     * - matches any valid Unicode surrogate pair
     * - matches a backslash followed by one or more letters
     * - matches a backslash followed by any BMP character, including newline
     * Just because the Lexer matches something doesn't mean it's valid input:
     * If there is no matching function or symbol definition, the Parser will
     * still reject the input.
     */const spaceRegexString="[ \r\n\t]";const controlWordRegexString="\\\\[a-zA-Z@]+";const controlSymbolRegexString="\\\\[^\uD800-\uDFFF]";const controlWordWhitespaceRegexString=`${controlWordRegexString}${spaceRegexString}*`;const controlWordWhitespaceRegex=new RegExp(`^(${controlWordRegexString})${spaceRegexString}*$`);const combiningDiacriticalMarkString="[\u0300-\u036f]";const combiningDiacriticalMarksEndRegex=new RegExp(`${combiningDiacriticalMarkString}+$`);const tokenRegexString=`(${spaceRegexString}+)|`+// whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]"+// single codepoint
`${combiningDiacriticalMarkString}*`    +// ...plus accents
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]"+// surrogate pair
`${combiningDiacriticalMarkString}*`    +// ...plus accents
    "|\\\\verb\\*([^]).*?\\3"+// \verb*
    "|\\\\verb([^*a-zA-Z]).*?\\4"+// \verb unstarred
    "|\\\\operatorname\\*"+// \operatorname*
`|${controlWordWhitespaceRegexString}`    +// \macroName + spaces
`|${controlSymbolRegexString})`    ;// \\, \', etc.
    /** Main Lexer class */class Lexer{// category codes, only supports comment characters (14) for now
    constructor(input,settings){this.input=void 0;this.settings=void 0;this.tokenRegex=void 0;this.catcodes=void 0;// Separate accents from characters
    this.input=input;this.settings=settings;this.tokenRegex=new RegExp(tokenRegexString,'g');this.catcodes={"%":14// comment character
    };}setCatcode(char,code){this.catcodes[char]=code;}/**
       * This function lexes a single token.
       */lex(){const input=this.input;const pos=this.tokenRegex.lastIndex;if(pos===input.length){return new Token("EOF",new SourceLocation(this,pos,pos));}const match=this.tokenRegex.exec(input);if(match===null||match.index!==pos){throw new ParseError(`Unexpected character: '${input[pos]}'`,new Token(input[pos],new SourceLocation(this,pos,pos+1)));}let text=match[2]||" ";if(this.catcodes[text]===14){// comment character
    const nlIndex=input.indexOf('\n',this.tokenRegex.lastIndex);if(nlIndex===-1){this.tokenRegex.lastIndex=input.length;// EOF
    this.settings.reportNonstrict("commentAtEnd","% comment has no terminating newline; LaTeX would "+"fail because of commenting the end of math mode (e.g. $)");}else {this.tokenRegex.lastIndex=nlIndex+1;}return this.lex();}// Trim any trailing whitespace from control word match
    const controlMatch=text.match(controlWordWhitespaceRegex);if(controlMatch){text=controlMatch[1];}return new Token(text,new SourceLocation(this,pos,this.tokenRegex.lastIndex));}}/**
     * A `Namespace` refers to a space of nameable things like macros or lengths,
     * which can be `set` either globally or local to a nested group, using an
     * undo stack similar to how TeX implements this functionality.
     * Performance-wise, `get` and local `set` take constant time, while global
     * `set` takes time proportional to the depth of group nesting.
     */class Namespace{/**
       * Both arguments are optional.  The first argument is an object of
       * built-in mappings which never change.  The second argument is an object
       * of initial (global-level) mappings, which will constantly change
       * according to any global/top-level `set`s done.
       */constructor(builtins,globalMacros){if(builtins===void 0){builtins={};}if(globalMacros===void 0){globalMacros={};}this.current=void 0;this.builtins=void 0;this.undefStack=void 0;this.current=globalMacros;this.builtins=builtins;this.undefStack=[];}/**
       * Start a new nested group, affecting future local `set`s.
       */beginGroup(){this.undefStack.push({});}/**
       * End current nested group, restoring values before the group began.
       */endGroup(){if(this.undefStack.length===0){throw new ParseError("Unbalanced namespace destruction: attempt "+"to pop global namespace; please report this as a bug");}const undefs=this.undefStack.pop();for(const undef in undefs){if(undefs.hasOwnProperty(undef)){if(undefs[undef]===undefined){delete this.current[undef];}else {this.current[undef]=undefs[undef];}}}}/**
       * Detect whether `name` has a definition.  Equivalent to
       * `get(name) != null`.
       */has(name){return this.current.hasOwnProperty(name)||this.builtins.hasOwnProperty(name);}/**
       * Get the current value of a name, or `undefined` if there is no value.
       *
       * Note: Do not use `if (namespace.get(...))` to detect whether a macro
       * is defined, as the definition may be the empty string which evaluates
       * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
       * `if (namespace.has(...))`.
       */get(name){if(this.current.hasOwnProperty(name)){return this.current[name];}else {return this.builtins[name];}}/**
       * Set the current value of a name, and optionally set it globally too.
       * Local set() sets the current value and (when appropriate) adds an undo
       * operation to the undo stack.  Global set() may change the undo
       * operation at every level, so takes time linear in their number.
       */set(name,value,global){if(global===void 0){global=false;}if(global){// Global set is equivalent to setting in all groups.  Simulate this
    // by destroying any undos currently scheduled for this name,
    // and adding an undo with the *new* value (in case it later gets
    // locally reset within this environment).
    for(let i=0;i<this.undefStack.length;i++){delete this.undefStack[i][name];}if(this.undefStack.length>0){this.undefStack[this.undefStack.length-1][name]=value;}}else {// Undo this set at end of this group (possibly to `undefined`),
    // unless an undo is already in place, in which case that older
    // value is the correct one.
    const top=this.undefStack[this.undefStack.length-1];if(top&&!top.hasOwnProperty(name)){top[name]=this.current[name];}}this.current[name]=value;}}/**
     * Predefined macros for KaTeX.
     * This can be used to define some commands in terms of others.
     */const builtinMacros={};function defineMacro(name,body){builtinMacros[name]=body;}//////////////////////////////////////////////////////////////////////
    // macro tools
    defineMacro("\\noexpand",function(context){// The expansion is the token itself; but that token is interpreted
    // as if its meaning were \relax if it is a control sequence that
    // would ordinarily be expanded by TeXs expansion rules.
    const t=context.popToken();if(context.isExpandable(t.text)){t.noexpand=true;t.treatAsRelax=true;}return {tokens:[t],numArgs:0};});defineMacro("\\expandafter",function(context){// TeX first reads the token that comes immediately after \expandafter,
    // without expanding it; lets call this token t. Then TeX reads the
    // token that comes after t (and possibly more tokens, if that token
    // has an argument), replacing it by its expansion. Finally TeX puts
    // t back in front of that expansion.
    const t=context.popToken();context.expandOnce(true);// expand only an expandable token
    return {tokens:[t],numArgs:0};});// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
    // TeX source: \long\def\@firstoftwo#1#2{#1}
    defineMacro("\\@firstoftwo",function(context){const args=context.consumeArgs(2);return {tokens:args[0],numArgs:0};});// LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
    // TeX source: \long\def\@secondoftwo#1#2{#2}
    defineMacro("\\@secondoftwo",function(context){const args=context.consumeArgs(2);return {tokens:args[1],numArgs:0};});// LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
    // symbol that isn't a space, consuming any spaces but not consuming the
    // first nonspace character.  If that nonspace character matches #1, then
    // the macro expands to #2; otherwise, it expands to #3.
    defineMacro("\\@ifnextchar",function(context){const args=context.consumeArgs(3);// symbol, if, else
    context.consumeSpaces();const nextToken=context.future();if(args[0].length===1&&args[0][0].text===nextToken.text){return {tokens:args[1],numArgs:0};}else {return {tokens:args[2],numArgs:0};}});// LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
    // If it is `*`, then it consumes the symbol, and the macro expands to #1;
    // otherwise, the macro expands to #2 (without consuming the symbol).
    // TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
    defineMacro("\\@ifstar","\\@ifnextchar *{\\@firstoftwo{#1}}");// LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
    defineMacro("\\TextOrMath",function(context){const args=context.consumeArgs(2);if(context.mode==='text'){return {tokens:args[0],numArgs:0};}else {return {tokens:args[1],numArgs:0};}});// Lookup table for parsing numbers in base 8 through 16
    const digitToNumber={"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"a":10,"A":10,"b":11,"B":11,"c":12,"C":12,"d":13,"D":13,"e":14,"E":14,"f":15,"F":15};// TeX \char makes a literal character (catcode 12) using the following forms:
    // (see The TeXBook, p. 43)
    //   \char123  -- decimal
    //   \char'123 -- octal
    //   \char"123 -- hex
    //   \char`x   -- character that can be written (i.e. isn't active)
    //   \char`\x  -- character that cannot be written (e.g. %)
    // These all refer to characters from the font, so we turn them into special
    // calls to a function \@char dealt with in the Parser.
    defineMacro("\\char",function(context){let token=context.popToken();let base;let number='';if(token.text==="'"){base=8;token=context.popToken();}else if(token.text==='"'){base=16;token=context.popToken();}else if(token.text==="`"){token=context.popToken();if(token.text[0]==="\\"){number=token.text.charCodeAt(1);}else if(token.text==="EOF"){throw new ParseError("\\char` missing argument");}else {number=token.text.charCodeAt(0);}}else {base=10;}if(base){// Parse a number in the given base, starting with first `token`.
    number=digitToNumber[token.text];if(number==null||number>=base){throw new ParseError(`Invalid base-${base} digit ${token.text}`);}let digit;while((digit=digitToNumber[context.future().text])!=null&&digit<base){number*=base;number+=digit;context.popToken();}}return `\\@char{${number}}`;});// \newcommand{\macro}[args]{definition}
    // \renewcommand{\macro}[args]{definition}
    // TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}
    const newcommand=(context,existsOK,nonexistsOK)=>{let arg=context.consumeArgs(1)[0];if(arg.length!==1){throw new ParseError("\\newcommand's first argument must be a macro name");}const name=arg[0].text;const exists=context.isDefined(name);if(exists&&!existsOK){throw new ParseError(`\\newcommand{${name}} attempting to redefine `+`${name}; use \\renewcommand`);}if(!exists&&!nonexistsOK){throw new ParseError(`\\renewcommand{${name}} when command ${name} `+`does not yet exist; use \\newcommand`);}let numArgs=0;arg=context.consumeArgs(1)[0];if(arg.length===1&&arg[0].text==="["){let argText='';let token=context.expandNextToken();while(token.text!=="]"&&token.text!=="EOF"){// TODO: Should properly expand arg, e.g., ignore {}s
    argText+=token.text;token=context.expandNextToken();}if(!argText.match(/^\s*[0-9]+\s*$/)){throw new ParseError(`Invalid number of arguments: ${argText}`);}numArgs=parseInt(argText);arg=context.consumeArgs(1)[0];}// Final arg is the expansion of the macro
    context.macros.set(name,{tokens:arg,numArgs});return '';};defineMacro("\\newcommand",context=>newcommand(context,false,true));defineMacro("\\renewcommand",context=>newcommand(context,true,false));defineMacro("\\providecommand",context=>newcommand(context,true,true));// terminal (console) tools
    defineMacro("\\message",context=>{const arg=context.consumeArgs(1)[0];// eslint-disable-next-line no-console
    console.log(arg.reverse().map(token=>token.text).join(""));return '';});defineMacro("\\errmessage",context=>{const arg=context.consumeArgs(1)[0];// eslint-disable-next-line no-console
    console.error(arg.reverse().map(token=>token.text).join(""));return '';});defineMacro("\\show",context=>{const tok=context.popToken();const name=tok.text;// eslint-disable-next-line no-console
    console.log(tok,context.macros.get(name),functions[name],symbols.math[name],symbols.text[name]);return '';});//////////////////////////////////////////////////////////////////////
    // Grouping
    // \let\bgroup={ \let\egroup=}
    defineMacro("\\bgroup","{");defineMacro("\\egroup","}");// Symbols from latex.ltx:
    // \def\lq{`}
    // \def\rq{'}
    // \def \aa {\r a}
    // \def \AA {\r A}
    defineMacro("\\lq","`");defineMacro("\\rq","'");defineMacro("\\aa","\\r a");defineMacro("\\AA","\\r A");// Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
    // \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
    // \DeclareTextCommandDefault{\textregistered}{\textcircled{%
    //      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
    // \DeclareRobustCommand{\copyright}{%
    //    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}
    defineMacro("\\textcopyright","\\html@mathml{\\textcircled{c}}{\\char`}");defineMacro("\\copyright","\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");defineMacro("\\textregistered","\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");// Characters omitted from Unicode range 1D4001D7FF
    defineMacro("\u212C","\\mathscr{B}");// script
    defineMacro("\u2130","\\mathscr{E}");defineMacro("\u2131","\\mathscr{F}");defineMacro("\u210B","\\mathscr{H}");defineMacro("\u2110","\\mathscr{I}");defineMacro("\u2112","\\mathscr{L}");defineMacro("\u2133","\\mathscr{M}");defineMacro("\u211B","\\mathscr{R}");defineMacro("\u212D","\\mathfrak{C}");// Fraktur
    defineMacro("\u210C","\\mathfrak{H}");defineMacro("\u2128","\\mathfrak{Z}");// Define \Bbbk with a macro that works in both HTML and MathML.
    defineMacro("\\Bbbk","\\Bbb{k}");// Unicode middle dot
    // The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
    // the dot at U+22C5 and gives it punct spacing.
    defineMacro("\u00b7","\\cdotp");// \llap and \rlap render their contents in text mode
    defineMacro("\\llap","\\mathllap{\\textrm{#1}}");defineMacro("\\rlap","\\mathrlap{\\textrm{#1}}");defineMacro("\\clap","\\mathclap{\\textrm{#1}}");// \not is defined by base/fontmath.ltx via
    // \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
    // It's thus treated like a \mathrel, but defined by a symbol that has zero
    // width but extends to the right.  We use \rlap to get that spacing.
    // For MathML we write U+0338 here. buildMathML.js will then do the overlay.
    defineMacro("\\not",'\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');// Negated symbols from base/fontmath.ltx:
    // \def\neq{\not=} \let\ne=\neq
    // \DeclareRobustCommand
    //   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
    // \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}
    defineMacro("\\neq","\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");defineMacro("\\ne","\\neq");defineMacro("\u2260","\\neq");defineMacro("\\notin","\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}"+"{\\mathrel{\\char`}}");defineMacro("\u2209","\\notin");// Unicode stacked relations
    defineMacro("\u2258","\\html@mathml{"+"\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}"+"}{\\mathrel{\\char`\u2258}}");defineMacro("\u2259","\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");defineMacro("\u225A","\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");defineMacro("\u225B","\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}"+"{\\mathrel{\\char`\u225B}}");defineMacro("\u225D","\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}"+"{\\mathrel{\\char`\u225D}}");defineMacro("\u225E","\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}"+"{\\mathrel{\\char`\u225E}}");defineMacro("\u225F","\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");// Misc Unicode
    defineMacro("\u27C2","\\perp");defineMacro("\u203C","\\mathclose{!\\mkern-0.8mu!}");defineMacro("\u220C","\\notni");defineMacro("\u231C","\\ulcorner");defineMacro("\u231D","\\urcorner");defineMacro("\u231E","\\llcorner");defineMacro("\u231F","\\lrcorner");defineMacro("\u00A9","\\copyright");defineMacro("\u00AE","\\textregistered");defineMacro("\uFE0F","\\textregistered");// The KaTeX fonts have corners at codepoints that don't match Unicode.
    // For MathML purposes, use the Unicode code point.
    defineMacro("\\ulcorner","\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}");defineMacro("\\urcorner","\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}");defineMacro("\\llcorner","\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}");defineMacro("\\lrcorner","\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}");//////////////////////////////////////////////////////////////////////
    // LaTeX_2
    // \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
    // \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
    // We'll call \varvdots, which gets a glyph from symbols.js.
    // The zero-width rule gets us an equivalent to the vertical 6pt kern.
    defineMacro("\\vdots","\\mathord{\\varvdots\\rule{0pt}{15pt}}");defineMacro("\u22ee","\\vdots");//////////////////////////////////////////////////////////////////////
    // amsmath.sty
    // http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
    // Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
    // but they are equivalent to \mathit{\Letter}.
    defineMacro("\\varGamma","\\mathit{\\Gamma}");defineMacro("\\varDelta","\\mathit{\\Delta}");defineMacro("\\varTheta","\\mathit{\\Theta}");defineMacro("\\varLambda","\\mathit{\\Lambda}");defineMacro("\\varXi","\\mathit{\\Xi}");defineMacro("\\varPi","\\mathit{\\Pi}");defineMacro("\\varSigma","\\mathit{\\Sigma}");defineMacro("\\varUpsilon","\\mathit{\\Upsilon}");defineMacro("\\varPhi","\\mathit{\\Phi}");defineMacro("\\varPsi","\\mathit{\\Psi}");defineMacro("\\varOmega","\\mathit{\\Omega}");//\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
    defineMacro("\\substack","\\begin{subarray}{c}#1\\end{subarray}");// \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
    // \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}
    defineMacro("\\colon","\\nobreak\\mskip2mu\\mathpunct{}"+"\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");// \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}
    defineMacro("\\boxed","\\fbox{$\\displaystyle{#1}$}");// \def\iff{\DOTSB\;\Longleftrightarrow\;}
    // \def\implies{\DOTSB\;\Longrightarrow\;}
    // \def\impliedby{\DOTSB\;\Longleftarrow\;}
    defineMacro("\\iff","\\DOTSB\\;\\Longleftrightarrow\\;");defineMacro("\\implies","\\DOTSB\\;\\Longrightarrow\\;");defineMacro("\\impliedby","\\DOTSB\\;\\Longleftarrow\\;");// AMSMath's automatic \dots, based on \mdots@@ macro.
    const dotsByToken={',':'\\dotsc','\\not':'\\dotsb',// \keybin@ checks for the following:
    '+':'\\dotsb','=':'\\dotsb','<':'\\dotsb','>':'\\dotsb','-':'\\dotsb','*':'\\dotsb',':':'\\dotsb',// Symbols whose definition starts with \DOTSB:
    '\\DOTSB':'\\dotsb','\\coprod':'\\dotsb','\\bigvee':'\\dotsb','\\bigwedge':'\\dotsb','\\biguplus':'\\dotsb','\\bigcap':'\\dotsb','\\bigcup':'\\dotsb','\\prod':'\\dotsb','\\sum':'\\dotsb','\\bigotimes':'\\dotsb','\\bigoplus':'\\dotsb','\\bigodot':'\\dotsb','\\bigsqcup':'\\dotsb','\\And':'\\dotsb','\\longrightarrow':'\\dotsb','\\Longrightarrow':'\\dotsb','\\longleftarrow':'\\dotsb','\\Longleftarrow':'\\dotsb','\\longleftrightarrow':'\\dotsb','\\Longleftrightarrow':'\\dotsb','\\mapsto':'\\dotsb','\\longmapsto':'\\dotsb','\\hookrightarrow':'\\dotsb','\\doteq':'\\dotsb',// Symbols whose definition starts with \mathbin:
    '\\mathbin':'\\dotsb',// Symbols whose definition starts with \mathrel:
    '\\mathrel':'\\dotsb','\\relbar':'\\dotsb','\\Relbar':'\\dotsb','\\xrightarrow':'\\dotsb','\\xleftarrow':'\\dotsb',// Symbols whose definition starts with \DOTSI:
    '\\DOTSI':'\\dotsi','\\int':'\\dotsi','\\oint':'\\dotsi','\\iint':'\\dotsi','\\iiint':'\\dotsi','\\iiiint':'\\dotsi','\\idotsint':'\\dotsi',// Symbols whose definition starts with \DOTSX:
    '\\DOTSX':'\\dotsx'};defineMacro("\\dots",function(context){// TODO: If used in text mode, should expand to \textellipsis.
    // However, in KaTeX, \textellipsis and \ldots behave the same
    // (in text mode), and it's unlikely we'd see any of the math commands
    // that affect the behavior of \dots when in text mode.  So fine for now
    // (until we support \ifmmode ... \else ... \fi).
    let thedots='\\dotso';const next=context.expandAfterFuture().text;if(next in dotsByToken){thedots=dotsByToken[next];}else if(next.substr(0,4)==='\\not'){thedots='\\dotsb';}else if(next in symbols.math){if(utils.contains(['bin','rel'],symbols.math[next].group)){thedots='\\dotsb';}}return thedots;});const spaceAfterDots={// \rightdelim@ checks for the following:
    ')':true,']':true,'\\rbrack':true,'\\}':true,'\\rbrace':true,'\\rangle':true,'\\rceil':true,'\\rfloor':true,'\\rgroup':true,'\\rmoustache':true,'\\right':true,'\\bigr':true,'\\biggr':true,'\\Bigr':true,'\\Biggr':true,// \extra@ also tests for the following:
    '$':true,// \extrap@ checks for the following:
    ';':true,'.':true,',':true};defineMacro("\\dotso",function(context){const next=context.future().text;if(next in spaceAfterDots){return "\\ldots\\,";}else {return "\\ldots";}});defineMacro("\\dotsc",function(context){const next=context.future().text;// \dotsc uses \extra@ but not \extrap@, instead specially checking for
    // ';' and '.', but doesn't check for ','.
    if(next in spaceAfterDots&&next!==','){return "\\ldots\\,";}else {return "\\ldots";}});defineMacro("\\cdots",function(context){const next=context.future().text;if(next in spaceAfterDots){return "\\@cdots\\,";}else {return "\\@cdots";}});defineMacro("\\dotsb","\\cdots");defineMacro("\\dotsm","\\cdots");defineMacro("\\dotsi","\\!\\cdots");// amsmath doesn't actually define \dotsx, but \dots followed by a macro
    // starting with \DOTSX implies \dotso, and then \extra@ detects this case
    // and forces the added `\,`.
    defineMacro("\\dotsx","\\ldots\\,");// \let\DOTSI\relax
    // \let\DOTSB\relax
    // \let\DOTSX\relax
    defineMacro("\\DOTSI","\\relax");defineMacro("\\DOTSB","\\relax");defineMacro("\\DOTSX","\\relax");// Spacing, based on amsmath.sty's override of LaTeX defaults
    // \DeclareRobustCommand{\tmspace}[3]{%
    //   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
    defineMacro("\\tmspace","\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");// \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
    // TODO: math mode should use \thinmuskip
    defineMacro("\\,","\\tmspace+{3mu}{.1667em}");// \let\thinspace\,
    defineMacro("\\thinspace","\\,");// \def\>{\mskip\medmuskip}
    // \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
    // TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
    defineMacro("\\>","\\mskip{4mu}");defineMacro("\\:","\\tmspace+{4mu}{.2222em}");// \let\medspace\:
    defineMacro("\\medspace","\\:");// \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
    // TODO: math mode should use \thickmuskip = 5mu plus 5mu
    defineMacro("\\;","\\tmspace+{5mu}{.2777em}");// \let\thickspace\;
    defineMacro("\\thickspace","\\;");// \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
    // TODO: math mode should use \thinmuskip
    defineMacro("\\!","\\tmspace-{3mu}{.1667em}");// \let\negthinspace\!
    defineMacro("\\negthinspace","\\!");// \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
    // TODO: math mode should use \medmuskip
    defineMacro("\\negmedspace","\\tmspace-{4mu}{.2222em}");// \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
    // TODO: math mode should use \thickmuskip
    defineMacro("\\negthickspace","\\tmspace-{5mu}{.277em}");// \def\enspace{\kern.5em }
    defineMacro("\\enspace","\\kern.5em ");// \def\enskip{\hskip.5em\relax}
    defineMacro("\\enskip","\\hskip.5em\\relax");// \def\quad{\hskip1em\relax}
    defineMacro("\\quad","\\hskip1em\\relax");// \def\qquad{\hskip2em\relax}
    defineMacro("\\qquad","\\hskip2em\\relax");// \tag@in@display form of \tag
    defineMacro("\\tag","\\@ifstar\\tag@literal\\tag@paren");defineMacro("\\tag@paren","\\tag@literal{({#1})}");defineMacro("\\tag@literal",context=>{if(context.macros.get("\\df@tag")){throw new ParseError("Multiple \\tag");}return "\\gdef\\df@tag{\\text{#1}}";});// \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
    //   {\operator@font mod}\penalty900
    //   \mkern5mu\nonscript\mskip-\medmuskip}
    // \newcommand{\pod}[1]{\allowbreak
    //   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
    // \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
    // \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
    //   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
    // TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
    defineMacro("\\bmod","\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"+"\\mathbin{\\rm mod}"+"\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");defineMacro("\\pod","\\allowbreak"+"\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");defineMacro("\\pmod","\\pod{{\\rm mod}\\mkern6mu#1}");defineMacro("\\mod","\\allowbreak"+"\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}"+"{\\rm mod}\\,\\,#1");// \pmb    --   A simulation of bold.
    // The version in ambsy.sty works by typesetting three copies of the argument
    // with small offsets. We use two copies. We omit the vertical offset because
    // of rendering problems that makeVList encounters in Safari.
    defineMacro("\\pmb","\\html@mathml{"+"\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}"+"{\\mathbf{#1}}");//////////////////////////////////////////////////////////////////////
    // LaTeX source2e
    // \\ defaults to \newline, but changes to \cr within array environment
    defineMacro("\\\\","\\newline");// \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
    // TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
    // support \@ yet, so that's omitted, and we add \text so that the result
    // doesn't look funny in math mode.
    defineMacro("\\TeX","\\textrm{\\html@mathml{"+"T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX"+"}{TeX}}");// \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
    //         {\sbox\z@ T%
    //          \vbox to\ht\z@{\hbox{\check@mathfonts
    //                               \fontsize\sf@size\z@
    //                               \math@fontsfalse\selectfont
    //                               A}%
    //                         \vss}%
    //         }%
    //         \kern-.15em%
    //         \TeX}
    // This code aligns the top of the A with the T (from the perspective of TeX's
    // boxes, though visually the A appears to extend above slightly).
    // We compute the corresponding \raisebox when A is rendered in \normalsize
    // \scriptstyle, which has a scale factor of 0.7 (see Options.js).
    const latexRaiseA=metricMap['Main-Regular']["T".charCodeAt(0)][1]-0.7*metricMap['Main-Regular']["A".charCodeAt(0)][1]+"em";defineMacro("\\LaTeX","\\textrm{\\html@mathml{"+`L\\kern-.36em\\raisebox{${latexRaiseA}}{\\scriptstyle A}`+"\\kern-.15em\\TeX}{LaTeX}}");// New KaTeX logo based on tweaking LaTeX logo
    defineMacro("\\KaTeX","\\textrm{\\html@mathml{"+`K\\kern-.17em\\raisebox{${latexRaiseA}}{\\scriptstyle A}`+"\\kern-.15em\\TeX}{KaTeX}}");// \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
    // \def\@hspace#1{\hskip  #1\relax}
    // \def\@hspacer#1{\vrule \@width\z@\nobreak
    //                 \hskip #1\hskip \z@skip}
    defineMacro("\\hspace","\\@ifstar\\@hspacer\\@hspace");defineMacro("\\@hspace","\\hskip #1\\relax");defineMacro("\\@hspacer","\\rule{0pt}{0pt}\\hskip #1\\relax");//////////////////////////////////////////////////////////////////////
    // mathtools.sty
    //\providecommand\ordinarycolon{:}
    defineMacro("\\ordinarycolon",":");//\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
    //TODO(edemaine): Not yet centered. Fix via \raisebox or #726
    defineMacro("\\vcentcolon","\\mathrel{\\mathop\\ordinarycolon}");// \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}
    defineMacro("\\dblcolon","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}"+"{\\mathop{\\char\"2237}}");// \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}
    defineMacro("\\coloneqq","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}"+"{\\mathop{\\char\"2254}}");// 
    // \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}
    defineMacro("\\Coloneqq","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}"+"{\\mathop{\\char\"2237\\char\"3d}}");// \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
    defineMacro("\\coloneq","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}"+"{\\mathop{\\char\"3a\\char\"2212}}");// \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
    defineMacro("\\Coloneq","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}"+"{\\mathop{\\char\"2237\\char\"2212}}");// \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}
    defineMacro("\\eqqcolon","\\html@mathml{"+"\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}"+"{\\mathop{\\char\"2255}}");// 
    // \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
    defineMacro("\\Eqqcolon","\\html@mathml{"+"\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}"+"{\\mathop{\\char\"3d\\char\"2237}}");// \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}
    defineMacro("\\eqcolon","\\html@mathml{"+"\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}"+"{\\mathop{\\char\"2239}}");// \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
    defineMacro("\\Eqcolon","\\html@mathml{"+"\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}"+"{\\mathop{\\char\"2212\\char\"2237}}");// \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
    defineMacro("\\colonapprox","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}"+"{\\mathop{\\char\"3a\\char\"2248}}");// \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
    defineMacro("\\Colonapprox","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}"+"{\\mathop{\\char\"2237\\char\"2248}}");// \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
    defineMacro("\\colonsim","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}"+"{\\mathop{\\char\"3a\\char\"223c}}");// \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
    defineMacro("\\Colonsim","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}"+"{\\mathop{\\char\"2237\\char\"223c}}");// Some Unicode characters are implemented with macros to mathtools functions.
    defineMacro("\u2237","\\dblcolon");// ::
    defineMacro("\u2239","\\eqcolon");// -:
    defineMacro("\u2254","\\coloneqq");// :=
    defineMacro("\u2255","\\eqqcolon");// =:
    defineMacro("\u2A74","\\Coloneqq");// ::=
    //////////////////////////////////////////////////////////////////////
    // colonequals.sty
    // Alternate names for mathtools's macros:
    defineMacro("\\ratio","\\vcentcolon");defineMacro("\\coloncolon","\\dblcolon");defineMacro("\\colonequals","\\coloneqq");defineMacro("\\coloncolonequals","\\Coloneqq");defineMacro("\\equalscolon","\\eqqcolon");defineMacro("\\equalscoloncolon","\\Eqqcolon");defineMacro("\\colonminus","\\coloneq");defineMacro("\\coloncolonminus","\\Coloneq");defineMacro("\\minuscolon","\\eqcolon");defineMacro("\\minuscoloncolon","\\Eqcolon");// \colonapprox name is same in mathtools and colonequals.
    defineMacro("\\coloncolonapprox","\\Colonapprox");// \colonsim name is same in mathtools and colonequals.
    defineMacro("\\coloncolonsim","\\Colonsim");// Additional macros, implemented by analogy with mathtools definitions:
    defineMacro("\\simcolon","\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");defineMacro("\\simcoloncolon","\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");defineMacro("\\approxcolon","\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");defineMacro("\\approxcoloncolon","\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");// Present in newtxmath, pxfonts and txfonts
    defineMacro("\\notni","\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");defineMacro("\\limsup","\\DOTSB\\operatorname*{lim\\,sup}");defineMacro("\\liminf","\\DOTSB\\operatorname*{lim\\,inf}");//////////////////////////////////////////////////////////////////////
    // MathML alternates for KaTeX glyphs in the Unicode private area
    defineMacro("\\gvertneqq","\\html@mathml{\\@gvertneqq}{\u2269}");defineMacro("\\lvertneqq","\\html@mathml{\\@lvertneqq}{\u2268}");defineMacro("\\ngeqq","\\html@mathml{\\@ngeqq}{\u2271}");defineMacro("\\ngeqslant","\\html@mathml{\\@ngeqslant}{\u2271}");defineMacro("\\nleqq","\\html@mathml{\\@nleqq}{\u2270}");defineMacro("\\nleqslant","\\html@mathml{\\@nleqslant}{\u2270}");defineMacro("\\nshortmid","\\html@mathml{\\@nshortmid}{}");defineMacro("\\nshortparallel","\\html@mathml{\\@nshortparallel}{}");defineMacro("\\nsubseteqq","\\html@mathml{\\@nsubseteqq}{\u2288}");defineMacro("\\nsupseteqq","\\html@mathml{\\@nsupseteqq}{\u2289}");defineMacro("\\varsubsetneq","\\html@mathml{\\@varsubsetneq}{}");defineMacro("\\varsubsetneqq","\\html@mathml{\\@varsubsetneqq}{}");defineMacro("\\varsupsetneq","\\html@mathml{\\@varsupsetneq}{}");defineMacro("\\varsupsetneqq","\\html@mathml{\\@varsupsetneqq}{}");defineMacro("\\imath","\\html@mathml{\\@imath}{\u0131}");defineMacro("\\jmath","\\html@mathml{\\@jmath}{\u0237}");//////////////////////////////////////////////////////////////////////
    // stmaryrd and semantic
    // The stmaryrd and semantic packages render the next four items by calling a
    // glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.
    defineMacro("\\llbracket","\\html@mathml{"+"\\mathopen{[\\mkern-3.2mu[}}"+"{\\mathopen{\\char`\u27e6}}");defineMacro("\\rrbracket","\\html@mathml{"+"\\mathclose{]\\mkern-3.2mu]}}"+"{\\mathclose{\\char`\u27e7}}");defineMacro("\u27e6","\\llbracket");// blackboard bold [
    defineMacro("\u27e7","\\rrbracket");// blackboard bold ]
    defineMacro("\\lBrace","\\html@mathml{"+"\\mathopen{\\{\\mkern-3.2mu[}}"+"{\\mathopen{\\char`\u2983}}");defineMacro("\\rBrace","\\html@mathml{"+"\\mathclose{]\\mkern-3.2mu\\}}}"+"{\\mathclose{\\char`\u2984}}");defineMacro("\u2983","\\lBrace");// blackboard bold {
    defineMacro("\u2984","\\rBrace");// blackboard bold }
    // TODO: Create variable sized versions of the last two items. I believe that
    // will require new font glyphs.
    // The stmaryrd function `\minuso` provides a "Plimsoll" symbol that
    // superimposes the characters \circ and \mathminus. Used in chemistry.
    defineMacro("\\minuso","\\mathbin{\\html@mathml{"+"{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}"+"{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}"+"{\\char`}}");defineMacro("","\\minuso");//////////////////////////////////////////////////////////////////////
    // texvc.sty
    // The texvc package contains macros available in mediawiki pages.
    // We omit the functions deprecated at
    // https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
    // We also omit texvc's \O, which conflicts with \text{\O}
    defineMacro("\\darr","\\downarrow");defineMacro("\\dArr","\\Downarrow");defineMacro("\\Darr","\\Downarrow");defineMacro("\\lang","\\langle");defineMacro("\\rang","\\rangle");defineMacro("\\uarr","\\uparrow");defineMacro("\\uArr","\\Uparrow");defineMacro("\\Uarr","\\Uparrow");defineMacro("\\N","\\mathbb{N}");defineMacro("\\R","\\mathbb{R}");defineMacro("\\Z","\\mathbb{Z}");defineMacro("\\alef","\\aleph");defineMacro("\\alefsym","\\aleph");defineMacro("\\Alpha","\\mathrm{A}");defineMacro("\\Beta","\\mathrm{B}");defineMacro("\\bull","\\bullet");defineMacro("\\Chi","\\mathrm{X}");defineMacro("\\clubs","\\clubsuit");defineMacro("\\cnums","\\mathbb{C}");defineMacro("\\Complex","\\mathbb{C}");defineMacro("\\Dagger","\\ddagger");defineMacro("\\diamonds","\\diamondsuit");defineMacro("\\empty","\\emptyset");defineMacro("\\Epsilon","\\mathrm{E}");defineMacro("\\Eta","\\mathrm{H}");defineMacro("\\exist","\\exists");defineMacro("\\harr","\\leftrightarrow");defineMacro("\\hArr","\\Leftrightarrow");defineMacro("\\Harr","\\Leftrightarrow");defineMacro("\\hearts","\\heartsuit");defineMacro("\\image","\\Im");defineMacro("\\infin","\\infty");defineMacro("\\Iota","\\mathrm{I}");defineMacro("\\isin","\\in");defineMacro("\\Kappa","\\mathrm{K}");defineMacro("\\larr","\\leftarrow");defineMacro("\\lArr","\\Leftarrow");defineMacro("\\Larr","\\Leftarrow");defineMacro("\\lrarr","\\leftrightarrow");defineMacro("\\lrArr","\\Leftrightarrow");defineMacro("\\Lrarr","\\Leftrightarrow");defineMacro("\\Mu","\\mathrm{M}");defineMacro("\\natnums","\\mathbb{N}");defineMacro("\\Nu","\\mathrm{N}");defineMacro("\\Omicron","\\mathrm{O}");defineMacro("\\plusmn","\\pm");defineMacro("\\rarr","\\rightarrow");defineMacro("\\rArr","\\Rightarrow");defineMacro("\\Rarr","\\Rightarrow");defineMacro("\\real","\\Re");defineMacro("\\reals","\\mathbb{R}");defineMacro("\\Reals","\\mathbb{R}");defineMacro("\\Rho","\\mathrm{P}");defineMacro("\\sdot","\\cdot");defineMacro("\\sect","\\S");defineMacro("\\spades","\\spadesuit");defineMacro("\\sub","\\subset");defineMacro("\\sube","\\subseteq");defineMacro("\\supe","\\supseteq");defineMacro("\\Tau","\\mathrm{T}");defineMacro("\\thetasym","\\vartheta");// TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");
    defineMacro("\\weierp","\\wp");defineMacro("\\Zeta","\\mathrm{Z}");//////////////////////////////////////////////////////////////////////
    // statmath.sty
    // https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf
    defineMacro("\\argmin","\\DOTSB\\operatorname*{arg\\,min}");defineMacro("\\argmax","\\DOTSB\\operatorname*{arg\\,max}");defineMacro("\\plim","\\DOTSB\\mathop{\\operatorname{plim}}\\limits");//////////////////////////////////////////////////////////////////////
    // braket.sty
    // http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf
    defineMacro("\\bra","\\mathinner{\\langle{#1}|}");defineMacro("\\ket","\\mathinner{|{#1}\\rangle}");defineMacro("\\braket","\\mathinner{\\langle{#1}\\rangle}");defineMacro("\\Bra","\\left\\langle#1\\right|");defineMacro("\\Ket","\\left|#1\\right\\rangle");// Custom Khan Academy colors, should be moved to an optional package
    defineMacro("\\blue","\\textcolor{##6495ed}{#1}");defineMacro("\\orange","\\textcolor{##ffa500}{#1}");defineMacro("\\pink","\\textcolor{##ff00af}{#1}");defineMacro("\\red","\\textcolor{##df0030}{#1}");defineMacro("\\green","\\textcolor{##28ae7b}{#1}");defineMacro("\\gray","\\textcolor{gray}{#1}");defineMacro("\\purple","\\textcolor{##9d38bd}{#1}");defineMacro("\\blueA","\\textcolor{##ccfaff}{#1}");defineMacro("\\blueB","\\textcolor{##80f6ff}{#1}");defineMacro("\\blueC","\\textcolor{##63d9ea}{#1}");defineMacro("\\blueD","\\textcolor{##11accd}{#1}");defineMacro("\\blueE","\\textcolor{##0c7f99}{#1}");defineMacro("\\tealA","\\textcolor{##94fff5}{#1}");defineMacro("\\tealB","\\textcolor{##26edd5}{#1}");defineMacro("\\tealC","\\textcolor{##01d1c1}{#1}");defineMacro("\\tealD","\\textcolor{##01a995}{#1}");defineMacro("\\tealE","\\textcolor{##208170}{#1}");defineMacro("\\greenA","\\textcolor{##b6ffb0}{#1}");defineMacro("\\greenB","\\textcolor{##8af281}{#1}");defineMacro("\\greenC","\\textcolor{##74cf70}{#1}");defineMacro("\\greenD","\\textcolor{##1fab54}{#1}");defineMacro("\\greenE","\\textcolor{##0d923f}{#1}");defineMacro("\\goldA","\\textcolor{##ffd0a9}{#1}");defineMacro("\\goldB","\\textcolor{##ffbb71}{#1}");defineMacro("\\goldC","\\textcolor{##ff9c39}{#1}");defineMacro("\\goldD","\\textcolor{##e07d10}{#1}");defineMacro("\\goldE","\\textcolor{##a75a05}{#1}");defineMacro("\\redA","\\textcolor{##fca9a9}{#1}");defineMacro("\\redB","\\textcolor{##ff8482}{#1}");defineMacro("\\redC","\\textcolor{##f9685d}{#1}");defineMacro("\\redD","\\textcolor{##e84d39}{#1}");defineMacro("\\redE","\\textcolor{##bc2612}{#1}");defineMacro("\\maroonA","\\textcolor{##ffbde0}{#1}");defineMacro("\\maroonB","\\textcolor{##ff92c6}{#1}");defineMacro("\\maroonC","\\textcolor{##ed5fa6}{#1}");defineMacro("\\maroonD","\\textcolor{##ca337c}{#1}");defineMacro("\\maroonE","\\textcolor{##9e034e}{#1}");defineMacro("\\purpleA","\\textcolor{##ddd7ff}{#1}");defineMacro("\\purpleB","\\textcolor{##c6b9fc}{#1}");defineMacro("\\purpleC","\\textcolor{##aa87ff}{#1}");defineMacro("\\purpleD","\\textcolor{##7854ab}{#1}");defineMacro("\\purpleE","\\textcolor{##543b78}{#1}");defineMacro("\\mintA","\\textcolor{##f5f9e8}{#1}");defineMacro("\\mintB","\\textcolor{##edf2df}{#1}");defineMacro("\\mintC","\\textcolor{##e0e5cc}{#1}");defineMacro("\\grayA","\\textcolor{##f6f7f7}{#1}");defineMacro("\\grayB","\\textcolor{##f0f1f2}{#1}");defineMacro("\\grayC","\\textcolor{##e3e5e6}{#1}");defineMacro("\\grayD","\\textcolor{##d6d8da}{#1}");defineMacro("\\grayE","\\textcolor{##babec2}{#1}");defineMacro("\\grayF","\\textcolor{##888d93}{#1}");defineMacro("\\grayG","\\textcolor{##626569}{#1}");defineMacro("\\grayH","\\textcolor{##3b3e40}{#1}");defineMacro("\\grayI","\\textcolor{##21242c}{#1}");defineMacro("\\kaBlue","\\textcolor{##314453}{#1}");defineMacro("\\kaGreen","\\textcolor{##71B307}{#1}");/**
     * This file contains the gullet where macros are expanded
     * until only non-macro tokens remain.
     */ // List of commands that act like macros but aren't defined as a macro,
    // function, or symbol.  Used in `isDefined`.
    const implicitCommands={"\\relax":true,// MacroExpander.js
    "^":true,// Parser.js
    "_":true,// Parser.js
    "\\limits":true,// Parser.js
    "\\nolimits":true// Parser.js
    };class MacroExpander{constructor(input,settings,mode){this.settings=void 0;this.expansionCount=void 0;this.lexer=void 0;this.macros=void 0;this.stack=void 0;this.mode=void 0;this.settings=settings;this.expansionCount=0;this.feed(input);// Make new global namespace
    this.macros=new Namespace(builtinMacros,settings.macros);this.mode=mode;this.stack=[];// contains tokens in REVERSE order
    }/**
       * Feed a new input string to the same MacroExpander
       * (with existing macros etc.).
       */feed(input){this.lexer=new Lexer(input,this.settings);}/**
       * Switches between "text" and "math" modes.
       */switchMode(newMode){this.mode=newMode;}/**
       * Start a new group nesting within all namespaces.
       */beginGroup(){this.macros.beginGroup();}/**
       * End current group nesting within all namespaces.
       */endGroup(){this.macros.endGroup();}/**
       * Returns the topmost token on the stack, without expanding it.
       * Similar in behavior to TeX's `\futurelet`.
       */future(){if(this.stack.length===0){this.pushToken(this.lexer.lex());}return this.stack[this.stack.length-1];}/**
       * Remove and return the next unexpanded token.
       */popToken(){this.future();// ensure non-empty stack
    return this.stack.pop();}/**
       * Add a given token to the token stack.  In particular, this get be used
       * to put back a token returned from one of the other methods.
       */pushToken(token){this.stack.push(token);}/**
       * Append an array of tokens to the token stack.
       */pushTokens(tokens){this.stack.push(...tokens);}/**
       * Consume all following space tokens, without expansion.
       */consumeSpaces(){for(;;){const token=this.future();if(token.text===" "){this.stack.pop();}else {break;}}}/**
       * Consume the specified number of arguments from the token stream,
       * and return the resulting array of arguments.
       */consumeArgs(numArgs){const args=[];// obtain arguments, either single token or balanced {} group
    for(let i=0;i<numArgs;++i){this.consumeSpaces();// ignore spaces before each argument
    const startOfArg=this.popToken();if(startOfArg.text==="{"){const arg=[];let depth=1;while(depth!==0){const tok=this.popToken();arg.push(tok);if(tok.text==="{"){++depth;}else if(tok.text==="}"){--depth;}else if(tok.text==="EOF"){throw new ParseError("End of input in macro argument",startOfArg);}}arg.pop();// remove last }
    arg.reverse();// like above, to fit in with stack order
    args[i]=arg;}else if(startOfArg.text==="EOF"){throw new ParseError("End of input expecting macro argument");}else {args[i]=[startOfArg];}}return args;}/**
       * Expand the next token only once if possible.
       *
       * If the token is expanded, the resulting tokens will be pushed onto
       * the stack in reverse order and will be returned as an array,
       * also in reverse order.
       *
       * If not, the next token will be returned without removing it
       * from the stack.  This case can be detected by a `Token` return value
       * instead of an `Array` return value.
       *
       * In either case, the next token will be on the top of the stack,
       * or the stack will be empty.
       *
       * Used to implement `expandAfterFuture` and `expandNextToken`.
       *
       * At the moment, macro expansion doesn't handle delimited macros,
       * i.e. things like those defined by \def\foo#1\end{}.
       * See the TeX book page 202ff. for details on how those should behave.
       *
       * If expandableOnly, only expandable tokens are expanded and
       * an undefined control sequence results in an error.
       */expandOnce(expandableOnly){const topToken=this.popToken();const name=topToken.text;const expansion=!topToken.noexpand?this._getExpansion(name):null;if(expansion==null||expandableOnly&&expansion.unexpandable){if(expandableOnly&&expansion==null&&name[0]==="\\"&&!this.isDefined(name)){throw new ParseError("Undefined control sequence: "+name);}this.pushToken(topToken);return topToken;}this.expansionCount++;if(this.expansionCount>this.settings.maxExpand){throw new ParseError("Too many expansions: infinite loop or "+"need to increase maxExpand setting");}let tokens=expansion.tokens;if(expansion.numArgs){const args=this.consumeArgs(expansion.numArgs);// paste arguments in place of the placeholders
    tokens=tokens.slice();// make a shallow copy
    for(let i=tokens.length-1;i>=0;--i){let tok=tokens[i];if(tok.text==="#"){if(i===0){throw new ParseError("Incomplete placeholder at end of macro body",tok);}tok=tokens[--i];// next token on stack
    if(tok.text==="#"){// ##  #
    tokens.splice(i+1,1);// drop first #
    }else if(/^[1-9]$/.test(tok.text)){// replace the placeholder with the indicated argument
    tokens.splice(i,2,...args[+tok.text-1]);}else {throw new ParseError("Not a valid argument number",tok);}}}}// Concatenate expansion onto top of stack.
    this.pushTokens(tokens);return tokens;}/**
       * Expand the next token only once (if possible), and return the resulting
       * top token on the stack (without removing anything from the stack).
       * Similar in behavior to TeX's `\expandafter\futurelet`.
       * Equivalent to expandOnce() followed by future().
       */expandAfterFuture(){this.expandOnce();return this.future();}/**
       * Recursively expand first token, then return first non-expandable token.
       */expandNextToken(){for(;;){const expanded=this.expandOnce();// expandOnce returns Token if and only if it's fully expanded.
    if(expanded instanceof Token){// \relax stops the expansion, but shouldn't get returned (a
    // null return value couldn't get implemented as a function).
    // the token after \noexpand is interpreted as if its meaning
    // were \relax
    if(expanded.text==="\\relax"||expanded.treatAsRelax){this.stack.pop();}else {return this.stack.pop();// === expanded
    }}}// Flow unable to figure out that this pathway is impossible.
    // https://github.com/facebook/flow/issues/4808
    throw new Error();// eslint-disable-line no-unreachable
    }/**
       * Fully expand the given macro name and return the resulting list of
       * tokens, or return `undefined` if no such macro is defined.
       */expandMacro(name){return this.macros.has(name)?this.expandTokens([new Token(name)]):undefined;}/**
       * Fully expand the given token stream and return the resulting list of tokens
       */expandTokens(tokens){const output=[];const oldStackLength=this.stack.length;this.pushTokens(tokens);while(this.stack.length>oldStackLength){const expanded=this.expandOnce(true);// expand only expandable tokens
    // expandOnce returns Token if and only if it's fully expanded.
    if(expanded instanceof Token){if(expanded.treatAsRelax){// the expansion of \noexpand is the token itself
    expanded.noexpand=false;expanded.treatAsRelax=false;}output.push(this.stack.pop());}}return output;}/**
       * Fully expand the given macro name and return the result as a string,
       * or return `undefined` if no such macro is defined.
       */expandMacroAsText(name){const tokens=this.expandMacro(name);if(tokens){return tokens.map(token=>token.text).join("");}else {return tokens;}}/**
       * Returns the expanded macro as a reversed array of tokens and a macro
       * argument count.  Or returns `null` if no such macro.
       */_getExpansion(name){const definition=this.macros.get(name);if(definition==null){// mainly checking for undefined here
    return definition;}const expansion=typeof definition==="function"?definition(this):definition;if(typeof expansion==="string"){let numArgs=0;if(expansion.indexOf("#")!==-1){const stripped=expansion.replace(/##/g,"");while(stripped.indexOf("#"+(numArgs+1))!==-1){++numArgs;}}const bodyLexer=new Lexer(expansion,this.settings);const tokens=[];let tok=bodyLexer.lex();while(tok.text!=="EOF"){tokens.push(tok);tok=bodyLexer.lex();}tokens.reverse();// to fit in with stack using push and pop
    const expanded={tokens,numArgs};return expanded;}return expansion;}/**
       * Determine whether a command is currently "defined" (has some
       * functionality), meaning that it's a macro (in the current group),
       * a function, a symbol, or one of the special commands listed in
       * `implicitCommands`.
       */isDefined(name){return this.macros.has(name)||functions.hasOwnProperty(name)||symbols.math.hasOwnProperty(name)||symbols.text.hasOwnProperty(name)||implicitCommands.hasOwnProperty(name);}/**
       * Determine whether a command is expandable.
       */isExpandable(name){const macro=this.macros.get(name);return macro!=null?typeof macro==="string"||typeof macro==="function"||!macro.unexpandable// TODO(ylem): #2085
    :functions.hasOwnProperty(name)/* && !functions[name].primitive*/;}}/* eslint no-constant-condition:0 */const unicodeAccents={"":{"text":"\\'","math":"\\acute"},"":{"text":"\\`","math":"\\grave"},"":{"text":"\\\"","math":"\\ddot"},"":{"text":"\\~","math":"\\tilde"},"":{"text":"\\=","math":"\\bar"},"":{"text":"\\u","math":"\\breve"},"":{"text":"\\v","math":"\\check"},"":{"text":"\\^","math":"\\hat"},"":{"text":"\\.","math":"\\dot"},"":{"text":"\\r","math":"\\mathring"},"":{"text":"\\H"}};const unicodeSymbols={"":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"b","":"c","":"c","":"c","":"c","":"d","":"d","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"j","":"j","":"k","":"k","":"l","":"l","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"p","":"p","":"r","":"r","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"t","":"t","":"t","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"v","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"B","":"C","":"C","":"C","":"C","":"D","":"D","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"J","":"K","":"K","":"L","":"L","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"P","":"P","":"R","":"R","":"R","":"S","":"S","":"S","":"S","":"S","":"S","":"T","":"T","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":""};/**
     * This file contains the parser used to parse out a TeX expression from the
     * input. Since TeX isn't context-free, standard parsers don't work particularly
     * well.
     *
     * The strategy of this parser is as such:
     *
     * The main functions (the `.parse...` ones) take a position in the current
     * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
     * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
     * individual tokens are needed at a position, the lexer is called to pull out a
     * token, which is then used.
     *
     * The parser has a property called "mode" indicating the mode that
     * the parser is currently in. Currently it has to be one of "math" or
     * "text", which denotes whether the current environment is a math-y
     * one or a text-y one (e.g. inside \text). Currently, this serves to
     * limit the functions which can be used in text mode.
     *
     * The main functions then return an object which contains the useful data that
     * was parsed at its given point, and a new position at the end of the parsed
     * data. The main functions can call each other and continue the parsing by
     * using the returned position as a new starting point.
     *
     * There are also extra `.handle...` functions, which pull out some reused
     * functionality into self-contained functions.
     *
     * The functions return ParseNodes.
     */class Parser{constructor(input,settings){this.mode=void 0;this.gullet=void 0;this.settings=void 0;this.leftrightDepth=void 0;this.nextToken=void 0;// Start in math mode
    this.mode="math";// Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet=new MacroExpander(input,settings,this.mode);// Store the settings for use in parsing
    this.settings=settings;// Count leftright depth (for \middle errors)
    this.leftrightDepth=0;}/**
       * Checks a result to make sure it has the right type, and throws an
       * appropriate error otherwise.
       */expect(text,consume){if(consume===void 0){consume=true;}if(this.fetch().text!==text){throw new ParseError(`Expected '${text}', got '${this.fetch().text}'`,this.fetch());}if(consume){this.consume();}}/**
       * Discards the current lookahead token, considering it consumed.
       */consume(){this.nextToken=null;}/**
       * Return the current lookahead token, or if there isn't one (at the
       * beginning, or if the previous lookahead token was consume()d),
       * fetch the next token as the new lookahead token and return it.
       */fetch(){if(this.nextToken==null){this.nextToken=this.gullet.expandNextToken();}return this.nextToken;}/**
       * Switches between "text" and "math" modes.
       */switchMode(newMode){this.mode=newMode;this.gullet.switchMode(newMode);}/**
       * Main parsing function, which parses an entire input.
       */parse(){if(!this.settings.globalGroup){// Create a group namespace for the math expression.
    // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
    this.gullet.beginGroup();}// Use old \color behavior (same as LaTeX's \textcolor) if requested.
    // We do this within the group for the math expression, so it doesn't
    // pollute settings.macros.
    if(this.settings.colorIsTextColor){this.gullet.macros.set("\\color","\\textcolor");}// Try to parse the input
    const parse=this.parseExpression(false);// If we succeeded, make sure there's an EOF at the end
    this.expect("EOF");// End the group namespace for the expression
    if(!this.settings.globalGroup){this.gullet.endGroup();}return parse;}parseExpression(breakOnInfix,breakOnTokenText){const body=[];// Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while(true){// Ignore spaces in math mode
    if(this.mode==="math"){this.consumeSpaces();}const lex=this.fetch();if(Parser.endOfExpression.indexOf(lex.text)!==-1){break;}if(breakOnTokenText&&lex.text===breakOnTokenText){break;}if(breakOnInfix&&functions[lex.text]&&functions[lex.text].infix){break;}const atom=this.parseAtom(breakOnTokenText);if(!atom){break;}else if(atom.type==="internal"){continue;}body.push(atom);}if(this.mode==="text"){this.formLigatures(body);}return this.handleInfixNodes(body);}/**
       * Rewrites infix operators such as \over with corresponding commands such
       * as \frac.
       *
       * There can only be one infix operator per group.  If there's more than one
       * then the expression is ambiguous.  This can be resolved by adding {}.
       */handleInfixNodes(body){let overIndex=-1;let funcName;for(let i=0;i<body.length;i++){if(body[i].type==="infix"){if(overIndex!==-1){throw new ParseError("only one infix operator per group",body[i].token);}overIndex=i;funcName=body[i].replaceWith;}}if(overIndex!==-1&&funcName){let numerNode;let denomNode;const numerBody=body.slice(0,overIndex);const denomBody=body.slice(overIndex+1);if(numerBody.length===1&&numerBody[0].type==="ordgroup"){numerNode=numerBody[0];}else {numerNode={type:"ordgroup",mode:this.mode,body:numerBody};}if(denomBody.length===1&&denomBody[0].type==="ordgroup"){denomNode=denomBody[0];}else {denomNode={type:"ordgroup",mode:this.mode,body:denomBody};}let node;if(funcName==="\\\\abovefrac"){node=this.callFunction(funcName,[numerNode,body[overIndex],denomNode],[]);}else {node=this.callFunction(funcName,[numerNode,denomNode],[]);}return [node];}else {return body;}}// The greediness of a superscript or subscript
    /**
       * Handle a subscript or superscript with nice errors.
       */handleSupSubscript(name){const symbolToken=this.fetch();const symbol=symbolToken.text;this.consume();const group=this.parseGroup(name,false,Parser.SUPSUB_GREEDINESS,undefined,undefined,true);// ignore spaces before sup/subscript argument
    if(!group){throw new ParseError("Expected group after '"+symbol+"'",symbolToken);}return group;}/**
       * Converts the textual input of an unsupported command into a text node
       * contained within a color node whose color is determined by errorColor
       */formatUnsupportedCmd(text){const textordArray=[];for(let i=0;i<text.length;i++){textordArray.push({type:"textord",mode:"text",text:text[i]});}const textNode={type:"text",mode:this.mode,body:textordArray};const colorNode={type:"color",mode:this.mode,color:this.settings.errorColor,body:[textNode]};return colorNode;}/**
       * Parses a group with optional super/subscripts.
       */parseAtom(breakOnTokenText){// The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    const base=this.parseGroup("atom",false,null,breakOnTokenText);// In text mode, we don't have superscripts or subscripts
    if(this.mode==="text"){return base;}// Note that base may be empty (i.e. null) at this point.
    let superscript;let subscript;while(true){// Guaranteed in math mode, so eat any spaces first.
    this.consumeSpaces();// Lex the first token
    const lex=this.fetch();if(lex.text==="\\limits"||lex.text==="\\nolimits"){// We got a limit control
    if(base&&base.type==="op"){const limits=lex.text==="\\limits";base.limits=limits;base.alwaysHandleSupSub=true;}else if(base&&base.type==="operatorname"&&base.alwaysHandleSupSub){const limits=lex.text==="\\limits";base.limits=limits;}else {throw new ParseError("Limit controls must follow a math operator",lex);}this.consume();}else if(lex.text==="^"){// We got a superscript start
    if(superscript){throw new ParseError("Double superscript",lex);}superscript=this.handleSupSubscript("superscript");}else if(lex.text==="_"){// We got a subscript start
    if(subscript){throw new ParseError("Double subscript",lex);}subscript=this.handleSupSubscript("subscript");}else if(lex.text==="'"){// We got a prime
    if(superscript){throw new ParseError("Double superscript",lex);}const prime={type:"textord",mode:this.mode,text:"\\prime"};// Many primes can be grouped together, so we handle this here
    const primes=[prime];this.consume();// Keep lexing tokens until we get something that's not a prime
    while(this.fetch().text==="'"){// For each one, add another prime to the list
    primes.push(prime);this.consume();}// If there's a superscript following the primes, combine that
    // superscript in with the primes.
    if(this.fetch().text==="^"){primes.push(this.handleSupSubscript("superscript"));}// Put everything into an ordgroup as the superscript
    superscript={type:"ordgroup",mode:this.mode,body:primes};}else {// If it wasn't ^, _, or ', stop parsing super/subscripts
    break;}}// Base must be set if superscript or subscript are set per logic above,
    // but need to check here for type check to pass.
    if(superscript||subscript){// If we got either a superscript or subscript, create a supsub
    return {type:"supsub",mode:this.mode,base:base,sup:superscript,sub:subscript};}else {// Otherwise return the original body
    return base;}}/**
       * Parses an entire function, including its base and all of its arguments.
       */parseFunction(breakOnTokenText,name,// For error reporting.
    greediness){const token=this.fetch();const func=token.text;const funcData=functions[func];if(!funcData){return null;}this.consume();// consume command token
    if(greediness!=null&&funcData.greediness<=greediness){throw new ParseError("Got function '"+func+"' with no arguments"+(name?" as "+name:""),token);}else if(this.mode==="text"&&!funcData.allowedInText){throw new ParseError("Can't use function '"+func+"' in text mode",token);}else if(this.mode==="math"&&funcData.allowedInMath===false){throw new ParseError("Can't use function '"+func+"' in math mode",token);}const _this$parseArguments=this.parseArguments(func,funcData),args=_this$parseArguments.args,optArgs=_this$parseArguments.optArgs;return this.callFunction(func,args,optArgs,token,breakOnTokenText);}/**
       * Call a function handler with a suitable context and arguments.
       */callFunction(name,args,optArgs,token,breakOnTokenText){const context={funcName:name,parser:this,token,breakOnTokenText};const func=functions[name];if(func&&func.handler){return func.handler(context,args,optArgs);}else {throw new ParseError(`No function handler for ${name}`);}}/**
       * Parses the arguments of a function or environment
       */parseArguments(func,// Should look like "\name" or "\begin{name}".
    funcData){const totalArgs=funcData.numArgs+funcData.numOptionalArgs;if(totalArgs===0){return {args:[],optArgs:[]};}const baseGreediness=funcData.greediness;const args=[];const optArgs=[];for(let i=0;i<totalArgs;i++){const argType=funcData.argTypes&&funcData.argTypes[i];const isOptional=i<funcData.numOptionalArgs;// Ignore spaces between arguments.  As the TeXbook says:
    // "After you have said \def\row#1#2{...}, you are allowed to
    //  put spaces between the arguments (e.g., \row x n), because
    //  TeX doesnt use single spaces as undelimited arguments."
    const consumeSpaces=i>0&&!isOptional||// Also consume leading spaces in math mode, as parseSymbol
    // won't know what to do with them.  This can only happen with
    // macros, e.g. \frac\foo\foo where \foo expands to a space symbol.
    // In LaTeX, the \foo's get treated as (blank) arguments.
    // In KaTeX, for now, both spaces will get consumed.
    // TODO(edemaine)
    i===0&&!isOptional&&this.mode==="math";const arg=this.parseGroupOfType(`argument to '${func}'`,argType,isOptional,baseGreediness,consumeSpaces);if(!arg){if(isOptional){optArgs.push(null);continue;}throw new ParseError(`Expected group after '${func}'`,this.fetch());}(isOptional?optArgs:args).push(arg);}return {args,optArgs};}/**
       * Parses a group when the mode is changing.
       */parseGroupOfType(name,type,optional,greediness,consumeSpaces){switch(type){case"color":if(consumeSpaces){this.consumeSpaces();}return this.parseColorGroup(optional);case"size":if(consumeSpaces){this.consumeSpaces();}return this.parseSizeGroup(optional);case"url":return this.parseUrlGroup(optional,consumeSpaces);case"math":case"text":return this.parseGroup(name,optional,greediness,undefined,type,consumeSpaces);case"hbox":{// hbox argument type wraps the argument in the equivalent of
    // \hbox, which is like \text but switching to \textstyle size.
    const group=this.parseGroup(name,optional,greediness,undefined,"text",consumeSpaces);if(!group){return group;}const styledGroup={type:"styling",mode:group.mode,body:[group],style:"text"// simulate \textstyle
    };return styledGroup;}case"raw":{if(consumeSpaces){this.consumeSpaces();}if(optional&&this.fetch().text==="{"){return null;}const token=this.parseStringGroup("raw",optional,true);if(token){return {type:"raw",mode:"text",string:token.text};}else {throw new ParseError("Expected raw group",this.fetch());}}case"original":case null:case undefined:return this.parseGroup(name,optional,greediness,undefined,undefined,consumeSpaces);default:throw new ParseError("Unknown group type as "+name,this.fetch());}}/**
       * Discard any space tokens, fetching the next non-space token.
       */consumeSpaces(){while(this.fetch().text===" "){this.consume();}}/**
       * Parses a group, essentially returning the string formed by the
       * brace-enclosed tokens plus some position information.
       */parseStringGroup(modeName,// Used to describe the mode in error messages.
    optional,raw){const groupBegin=optional?"[":"{";const groupEnd=optional?"]":"}";const beginToken=this.fetch();if(beginToken.text!==groupBegin){if(optional){return null;}else if(raw&&beginToken.text!=="EOF"&&/[^{}[\]]/.test(beginToken.text)){this.consume();return beginToken;}}const outerMode=this.mode;this.mode="text";this.expect(groupBegin);let str="";const firstToken=this.fetch();let nested=0;// allow nested braces in raw string group
    let lastToken=firstToken;let nextToken;while((nextToken=this.fetch()).text!==groupEnd||raw&&nested>0){switch(nextToken.text){case"EOF":throw new ParseError("Unexpected end of input in "+modeName,firstToken.range(lastToken,str));case groupBegin:nested++;break;case groupEnd:nested--;break;}lastToken=nextToken;str+=lastToken.text;this.consume();}this.expect(groupEnd);this.mode=outerMode;return firstToken.range(lastToken,str);}/**
       * Parses a regex-delimited group: the largest sequence of tokens
       * whose concatenated strings match `regex`. Returns the string
       * formed by the tokens plus some position information.
       */parseRegexGroup(regex,modeName){const outerMode=this.mode;this.mode="text";const firstToken=this.fetch();let lastToken=firstToken;let str="";let nextToken;while((nextToken=this.fetch()).text!=="EOF"&&regex.test(str+nextToken.text)){lastToken=nextToken;str+=lastToken.text;this.consume();}if(str===""){throw new ParseError("Invalid "+modeName+": '"+firstToken.text+"'",firstToken);}this.mode=outerMode;return firstToken.range(lastToken,str);}/**
       * Parses a color description.
       */parseColorGroup(optional){const res=this.parseStringGroup("color",optional);if(!res){return null;}const match=/^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);if(!match){throw new ParseError("Invalid color: '"+res.text+"'",res);}let color=match[0];if(/^[0-9a-f]{6}$/i.test(color)){// We allow a 6-digit HTML color spec without a leading "#".
    // This follows the xcolor package's HTML color model.
    // Predefined color names are all missed by this RegEx pattern.
    color="#"+color;}return {type:"color-token",mode:this.mode,color};}/**
       * Parses a size specification, consisting of magnitude and unit.
       */parseSizeGroup(optional){let res;let isBlank=false;if(!optional&&this.fetch().text!=="{"){res=this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/,"size");}else {res=this.parseStringGroup("size",optional);}if(!res){return null;}if(!optional&&res.text.length===0){// Because we've tested for what is !optional, this block won't
    // affect \kern, \hspace, etc. It will capture the mandatory arguments
    // to \genfrac and \above.
    res.text="0pt";// Enable \above{}
    isBlank=true;// This is here specifically for \genfrac
    }const match=/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);if(!match){throw new ParseError("Invalid size: '"+res.text+"'",res);}const data={number:+(match[1]+match[2]),// sign + magnitude, cast to number
    unit:match[3]};if(!validUnit(data)){throw new ParseError("Invalid unit: '"+data.unit+"'",res);}return {type:"size",mode:this.mode,value:data,isBlank};}/**
       * Parses an URL, checking escaped letters and allowed protocols,
       * and setting the catcode of % as an active character (as in \hyperref).
       */parseUrlGroup(optional,consumeSpaces){this.gullet.lexer.setCatcode("%",13);// active character
    const res=this.parseStringGroup("url",optional,true);// get raw string
    this.gullet.lexer.setCatcode("%",14);// comment character
    if(!res){return null;}// hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.
    const url=res.text.replace(/\\([#$%&~_^{}])/g,'$1');return {type:"url",mode:this.mode,url};}/**
       * If `optional` is false or absent, this parses an ordinary group,
       * which is either a single nucleus (like "x") or an expression
       * in braces (like "{x+y}") or an implicit group, a group that starts
       * at the current position, and ends right before a higher explicit
       * group ends, or at EOF.
       * If `optional` is true, it parses either a bracket-delimited expression
       * (like "[x+y]") or returns null to indicate the absence of a
       * bracket-enclosed group.
       * If `mode` is present, switches to that mode while parsing the group,
       * and switches back after.
       */parseGroup(name,// For error reporting.
    optional,greediness,breakOnTokenText,mode,consumeSpaces){// Switch to specified mode
    const outerMode=this.mode;if(mode){this.switchMode(mode);}// Consume spaces if requested, crucially *after* we switch modes,
    // so that the next non-space token is parsed in the correct mode.
    if(consumeSpaces){this.consumeSpaces();}// Get first token
    const firstToken=this.fetch();const text=firstToken.text;let result;// Try to parse an open brace or \begingroup
    if(optional?text==="[":text==="{"||text==="\\begingroup"){this.consume();const groupEnd=Parser.endOfGroup[text];// Start a new group namespace
    this.gullet.beginGroup();// If we get a brace, parse an expression
    const expression=this.parseExpression(false,groupEnd);const lastToken=this.fetch();// Check that we got a matching closing brace
    this.expect(groupEnd);// End group namespace
    this.gullet.endGroup();result={type:"ordgroup",mode:this.mode,loc:SourceLocation.range(firstToken,lastToken),body:expression,// A group formed by \begingroup...\endgroup is a semi-simple group
    // which doesn't affect spacing in math mode, i.e., is transparent.
    // https://tex.stackexchange.com/questions/1930/when-should-one-
    // use-begingroup-instead-of-bgroup
    semisimple:text==="\\begingroup"||undefined};}else if(optional){// Return nothing for an optional group
    result=null;}else {// If there exists a function with this name, parse the function.
    // Otherwise, just return a nucleus
    result=this.parseFunction(breakOnTokenText,name,greediness)||this.parseSymbol();if(result==null&&text[0]==="\\"&&!implicitCommands.hasOwnProperty(text)){if(this.settings.throwOnError){throw new ParseError("Undefined control sequence: "+text,firstToken);}result=this.formatUnsupportedCmd(text);this.consume();}}// Switch mode back
    if(mode){this.switchMode(outerMode);}return result;}/**
       * Form ligature-like combinations of characters for text mode.
       * This includes inputs like "--", "---", "``" and "''".
       * The result will simply replace multiple textord nodes with a single
       * character in each value by a single textord node having multiple
       * characters in its value.  The representation is still ASCII source.
       * The group will be modified in place.
       */formLigatures(group){let n=group.length-1;for(let i=0;i<n;++i){const a=group[i];// $FlowFixMe: Not every node type has a `text` property.
    const v=a.text;if(v==="-"&&group[i+1].text==="-"){if(i+1<n&&group[i+2].text==="-"){group.splice(i,3,{type:"textord",mode:"text",loc:SourceLocation.range(a,group[i+2]),text:"---"});n-=2;}else {group.splice(i,2,{type:"textord",mode:"text",loc:SourceLocation.range(a,group[i+1]),text:"--"});n-=1;}}if((v==="'"||v==="`")&&group[i+1].text===v){group.splice(i,2,{type:"textord",mode:"text",loc:SourceLocation.range(a,group[i+1]),text:v+v});n-=1;}}}/**
       * Parse a single symbol out of the string. Here, we handle single character
       * symbols and special functions like \verb.
       */parseSymbol(){const nucleus=this.fetch();let text=nucleus.text;if(/^\\verb[^a-zA-Z]/.test(text)){this.consume();let arg=text.slice(5);const star=arg.charAt(0)==="*";if(star){arg=arg.slice(1);}// Lexer's tokenRegex is constructed to always have matching
    // first/last characters.
    if(arg.length<2||arg.charAt(0)!==arg.slice(-1)){throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);}arg=arg.slice(1,-1);// remove first and last char
    return {type:"verb",mode:"text",body:arg,star};}// At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.
    if(unicodeSymbols.hasOwnProperty(text[0])&&!symbols[this.mode][text[0]]){// This behavior is not strict (XeTeX-compatible) in math mode.
    if(this.settings.strict&&this.mode==="math"){this.settings.reportNonstrict("unicodeTextInMathMode",`Accented Unicode text character "${text[0]}" used in `+`math mode`,nucleus);}text=unicodeSymbols[text[0]]+text.substr(1);}// Strip off any combining characters
    const match=combiningDiacriticalMarksEndRegex.exec(text);if(match){text=text.substring(0,match.index);if(text==='i'){text='\u0131';// dotless i, in math and text mode
    }else if(text==='j'){text='\u0237';// dotless j, in math and text mode
    }}// Recognize base symbol
    let symbol;if(symbols[this.mode][text]){if(this.settings.strict&&this.mode==='math'&&extraLatin.indexOf(text)>=0){this.settings.reportNonstrict("unicodeTextInMathMode",`Latin-1/Unicode text character "${text[0]}" used in `+`math mode`,nucleus);}const group=symbols[this.mode][text].group;const loc=SourceLocation.range(nucleus);let s;if(ATOMS.hasOwnProperty(group)){// $FlowFixMe
    const family=group;s={type:"atom",mode:this.mode,family,loc,text};}else {// $FlowFixMe
    s={type:group,mode:this.mode,loc,text};}symbol=s;}else if(text.charCodeAt(0)>=0x80){// no symbol for e.g. ^
    if(this.settings.strict){if(!supportedCodepoint(text.charCodeAt(0))){this.settings.reportNonstrict("unknownSymbol",`Unrecognized Unicode character "${text[0]}"`+` (${text.charCodeAt(0)})`,nucleus);}else if(this.mode==="math"){this.settings.reportNonstrict("unicodeTextInMathMode",`Unicode text character "${text[0]}" used in math mode`,nucleus);}}// All nonmathematical Unicode characters are rendered as if they
    // are in text mode (wrapped in \text) because that's what it
    // takes to render them in LaTeX.  Setting `mode: this.mode` is
    // another natural choice (the user requested math mode), but
    // this makes it more difficult for getCharacterMetrics() to
    // distinguish Unicode characters without metrics and those for
    // which we want to simulate the letter M.
    symbol={type:"textord",mode:"text",loc:SourceLocation.range(nucleus),text};}else {return null;// EOF, ^, _, {, }, etc.
    }this.consume();// Transform combining characters into accents
    if(match){for(let i=0;i<match[0].length;i++){const accent=match[0][i];if(!unicodeAccents[accent]){throw new ParseError(`Unknown accent ' ${accent}'`,nucleus);}const command=unicodeAccents[accent][this.mode];if(!command){throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`,nucleus);}symbol={type:"accent",mode:this.mode,loc:SourceLocation.range(nucleus),label:command,isStretchy:false,isShifty:true,base:symbol};}}return symbol;}}Parser.endOfExpression=["}","\\endgroup","\\end","\\right","&"];Parser.endOfGroup={"[":"]","{":"}","\\begingroup":"\\endgroup"/**
       * Parses an "expression", which is a list of atoms.
       *
       * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
       *                 happens when functions have higher precendence han infix
       *                 nodes in implicit parses.
       *
       * `breakOnTokenText`: The text of the token that the expression should end
       *                     with, or `null` if something else should end the
       *                     expression.
       */};Parser.SUPSUB_GREEDINESS=1;/**
     * Provides a single function for parsing an expression using a Parser
     * TODO(emily): Remove this
     */ /**
     * Parses an expression using a Parser, then returns the parsed result.
     */const parseTree=function parseTree(toParse,settings){if(!(typeof toParse==='string'||toParse instanceof String)){throw new TypeError('KaTeX can only parse string typed expression');}const parser=new Parser(toParse,settings);// Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
    delete parser.gullet.macros.current["\\df@tag"];let tree=parser.parse();// If the input used \tag, it will set the \df@tag macro to the tag.
    // In this case, we separately parse the tag and wrap the tree.
    if(parser.gullet.macros.get("\\df@tag")){if(!settings.displayMode){throw new ParseError("\\tag works only in display equations");}parser.gullet.feed("\\df@tag");tree=[{type:"tag",mode:"text",body:tree,tag:parser.parse()}];}return tree;};/* eslint no-console:0 */ /**
     * Parse and build an expression, and place that expression in the DOM node
     * given.
     */let render=function render(expression,baseNode,options){baseNode.textContent="";const node=renderToDomTree(expression,options).toNode();baseNode.appendChild(node);};// KaTeX's styles don't work properly in quirks mode. Print out an error, and
    // disable rendering.
    if(typeof document!=="undefined"){if(document.compatMode!=="CSS1Compat"){typeof console!=="undefined"&&console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your "+"website has a suitable doctype.");render=function render(){throw new ParseError("KaTeX doesn't work in quirks mode.");};}}/**
     * Parse and build an expression, and return the markup for that.
     */const renderToString=function renderToString(expression,options){const markup=renderToDomTree(expression,options).toMarkup();return markup;};/**
     * Parse an expression and return the parse tree.
     */const generateParseTree=function generateParseTree(expression,options){const settings=new Settings(options);return parseTree(expression,settings);};/**
     * If the given error is a KaTeX ParseError and options.throwOnError is false,
     * renders the invalid LaTeX as a span with hover title giving the KaTeX
     * error message.  Otherwise, simply throws the error.
     */const renderError=function renderError(error,expression,options){if(options.throwOnError||!(error instanceof ParseError)){throw error;}const node=buildCommon.makeSpan(["katex-error"],[new SymbolNode(expression)]);node.setAttribute("title",error.toString());node.setAttribute("style",`color:${options.errorColor}`);return node;};/**
     * Generates and returns the katex build tree. This is used for advanced
     * use cases (like rendering to custom output).
     */const renderToDomTree=function renderToDomTree(expression,options){const settings=new Settings(options);try{const tree=parseTree(expression,settings);return buildTree(tree,expression,settings);}catch(error){return renderError(error,expression,settings);}};/**
     * Generates and returns the katex build tree, with just HTML (no MathML).
     * This is used for advanced use cases (like rendering to custom output).
     */const renderToHTMLTree=function renderToHTMLTree(expression,options){const settings=new Settings(options);try{const tree=parseTree(expression,settings);return buildHTMLTree(tree,expression,settings);}catch(error){return renderError(error,expression,settings);}};var katex={/**
       * Current KaTeX version
       */version:"0.12.0",/**
       * Renders the given LaTeX into an HTML+MathML combination, and adds
       * it as a child to the specified DOM node.
       */render,/**
       * Renders the given LaTeX into an HTML+MathML combination string,
       * for sending to the client.
       */renderToString,/**
       * KaTeX error, usually during parsing.
       */ParseError,/**
       * Parses the given LaTeX into KaTeX's internal parse tree structure,
       * without rendering to HTML or MathML.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */__parse:generateParseTree,/**
       * Renders the given LaTeX into an HTML+MathML internal DOM tree
       * representation, without flattening that representation to a string.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */__renderToDomTree:renderToDomTree,/**
       * Renders the given LaTeX into an HTML internal DOM tree representation,
       * without MathML and without flattening that representation to a string.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */__renderToHTMLTree:renderToHTMLTree,/**
       * extends internal font metrics object with a new object
       * each key in the new object represents a font name
      */__setFontMetrics:setFontMetrics,/**
       * adds a new symbol to builtin symbols table
       */__defineSymbol:defineSymbol,/**
       * adds a new macro to builtin macro list
       */__defineMacro:defineMacro,/**
       * Expose the dom tree node types, which can be useful for type checking nodes.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */__domTree:{Span,Anchor,SymbolNode,SvgNode,PathNode,LineNode}};

    class Latex extends UI$1.Element {
      setOptions(options) {
        if (options.children?.length) {
          let value = "";
          for (let child of options.children) {
            if (child instanceof UI$1.TextElement) {
              value += child.getValue();
            } else {
              value += child.toString();
            }
          }
          options.value = options.value || value;
        }
        super.setOptions(options);
      }
      updateOptions(options) {
        const oldValue = this.options.value;
        this.setOptions(Object.assign(this.options, options));
        if (oldValue !== this.options.value) {
          this.redraw();
        }
      }
      getNodeType() {
        return "span";
      }
      redraw() {
        super.redraw();
        this.node.innerHTML = katex.renderToString(this.options.value, {
          throwOnError: false
        });
      }
    }

    class ProgrammingLanguageTable extends Table {
      getDefaultColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let nameHeaderStyle = {
          textAlign: "left",
          verticalAlign: "middle",
          width: "20%"
        };
        let compilerHeaderStyle = {
          textAlign: "left",
          verticalAlign: "middle",
          width: "30%"
        };
        let commentHeaderStyle = {
          textAlign: "left",
          verticalAlign: "middle",
          width: "50%"
        };
        return [{
          value: language => language.name,
          headerName: "Language",
          headerStyle: nameHeaderStyle,
          cellStyle: cellStyle
        }, {
          value: language => language.compiler,
          headerName: "Compiler",
          headerStyle: compilerHeaderStyle,
          cellStyle: cellStyle
        }, {
          value: language => {
            if (language.comment) {
              return UI$1.createElement(MarkupRenderer, {
                value: language.comment
              });
            }
            return null;
          },
          headerName: "Comment",
          headerStyle: commentHeaderStyle,
          cellStyle: cellStyle
        }];
      }
      getEntries() {
        return ProgrammingLanguage.all();
      }
    }

    class ArticleRenderer extends MarkupRenderer {
      setOptions(options) {
        options.classMap = options.classMap || this.constructor.markupClassMap;
        super.setOptions(options);
      }
      getEditButton() {
        if (this.options.showEditButton && this.options.article.canBeEditedByUser()) {
          let url = this.options.editButtonUrl || "/article/" + this.options.article.id + "/edit/";
          return UI$1.createElement("div", {
            className: "text-left"
          }, UI$1.createElement("a", {
            href: url,
            target: "_blank"
          }, UI$1.createElement(Button$1, {
            label: UI$1.T("Edit"),
            style: {
              "margin": "10px"
            }
          })));
        }
      }
      render() {
        return [this.getEditButton(), super.render()];
      }
      setArticle(article) {
        this.updateOptions({
          article
        });
      }
      getValue() {
        super.setValue(this.getArticleToRender().markup);
        return super.getValue();
      }
      getArticleToRender() {
        return this.options.article.getTranslation();
      }
      getArticleDependencies() {
        const dependencies = this.options.article.dependency;
        return dependencies?.split(",").map(dep => dep.trim()).filter(dep => !!dep);
      }
      redraw() {
        const dependencies = this.getArticleDependencies();
        if (!dependencies || dependencies.length === 0) {
          super.redraw();
          return;
        }
        const depPaths = dependencies.map(dep => `/static/js/${dep}.js`);
        ensure(depPaths, (...args) => {
          const reqDep = dependencies.map(dep => require(dep));
          this.registerDependencies(reqDep);
          super.redraw();
        });
      }
      onMount() {
        if (this.options.liveLanguage) {
          this.attachListener(Language, "localeChange", () => this.redraw());
        }
      }
    }
    class RecursiveArticleRenderer extends ArticleRenderer {
      setOptions(options) {
        super.setOptions(options);
        this.options.articleId = this.options.articleId || this.options.id;
      }
      redraw() {
        if (this.options.article) {
          return super.redraw();
        } else {
          ArticleStore.fetch(this.options.articleId, article => this.updateOptions({
            article
          }));
        }
      }
    }
    class ArticleSwitcher extends Switcher {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fullHeight: true
        });
      }
      constructor() {
        super(...arguments);
        this.articleChildMap = new WeakMap();
      }
      setOptions(options) {
        options = Object.assign({
          lazyRender: true
        }, options);
        super.setOptions(options);
      }
      getPageForArticle(article) {
        if (!this.articleChildMap.has(article)) {
          this.articleChildMap.set(article, UI$1.createElement(ArticleRenderer, {
            article: article,
            showEditButton: this.options.showEditButton
          }));
        }
        return this.articleChildMap.get(article);
      }
      setActive(article) {
        if (!(article instanceof Article)) {
          super.setActive(article);
          return;
        }
        super.setActive(this.getPageForArticle(article));
      }
      setActiveArticleId(articleId) {
        ArticleStore.fetch(articleId, article => {
          this.setActive(article);
        });
      }
      onMount() {
        super.onMount();
        if (this.options.initialArticle) {
          this.setActive(this.options.initialArticle);
        }
        if (this.options.initialArticleId) {
          this.setActiveArticleId(this.options.initialArticleId);
        }
      }
    }
    ArticleRenderer.markupClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["Article", RecursiveArticleRenderer], ["RawSVG", SVG.RawSVG]]);

    // Plugins should be used to extends on runtime the functionality of a class, to easily split functionality
    class Plugin extends Dispatchable {
      constructor(parent) {
        super();
        this.linkToParent(parent);
      }
      linkToParent(parent) {
        this.parent = parent;
      }
      name() {
        return this.constructor.pluginName();
      }
      static pluginName() {
        return this.name;
      }
    }

    // TODO: rename this to use Mixin in title
    const Pluginable = function (BaseClass) {
      return class Pluginable extends BaseClass {
        // TODO: this should probably take in a plugin instance also
        registerPlugin(PluginClass) {
          if (!this.hasOwnProperty("plugins")) {
            this.plugins = new Map();
          }
          // TODO: figure out plugin dependencies
          let plugin = new PluginClass(this);
          let pluginName = plugin.name();
          if (this.plugins.has(pluginName)) {
            console.error("You are overwriting an existing plugin: ", pluginName, " for object ", this);
          }
          this.plugins.set(pluginName, plugin);
        }
        removePlugin(pluginName) {
          let plugin = this.getPlugin(pluginName);
          if (plugin) {
            plugin.remove(this);
            this.plugins.delete(plugin.name());
          } else {
            console.error("Can't remove plugin ", pluginName);
          }
        }
        getPlugin(pluginName) {
          if (!(typeof pluginName === "string")) {
            pluginName = pluginName.pluginName();
          }
          if (this.plugins) {
            return this.plugins.get(pluginName);
          } else {
            return null;
          }
        }
      };
    };

    class MarkupEditor extends Panel {
      getDefaultOptions() {
        return {
          showButtons: true
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("textAlign", "center");
      }
      getMarkupRenderer() {
        let rendererOptions = {};
        if (this.options.classMap) {
          rendererOptions.classMap = this.options.classMap;
        }
        return UI$1.createElement(MarkupRenderer, _extends({
          ref: this.refLink("markupRenderer"),
          value: this.options.value,
          style: {
            height: "100%",
            overflow: "auto"
          }
        }, rendererOptions));
      }
      getEditor() {
        return UI$1.createElement(TextArea, {
          ref: "codeEditor",
          style: {
            width: "100%",
            height: "calc(100% - 3px)",
            resize: "none",
            backgroundColor: "#F9F9F9"
          },
          value: this.options.value || ""
        });
      }
      render() {
        let buttons;
        if (this.options.showButtons) {
          buttons = UI$1.createElement("div", {
            style: {
              margin: 6
            }
          }, UI$1.createElement("span", {
            onClick: () => this.toggleEditorPanel()
          }, UI$1.createElement(RawCheckboxInput, {
            checked: true
          }), "Editor"), UI$1.createElement("span", {
            onClick: () => this.togglePreviewPanel()
          }, UI$1.createElement(RawCheckboxInput, {
            checked: true
          }), "Preview"));
        }
        return [buttons, UI$1.createElement(SectionDivider, {
          ref: "sectionDivider",
          orientation: Orientation$1.HORIZONTAL,
          style: {
            textAlign: "initial",
            height: "100%",
            width: "100%",
            display: "inline-block",
            overflow: "hidden"
          }
        }, UI$1.createElement(Panel, {
          ref: "editorPanel",
          style: {
            width: "50%",
            height: "100%",
            overflow: "hidden"
          }
        }, this.getEditor()), UI$1.createElement(Panel, {
          ref: "rendererPanel",
          style: {
            width: "50%",
            height: "100%",
            overflow: "auto",
            padding: "10px"
          }
        }, this.getMarkupRenderer()))];
      }
      updateValue(markup) {
        this.markupRenderer.setValue(markup);
        this.markupRenderer.redraw();
      }
      appendValue(markup, separator = "\n") {
        let value = this.getValue();
        if (value && separator != null) {
          value += separator;
        }
        value += markup;
        this.setValue(value);
        this.updateValue(value);
      }
      setEditorOptions() {
        this.editorPanel.addListener("resize", () => {
          this.codeEditor.setWidth(this.editorPanel.getWidth() - 15);
        });
        this.codeEditor.addNodeListener("input", () => {
          let markup = this.codeEditor.getValue();
          try {
            this.updateValue(markup);
          } catch (e) {
            console.error("Exception in parsing markup: ", e);
          }
        });
      }
      toggleEditorPanel() {
        if (this.editorPanel.getWidth() === 0) {
          this.sectionDivider.expandChild(0);
        } else {
          this.sectionDivider.collapseChild(0);
        }
      }
      togglePreviewPanel() {
        if (this.rendererPanel.getWidth() === 0) {
          this.sectionDivider.expandChild(1);
        } else {
          this.sectionDivider.collapseChild(1);
        }
      }
      onMount() {
        this.setEditorOptions();
      }
      getValue() {
        return this.codeEditor.getValue();
      }
      setValue(value) {
        this.updateValue(value);
        return this.codeEditor.setValue(value);
      }
    }

    class MarkupEditorModal extends Modal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          height: "85%",
          width: "80%",
          destroyOnHide: false
        });
      }
      getMarkupEditorStyle() {
        return {
          height: "85%",
          border: "solid 5px #DDD",
          borderRadius: "10px"
        };
      }
      getButtonStyle() {
        return {
          margin: "5px"
        };
      }
      render() {
        return [UI$1.createElement(MarkupEditor, {
          ref: this.refLink("markupEditor"),
          classMap: this.options.classMap,
          showButtons: false,
          style: this.getMarkupEditorStyle()
        }), UI$1.createElement("div", {
          ref: this.refLink("buttonPanel"),
          style: {
            "text-align": "center"
          }
        }, UI$1.createElement(Button$1, {
          ref: "graphExample",
          label: "Graph",
          onClick: () => {
            this.appendGraphExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI$1.createElement(Button$1, {
          ref: "submissionExample",
          label: "Submission",
          onClick: () => {
            this.appendSubmissionExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI$1.createElement(Button$1, {
          ref: "codeSnippetExample",
          label: "Code",
          onClick: () => {
            this.appendCodeExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI$1.createElement(Button$1, {
          ref: "linkExample",
          label: "Link",
          onClick: () => {
            this.appendLinkExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI$1.createElement(Button$1, {
          ref: "latexExample",
          label: "LaTeX",
          onClick: () => {
            this.appendLatexExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI$1.createElement(Button$1, {
          ref: this.refLink("doneButton"),
          level: Level.PRIMARY,
          label: "Done",
          className: "pull-right",
          style: this.getButtonStyle()
        })),
        //<span ref={this.refLink("emotesContainer")} style={{float: "left", position: "relative", margin: "5px"}}>
        //    <EmojiButton ref="emotes" label="Emoticons" getTextBox={() => this.markupEditor}/>
        //</span>
        //<Button ref="userExample" label="User"
        //           onClick={() => {this.appendUserExample()}} style={this.getButtonStyle()} className="pull-left"/>
        UI$1.createElement("div", {
          className: "",
          style: {
            "position": "absolute",
            "width": "90%",
            "margin-top": "45px"
          }
        }, UI$1.createElement(Link, {
          href: "/about/#markup",
          value: "More details here"
        }))];
      }
      appendLatexExample() {
        this.markupEditor.appendValue("$$lim_{x\\to\\infty} f(x)$$");
      }
      appendGraphExample() {
        this.markupEditor.appendValue("<Graph nodes={[{}, {}, {}]} edges={[{source:1, target:2}]} directed />");
      }
      appendSubmissionExample() {
        this.markupEditor.appendValue("<Submission id={25717} />");
      }
      appendCodeExample() {
        this.markupEditor.appendValue("```java\n" + "class Main {\n" + "    public static void main (String[] args) throws java.lang.Exception {\n" + "        System.out.println(\"42\");\n" + "    }\n" + "}\n" + "```");
      }
      appendUserExample() {
        this.markupEditor.appendValue("<User id={1} />");
      }
      appendLinkExample() {
        this.markupEditor.appendValue("<Link href=\"https://csacademy.com\" value=\"Cool website\" newTab/>");
      }
      hide() {
        super.hide();
        if (this.options.hideCallback) {
          this.options.hideCallback(this);
        }
      }
      show() {
        super.show();
        if (this.options.showCallback) {
          this.options.showCallback(this);
        }
      }
      onMount() {
        super.onMount();
        this.doneButton.addClickListener(() => {
          this.hide();
        });
      }
    }

    class ChatMarkupRenderer extends MarkupRenderer {
      setOptions(options) {
        options.classMap = this.constructor.classMap;
        super.setOptions(options);
      }
    }
    ChatMarkupRenderer.classMap = new MarkupClassMap(MarkupClassMap.GLOBAL);

    var _class$1i, _descriptor$E, _descriptor2$A, _descriptor3$t, _descriptor4$q, _descriptor5$o, _descriptor6$k, _descriptor7$g, _descriptor8$f, _descriptor9$b, _descriptor10$9, _descriptor11$7, _descriptor12$5, _descriptor13$5, _descriptor14$5, _descriptor15$4, _descriptor16$4, _descriptor17$4, _descriptor18$2, _descriptor19$1, _descriptor20$1, _descriptor21$1;
    let loginHeight = 500;
    let registerHeight = 500;
    let width = 500;
    let buttonHeight = 60;
    let fontAwesomeIconHeight = 40;
    let textColor = "#252525";
    let signInButtonHeight = 50;
    let signInButtonWidth = 120;
    let LoginStyle = (_class$1i = class LoginStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "loginRegisterSystem", _descriptor$E, this);
        _initializerDefineProperty(this, "loginRegisterButtons", _descriptor2$A, this);
        _initializerDefineProperty(this, "loginSystemButton", _descriptor3$t, this);
        _initializerDefineProperty(this, "registerSystemButton", _descriptor4$q, this);
        this.selectedLeft = {
          borderBottom: "0",
          borderRight: "0",
          backgroundColor: "#fff",
          fontWeight: "bold"
        };
        _initializerDefineProperty(this, "selectedLeftClass", _descriptor5$o, this);
        this.selectedRight = {
          borderBottom: "0",
          borderLeft: "0",
          backgroundColor: "#fff",
          fontWeight: "bold"
        };
        _initializerDefineProperty(this, "selectedRightClass", _descriptor6$k, this);
        _initializerDefineProperty(this, "loginWidget", _descriptor7$g, this);
        _initializerDefineProperty(this, "registerWidget", _descriptor8$f, this);
        this.fontAwesomeIcon = {
          height: fontAwesomeIconHeight + "px",
          lineHeight: fontAwesomeIconHeight + "px",
          width: "15%",
          maxWidth: "15%",
          textAlign: "center",
          fontSize: "150%",
          display: "inline-block",
          float: "left",
          borderTopLeftRadius: "5px",
          borderBottomLeftRadius: "5px",
          borderRight: "0px solid white",
          marginTop: "20px"
        };
        _initializerDefineProperty(this, "input", _descriptor9$b, this);
        _initializerDefineProperty(this, "countrySelect", _descriptor10$9, this);
        _initializerDefineProperty(this, "badLogin", _descriptor11$7, this);
        _initializerDefineProperty(this, "forgotPassword", _descriptor12$5, this);
        _initializerDefineProperty(this, "signInButtonContainer", _descriptor13$5, this);
        _initializerDefineProperty(this, "signInButton", _descriptor14$5, this);
        _initializerDefineProperty(this, "horizontalLine", _descriptor15$4, this);
        this.connectWith = {
          width: "100%",
          textAlign: "center",
          marginTop: "20px"
        };
        this.connectIcons = {
          width: "60%",
          marginLeft: "20%",
          marginRight: "20%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: "20px"
        };
        _initializerDefineProperty(this, "faLogo", _descriptor16$4, this);
        _initializerDefineProperty(this, "recaptchaContainer", _descriptor17$4, this);
        _initializerDefineProperty(this, "connectWithButtonsSpan", _descriptor18$2, this);
        _initializerDefineProperty(this, "thirdPartyLoginContainer", _descriptor19$1, this);
        this.socialConnectDimensions = "35px";
        _initializerDefineProperty(this, "socialConnectButtonContainer", _descriptor20$1, this);
        _initializerDefineProperty(this, "socialConnectButtonIcon", _descriptor21$1, this);
      }
    }, (_descriptor$E = _applyDecoratedDescriptor(_class$1i.prototype, "loginRegisterSystem", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          if (Device.isTouchDevice()) {
            console.log("Touch device mode on");
            return {
              position: "absolute",
              height: loginHeight + "px",
              width: width + "px",
              backgroundColor: "#fff",
              maxHeight: "100%",
              maxWidth: "100%"
            };
          } else {
            return {
              maxWidth: "100%",
              height: loginHeight + "px",
              width: width + "px",
              margin: "0 auto",
              backgroundColor: "#fff"
            };
          }
        };
      }
    }), _descriptor2$A = _applyDecoratedDescriptor(_class$1i.prototype, "loginRegisterButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          width: "100%",
          height: buttonHeight / loginHeight * 100 + "%"
        };
      }
    }), _descriptor3$t = _applyDecoratedDescriptor(_class$1i.prototype, "loginSystemButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // height: buttonHeight + "px",
          height: "100%",
          // lineHeight: buttonHeight / loginHeight * 100 + "%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          textAlign: "center",
          width: "50%",
          backgroundColor: "#f6f6f6",
          color: textColor,
          border: "1px solid #d3d5d9",
          cursor: "pointer",
          float: "left",
          borderLeft: "0",
          borderTop: "0",
          textTransform: "uppercase",
          fontSize: "1.1em"
        };
      }
    }), _descriptor4$q = _applyDecoratedDescriptor(_class$1i.prototype, "registerSystemButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // height: buttonHeight + "px",
          height: "100%",
          // lineHeight: buttonHeight / loginHeight * 100 + "%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          textAlign: "center",
          width: "50%",
          backgroundColor: "#f6f6f6",
          color: textColor,
          border: "1px solid #d3d5d9",
          cursor: "pointer",
          float: "left",
          borderRight: "0",
          borderTop: "0",
          textTransform: "uppercase",
          fontSize: "1.1em"
        };
      }
    }), _descriptor5$o = _applyDecoratedDescriptor(_class$1i.prototype, "selectedLeftClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "0",
          borderRight: "0",
          backgroundColor: "#fff"
        };
      }
    }), _descriptor6$k = _applyDecoratedDescriptor(_class$1i.prototype, "selectedRightClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "0",
          borderLeft: "0",
          backgroundColor: "#fff"
        };
      }
    }), _descriptor7$g = _applyDecoratedDescriptor(_class$1i.prototype, "loginWidget", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: loginHeight - buttonHeight + "px",
          width: width + "px",
          maxWidth: "100%",
          padding: "5% 10%",
          color: textColor,
          borderTop: "0px solid #d3d5d9"
        };
      }
    }), _descriptor8$f = _applyDecoratedDescriptor(_class$1i.prototype, "registerWidget", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: registerHeight - buttonHeight + "px",
          width: width + "px",
          maxWidth: "100%",
          padding: "5% 10%",
          color: textColor,
          borderTop: "0px solid #d3d5d9"
        };
      }
    }), _descriptor9$b = _applyDecoratedDescriptor(_class$1i.prototype, "input", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "85%",
          maxWidth: "85%",
          height: fontAwesomeIconHeight + "px",
          lineHeight: fontAwesomeIconHeight + "px",
          display: "inline-block",
          float: "left",
          borderRadius: "0",
          borderTopRightRadius: "5px",
          borderBottomRightRadius: "5px",
          marginTop: "20px",
          fontWeight: "bold",
          color: textColor,
          border: "0px solid #d3d5d9",
          borderLeft: "0px solid white",
          boxShadow: "none",
          fontSize: "85%",
          ":focus": {
            boxShadow: "none",
            outline: "none",
            border: "0px solid #d3d5d9",
            borderLeft: "0px solid white"
          }
        };
      }
    }), _descriptor10$9 = _applyDecoratedDescriptor(_class$1i.prototype, "countrySelect", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "85%",
          maxWidth: "85%",
          lineHeight: "30px",
          marginTop: "30px",
          marginBottom: "10px"
        };
      }
    }), _descriptor11$7 = _applyDecoratedDescriptor(_class$1i.prototype, "badLogin", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "30px",
          width: "100%",
          fontSize: "14px",
          color: this.themeProps.COLOR_DANGER,
          textAlign: "center"
        };
      }
    }), _descriptor12$5 = _applyDecoratedDescriptor(_class$1i.prototype, "forgotPassword", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          paddingRight: "5px"
        };
      }
    }), _descriptor13$5 = _applyDecoratedDescriptor(_class$1i.prototype, "signInButtonContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: "50px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "20px auto"
        };
      }
    }), _descriptor14$5 = _applyDecoratedDescriptor(_class$1i.prototype, "signInButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "auto",
          marginRight: "auto",
          backgroundColor: "#f6f6f6",
          marginTop: "20px",
          minWidth: signInButtonWidth + "px",
          height: signInButtonHeight + "px",
          textAlign: "center",
          lineHeight: signInButtonHeight + "px",
          border: "0px solid #d3d5d9",
          fontSize: "18px",
          color: "#252525",
          ":hover": {
            border: "0px solid #0b79a7",
            borderBottom: "2px solid #0b79a7",
            color: "#0b79a7"
          }
        };
      }
    }), _descriptor15$4 = _applyDecoratedDescriptor(_class$1i.prototype, "horizontalLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "1px solid #d3d5d9",
          width: "100%",
          marginTop: "20px"
        };
      }
    }), _descriptor16$4 = _applyDecoratedDescriptor(_class$1i.prototype, "faLogo", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          paddingLeft: "15px",
          paddingRight: "15px",
          borderRadius: "3px",
          textAlign: "center",
          fontSize: "18px",
          marginLeft: "5px",
          marginRight: "5px",
          transition: ".2s",
          color: "#fff",
          ":hover": {
            transition: ".2s",
            opacity: ".9"
          },
          cursor: "pointer",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          fontWeight: "bold"
        };
      }
    }), _descriptor17$4 = _applyDecoratedDescriptor(_class$1i.prototype, "recaptchaContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "space-around",
          alignItems: "center",
          flexDirection: "column",
          width: "100%"
        };
      }
    }), _descriptor18$2 = _applyDecoratedDescriptor(_class$1i.prototype, "connectWithButtonsSpan", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: "15px",
          fontSize: "15px"
        };
      }
    }), _descriptor19$1 = _applyDecoratedDescriptor(_class$1i.prototype, "thirdPartyLoginContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexWrap: "wrap",
          margin: "15px 0"
        };
      }
    }), _descriptor20$1 = _applyDecoratedDescriptor(_class$1i.prototype, "socialConnectButtonContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          alignItems: "center",
          height: this.socialConnectDimensions,
          color: "#fff",
          paddingRight: "10px",
          borderRadius: "5px",
          margin: "5px",
          outline: "none",
          paddingTop: "0",
          cursor: "pointer",
          fontSize: "13px",
          border: "0",
          ":hover": {
            opacity: ".85"
          }
        };
      }
    }), _descriptor21$1 = _applyDecoratedDescriptor(_class$1i.prototype, "socialConnectButtonIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.socialConnectDimensions,
          width: this.socialConnectDimensions,
          display: "flex !important",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    })), _class$1i);

    class SocialAccountManager extends Dispatchable {
      constructor(socialApp, options) {
        super();
        this.socialApp = socialApp;
        this.options = options;
      }
      getSocialApp() {
        return this.socialApp;
      }
      getClientId() {
        return this.getSocialApp().getClientId();
      }
      setLoaded() {
        this.loaded = true;
        this.dispatch("loaded");
      }
      static getInstance() {
        if (!this._Global) {
          this._Global = new this();
        }
        return this._Global;
      }

      // TODO: all managers should call the onError function (if one is passed in) to report issues
      static login(callback, onError) {
        this.getInstance().login(...arguments);
      }
      static connect(callback, onError) {
        this.getInstance().connect(...arguments);
      }
    }

    class GoogleManager extends SocialAccountManager {
      constructor() {
        super(SocialAppStore.getSocialAppByName("Google"), {
          loginByTokenUrl: "/accounts/google/login/token/"
        });
        this.ensureScriptNodeExists();
      }
      sendData(url, data, onSuccess = NOOP_FUNCTION) {
        Ajax.postJSON(url, data).then(onSuccess);
      }
      ensureScriptNodeExists() {
        const id = "google-jsapi";
        if (document.getElementById(id)) {
          return;
        }
        let scriptElement = document.createElement("script");
        scriptElement.id = id;
        scriptElement.async = true;
        scriptElement.onload = () => {
          gapi.load("auth2", () => {
            gapi.auth2.init({
              client_id: this.getClientId()
            }).then(() => {
              // Handle the initial sign-in state.
              // this.updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
              this.updateSigninStatus(this.getGoogleAuth().isSignedIn.get());

              // Listen for sign-in state changes.
              // gapi.auth2.getAuthInstance().isSignedIn.listen(this.updateSigninStatus);
              this.getGoogleAuth().isSignedIn.listen(this.updateSigninStatus);
              this.setLoaded();
            });
          });
        };
        scriptElement.src = "https://apis.google.com/js/platform.js";
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
      }
      getGoogleAuth() {
        return gapi.auth2.getAuthInstance();
      }
      getGoogleUser() {
        return this.getGoogleAuth().currentUser.get();
      }
      getAuthResponse() {
        return this.getGoogleUser().getAuthResponse();
      }
      updateSigninStatus(isSignedIn) {
        if (isSignedIn) {
          console.log("Google user is signed in");
        }
      }
      handleProcess(process) {
        if (!this.loaded) {
          this.addListenerOnce("loaded", () => this.handleProcess(process));
          return;
        }
        this.getGoogleAuth().grantOfflineAccess({
          redirect_uri: "postmessage",
          immediate: false
        }).then(data => {
          Object.assign(data, {
            process: process
          });
          this.sendData(this.options.loginByTokenUrl, data, () => self.location.reload());
        });
      }
      login() {
        this.handleProcess("login");
      }
      connect() {
        this.handleProcess("connect");
      }
    }

    class FacebookManager extends SocialAccountManager {
      constructor() {
        super(SocialAppStore.getSocialAppByName("Facebook"), {
          version: "v2.7",
          loginByTokenUrl: "/accounts/facebook/login/token/",
          loginOptions: {
            auth_type: "rerequest",
            scope: "email"
          },
          logoutUrl: "/accounts/logout/",
          // TODO: should probably look at https://www.facebook.com/translations/FacebookLocales.xml and Language.Locale
          locale: "en_US"
        });
        this.ensureScriptNodeExists();
      }
      sendData(url, data) {
        Ajax.postJSON(url, data).then(data => {
          if (data.next) {
            self.location.href = data.next;
          } else {
            location.reload();
          }
        }, error => {
          this.dispatch("loginError", error);
        });
      }
      ensureScriptNodeExists() {
        self.fbAsyncInit = () => {
          FB.init({
            appId: this.getClientId(),
            version: this.options.version,
            status: true,
            cookie: true,
            xfbml: true
          });
          this.setLoaded();
        };
        const id = "facebook-jssdk";
        if (document.getElementById(id)) {
          return;
        }
        let scriptElement = document.createElement("script");
        scriptElement.id = id;
        scriptElement.async = true;
        scriptElement.src = "//connect.facebook.net/" + this.options.locale + "/sdk.js";
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
      }
      onLoginCanceled(response) {}
      onLoginError(response) {}
      onLoginSuccess(response, nextUrl, process) {
        let data = {
          next: nextUrl || '',
          process: process,
          accessToken: response.authResponse.accessToken,
          expiresIn: response.authResponse.expiresIn
        };
        this.sendData(this.options.loginByTokenUrl, data);
      }
      logout() {
        if (!self.FB) {
          return;
        }
        FB.logout(response => {
          this.onLogoutSuccess(response, nextUrl);
        });
      }
      onLogoutSuccess(response) {
        if (this.options.logoutUrl) {
          this.sendData(this.options.logoutUrl, data);
        }
      }
      handleProcess(nextUrl, action, process) {
        if (!this.loaded) {
          this.addListenerOnce("loaded", () => this.handleProcess(process));
          return;
        }
        if (action === "reauthenticate") {
          this.options.loginOptions.auth_type = action;
        }
        FB.login(response => {
          if (response.authResponse) {
            this.onLoginSuccess(response, nextUrl, process);
          } else if (response && response.status && ["not_authorized", "unknown"].indexOf(response.status) > -1) {
            this.onLoginCanceled(response);
          } else {
            this.onLoginError(response);
          }
        }, this.options.loginOptions);
      }
      login(nextUrl, action, process) {
        this.handleProcess(self.location.pathname, "authenticate", "login");
      }
      connect(nextUrl, action, process) {
        this.handleProcess(self.location.pathname, "authenticate", "connect");
      }
    }

    class GithubManager extends SocialAccountManager {
      constructor() {
        super(SocialAppStore.getSocialAppByName("Github"), {
          loginWindowOptions: "height=600,width=800,scrollbars=yes"
        });
      }
      login(callback) {
        const githubUri = "https://github.com/login/oauth/authorize";
        const rawParams = {
          client_id: this.getClientId()
        };
        const uri = composeURL(githubUri, rawParams);
        const githubWindow = window.open(uri, "githubWindow", this.options.loginWindowOptions);
        githubWindow.onbeforeunload = callback;
      }
    }

    var _dec$T, _class$1h, _dec2$l, _class2$G;
    const THIRD_PARTY_LOGIN_HANDLERS = {
      Google: {
        name: "Google",
        color: "#de4b39",
        icon: "google",
        loginManager: GoogleManager
      },
      Facebook: {
        name: "Facebook",
        color: "#3b5998",
        icon: "facebook",
        loginManager: FacebookManager
      },
      Github: {
        name: "Github",
        color: "#000",
        icon: "github",
        loginManager: GithubManager
      }
    };
    let SocialConnectButton = (_dec$T = registerStyle(LoginStyle), _dec$T(_class$1h = class SocialConnectButton extends UI$1.Primitive("button") {
      extraNodeAttributes(attr) {
        let {
          specificInfo
        } = this.options;
        attr.addClass(this.styleSheet.socialConnectButtonContainer);
        attr.setStyle({
          backgroundColor: specificInfo.color
        });
      }
      getLoginManager() {
        return this.options.specificInfo.loginManager.getInstance();
      }
      render() {
        let {
          specificInfo
        } = this.options;
        return [MakeIcon(specificInfo.icon, {
          className: this.styleSheet.socialConnectButtonIcon
        }), UI$1.createElement("span", null, " ", specificInfo.name)];
      }
      onMount() {
        // Access the login manager, to load any scripts needed by the social provider
        // TODO: try to find a way to not load all provider scripts on the login page
        this.getLoginManager();
        this.addClickListener(() => {
          this.options.loginElement?.clearErrorMessage();
          this.getLoginManager().login();
        });
      }
    }) || _class$1h);
    let ThirdPartyLogin = (_dec2$l = registerStyle(LoginStyle), _dec2$l(_class2$G = class ThirdPartyLogin extends UI$1.Element {
      getConnectWith() {
        return UI$1.createElement("div", {
          style: this.styleSheet.connectWith
        }, UI$1.T("or connect with"));
      }
      getConnectWithButtons() {
        const {
          socialApps
        } = this.options;
        return UI$1.createElement("div", {
          className: this.styleSheet.thirdPartyLoginContainer
        }, socialApps.map(socialApp => UI$1.createElement(SocialConnectButton, {
          specificInfo: THIRD_PARTY_LOGIN_HANDLERS[socialApp.name],
          loginElement: this.options.loginElement
        })));
      }
      render() {
        return [this.getConnectWith(), this.getConnectWithButtons()];
      }
    }) || _class2$G);

    var _dec$S, _class$1g, _dec2$k, _class2$F, _dec3$8, _class3$h, _dec4$3, _class4$9, _dec5$1, _class5$4;
    const ERROR_TIMEOUT = 6 * 1000;
    let LoginWidget = (_dec$S = registerStyle(LoginStyle), _dec$S(_class$1g = class LoginWidget extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.loginWidget);
      }
      getEmailInput(emailIcon = "user") {
        return [UI$1.createElement("div", {
          style: {
            width: "100%"
          }
        }, UI$1.createElement(FAIcon, {
          icon: emailIcon,
          style: this.styleSheet.fontAwesomeIcon
        }), UI$1.createElement(EmailInput, {
          autofocus: "autofocus",
          placeholder: "Email address",
          name: "email",
          ref: "emailInput",
          className: this.styleSheet.input
        }))];
      }
      getPasswordInput(passwordInputOptions = {}) {
        passwordInputOptions = Object.assign({
          name: "password",
          className: this.styleSheet.input,
          ref: "passwordInput",
          placeholder: "Password",
          style: {
            marginBottom: "20px"
          }
        }, passwordInputOptions);
        return [UI$1.createElement("div", {
          style: {
            width: "80% !important"
          }
        }, UI$1.createElement(FAIcon, {
          icon: "lock",
          style: this.styleSheet.fontAwesomeIcon
        }), UI$1.createElement(PasswordInput, passwordInputOptions))];
      }
      getForgotPassword() {
        return UI$1.createElement(Link, {
          className: this.styleSheet.forgotPassword,
          href: "/accounts/password_reset",
          value: UI$1.T("Forgot Password?")
        });
      }
      getClearBothArea() {
        return UI$1.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        });
      }
      getErrorArea() {
        return UI$1.createElement(TemporaryMessageArea, {
          className: this.styleSheet.badLogin,
          ref: "loginErrorMessage"
        });
      }
      getSignInValue() {
        return "Sign In";
      }
      getSignInButton() {
        return UI$1.createElement("div", {
          className: this.styleSheet.signInButtonContainer
        }, UI$1.createElement(SubmitInput, {
          className: this.styleSheet.signInButton,
          value: this.getSignInValue()
        }));
      }
      getHorizontalLine() {
        return UI$1.createElement("div", {
          className: this.styleSheet.horizontalLine
        });
      }
      getThirdPartyLogin() {
        const socialApps = SocialAppStore.all();
        return socialApps.length > 0 && [this.getHorizontalLine(), UI$1.createElement(ThirdPartyLogin, {
          socialApps: socialApps,
          loginElement: this
        })];
      }
      render() {
        return [UI$1.createElement("form", {
          ref: "form"
        }, this.getEmailInput(), this.getPasswordInput(), this.getForgotPassword(), this.getSignInButton(), this.getClearBothArea(), this.getErrorArea()), this.getThirdPartyLogin()];
      }
      setErrorMessage(error, isError = true) {
        this.loginErrorMessage.showMessage(error.message, isError ? Theme.props.COLOR_DANGER : "#000", ERROR_TIMEOUT);
      }
      clearErrorMessage() {
        this.loginErrorMessage.clear();
      }
      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue(),
          password: this.passwordInput.getValue(),
          remember: true
        };
        Ajax.postJSON("/accounts/login/", data).then(() => location.reload(), error => this.setErrorMessage(error));
      }
      onMount() {
        if (this.form) {
          this.form.addNodeListener("submit", event => {
            this.sendLogin();
            event.preventDefault();
          });
        }
      }
    }) || _class$1g);
    class RecaptchaWidget extends UI$1.Element {
      render() {
        return UI$1.createElement("div", {
          key: Math.random()
        });
      }
      redraw() {
        super.redraw();
        if (window.grecaptcha && window.GOOGLE_RECAPTCHA_PUBLIC_KEY) {
          this.captchaId = grecaptcha.render(this.children[0].node, {
            "sitekey": window.GOOGLE_RECAPTCHA_PUBLIC_KEY
          });
        }
      }
      getResponse() {
        return grecaptcha.getResponse(this.captchaId);
      }
      onMount() {
        window.onRecaptchaCallback = () => this.redraw();
        ensure("https://www.google.com/recaptcha/api.js?render=explicit&onload=onRecaptchaCallback", () => {});
      }
    }
    let RegisterWidget = (_dec2$k = registerStyle(LoginStyle), _dec2$k(_class2$F = class RegisterWidget extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.registerWidget);
      }
      getSignUpButton() {
        return UI$1.createElement("div", {
          className: this.styleSheet.signInButtonContainer
        }, UI$1.createElement(SubmitInput, {
          className: this.styleSheet.signInButton,
          value: "Sign Up",
          ref: "submitButton"
        }));
      }
      getUsernameInput() {
        return [UI$1.createElement("div", {
          style: {
            width: "100%"
          }
        }, UI$1.createElement(FAIcon, {
          icon: "user",
          style: this.styleSheet.fontAwesomeIcon
        }), UI$1.createElement(TextInput, {
          placeholder: "Username",
          ref: "usernameInput",
          className: this.styleSheet.input
        }))];
      }
      getCountryInput() {
        return [UI$1.createElement("div", {
          style: {
            width: "100%",
            marginBottom: "20px"
          }
        }, UI$1.createElement(FAIcon, {
          icon: "flag",
          style: this.styleSheet.fontAwesomeIcon
        }), UI$1.createElement(Select, {
          ref: "countrySelect",
          options: CountryStore.allWithNone("Don't set country"),
          className: this.styleSheet.countrySelect
        }), UI$1.createElement("div", {
          style: {
            clear: "both"
          }
        }))];
      }
      render() {
        let formFields = [this.getEmailInput(), this.getPasswordInput()];
        {
          formFields.splice(1, 0, this.getUsernameInput());
          formFields[0] = this.getEmailInput("envelope");
        }
        {
          formFields[formFields.length - 1] = this.getPasswordInput({
            style: {}
          });
          formFields.push(this.getCountryInput());
        }
        // TODO: This should be done in another way.
        if (window.location.hostname !== "localhost") {
          this.recaptchaWidget = UI$1.createElement(RecaptchaWidget, null);
        }
        return [UI$1.createElement("form", {
          ref: "form"
        }, formFields, UI$1.createElement("div", {
          className: this.styleSheet.recaptchaContainer
        }, this.recaptchaWidget, this.getSignUpButton(), UI$1.createElement(TemporaryMessageArea, {
          ref: "errorArea"
        })))];
      }
      sendRegistration() {
        this.submitButton.updateOptions({
          value: "Signing up..."
        });
        const data = {
          email: this.emailInput.getValue(),
          recaptchaKey: this.recaptchaWidget && this.recaptchaWidget.getResponse(),
          password: this.passwordInput.getValue()
        };
        if (this.usernameInput) {
          data.username = this.usernameInput.getValue();
        }
        if (this.countrySelect) {
          data.countryId = this.countrySelect.get().id;
        }
        Ajax.postJSON("/accounts/signup_request/", data).then(() => {
          this.recaptchaWidget && this.recaptchaWidget.hide();
          this.submitButton.hide();
          this.errorArea.showMessage("Done! Please check your email to continue", "black", 26 * 60 * 60 * 1000);
        }, error => {
          this.errorArea.showMessage("Error in registration: " + error.message, "red", 4000);
          this.submitButton.updateOptions({
            value: "Sign Up"
          });
          this.recaptchaWidget && this.recaptchaWidget.redraw();
        });
      }
      onMount() {
        this.form.addNodeListener("submit", event => {
          event.preventDefault();
          this.sendRegistration();
        });
      }
    }) || _class2$F);
    RegisterWidget.prototype.getEmailInput = LoginWidget.prototype.getEmailInput;
    RegisterWidget.prototype.getPasswordInput = LoginWidget.prototype.getPasswordInput;
    RegisterWidget.prototype.getHorizontalLine = LoginWidget.prototype.getHorizontalLine;

    // original name: LoginRegisterSystem
    let NormalLogin = (_dec3$8 = registerStyle(LoginStyle), _dec3$8(_class3$h = class NormalLogin extends UI$1.Element {
      constructor() {
        super();
        this.state = 0;
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.loginRegisterSystem);
      }
      getLoginButton() {
        let style = {};
        if (this.state === 0) {
          style = this.styleSheet.selectedLeft;
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.loginSystemButton,
          style: style,
          ref: "loginButton"
        }, UI$1.T("Log In"));
      }
      getRegisterButton() {
        let style = {};
        if (this.state === 1) {
          style = this.styleSheet.selectedRight;
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.registerSystemButton,
          style: style,
          ref: "registerButton"
        }, UI$1.T("Sign Up"));
      }
      render() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.loginRegisterButtons
        }, this.getLoginButton(), this.getRegisterButton()), UI$1.createElement(Switcher, {
          ref: "switcher"
        }, UI$1.createElement(LoginWidget, {
          ref: "loginWidget",
          active: this.state === 0
        }), UI$1.createElement(RegisterWidget, {
          ref: "registerWidget",
          active: this.state === 1
        }))];
      }
      onMount() {
        this.loginButton.addClickListener(() => {
          this.state = 0;
          this.switcher.setActive(this.loginWidget);
          this.redraw();
        });
        this.registerButton.addClickListener(() => {
          this.state = 1;
          this.switcher.setActive(this.registerWidget);
          this.redraw();
        });
      }
    }) || _class3$h);
    (_dec4$3 = registerStyle(LoginStyle), _dec4$3(_class4$9 = class LoginTabButton extends UI$1.Primitive(BasicTabTitle, "div") {
      getDefaultOptions() {
        return {
          children: [UI$1.T("Log In")]
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.loginSystemButton);
        if (this.options.active) {
          attr.addClass(this.styleSheet.selectedLeftClass);
        }
      }
    }) || _class4$9);
    (_dec5$1 = registerStyle(LoginStyle), _dec5$1(_class5$4 = class RegisterTabButton extends UI$1.Primitive(BasicTabTitle, "div") {
      getDefaultOptions() {
        return {
          children: [UI$1.T("Register")]
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.registerSystemButton);
        if (this.options.active) {
          attr.addClass(this.styleSheet.selectedRightClass);
        }
      }
    }) || _class5$4);
    class Login extends UI$1.Element {
      render() {
        return [UI$1.createElement(NormalLogin, null)];
      }
    }

    class LoginModal extends Modal {
      getModalWindowStyle() {
        if (Device.isTouchDevice()) {
          return {
            position: "relative",
            padding: "0",
            boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
            // margin: "60px auto",
            display: this.options.display || "block",
            left: "0",
            right: "0",
            width: "100vw",
            height: "600px",
            background: "white",
            overflow: this.options.overflow || "auto",
            maxHeight: "100%",
            maxWidth: "500px",
            verticalAlign: "center",
            margin: "0 auto"
          };
        }
        return {
          position: "relative",
          padding: "0",
          boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
          margin: "60px auto",
          display: this.options.display || "block",
          maxHeight: this.options.maxHeight || "85%",
          left: "0",
          right: "0",
          width: "500px",
          height: this.options.height || "600px",
          background: "white",
          overflow: this.options.overflow || "auto"
        };
      }
      render() {
        return UI$1.createElement(Login, null);
      }
      static requireLogin(func) {
        if (USER.isAuthenticated) {
          return func();
        } else {
          this.show();
        }
      }
    }

    var _class$1f, _descriptor$D, _descriptor2$z, _descriptor3$s, _descriptor4$p, _descriptor5$n;
    let VotingWidgetStyle = (_class$1f = class VotingWidgetStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.height = 40;
        this.size = 1;
        this.likeColor = this.options.likeColor || "#1E8921";
        //            |
        this.dislikeColor = this.options.dislikeColor || "#C5302C";
        //      |- Triadic colors + Shades
        this.notVoteColor = this.options.notVoteColor || "#313534";
        this.balanceColor = this.options.balanceColor || "#313534";
        this.orientation = Orientation$1.VERTICAL;
        _initializerDefineProperty(this, "container", _descriptor$D, this);
        this.mainClass = {
          height: "40px",
          lineHeight: "40px",
          fontSize: "14px",
          color: "#767676",
          display: "inline-block",
          float: "right",
          textAlign: "right"
        };
        this.thumbsStyle = {
          fontSize: this.height / 2 + "px",
          lineHeight: this.height + "px"
        };
        _initializerDefineProperty(this, "displayStyle", _descriptor2$z, this);
        this.counterStyle = {
          fontSize: 18 * this.size + "px",
          fontWeight: "900",
          color: this.balanceColor
        };
        _initializerDefineProperty(this, "thumbsUpHoverStyle", _descriptor3$s, this);
        _initializerDefineProperty(this, "thumbsDownHoverStyle", _descriptor4$p, this);
        _initializerDefineProperty(this, "padding", _descriptor5$n, this);
      }
    }, (_descriptor$D = _applyDecoratedDescriptor(_class$1f.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          fontSize: "14px",
          color: "#767676",
          display: "flex",
          justifyContent: "flex-end",
          alignItems: "center"
        };
      }
    }), _descriptor2$z = _applyDecoratedDescriptor(_class$1f.prototype, "displayStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          paddingLeft: "3px"
        };
      }
    }), _descriptor3$s = _applyDecoratedDescriptor(_class$1f.prototype, "thumbsUpHoverStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: ".25s",
          ":hover": {
            color: this.likeColor,
            opacity: ".8",
            transition: ".25s"
          }
        };
      }
    }), _descriptor4$p = _applyDecoratedDescriptor(_class$1f.prototype, "thumbsDownHoverStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: ".25s",
          ":hover": {
            color: this.dislikeColor,
            opacity: ".8",
            transition: ".25s"
          }
        };
      }
    }), _descriptor5$n = _applyDecoratedDescriptor(_class$1f.prototype, "padding", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "3px",
          float: "left",
          display: "inline-block",
          height: this.height + "px"
        };
      }
    })), _class$1f);

    var _dec$R, _class$1e;
    class VotingWidget extends UI$1.Element {
      setOptions(options) {
        options = Object.assign({
          votesBalance: 0,
          userVote: VoteStatus.NONE,
          size: 1,
          likeColor: this.options.likeColor || "#1E8921",
          //            |
          dislikeColor: this.options.dislikeColor || "#C5302C",
          //      |- Triadic colors + Shades
          notVoteColor: this.options.notVoteColor || "#313534",
          balanceColor: this.options.balanceColor || "#313534",
          orientation: Orientation$1.VERTICAL
        }, options);
        super.setOptions(options);
      }
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center",
          marginRight: "10px"
        });
      }
      render() {
        let buttonsStyle = {
          paddingLeft: "4px",
          paddingRight: "4px",
          paddingTop: "0px",
          paddingBottom: "0px",
          lineHeight: "0px",
          backgroundColor: "transparent",
          borderColor: "transparent",
          fontSize: 40 * this.options.size + "px",
          marginTop: 8 * this.options.size + "px",
          marginBottom: 8 * this.options.size + "px",
          display: this.options.orientation === Orientation$1.VERTICAL ? "block" : "inline-block",
          marginLeft: "auto",
          marginRight: "auto",
          opacity: 0.7,
          cursor: "pointer",
          color: this.options.notVoteColor
        };
        let likeButtonStyle = Object.assign({}, buttonsStyle);
        if (this.getUserVote() === VoteStatus.LIKE) {
          likeButtonStyle.color = this.options.likeColor;
        }
        let dislikeButtonStyle = Object.assign({}, buttonsStyle);
        if (this.getUserVote() === VoteStatus.DISLIKE) {
          dislikeButtonStyle.color = this.options.dislikeColor;
        }
        let counterStyle = {
          fontSize: 18 * this.options.size + "px",
          fontWeight: "900",
          "color": this.options.balanceColor
        };
        return [UI$1.createElement("span", {
          className: "fa fa-caret-up voteButton",
          ref: "likeButton",
          icon: "caret-up",
          style: likeButtonStyle,
          HTMLtitle: "Click to like"
        }), UI$1.createElement("span", {
          ref: "counterContainer",
          style: counterStyle
        }, UI$1.createElement(UI$1.TextElement, {
          ref: "counter",
          value: this.getVotesBalance() + ""
        })), UI$1.createElement("span", {
          className: "fa fa-caret-down voteButton",
          ref: "dislikeButton",
          icon: "caret-down",
          style: dislikeButtonStyle,
          HTMLtitle: "Click to dislike"
        })];
      }
      getVotesBalance() {
        return this.options.votesBalance;
      }
      getUserVote() {
        return this.options.userVote;
      }
    }
    class CommentVotingWidget extends VotingWidget {
      getVotesBalance() {
        return this.options.message.getVotesBalance();
      }
      getUserVote() {
        return this.options.message.getUserVote();
      }
      setOptions(options) {
        super.setOptions(options);
        this.updateTarget(this.options.message);
      }
      updateTarget(target) {
        if (!target || target instanceof UserReactionCollection) {
          this.options.target = target;
          return;
        }
        const possibleTarget = target.getReactionCollection();
        if (possibleTarget) {
          this.options.target = possibleTarget;
          return;
        }
        let tempListener = this.attachEventListener(target, "createReactionCollection", () => {
          this.updateOptions({
            target: target.getReactionCollection()
          });
          this.setupListener();
          tempListener.remove();
        });
      }
      setupListener() {
        let target = this.options.target;
        if (target) {
          this.attachChangeListener(target, () => {
            this.redraw();
          });
        }
      }
      onMount() {
        this.setupListener();
        this.likeButton.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }
          if (this.getUserVote() === VoteStatus.LIKE) {
            this.options.message.resetReaction();
          } else {
            this.options.message.like();
          }
        });
        this.dislikeButton.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }
          if (this.getUserVote() === VoteStatus.DISLIKE) {
            this.options.message.resetReaction();
          } else {
            this.options.message.dislike();
          }
        });
        this.options.message.addListener("reaction", () => {
          this.redraw();
        });
      }
    }

    // TODO: rewrite
    let CommentVotingWidgetWithThumbs = (_dec$R = registerStyle(VotingWidgetStyle), _dec$R(_class$1e = class CommentVotingWidgetWithThumbs extends CommentVotingWidget {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.container);
      }
      getNumLikes() {
        return this.options.message.getNumLikes();
      }
      getNumDislikes() {
        return this.options.message.getNumDislikes();
      }
      render() {
        let thumbsUpScoreStyle = {};
        let thumbsDownScoreStyle = {};

        // TODO: remove duplicate code
        let likeButtonStyle = Object.assign({}, this.styleSheet.thumbsStyle);
        if (this.getUserVote() === VoteStatus.LIKE) {
          likeButtonStyle.color = thumbsUpScoreStyle.color = this.options.likeColor;
          thumbsUpScoreStyle.fontWeight = "bold";
        }
        let dislikeButtonStyle = Object.assign({}, this.styleSheet.thumbsStyle);
        if (this.getUserVote() === VoteStatus.DISLIKE) {
          dislikeButtonStyle.color = thumbsDownScoreStyle.color = this.options.dislikeColor;
          thumbsDownScoreStyle.fontWeight = "bold";
        }
        return [UI$1.createElement("span", {
          className: this.styleSheet.displayStyle,
          style: thumbsUpScoreStyle
        }, this.getNumLikes()), UI$1.createElement("span", {
          className: "fa fa-thumbs-up voteButton " + this.styleSheet.displayStyle + " " + this.styleSheet.thumbsUpHoverStyle,
          ref: "likeButton",
          icon: "thumbs-up",
          style: likeButtonStyle,
          HTMLtitle: "Click to like"
        }), UI$1.createElement("div", {
          className: this.styleSheet.padding
        }), UI$1.createElement("span", {
          className: this.styleSheet.displayStyle,
          style: thumbsDownScoreStyle
        }, this.getNumDislikes()), UI$1.createElement("span", {
          className: "fa fa-thumbs-down voteButton " + this.styleSheet.displayStyle + " " + this.styleSheet.thumbsDownHoverStyle,
          ref: "dislikeButton",
          icon: "thumbs-down",
          style: dislikeButtonStyle,
          HTMLtitle: "Click to dislike"
        })];
      }
    }) || _class$1e);

    var _class$1d, _descriptor$C, _descriptor2$y, _descriptor3$r, _descriptor4$o, _descriptor5$m, _descriptor6$j, _descriptor7$f, _descriptor8$e, _descriptor9$a, _descriptor10$8, _descriptor11$6;
    let ChatStyle = (_class$1d = class ChatStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.navbarHeight = "50px";
        this.renderMessageHeight = "100px";
        this.userFontSize = "1.1em";
        this.commentFontSize = "1.1em";
        this.backgroundColor = "#fff";
        this.hrBackgroundColor = "#ddd";
        this.hoverBackgroundColor = "#f8f8f8";
        _initializerDefineProperty(this, "renderMessageView", _descriptor$C, this);
        _initializerDefineProperty(this, "renderMessage", _descriptor2$y, this);
        _initializerDefineProperty(this, "chatInput", _descriptor3$r, this);
        _initializerDefineProperty(this, "messageBoxButton", _descriptor4$o, this);
        this.previewButton = {
          // TODO: This is currently not restyled.
          // We might not want to use it because previewButton is bad practice
          height: "30px",
          width: "30px",
          borderRadius: "100%",
          fontSize: "100%",
          marginLeft: "5px"
        };
        this.loadMoreButton = {
          border: "0px",
          color: "#333",
          borderRadius: "0",
          borderBottom: "0",
          backgroundColor: "#eee",
          padding: "5px 10px",
          textTransform: "uppercase",
          marginTop: "15px"
        };
        _initializerDefineProperty(this, "messageTimeStampHr", _descriptor5$m, this);
        _initializerDefineProperty(this, "messageTimeStamp", _descriptor6$j, this);
        _initializerDefineProperty(this, "groupChatMessage", _descriptor7$f, this);
        _initializerDefineProperty(this, "comment", _descriptor8$e, this);
        _initializerDefineProperty(this, "userHandle", _descriptor9$a, this);
        _initializerDefineProperty(this, "commentContent", _descriptor10$8, this);
        _initializerDefineProperty(this, "timestamp", _descriptor11$6, this);
      }
    }, (_descriptor$C = _applyDecoratedDescriptor(_class$1d.prototype, "renderMessageView", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          width: "100%",
          overflowY: "auto",
          overflowX: "hidden",
          backgroundColor: this.backgroundColor,
          position: "relative",
          wordBreak: "break-word"
        };
      }
    }), _descriptor2$y = _applyDecoratedDescriptor(_class$1d.prototype, "renderMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.renderMessageHeight,
          maxHeight: this.renderMessageHeight,
          width: "100%",
          borderTop: "1px solid " + this.hrBackgroundColor,
          backgroundColor: this.backgroundColor,
          position: "relative"
        };
      }
    }), _descriptor3$r = _applyDecoratedDescriptor(_class$1d.prototype, "chatInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          width: "calc(100% - 50px)",
          paddingBottom: "0",
          fontSize: "14px",
          borderRadius: "0",
          paddingLeft: "8px",
          border: "0px",
          paddingTop: "5px",
          resize: "none",
          transition: ".2s",
          display: "inline-block",
          float: "left",
          outline: "none",
          position: "absolute",
          ":focus": {
            outline: "none",
            boxShadow: "none"
          },
          ":active": {
            outline: "none",
            boxShadow: "none"
          }
        };
      }
    }), _descriptor4$o = _applyDecoratedDescriptor(_class$1d.prototype, "messageBoxButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          flex: "1",
          backgroundColor: "#fff",
          border: "0",
          fontSize: "18px",
          transition: ".2s",
          color: "#333",
          padding: "0",
          ":hover": {
            backgroundColor: "transparent",
            color: "#2089b5",
            transition: ".2s"
          },
          ":active": {
            backgroundColor: "transparent",
            color: "#2089b5",
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: "transparent",
            color: "#2089b5",
            transition: ".2s",
            outline: "none"
          },
          ":focus:active": {
            backgroundColor: "transparent",
            color: "#2089b5"
          },
          ":hover:active": {
            backgroundColor: "transparent",
            color: "#2089b5"
          }
        };
      }
    }), _descriptor5$m = _applyDecoratedDescriptor(_class$1d.prototype, "messageTimeStampHr", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "1px",
          marginTop: "1.5em",
          marginBottom: "1.5em",
          width: "100%",
          maxWidth: "100%",
          backgroundColor: this.hrBackgroundColor,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          textTransform: "uppercase"
        };
      }
    }), _descriptor6$j = _applyDecoratedDescriptor(_class$1d.prototype, "messageTimeStamp", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "1.5em",
          width: "auto",
          paddingLeft: "10px",
          paddingRight: "10px",
          backgroundColor: this.backgroundColor,
          textAlign: "center",
          color: "#222",
          fontWeight: "bold"
        };
      }
    }), _descriptor7$f = _applyDecoratedDescriptor(_class$1d.prototype, "groupChatMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          backgroundColor: "#fff"
        };
      }
    }), _descriptor8$e = _applyDecoratedDescriptor(_class$1d.prototype, "comment", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: "12px",
          paddingRight: "12px",
          paddingTop: "12px",
          paddingBottom: "12px",
          ":hover": {
            backgroundColor: this.hoverBackgroundColor
          }
        };
      }
    }), _descriptor9$a = _applyDecoratedDescriptor(_class$1d.prototype, "userHandle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.userFontSize
        };
      }
    }), _descriptor10$8 = _applyDecoratedDescriptor(_class$1d.prototype, "commentContent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          " p": {
            marginTop: "0",
            marginBottom: "0",
            fontSize: this.commentFontSize,
            color: "#454545",
            // textAlign: "justify",
            wordWrap: "break-word"
          }
        };
      }
    }), _descriptor11$6 = _applyDecoratedDescriptor(_class$1d.prototype, "timestamp", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#262626",
          fontWeight: "bold",
          margin: "0 10px"
        };
      }
    })), _class$1d);

    var _dec$Q, _class$1c, _dec2$j, _class2$E;
    ButtonStyle.getInstance().ensureFirstUpdate();
    InputStyle.getInstance().ensureFirstUpdate();
    class PreviewMarkupButton extends Button$1 {
      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI$1.T("Preview");
        }
        super.setOptions(options);
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          MarkupEditorModal.show({
            classMap: ChatMarkupRenderer.classMap,
            showCallback: modal => {
              modal.markupEditor.setValue(this.options.getValue());
              modal.markupEditor.codeEditor.getAce().focus();
            },
            hideCallback: modal => {
              this.options.setValue(modal.markupEditor.getValue());
            }
          });
        });
      }
    }
    class EditableMessage extends UI$1.Element {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          deletable: true
        });
      }
      setOptions(options) {
        super.setOptions(options);
        this.message = options.message;
      }
      render() {
        return [UI$1.createElement(Button$1, {
          ref: "editButton",
          onClick: () => this.toggleEditMode()
        }, UI$1.T("Edit")), UI$1.createElement(Switcher, {
          ref: "contentSwitcher"
        }, UI$1.createElement("span", {
          ref: "contentContainer",
          style: {
            "white-space": "pre-line"
          }
        }, this.message.hasMarkupEnabled() ? UI$1.createElement(ChatMarkupRenderer, {
          ref: this.refLink("content"),
          value: this.message.getContent(),
          style: {
            height: "auto"
          }
        }) : UI$1.createElement(UI$1.TextElement, {
          ref: "content",
          value: this.message.getContent()
        })))];
      }
      showEditMode() {
        if (!this.editContent) {
          let writingSectionStyle = {
            "margin-top": "5px"
          };
          let chatInputStyle = {
            overflow: "auto",
            height: "60px",
            width: "100%"
          };
          this.editContent = UI$1.createElement("div", {
            style: writingSectionStyle
          }, UI$1.createElement(TextArea, {
            ref: this.refLink("messageInput"),
            style: chatInputStyle,
            className: "form-control",
            value: this.message.getContent()
          }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
            label: UI$1.T("Cancel"),
            size: Size.SMALL,
            onClick: () => {
              this.hideEditMode();
            }
          }), UI$1.createElement(PreviewMarkupButton, {
            size: Size.SMALL,
            getValue: () => {
              return this.messageInput.getValue();
            },
            setValue: value => {
              this.messageInput.setValue(value);
              this.messageInput.node.focus();
            }
          }), UI$1.createElement(Button$1, {
            label: UI$1.T("Save changes"),
            level: Level.PRIMARY,
            onClick: () => this.saveMessageChanges(),
            size: Size.SMALL
          }), this.options.deletable ? UI$1.createElement(Button$1, {
            level: Level.DANGER,
            label: UI$1.T("Delete"),
            size: Size.SMALL,
            onClick: () => this.deleteMessage()
          }) : ""));
        } else {
          this.messageInput.setValue(this.message.getContent());
        }
        if (!this.contentSwitcher.hasChild(this.editContent)) {
          this.contentSwitcher.appendChild(this.editContent);
        }
        this.contentSwitcher.setActive(this.editContent);
      }
      hideEditMode() {
        this.contentSwitcher.setActive(this.contentContainer);
      }
      toggleEditMode() {
        if (this.contentSwitcher.getActive() === this.contentContainer) {
          this.showEditMode();
        } else {
          this.hideEditMode();
        }
      }
      saveMessageChanges() {
        let content = this.messageInput.getValue();
        if (content) {
          this.message.edit(content, () => {
            this.hideEditMode();
          });
        }
      }
      deleteMessage() {
        if (this.options.deletable) {
          this.message.deleteMessage();
        }
      }
      onMount() {
        this.message.addListener("edit", () => {
          this.content.setValue(this.message.getContent());
          this.redraw();
        });
        this.message.addListener("delete", () => {
          // TODO: refactor this, should delete message, not hide
          this.hide();
        });
      }
    }
    let GroupChatMessage = (_dec$Q = registerStyle(ChatStyle), _dec$Q(_class$1c = class GroupChatMessage extends EditableMessage {
      setOptions(options) {
        super.setOptions(options);
        if (this.message.hasTemporaryId()) {
          // TODO: this can also happen when editing a message, another case for later
          this.message.addListener("postError", () => {
            this.redraw();
          });
          this.message.addListener("updateId", () => {
            // TODO: we might need to updated our position here
            this.options.key = this.message.id;
          });
        }
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.groupChatMessage);
      }
      shouldShowDayTimestamp() {
        let lastMessage = this.options.message.getPreviousMessage();
        return !lastMessage || isDifferentDay(lastMessage.timeAdded, this.options.message.timeAdded);
      }
      render() {
        let editButton;
        if (this.message.userId === USER.id || USER.isSuperUser) {
          // if (USER.isSuperUser) {
          editButton = UI$1.createElement("a", {
            style: Object.assign({
              "cursor": "pointer"
            }, this.styleSheet.timestamp),
            onClick: () => this.toggleEditMode()
          }, UI$1.T("Edit"));
        }
        if (!this.contentSwitcher) {
          this.contentSwitcher = UI$1.createElement(Switcher, null, UI$1.createElement("span", {
            ref: "contentContainer",
            style: {
              "white-space": "pre-line"
            }
          }, this.message.hasMarkupEnabled() ? UI$1.createElement(ChatMarkupRenderer, {
            ref: this.refLink("content"),
            value: this.message.getContent(),
            style: {
              height: "auto"
            }
          }) : UI$1.createElement(UI$1.TextElement, {
            ref: "content",
            value: this.message.getContent()
          })));
        }
        let date = null;
        if (this.shouldShowDayTimestamp()) {
          date = UI$1.createElement("div", {
            ref: "dayTimestamp",
            className: this.styleSheet.messageTimeStampHr
          }, UI$1.createElement("div", {
            className: this.styleSheet.messageTimeStamp
          }, StemDate.unix(this.message.timeAdded).format("dddd, MMMM Do")));
        }
        let errorElement = null;
        if (this.message.postError) {
          errorElement = UI$1.createElement("span", {
            ref: "errorArea",
            style: {
              marginLeft: "1rem"
            },
            className: "fa fa-warning",
            HTMLTitle: "Error: " + this.message.postError
          });
        }
        return [date, UI$1.createElement("div", {
          className: this.styleSheet.comment
        }, UI$1.createElement(UserHandle$1, {
          userId: this.message.userId,
          className: this.styleSheet.userHandle
        }), UI$1.createElement("span", {
          className: this.styleSheet.timestamp
        }, this.message.getTimeOfDay()), editButton, errorElement, UI$1.createElement("div", {
          className: this.styleSheet.commentContent
        }, this.contentSwitcher))];
      }
    }) || _class$1c);
    let PrivateChatMessage = (_dec2$j = registerStyle(ChatStyle), _dec2$j(_class2$E = class PrivateChatMessage extends Panel {
      setOptions(options) {
        super.setOptions(options);
        this.message = options.message;
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass(this.styleSheet.groupChatMessage);
        return attr;
      }
      shouldShowDayTimestamp() {
        let lastMessage = this.options.message.getPreviousMessage();
        return !lastMessage || isDifferentDay(lastMessage.timeAdded, this.options.message.timeAdded);
      }
      isOwnMessage() {
        return this.message.userId === USER.id;
      }
      render() {
        if (!this.contentSwitcher) {
          this.contentSwitcher = UI$1.createElement(Switcher, null, UI$1.createElement("span", {
            ref: "contentContainer",
            style: {
              "white-space": "pre-line"
            }
          }, this.message.hasMarkupEnabled() ? UI$1.createElement(ChatMarkupRenderer, {
            ref: this.refLink("content"),
            value: this.message.getContent(),
            style: {
              height: "auto"
            }
          }) : UI$1.createElement(UI$1.TextElement, {
            ref: "content",
            value: this.message.getContent()
          })));
        }
        let date = null;
        if (this.shouldShowDayTimestamp()) {
          date = UI$1.createElement("div", {
            className: this.styleSheet.messageTimeStampHr
          }, UI$1.createElement("div", {
            ref: "dayTimestamp",
            className: this.styleSheet.messageTimeStamp
          }, StemDate.unix(this.message.timeAdded).format("dddd, MMMM Do")));
        }
        let errorElement = null;
        if (this.message.postError) {
          errorElement = UI$1.createElement("span", {
            ref: "errorArea",
            style: {
              marginLeft: "1rem"
            },
            className: "fa fa-warning",
            HTMLTitle: "Error: " + this.message.postError
          });
        }
        let content = [UI$1.createElement("div", {
          className: this.styleSheet.comment,
          style: {
            margin: "8px 16px",
            backgroundColor: "#eee"
          }
        }, UI$1.createElement(UserHandle$1, {
          userId: this.message.userId,
          className: this.styleSheet.userHandle
        }), UI$1.createElement("span", {
          className: this.styleSheet.timestamp
        }, this.message.getTimeOfDay()), errorElement, UI$1.createElement("div", {
          className: this.styleSheet.commentContent
        }, this.contentSwitcher))];
        let paddingDiv = UI$1.createElement("div", {
          style: {
            flexGrow: "1000000"
          }
        });
        let result;
        if (this.isOwnMessage()) {
          result = [date, UI$1.createElement("div", {
            style: {
              display: "flex"
            }
          }, paddingDiv, content)];
        } else {
          result = [date, UI$1.createElement("div", {
            style: {
              display: "flex"
            }
          }, content, paddingDiv)];
        }
        return result;
      }
    }) || _class2$E);
    class ChatMessageScrollSection extends InfiniteScrollable {
      setOptions(options) {
        options = Object.assign({
          entryComparator: (a, b) => {
            return a.getNormalizedId() - b.getNormalizedId();
          }
        }, options);
        super.setOptions(options);
      }
      getTopMessage() {
        return this.children[1];
      }
    }
    let ChatWidget = ChatMessageClass => {
      var _dec3, _class3;
      let ChatWidgetClass = (_dec3 = registerStyle(ChatStyle), _dec3(_class3 = class ChatWidgetClass extends Pluginable(Panel) {
        getDefaultOptions(options) {
          return {
            dateTimestamps: true,
            renderMessage: messageInstance => {
              return UI$1.createElement(ChatMessageClass, {
                key: messageInstance.getNormalizedId(),
                message: messageInstance
              });
            }
          };
        }
        get messageThread() {
          return this.options.messageThread;
        }
        setOptions(options) {
          super.setOptions(options);
          this.initializeShowLoadMoreButton();
        }
        extraNodeAttributes(attr) {
          super.extraNodeAttributes(attr);
          attr.setStyle({
            display: "flex",
            flexDirection: "column"
          });
        }
        canOverwrite() {
          return false;
        }
        initializeShowLoadMoreButton() {
          // TODO: this is a shitty way of knowing if there are more messages!
          if (this.messageThread.getNumMessages() >= 20) {
            this.showLoadMoreButton = true;
          }
        }
        createVirtualMessage(request, message) {
          let virtualId = this.messageThread.getMaxMessageId() + "-" + MessageInstanceStore.generateVirtualId() + "-" + Math.random();
          let virtualMessageInstance = MessageInstanceStore.createVirtualMessageInstance(message, this.messageThread, virtualId);
          request.virtualId = virtualId;
          return virtualMessageInstance;
        }
        async sendMessage(message) {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }
          const request = {
            ...this.options.baseRequest
          };
          message = message || this.chatInput.getValue();
          message = message.trim();
          if (!message) {
            return;
          }
          request.message = message;

          // Create a virtual message to be drawn temporarily
          const virtualMessageInstance = this.createVirtualMessage(request, message);
          this.messageWindow.scrollToBottom();
          this.chatInput.setValue("");
          this.chatInput.dispatch("messageSent");
          try {
            const response = await Ajax.postJSON(this.getPostURL(), request, {
              disableStateImport: true
            });
            if (response.error) {
              virtualMessageInstance.setPostError(response.error);
              return;
            }
            if (virtualMessageInstance?.hasTemporaryId()) {
              MessageInstanceStore.applyUpdateObjectId(virtualMessageInstance, response.messageId);
              GlobalState$1.importState(response.state);
            }
          } catch (error) {
            if (virtualMessageInstance) {
              virtualMessageInstance.setPostError(42);
            }
            console.log("Error in sending chat message:\n" + error.message);
            console.log(error.stack);
          }
        }
        saveScrollPosition() {
          this.scrollPosition = this.messageWindow.node.scrollTop;
          this.scrollPercent = this.scrollPosition / (this.messageWindow.node.scrollHeight - this.messageWindow.node.clientHeight);
        }
        applyScrollPosition() {
          this.messageWindow.node.scrollTop = this.scrollPosition || this.messageWindow.node.scrollHeight;
          this.chatInput.node.focus();
        }
        addResizeListeners() {
          this.messageWindow.addNodeListener("scroll", () => {
            let scrollTop = this.messageWindow.node.scrollTop;
            if (scrollTop < 20) {
              this.loadMoreMessages();
            }
          });
          this.addListener("hide", () => {
            this.saveScrollPosition();
          });
          this.addListener("show", () => {
            this.applyScrollPosition();
          });
          window.addEventListener("resize", () => {
            this.saveScrollPosition();
            this.setAdaptiveHeight();
          });
          this.addListener("resize", () => {
            this.setAdaptiveHeight();
            this.messageWindow.node.scrollTop = this.scrollPercent * (this.messageWindow.node.scrollHeight - this.messageWindow.node.clientHeight);
          });
        }
        getDesiredHeight() {
          if (this.options.style && this.options.style.height) {
            return this.options.style.height;
          }
          let viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
          let navbarHeight = document.getElementById("navbar").offsetHeight; // use offsetHeight to accommodate padding and margin

          let availableHeight = viewportHeight - navbarHeight - (this.options.extraHeightOffset || 25);
          return Math.max(availableHeight || 0, 100) + "px"; // it needs at least 100px
        }
        setAdaptiveHeight() {
          this.setStyle("height", this.getDesiredHeight());
        }
        setHeight(height) {
          this.setStyle("height", height);
        }
        renderMessageView() {
          let loadMoreButton;
          if (this.showLoadMoreButton) {
            loadMoreButton = UI$1.createElement("div", {
              className: "text-center"
            }, UI$1.createElement(AjaxButton, {
              ref: this.refLink("loadMoreButton"),
              onClick: () => {
                this.loadMoreMessages();
              },
              style: this.styleSheet.loadMoreButton,
              statusOptions: ["Load more messages", {
                icon: "spinner fa-spin",
                label: " loading messages..."
              }, "Load more messages", "Failed"]
            }));
          }
          return [UI$1.createElement(ChatMessageScrollSection, {
            className: this.styleSheet.renderMessageView,
            ref: "messageWindow",
            entryRenderer: this.options.renderMessage,
            entries: this.messageThread.getMessages(),
            staticTop: loadMoreButton
          })];
        }
        getGetType() {
          return "GET";
        }
        loadMoreMessages() {
          // TODO: wrap this in something
          if (this.outstandingRequest) {
            return;
          }
          this.outstandingRequest = true;
          const topMessage = this.messageWindow.getTopMessage();
          let messageInstances = this.messageThread.getMessages();
          let lastMessageId = 999999999;
          if (messageInstances.length) {
            lastMessageId = messageInstances[0].id;
          }
          let request = Object.assign({
            lastMessageId: lastMessageId
          }, this.options.baseRequest || {});
          const oldScrollHeight = this.messageWindow.node.scrollHeight;
          if (this.loadMoreButton) {
            this.loadMoreButton.ajaxCall({
              url: this.getGetURL(),
              type: this.getGetType(),
              dataType: "json",
              data: request,
              complete: () => {
                //TODO(@Rocky): find out why this doesn't work
                this.outstandingRequest = false;
              }
            }).then(data => {
              const emptyData = !data.state || !data.state.MessageInstance;
              if (emptyData || data.state.MessageInstance.length < 20) {
                if (this.loadMoreButton) {
                  this.loadMoreButton.hide();
                }
                this.showLoadMoreButton = false;
                if (emptyData) {
                  return;
                }
              }
              let scrollDelta = 0;
              if (!topMessage.shouldShowDayTimestamp()) {
                scrollDelta += topMessage.dayTimestamp.getHeight();
                topMessage.dayTimestamp.addClass("hidden");
              }
              this.messageWindow.scrollToHeight(this.messageWindow.node.scrollHeight - oldScrollHeight - scrollDelta);
              this.outstandingRequest = false;
            });
          }
        }
        renderMessageBox() {
          return UI$1.createElement("div", {
            ref: "writingSection",
            className: this.styleSheet.renderMessage
          }, UI$1.createElement(TextArea, {
            readOnly: this.messageThread.muted,
            ref: "chatInput",
            placeholder: "Type a message...",
            className: this.styleSheet.chatInput
          }), UI$1.createElement("div", {
            style: {
              display: "flex",
              flexDirection: "column",
              height: "100%",
              position: "absolute",
              right: "0px",
              width: "50px"
            }
          }, UI$1.createElement(Button$1, {
            ref: "sendMessageButton",
            icon: "paper-plane",
            disabled: this.messageThread.muted,
            onClick: () => this.sendMessage(),
            className: this.styleSheet.messageBoxButton
          }), UI$1.createElement(PreviewMarkupButton, {
            ref: "previewMessageButton",
            getValue: () => {
              return this.chatInput.getValue();
            },
            setValue: value => {
              this.chatInput.setValue(value);
              this.chatInput.node.focus();
            },
            className: this.styleSheet.messageBoxButton,
            icon: "eye"
          })));
        }
        renderStatus() {
          if (this.messageThread.muted) {
            return [UI$1.createElement("h4", {
              style: {
                color: "red",
                textAlign: "center"
              }
            }, "This chat is currently turned off.")];
          } else {
            if (USER.isSuperUser) {
              let userData = [];
              for (let userId of this.messageThread.online) {
                userData.push([UI$1.createElement(UserHandle$1, {
                  id: parseInt(userId)
                })]);
              }
              return userData;
            }
          }
        }
        render() {
          return [this.renderMessageView(), this.renderMessageBox()];
        }
        getDefaultPlugins() {
          return ChatWidget.defaultPlugins || [];
        }
        onMount() {
          super.onMount();
          for (let plugin of this.options.plugins || this.getDefaultPlugins()) {
            this.registerPlugin(plugin);
          }
          this.attachChangeListener(this.messageThread, event => {
            if (event.type === "muted") {
              this.redraw();
            }
          });
          this.attachListener(this.messageThread, "newMessage", event => {
            //console.log("Received chat message: ", event);
            let messageInstance = MessageInstanceStore.get(event.data.id);

            // We calculate before adding new message
            let messageWindowScrollTop = this.messageWindow.node.scrollTop;
            let messageWindowscrollMax = this.messageWindow.node.scrollHeight - this.messageWindow.node.offsetHeight;
            this.messageWindow.insertEntry(messageInstance);

            // If we were at the bottom before message was appended, scroll automatically
            if (messageWindowScrollTop + 20 > messageWindowscrollMax) {
              setTimeout(() => {
                this.messageWindow.scrollToBottom();
              }, 0);
            }
          });
          this.addResizeListeners();
        }
      }) || _class3);
      return ChatWidgetClass;
    };
    class GroupChatWidget extends ChatWidget(GroupChatMessage) {
      setOptions(options) {
        super.setOptions(options);
        this.options.baseRequest = {
          chatId: this.options.chatId
        };
      }
      getPostURL() {
        return "/chat/group_chat_post/";
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          display: "flex",
          flexDirection: "column",
          overflowY: "hidden"
        });
      }
      getGetURL() {
        return "/chat/group_chat_state/";
      }
      renderMessageView() {
        let loadMoreButton;
        if (this.showLoadMoreButton) {
          loadMoreButton = UI$1.createElement("div", {
            className: "text-center"
          }, UI$1.createElement(AjaxButton, {
            ref: this.refLink("loadMoreButton"),
            onClick: () => {
              this.loadMoreMessages();
            },
            style: this.styleSheet.loadMoreButton,
            statusOptions: ["Load more messages", {
              icon: "spinner fa-spin",
              label: " loading messages..."
            }, "Load more messages", "Failed"]
          }));
        }
        return [UI$1.createElement(ChatMessageScrollSection, {
          className: this.styleSheet.renderMessageView,
          ref: "messageWindow",
          entryRenderer: this.options.renderMessage,
          entries: this.messageThread.getMessages(),
          staticTop: loadMoreButton
        })];
      }
    }
    class PrivateChatWidget extends ChatWidget(PrivateChatMessage) {
      setOptions(options) {
        options = Object.assign({
          messageThread: options.privateChat.getMessageThread(),
          baseRequest: {
            userId: options.privateChat.getOtherUserId(),
            privateChatId: options.privateChat.id
          }
        }, options);
        super.setOptions(options);
      }
      setPrivateChat(privateChat) {
        this.options.privateChat = privateChat;
        this.setOptions(this.options);
      }
      getPostURL() {
        return "/chat/private_chat_post/";
      }
      getGetType() {
        return "POST"; // It might create a chat if it doesn't have one
      }
      getGetURL() {
        return "/chat/private_chat_state/";
      }
    }
    class VotableChatMessage extends GroupChatMessage {
      render() {
        let result = super.render();
        result[1].options.children.push(UI$1.createElement(CommentVotingWidgetWithThumbs, {
          style: {
            display: "inline-block"
          },
          message: this.options.message
        }));
        return result;
      }
    }
    class VotableGroupChatWidget extends ChatWidget(VotableChatMessage) {
      setOptions(options) {
        options.messageThread = options.messageThread || MessageThreadStore.get(GroupChatStore.get(options.chatId).messageThreadId);
        super.setOptions(options);
        this.options.baseRequest = {
          chatId: this.options.chatId
        };
      }
      getPostURL() {
        return "/chat/group_chat_post/";
      }
      getGetURL() {
        return "/chat/group_chat_state/";
      }
    }

    var _class$1b, _descriptor$B, _descriptor2$x, _descriptor3$q, _descriptor4$n, _descriptor5$l, _descriptor6$i, _class2$D, _descriptor7$e, _descriptor8$d;
    const color$1 = {
      BLUE: "#20232d",
      HOVER_BLUE: "#364251",
      BLACK: "#181a22",
      HOVER_BLACK: "#323539",
      WHITE: "#eee"
    };
    let CSAStyle = {
      color: color$1
    };
    let BlogStyle = (_class$1b = class BlogStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.titleFontSize = "2em";
        _initializerDefineProperty(this, "commentsTitle", _descriptor$B, this);
        _initializerDefineProperty(this, "bottomSection", _descriptor2$x, this);
        _initializerDefineProperty(this, "blogEntryView", _descriptor3$q, this);
        this.title = {
          "font-size": this.titleFontSize,
          "padding-top": "20px",
          "padding-bottom": "10px",
          "text-decoration": "italic",
          "width": "100%",
          "text-align": "center",
          "word-wrap": "normal",
          "line-height": "60px"
        };
        this.writtenBy = {
          "width": "100%",
          "text-align": "left",
          "padding-top": "20px",
          "font-size": "1em",
          "color": "#666"
        };
        this.article = {
          "text-align": "justify",
          "font-size": "17px"
        };
        this.link = {
          textDecoration: "none",
          textAlign: "center",
          marginTop: "-15pt",
          fontSize: "1.1em"
        };
        this.blogArticleRenderer = {
          overflow: "hidden",
          position: "relative",
          maxHeight: "180px",
          "text-align": "justify",
          "font-size": "17px",
          marginBottom: "25px"
        };
        _initializerDefineProperty(this, "whiteOverlay", _descriptor4$n, this);
        _initializerDefineProperty(this, "loadMoreButton", _descriptor5$l, this);
        _initializerDefineProperty(this, "sendMessageButtonStyle", _descriptor6$i, this);
      }
    }, (_descriptor$B = _applyDecoratedDescriptor(_class$1b.prototype, "commentsTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "20px",
          color: "#333",
          marginTop: "10px",
          fontSize: "1em",
          textTransform: "uppercase"
        };
      }
    }), _descriptor2$x = _applyDecoratedDescriptor(_class$1b.prototype, "bottomSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "5px",
          height: "50px",
          width: "100%"
        };
      }
    }), _descriptor3$q = _applyDecoratedDescriptor(_class$1b.prototype, "blogEntryView", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "margin": "0 auto",
          "width": "900px",
          "max-width": "100%"
          // "padding-top": "50px",
          // "padding-bottom": "50px",
        };
      }
    }), _descriptor4$n = _applyDecoratedDescriptor(_class$1b.prototype, "whiteOverlay", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100px",
          background: "linear-gradient(rgba(255,255,255,0), #fff)",
          position: "absolute",
          marginTop: "-120px",
          pointerEvents: "none",
          width: "92%"
        };
      }
    }), _descriptor5$l = _applyDecoratedDescriptor(_class$1b.prototype, "loadMoreButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "16px",
          color: "#fff",
          height: "40px",
          marginTop: "10px",
          marginBottom: "20px",
          width: "auto",
          borderRadius: "0px",
          backgroundColor: CSAStyle.color.BLUE,
          border: "0",
          padding: "5px 10px",
          borderColor: CSAStyle.color.BLUE,
          fontSize: "1em",
          transition: ".2s",
          textTransform: "uppercase",
          opacity: "1",
          ":hover": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":active": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":active:focus": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          }
        };
      }
    }), _descriptor6$i = _applyDecoratedDescriptor(_class$1b.prototype, "sendMessageButtonStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "30px",
          marginTop: "10px",
          marginBottom: "20px",
          width: "auto",
          borderRadius: "0px",
          backgroundColor: CSAStyle.color.BLUE,
          borderColor: "#333",
          fontSize: "13px",
          transition: ".2s",
          ":hover": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":active": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus:active": {
            backgroundColor: CSAStyle.color.HOVER_BLUE,
            borderColor: CSAStyle.color.HOVER_BLUE,
            transition: ".2s"
          }
        };
      }
    })), _class$1b);
    let BlogArticleRendererStyle = (_class2$D = class BlogArticleRendererStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.hStyle = {
          "text-align": "center",
          "margin-top": "30px",
          "margin-bottom": "30px",
          "width": "100%"
        };
        _initializerDefineProperty(this, "blogArticleRenderer", _descriptor7$e, this);
        _initializerDefineProperty(this, "quote", _descriptor8$d, this);
      }
    }, (_descriptor7$e = _applyDecoratedDescriptor(_class2$D.prototype, "blogArticleRenderer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          " h1": this.hStyle,
          " h2": this.hStyle,
          " h3": this.hStyle,
          " h4": this.hStyle,
          " h5": this.hStyle,
          " h6": this.hStyle
        };
      }
    }), _descriptor8$d = _applyDecoratedDescriptor(_class2$D.prototype, "quote", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontStyle: "italic",
          color: "#707070",
          float: "right",
          display: "flex",
          width: "100%"
        };
      }
    })), _class2$D);

    var _class$1a, _descriptor$A, _descriptor2$w;
    let CommentWidgetStyle = (_class$1a = class CommentWidgetStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.loadMoreButton = {
          border: "0px",
          color: "#333",
          borderRadius: "0",
          borderBottom: "0",
          backgroundColor: "#eee",
          padding: "5px 10px"
        };
        this.writingSectionStyle = {
          height: "auto",
          marginTop: "10px"
        };
        _initializerDefineProperty(this, "chatInputStyle", _descriptor$A, this);
        _initializerDefineProperty(this, "chatInputMax", _descriptor2$w, this);
        this.previewButtonStyle = {
          // TODO: This is currently not restyled. We might not want to use it because previewButton is bad practice
          height: "30px",
          width: "auto",
          fontSize: "100%",
          marginLeft: "5px"
        };
      }
    }, (_descriptor$A = _applyDecoratedDescriptor(_class$1a.prototype, "chatInputStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "30px",
          width: "100%",
          paddingBottom: "0",
          fontSize: "14px",
          borderRadius: "0",
          outline: "none",
          paddingLeft: "8px",
          paddingTop: "5px",
          resize: "none",
          transition: ".2s",
          display: "block",
          border: "1px solid #aaa",
          ":focus": {
            height: "120px",
            transition: ".2s"
          },
          ":active": {
            height: "120px",
            transition: ".2s"
          }
        };
      }
    }), _descriptor2$w = _applyDecoratedDescriptor(_class$1a.prototype, "chatInputMax", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "120px"
        };
      }
    })), _class$1a);

    var _dec$P, _class$19, _dec2$i, _class2$C;
    class ThreadMessage extends EditableMessage {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          deletable: false
        });
      }
      render() {
        let messageDate = UI$1.createElement(TimePassedSpan, {
          timeStamp: this.message.getDate(),
          style: {
            color: "#666 !important",
            textTransform: "uppercase",
            fontSize: ".85em"
          }
        });
        let editButton;
        if (this.message.userId === USER.id || USER.isSuperUser) {
          editButton = UI$1.createElement("a", {
            style: Object.assign({
              "cursor": "pointer",
              padding: "0 10px",
              fontSize: "1.05em",
              lineHeight: "0px"
            }),
            onClick: () => this.toggleEditMode()
          }, "edit");
        }
        if (!this.contentSwitcher) {
          this.contentSwitcher = UI$1.createElement(Switcher, null, UI$1.createElement("div", {
            ref: "contentContainer"
          }, UI$1.createElement(MarkupRenderer, {
            ref: "content",
            value: this.message.getContent()
          })));
        }
        let votes = UI$1.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          style: {
            float: "left"
          },
          message: this.message,
          ref: "commentVotingWidget"
        });
        return [UI$1.createElement("span", {
          style: {
            float: "right",
            display: "inline-block",
            height: "40px",
            lineHeight: "40px"
          }
        }, messageDate), UI$1.createElement("div", {
          style: {
            height: "40px",
            lineHeight: "40px"
          }
        }, UI$1.createElement("div", {
          style: {
            height: "40px",
            lineHeight: "40px",
            display: "inline-block",
            float: "left",
            fontSize: ".95em",
            color: "#333"
          }
        }, UI$1.createElement(UserHandle$1, {
          userId: this.message.userId,
          style: {
            fontSize: "1.1em"
          }
        })), editButton), UI$1.createElement("div", {
          style: {
            paddingTop: "5px",
            fontSize: "16px"
          }
        }, this.contentSwitcher), UI$1.createElement("div", {
          style: {
            height: "40px"
          }
        }, votes), UI$1.createElement("div", {
          style: {
            height: "1px",
            width: "100%",
            backgroundColor: "#ddd"
          }
        })];
      }
    }
    class ToggleLogin extends UI$1.Primitive("span") {
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          LoginModal.show();
          return;
        });
      }
    }
    let BlogCommentWidget = (_dec$P = registerStyle(BlogStyle), _dec$P(_class$19 = class BlogCommentWidget extends ChatWidget(ThreadMessage) {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          entryComparator: (a, b) => {
            return b.getNormalizedId() - a.getNormalizedId();
          }
        });
      }
      get commentWidgetStyle() {
        return CommentWidgetStyle.getInstance();
      }
      renderMessageView() {
        let loadMoreButton;
        if (this.showLoadMoreButton) {
          loadMoreButton = UI$1.createElement("div", {
            className: "text-center"
          }, UI$1.createElement(AjaxButton, {
            ref: this.refLink("loadMoreButton"),
            onClick: () => {
              this.loadMoreMessages();
            },
            style: this.commentWidgetStyle.loadMoreButton,
            statusOptions: ["Load more messages", {
              icon: "spinner fa-spin",
              label: " loading messages..."
            }, "Load more messages", "Failed"]
          }));
        }
        return [UI$1.createElement(ChatMessageScrollSection, {
          ref: "messageWindow",
          entryRenderer: this.options.renderMessage,
          entries: this.messageThread.getMessages(true),
          entryComparator: this.options.entryComparator,
          staticTop: loadMoreButton
        })];
      }
      renderMessageBox() {
        return [UI$1.createElement("div", {
          ref: "writingSection",
          style: this.commentWidgetStyle.writingSectionStyle
        }, UI$1.createElement(TextArea, {
          readOnly: this.messageThread.muted,
          ref: "chatInput",
          onChange: () => {
            if (this.chatInput.getValue()) {
              this.chatInput.addClass(this.commentWidgetStyle.chatInputMax);
            } else {
              this.chatInput.removeClass(this.commentWidgetStyle.chatInputMax);
            }
          },
          className: this.commentWidgetStyle.chatInputStyle,
          placeholder: "Leave a comment..."
        }), UI$1.createElement(Button$1, {
          disabled: this.messageThread.muted,
          label: "SUBMIT",
          ref: "sendMessageButton",
          className: this.styleSheet.sendMessageButtonStyle,
          level: Level.PRIMARY,
          onClick: () => this.sendMessage()
        }))];
      }
      render() {
        return [this.renderMessageBox(), this.renderMessageView()];
      }
      getDefaultPlugins() {
        return CommentWidget.defaultPlugins || [];
      }
      createVirtualMessage(request, message) {
        return null;
      }
    }) || _class$19);
    let CommentWidget = (_dec2$i = registerStyle(BlogStyle), _dec2$i(_class2$C = class CommentWidget extends BlogCommentWidget {
      setOptions(options) {
        super.setOptions(options);
        this.key = this.messageThread.id;
        this.options.baseRequest = {
          chatId: this.options.chatId
        };
        this.options.dateTimestamps = false;
      }
      getPostURL() {
        return "/chat/group_chat_post/";
      }
      renderMessageBox() {
        if (USER.isAuthenticated) {
          return super.renderMessageBox();
        } else {
          return UI$1.createElement("div", {
            style: {
              color: "#333",
              paddingTop: "5px",
              paddingBottom: "5px"
            }
          }, "You need to\xA0", UI$1.createElement(ToggleLogin, {
            style: {
              backgroundColor: "#eee",
              cursor: "pointer",
              padding: "5px 10px"
            }
          }, "login"), "\xA0to send a comment.");
        }
      }
      render() {
        let commentsCount = this.messageThread.getMessages().length;
        let commentsTitle;
        commentsTitle = UI$1.createElement("div", {
          className: this.styleSheet.commentsTitle
        }, commentsCount, " ", commentsCount != 1 ? "comments" : "comment");
        return [commentsTitle, super.render()];
      }
    }) || _class2$C);
    class AsyncCommentThread extends UI$1.Element {
      getMessageThread() {
        let groupChat = GroupChatStore.get(this.options.chatId);
        return groupChat && groupChat.getMessageThread();
      }
      render() {
        let messageThread = this.getMessageThread();
        let commentWidgetOptions = {
          marginBottom: "10px",
          paddingBottom: "10px",
          height: "auto",
          width: "100%",
          marginTop: "50px",
          marginLeft: "0px",
          marginRight: "0px",
          border: "0px",
          maxWidth: "900px"
        };
        if (messageThread) {
          return [UI$1.createElement(CommentWidget, {
            ref: "commentsSection",
            chatId: this.options.chatId,
            messageThread: messageThread,
            style: commentWidgetOptions
          })];
        } else {
          GroupChatStore.fetch(this.options.chatId, groupChat => {
            this.redraw();
          });
          return [UI$1.createElement("div", {
            style: {
              width: "100%",
              height: "60px",
              lineHeight: "60px",
              fontSize: "1em",
              textAlign: "center",
              textTransform: "uppercase",
              fontWeight: "bold"
            }
          }, UI$1.createElement("span", {
            className: "fa fa-spinner fa-spin",
            style: {
              padding: "0 8px"
            }
          }), "Comments loading...")];
        }
      }
    }

    class EvalTasksSolutionsWidget extends UI$1.Element {
      setOptions(options = {}) {
        options = Object.assign({
          lazyRender: true
        }, options);
        super.setOptions(options);
      }
      getEvalTaskIds() {
        return this.options.evalTaskIds || [];
      }
      isLoaded() {
        for (let evalTaskId of this.getEvalTaskIds()) {
          if (!EvalTaskStore.get(evalTaskId)) {
            return false;
          }
        }
        return true;
      }
      getOverviewPanel() {
        if (!this.options.overviewArticleId) {
          return this.options.overview;
        }
        let articleComments;
        if (this.options.overviewDiscussionId) {
          articleComments = UI$1.createElement(AsyncCommentThread, {
            chatId: this.options.overviewDiscussionId
          });
        }
        return UI$1.createElement(Panel, {
          title: UI$1.T("Overview")
        }, UI$1.createElement(RecursiveArticleRenderer, {
          articleId: this.options.overviewArticleId
        }), articleComments);
      }
      getTaskPanels() {
        let panels = [];
        for (let evalTaskId of this.getEvalTaskIds()) {
          let evalTask = EvalTaskStore.get(evalTaskId);
          let articleId = evalTask.solutionArticleId;
          if (articleId) {
            let articleComments;
            if (evalTask.discussionId) {
              articleComments = UI$1.createElement(AsyncCommentThread, {
                chatId: evalTask.discussionId
              });
            }
            panels.push(UI$1.createElement(Panel, {
              title: evalTask.toString()
            }, UI$1.createElement(RecursiveArticleRenderer, {
              articleId: articleId
            }), articleComments));
          }
        }
        return panels;
      }
      fetchEvalTasks() {
        if (this.isLoading) {
          return;
        }
        this.isLoading = true;
        let request = {
          evalTaskIds: this.getEvalTaskIds()
        };
        Ajax.getJSON("/contest/contest_analysis/", request).then(() => this.redraw());
      }
      render() {
        if (this.isLoaded()) {
          return UI$1.createElement(TabArea, {
            lazyRender: this.options.lazyRender,
            variableHeightPanels: true
          }, unwrapArray([this.getOverviewPanel(), this.getTaskPanels()]));
        } else {
          this.fetchEvalTasks();
          return UI$1.createElement(Panel, {
            title: "Loading"
          }, UI$1.createElement("span", {
            className: "fa fa-spin fa-spinner fa-3x"
          }));
        }
      }
    }
    class ContestAnalysis extends UI$1.Element {
      render() {
        const evalTaskIds = this.options.contest.getContestTasks().map(contestTask => contestTask.evalTaskId);
        return UI$1.createElement(EvalTasksSolutionsWidget, {
          evalTaskIds: evalTaskIds,
          overviewArticleId: this.options.contest.analysisArticleId,
          overviewDiscussionId: this.options.contest.analysisDiscussionId
        });
      }
    }
    class AnalysisModal extends ActionModal {
      getBody() {
        return [UI$1.createElement("p", null, UI$1.T("The contest analysis has been published."))];
      }
      action() {
        Router.changeURL(this.options.contestPanel.getURLPrefix("analysis"));
        this.hide();
      }
      getActionName() {
        return UI$1.T("Go to analysis");
      }
      getCloseName() {
        return UI$1.T("Cancel");
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
    }

    // TODO: should probably be in a modal component
    class DemoMarkupEditor extends UI$1.Element {
      getArticle() {
        return ArticleStore.get(this.options.articleId);
      }
      render() {
        let article = this.getArticle();
        if (article) {
          return [UI$1.createElement(MarkupEditor, {
            value: article.markup,
            style: {
              height: "100%"
            },
            showButtons: false
          })];
        }
        ArticleStore.fetch(this.options.articleId, () => {
          setTimeout(() => {
            this.redraw();
          }, 100);
        });
        return [];
      }
    }

    class MarkupTable extends Table {
      setOptions(options) {
        options.columns = (options.columns || []).map(column => ({
          ...column,
          value: entry => UI$1.createElement(MarkupRenderer, {
            value: entry[column.fieldName] || entry[column.field] || ""
          })
        }));
        super.setOptions(options);
      }
      getEntries() {
        return this.options.rows || this.options.entries;
      }
    }

    var _class$18, _descriptor$z, _descriptor2$v, _dec$O, _class2$B;
    function getCircleStyle(size, borderSize, color, animationName, animationDuration) {
      return {
        position: "absolute",
        height: size + "px",
        width: size + "px",
        border: borderSize + "px solid " + color,
        borderRadius: size + "px",
        borderRight: borderSize + "px transparent",
        borderBottom: borderSize + "px transparent",
        rotate: "0deg",
        transform: "rotate(45deg)",
        animationName: animationName,
        animationDuration: animationDuration,
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      };
    }
    function createCircle(size, borderSize, color, animationName, animationDuration) {
      return UI$1.createElement("div", {
        style: getCircleStyle(size, borderSize, color, animationName, animationDuration)
      });
    }
    let RotatingHelperStyle = (_class$18 = class RotatingHelperStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "rotateClockwise", _descriptor$z, this);
        _initializerDefineProperty(this, "rotateCounterclockwise", _descriptor2$v, this);
      }
    }, (_descriptor$z = _applyDecoratedDescriptor(_class$18.prototype, "rotateClockwise", [keyframesRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "0%": {
            transform: "rotate(0deg)"
          },
          "100%": {
            transform: "rotate(360deg)"
          }
        };
      }
    }), _descriptor2$v = _applyDecoratedDescriptor(_class$18.prototype, "rotateCounterclockwise", [keyframesRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "0%": {
            transform: "rotate(0deg)"
          },
          "100%": {
            transform: "rotate(-360deg)"
          }
        };
      }
    })), _class$18);
    let ConcentricCirclesLoadingScreen = (_dec$O = registerStyle(RotatingHelperStyle), _dec$O(_class2$B = class ConcentricCirclesLoadingScreen extends UI$1.Element {
      render() {
        let centerConstant = 100;
        return UI$1.createElement("div", {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            marginTop: "200px"
          }
        }, createCircle(225 - centerConstant, 5, "#3a4859", this.styleSheet.rotateClockwise, "2.25s"), createCircle(200 - centerConstant, 4, "#666666", this.styleSheet.rotateCounterclockwise, "1.5s"), createCircle(175 - centerConstant, 3, "#aaaaaa", this.styleSheet.rotateClockwise, "1s"), createCircle(150 - centerConstant, 2, "#20232d", this.styleSheet.rotateCounterclockwise, "3s"));
      }
    }) || _class2$B);

    // You can configure the loading/error states by defining the "renderLoading" and "renderError" attributes of the
    // function somewhere globally in your app.
    // Example:
    // StateDependentElement.renderLoading = "Loading...";
    // or
    // StateDependentElement.renderLoading = () => <MyCustomLoadingAnimation />
    // StateDependentElement.renderError = (error) => <MyCustomErrorMessageClass error={error} />

    let StateDependentElement = BaseClass => class StateDependentElementClass extends DelayedElement(BaseClass) {
      importState(data) {
        GlobalState$1.load(data);
        for (let key of Object.keys(data)) {
          if (key !== "state") {
            this.options[key] = data[key];
          }
        }
      }
      getAjaxUrl() {
        let url = location.pathname;
        if (!url.endsWith("/")) {
          url += "/";
        }
        return url;
      }
      getAjaxRequest() {
        return {};
      }
      renderNotLoaded() {
        let renderLoading = StateDependentElement.renderLoading;
        if (typeof renderLoading === "function") {
          renderLoading = renderLoading();
        }
        return renderLoading;
      }
      setError(error) {
        this.options.error = error;
      }
      renderError() {
        let renderError = StateDependentElement.renderError;
        if (typeof renderError === "function") {
          renderError = renderError(this.options.error);
        }
        return renderError;
      }
      renderLoaded() {
        if (this.options.error) {
          return this.renderError();
        }
        return super.renderLoaded();
      }
      onDelayedMount() {
        if (!this.options.error) {
          super.onDelayedMount();
        }
      }
      beforeRedrawNotLoaded() {
        Ajax.getJSON(this.getAjaxUrl(), this.getAjaxRequest()).then(data => {
          this.importState(data);
          this.setLoaded();
        }, error => {
          this.setError(error);
          this.setLoaded();
        });
      }
    };
    StateDependentElement.renderLoading = () => UI$1.createElement(ConcentricCirclesLoadingScreen, null);
    StateDependentElement.renderError = (error, message) => {
      return UI$1.createElement("div", {
        style: {
          maxWidth: "300px",
          margin: "0 auto",
          marginTop: "30px"
        }
      }, UI$1.createElement(CardPanel, {
        title: UI$1.T("Error in opening the URL"),
        level: Level.ERROR
      }, UI$1.createElement("h3", null, message || error.message)));
    };

    class Questionnaire extends StoreObject {
      constructor() {
        super(...arguments);
        this.questions = [];
      }
      getQuestions() {
        return this.questions.sort((a, b) => a.priority === b.priority ? a.id - b.id : a.priority - b.priority);
      }
      addQuestion(question) {
        this.questions.push(question);
      }
      getAllInstances() {
        return QuestionnaireInstanceStore.all().filter(instance => instance.questionnaireId === this.id);
      }
    }
    const QuestionnaireStore = new GenericObjectStore("questionnaire", Questionnaire);
    class QuestionnaireQuestion extends StoreObject {
      getQuestionnaire() {
        return QuestionnaireStore.get(this.questionnaireId);
      }
      constructor() {
        super(...arguments);
        this.getQuestionnaire().addQuestion(this);
        this.options = [];
      }
      addOption(option) {
        this.options.push(option);
      }
      getOptions() {
        return this.options.sort((a, b) => a.priority === b.priority ? a.id - b.id : a.priority - b.priority);
      }
      getCurrentUserResponse() {
        const userInstance = QuestionnaireInstanceStore.getCurrentUserInstance(this.questionnaireId);
        return userInstance && userInstance.getQuestionResponse(this.id);
      }
    }
    QuestionnaireQuestion.Type = {
      PLAIN_TEXT: 1,
      SINGLE_CHOICE: 2,
      MULTIPLE_CHOICE: 3
    };
    const QuestionnaireQuestionStore = new GenericObjectStore("questionnairequestion", QuestionnaireQuestion, {
      dependencies: ["Questionnaire"]
    });
    class QuestionnaireQuestionOption extends StoreObject {
      constructor() {
        super(...arguments);
        this.getQuestion() && this.getQuestion().addOption(this);
      }
      getQuestion() {
        return QuestionnaireQuestionStore.get(this.questionId);
      }
    }
    const QuestionnaireQuestionOptionStore = new GenericObjectStore("QuestionnaireQuestionOption", QuestionnaireQuestionOption, {
      dependencies: ["QuestionnaireQuestion"]
    });
    class QuestionnaireInstance extends StoreObject {
      constructor() {
        super(...arguments);
        this.questionResponses = new Map();
      }
      getQuestionnaire() {
        return QuestionnaireStore.get(this.questionnaireId);
      }
      addQuestionResponse(questionResponse) {
        this.questionResponses.set(questionResponse.questionId, questionResponse);
      }
      getQuestionResponse(questionId) {
        return this.questionResponses.get(questionId);
      }
    }
    class QuestionnaireInstanceStoreClass extends GenericObjectStore {
      constructor() {
        super("QuestionnaireInstance", QuestionnaireInstance, {
          dependencies: ["Questionnaire", "QuestionnaireQuestion", "QuestionnaireQuestionOption"]
        });
      }
      getCurrentUserInstance(questionnaireId) {
        return this.all().find(instance => instance.userId === USER.id && instance.questionnaireId === questionnaireId);
      }
    }
    const QuestionnaireInstanceStore = new QuestionnaireInstanceStoreClass();
    class QuestionnaireQuestionResponse extends StoreObject {
      constructor() {
        super(...arguments);
        this.getQuestionnaireInstance().addQuestionResponse(this);
      }
      getQuestionnaireInstance() {
        return QuestionnaireInstanceStore.get(this.instanceId);
      }
      getText() {
        return this.text || "";
      }
      getChoice() {
        return QuestionnaireQuestionOptionStore.get(this.choiceId);
      }
    }
    new GenericObjectStore("QuestionnaireQuestionResponse", QuestionnaireQuestionResponse, {
      dependencies: ["QuestionnaireInstance"]
    });

    var _class$17, _descriptor$y, _descriptor2$u, _descriptor3$p, _descriptor4$m, _descriptor5$k, _descriptor6$h, _descriptor7$d, _descriptor8$c, _descriptor9$9, _descriptor10$7, _dec$N, _class2$A, _dec2$h, _class3$g, _dec3$7, _class4$8;
    let QuestionnaireStyle = (_class$17 = class QuestionnaireStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "footer", _descriptor$y, this);
        _initializerDefineProperty(this, "questionPage", _descriptor2$u, this);
        _initializerDefineProperty(this, "questionTextArea", _descriptor3$p, this);
        _initializerDefineProperty(this, "questionAnswerArea", _descriptor4$m, this);
        _initializerDefineProperty(this, "form", _descriptor5$k, this);
        _initializerDefineProperty(this, "textArea", _descriptor6$h, this);
        _initializerDefineProperty(this, "radioInputContainer", _descriptor7$d, this);
        _initializerDefineProperty(this, "finished", _descriptor8$c, this);
        _initializerDefineProperty(this, "otherInput", _descriptor9$9, this);
        _initializerDefineProperty(this, "markup", _descriptor10$7, this);
      }
    }, (_descriptor$y = _applyDecoratedDescriptor(_class$17.prototype, "footer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        };
      }
    }), _descriptor2$u = _applyDecoratedDescriptor(_class$17.prototype, "questionPage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "30px"
        };
      }
    }), _descriptor3$p = _applyDecoratedDescriptor(_class$17.prototype, "questionTextArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.2em",
          minHeight: "60px"
        };
      }
    }), _descriptor4$m = _applyDecoratedDescriptor(_class$17.prototype, "questionAnswerArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "10px"
        };
      }
    }), _descriptor5$k = _applyDecoratedDescriptor(_class$17.prototype, "form", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor6$h = _applyDecoratedDescriptor(_class$17.prototype, "textArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          minHeight: "100px"
        };
      }
    }), _descriptor7$d = _applyDecoratedDescriptor(_class$17.prototype, "radioInputContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor8$c = _applyDecoratedDescriptor(_class$17.prototype, "finished", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.5em",
          alignItems: "center",
          height: "250px",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          textAlign: "center"
        };
      }
    }), _descriptor9$9 = _applyDecoratedDescriptor(_class$17.prototype, "otherInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          outline: 0,
          border: 0,
          minWidth: "220px",
          borderBottom: "1px solid #eee",
          marginLeft: "5px",
          transition: "0.4s",
          ":focus": {
            transition: "0.4s",
            borderBottom: "1px solid #777"
          },
          ":hover": {
            transition: "0.4s",
            borderBottom: "1px solid #777"
          }
        };
      }
    }), _descriptor10$7 = _applyDecoratedDescriptor(_class$17.prototype, "markup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          " p": {
            margin: 0
          }
        };
      }
    })), _class$17);
    let QuestionPage = (_dec$N = registerStyle(QuestionnaireStyle), _dec$N(_class2$A = class QuestionPage extends UI$1.Element {
      getDefaultOptions() {
        return {
          editable: true
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.questionPage);
      }
      isPlainText() {
        return this.options.question.type === QuestionnaireQuestion.Type.PLAIN_TEXT;
      }
      isSingleChoice() {
        return this.options.question.type === QuestionnaireQuestion.Type.SINGLE_CHOICE;
      }
      isMultipleChoice() {
        return this.options.question.type === QuestionnaireQuestion.Type.MULTIPLE_CHOICE;
      }
      getForm() {
        let formFields;
        let InputType;
        if (this.isSingleChoice()) {
          InputType = RadioInput;
        }
        if (this.isMultipleChoice()) {
          InputType = RawCheckboxInput;
        }
        if (!this.isPlainText()) {
          formFields = this.options.question.getOptions().map(option => UI$1.createElement("div", {
            className: this.styleSheet.radioInputContainer
          }, UI$1.createElement(InputType, {
            ref: "option" + option.id,
            name: this.options.question.id,
            initialValue: this.isChecked(option),
            disabled: !this.options.editable
          }), UI$1.createElement(MarkupRenderer, {
            value: option.answer,
            className: this.styleSheet.markup
          })));
          if (this.options.question.otherChoice) {
            formFields.push(UI$1.createElement("div", {
              className: this.styleSheet.radioInputContainer
            }, UI$1.createElement(InputType, {
              ref: "otherChoice",
              name: this.options.question.id,
              initialValue: this.isOtherChoice(),
              disabled: !this.options.editable
            }), "Other: ", UI$1.createElement(TextInput, {
              ref: "textArea",
              value: this.getTextValue(),
              className: this.styleSheet.otherInput,
              readOnly: !this.options.editable
            })));
          }
        } else {
          formFields = [UI$1.createElement(TextArea, {
            className: this.styleSheet.textArea,
            value: this.getTextValue(),
            ref: "textArea",
            readOnly: !this.options.editable
          })];
        }
        return UI$1.createElement(Form, {
          className: this.styleSheet.form
        }, formFields);
      }
      getResponse() {
        if (this.options.instance) {
          return this.options.instance.getQuestionResponse(this.options.question.id);
        }
        return this.options.question.getCurrentUserResponse();
      }
      isChecked(questionOption) {
        const userResponse = this.getResponse();
        return userResponse && userResponse.choiceIds.indexOf(questionOption.id) >= 0 || false;
      }
      isOtherChoice() {
        const userResponse = this.getResponse();
        return userResponse && (userResponse.choiceIds.length === 0 || this.isMultipleChoice()) && userResponse.text;
      }
      getTextValue() {
        const userResponse = this.getResponse();
        return userResponse && userResponse.text || "";
      }
      render() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.questionTextArea
        }, UI$1.createElement(MarkupRenderer, {
          value: this.options.question.text,
          className: this.styleSheet.markup
        })), UI$1.createElement("div", {
          className: this.styleSheet.questionAnswerArea
        }, this.getForm())];
      }
      getResponseData() {
        let response = {
          questionnaireId: this.options.question.questionnaireId,
          questionId: this.options.question.id
        };
        if (this.isPlainText() || this.options.question.otherChoice) {
          if (this.textArea.getValue()) {
            response.text = this.textArea.getValue();
          }
        }
        if (!this.isPlainText()) {
          let choiceIds = [];
          for (const option of this.options.question.getOptions()) {
            if (this["option" + option.id].getValue()) {
              choiceIds.push(option.id);
            }
          }
          if (choiceIds.length) {
            response.choiceIds = choiceIds;
          }
        }
        return response;
      }
      sendResponse() {
        this.ajaxThrottler = this.ajaxThrottler || new CallThrottler({
          throttle: 3000,
          debounce: 500
        });
        this.ajaxThrottler.wrap(() => Ajax.postJSON("/questionnaire_answer/", this.getResponseData()).then(() => this.options.panel.dispatch("updateFooter", false)))();
      }
      onMount() {
        if (!this.options.editable) {
          return;
        }
        if (!this.isPlainText()) {
          for (const option of this.options.question.getOptions()) {
            this["option" + option.id].addChangeListener(() => this.sendResponse());
          }
          if (this.options.question.otherChoice) {
            this.otherChoice.addChangeListener(() => this.sendResponse());
          }
        }
        if (this.isPlainText() || this.options.question.otherChoice) {
          this.textArea.addNodeListener("input", () => this.sendResponse());
        }
      }
    }) || _class2$A);
    class OrderedChildrenSwitcher extends Switcher {
      constructor() {
        super(...arguments);
        this.childIndex = 0;
      }
      getChildIndex() {
        return this.childIndex;
      }
      isFirstChild() {
        return this.getChildIndex() === 0;
      }
      isLastChild() {
        return this.getChildIndex() === this.options.children.length - 1;
      }
      updateChildIndex(delta) {
        const newChildIndex = this.childIndex + delta;
        if (0 <= newChildIndex && newChildIndex < this.options.children.length) {
          this.childIndex = newChildIndex;
          this.setActive(this.options.children[this.childIndex]);
        }
      }
    }
    let QuestionnairePanel = (_dec2$h = registerStyle(QuestionnaireStyle), _dec2$h(_class3$g = class QuestionnairePanel extends UI$1.Element {
      getQuestionnaire() {
        return QuestionnaireStore.get(this.options.questionnaireId);
      }
      getQuestions() {
        return this.getQuestionnaire().getQuestions();
      }
      render() {
        const questions = this.getQuestions();
        return [UI$1.createElement(OrderedChildrenSwitcher, {
          ref: "questionPageSwitcher",
          style: {
            minHeight: "300px"
          }
        }, questions.map(question => UI$1.createElement(QuestionPage, {
          question: question,
          panel: this
        }))), UI$1.createElement("div", {
          className: this.styleSheet.footer
        }, UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          icon: "arrow-left",
          ref: "backButton"
        })), UI$1.createElement("div", {
          ref: "progressArea"
        }), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          icon: "arrow-right",
          ref: "forwardButton"
        })))];
      }
      finish() {
        Ajax.postJSON("/questionnaire_submit/", {
          questionnaireId: this.options.questionnaireId
        });
        this.dispatch("finished");
        this.parent instanceof DelayedQuestionnairePanel && this.parent.dispatch("finished");
      }
      updateFooter() {
        this.backButton.setStyle("visibility", this.questionPageSwitcher.isFirstChild() ? "hidden" : "initial");
        const isLastPage = this.questionPageSwitcher.isLastChild();
        this.forwardButton.setStyle("visibility", isLastPage ? "hidden" : "initial");
        const currentQuestion = this.getQuestions()[this.questionPageSwitcher.childIndex];
        if (currentQuestion.getCurrentUserResponse()) {
          this.forwardButton.updateOptions({
            icon: "arrow-right",
            label: ""
          });
        } else {
          this.forwardButton.updateOptions({
            icon: "",
            label: UI$1.T("Skip")
          });
        }
        if (isLastPage) {
          this.progressArea.setChildren([UI$1.createElement(Button$1, {
            onClick: () => this.finish(),
            level: Level.PRIMARY
          }, UI$1.T("Finish"))]);
        } else {
          this.progressArea.setChildren([UI$1.createElement("div", {
            style: {
              fontSize: "1.3em"
            }
          }, (this.questionPageSwitcher.getChildIndex() + 1).toString() + "/" + this.getQuestions().length)]);
        }
      }
      onMount() {
        this.updateFooter();
        this.backButton.addClickListener(() => {
          this.questionPageSwitcher.updateChildIndex(-1);
          this.updateFooter();
        });
        this.forwardButton.addClickListener(() => {
          this.questionPageSwitcher.updateChildIndex(1);
          this.updateFooter();
        });
        this.addListener("updateFooter", () => {
          this.updateFooter();
        });
      }
    }) || _class3$g);
    let DelayedQuestionnairePanel = (_dec3$7 = registerStyle(QuestionnaireStyle), _dec3$7(_class4$8 = class DelayedQuestionnairePanel extends UI$1.Element {
      isFinished() {
        return !!QuestionnaireInstanceStore.getCurrentUserInstance(this.options.questionnaireId).dateSubmitted;
      }
      render() {
        if (this.options.error) {
          return StateDependentElement.renderError(this.options.error);
        }
        if (!this.options.loaded) {
          return StateDependentElement.renderLoading();
        }
        // if (this.isFinished()) {
        //     return <div className={this.styleSheet.finished}>
        //                 <div>
        //                     {UI.T("We have received your answer for this form.")}
        //                 </div>
        //                 <div>
        //                     {UI.T("Thank you!")}
        //                 </div>
        //            </div>;
        // }
        return UI$1.createElement(QuestionnairePanel, {
          questionnaireId: this.options.questionnaireId
        });
      }
      onMount() {
        Ajax.postJSON("/questionnaire_state/", {
          questionnaireId: this.options.questionnaireId
        }).then(() => this.updateOptions({
          loaded: true
        }), error => this.updateOptions({
          error
        }));
      }
    }) || _class4$8);
    class QuestionnaireModal extends Modal {
      render() {
        return UI$1.createElement(DelayedQuestionnairePanel, {
          questionnaireId: this.options.questionnaireId,
          ref: "questionnairePanel"
        });
      }
      onMount() {
        super.onMount();
        this.questionnairePanel.addListener("finished", () => this.hide());
      }
    }
    class QuestionnaireButton extends ActionModalButton(QuestionnaireModal) {
      getDefaultOptions() {
        return {
          level: Level.PRIMARY,
          label: UI$1.T("Open Questionnaire")
        };
      }
      getModalOptions() {
        return {
          questionnaireId: this.options.questionnaireId
        };
      }
    }

    const YOUTUBE_API_SRC = "https://www.youtube.com/iframe_api";
    const State = {
      NOT_STARTED: 1,
      LOADING: 2,
      LOADED: 3,
      ERROR: 4
    };
    class YoutubeIframe extends UI$1.Element {
      static ensureYoutubeAPI() {
        if (this.YOUTUBE_API_STATE === State.NOT_STARTED) {
          ensure(YOUTUBE_API_SRC, NOOP_FUNCTION);
          this.YOUTUBE_API_STATE = State.LOADING;

          // I do not like this pattern, Youtube...
          self.onYouTubeIframeAPIReady = () => {
            this.YOUTUBE_API_STATE = State.LOADED;
            this.youtubeAPI = YT;
            for (const callback of this._registeredCallbacks) {
              callback();
            }
            delete this._registeredCallbacks;
          };
        }
      }
      static registerDelayedCallback(callback) {
        if (!this._registeredCallbacks) {
          this._registeredCallbacks = [];
          this.ensureYoutubeAPI();
        }
        this._registeredCallbacks.push(callback);
      }
      static onYoutubeLoaded(callback) {
        if (this.YOUTUBE_API_STATE === State.LOADED) {
          callback();
          return;
        }
        if (this.YOUTUBE_API_STATE === State.ERROR) {
          throw Error("The Youtube API could not be reached.");
        }
        this.registerDelayedCallback(callback);
      }
      getDefaultOptions() {
        return {
          height: 270,
          width: 480
        };
      }
      getPlayer() {
        return this.player;
      }
      initializeYoutube() {
        this.player = new this.constructor.youtubeAPI.Player(this.node, {
          height: this.options.height,
          width: this.options.width,
          videoId: this.options.videoId
        });
        if (this._delayedListeners) {
          for (const delayedListener of this._delayedListeners) {
            this.getPlayer().addEventListener(...delayedListener);
          }
          delete this._delayedListeners;
        }
      }
      onMount() {
        this.constructor.onYoutubeLoaded(() => this.initializeYoutube());
      }
      onUnmount() {
        this.getPlayer() && this.getPlayer().destroy();
      }
    }
    YoutubeIframe.PLAYER_EVENTS = ["onReady", "onStateChange", "onPlaybackQualityChange", "onPlaybackRateChange", "onError", "onApiChange"];
    YoutubeIframe.YOUTUBE_API_STATE = State.NOT_STARTED;
    for (const playerEvent of YoutubeIframe.PLAYER_EVENTS) {
      YoutubeIframe.prototype["add" + playerEvent.substring(2) + "Listener"] = function (callback, ...extraArgs) {
        const player = this.getPlayer();
        if (player) {
          player.addEventListener(playerEvent, callback);
        } else {
          this._delayedListeners = this._delayedListeners || [];
          this._delayedListeners.push([playerEvent, callback, ...extraArgs]);
        }
      };
    }

    class LocalizedTime extends UI$1.Element {
      getDefaultOptions() {
        return {
          format: "HH:mm",
          value: 0
        };
      }
      render() {
        return new StemDate(this.options.value).format(this.options.format);
      }
    }

    function constant$3 (x) {
      return function constant() {
        return x;
      };
    }

    const pi = Math.PI,
      tau = 2 * pi,
      epsilon = 1e-6,
      tauEpsilon = tau - epsilon;
    function append(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
      if (d > 15) return append;
      const k = 10 ** d;
      return function (strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }
    class Path {
      constructor(digits) {
        this._x0 = this._y0 =
        // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
        this._append = digits == null ? append : appendRound(digits);
      }
      moveTo(x, y) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x, y) {
        this._append`L${this._x1 = +x},${this._y1 = +y}`;
      }
      quadraticCurveTo(x1, y1, x, y) {
        this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x, y) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
      }
      arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

        // Is the radius negative? Error.
        if (r < 0) throw new Error(`negative radius: ${r}`);
        let x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon)) ;

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        }

        // Otherwise, draw an arc!
        else {
          let x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }
          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;

        // Is the radius negative? Error.
        if (r < 0) throw new Error(`negative radius: ${r}`);
        let dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
          this._append`L${x0},${y0}`;
        }

        // Is this arc empty? Were done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau + tau;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon) {
          this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
        }
      }
      rect(x, y, w, h) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    }

    function withPath(shape) {
      let digits = 3;
      shape.digits = function (_) {
        if (!arguments.length) return digits;
        if (_ == null) {
          digits = null;
        } else {
          const d = Math.floor(_);
          if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        return shape;
      };
      return () => new Path(digits);
    }

    function array$1 (x) {
      return typeof x === "object" && "length" in x ? x // Array, TypedArray, NodeList, array-like
      : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }
    Linear.prototype = {
      areaStart: function () {
        this._line = 0;
      },
      areaEnd: function () {
        this._line = NaN;
      },
      lineStart: function () {
        this._point = 0;
      },
      lineEnd: function () {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function (x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
            break;
          case 1:
            this._point = 2;
          // falls through
          default:
            this._context.lineTo(x, y);
            break;
        }
      }
    };
    function curveLinear (context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }
    function y(p) {
      return p[1];
    }

    function line (x$1, y$1) {
      var defined = constant$3(true),
        context = null,
        curve = curveLinear,
        output = null,
        path = withPath(line);
      x$1 = typeof x$1 === "function" ? x$1 : x$1 === undefined ? x : constant$3(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : y$1 === undefined ? y : constant$3(y$1);
      function line(data) {
        var i,
          n = (data = array$1(data)).length,
          d,
          defined0 = false,
          buffer;
        if (context == null) output = curve(buffer = path());
        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();else output.lineEnd();
          }
          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }
        if (buffer) return output = null, buffer + "" || null;
      }
      line.x = function (_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$3(+_), line) : x$1;
      };
      line.y = function (_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$3(+_), line) : y$1;
      };
      line.defined = function (_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$3(!!_), line) : defined;
      };
      line.curve = function (_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };
      line.context = function (_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };
      return line;
    }

    function area (x0, y0, y1) {
      var x1 = null,
        defined = constant$3(true),
        context = null,
        curve = curveLinear,
        output = null,
        path = withPath(area);
      x0 = typeof x0 === "function" ? x0 : x0 === undefined ? x : constant$3(+x0);
      y0 = typeof y0 === "function" ? y0 : y0 === undefined ? constant$3(0) : constant$3(+y0);
      y1 = typeof y1 === "function" ? y1 : y1 === undefined ? y : constant$3(+y1);
      function area(data) {
        var i,
          j,
          k,
          n = (data = array$1(data)).length,
          d,
          defined0 = false,
          buffer,
          x0z = new Array(n),
          y0z = new Array(n);
        if (context == null) output = curve(buffer = path());
        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }
        if (buffer) return output = null, buffer + "" || null;
      }
      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }
      area.x = function (_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), x1 = null, area) : x0;
      };
      area.x0 = function (_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), area) : x0;
      };
      area.x1 = function (_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : x1;
      };
      area.y = function (_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), y1 = null, area) : y0;
      };
      area.y0 = function (_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), area) : y0;
      };
      area.y1 = function (_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : y1;
      };
      area.lineX0 = area.lineY0 = function () {
        return arealine().x(x0).y(y0);
      };
      area.lineY1 = function () {
        return arealine().x(x0).y(y1);
      };
      area.lineX1 = function () {
        return arealine().x(x1).y(y0);
      };
      area.defined = function (_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$3(!!_), area) : defined;
      };
      area.curve = function (_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };
      area.context = function (_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };
      return area;
    }

    class LinePlot extends SVG.Path {
      getDefaultOptions() {
        return {
          d: "",
          fill: "none",
          stroke: "darkgrey",
          strokeWidth: 1.5,
          interpolation: "linear"
        };
      }
      setOptions(options) {
        Object.assign(options, this.options.plotOptions);
        super.setOptions(options);
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getLineData());
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }
      getLineData() {
        this.linePathGenerator = line().x(data => {
          return this.options.chart.xAxisOptions.scale(this.options.plotOptions.xCoordinateAlias(data));
        }).y(data => {
          return this.options.chart.yAxisOptions.scale(this.options.plotOptions.yCoordinateAlias(data));
        });
        return this.linePathGenerator(this.options.plotOptions.pointsAlias(this.options.data));
      }
      onMount() {
        this.options.chart.addZoomListener(() => {
          this.redraw();
        });
      }
    }

    class PointPlotElement extends SVG.Circle {
      getDefaultOptions() {
        return {
          center: {
            x: 0,
            y: 0
          },
          radius: 5,
          fill: "grey",
          strokeWidth: 0.5,
          stroke: "darkgrey"
        };
      }
      redraw() {
        //this.options.center = {
        //    x: this.options.xAxisScale(this.options.xCoordinateAlias(this.options.data)),
        //    y: this.options.yAxisScale(this.options.yCoordinateAlias(this.options.data))
        //};
        this.translate(this.options.xAxisScale(this.options.xCoordinateAlias(this.options.data)), this.options.yAxisScale(this.options.yCoordinateAlias(this.options.data)));
        super.redraw();
      }
    }
    const PointPlot = PointPlotElementClass => class PointPlot extends SVG.Group {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }
      getPoints() {
        this.points = [];
        this.pointsData = this.options.plotOptions.pointsAlias(this.options.data);
        for (let i = 0; i < this.pointsData.length; i += 1) {
          this.points[i] = UI$1.createElement(PointPlotElementClass, _extends({
            ref: this.refLinkArray("points", i)
          }, this.options.plotOptions, {
            data: this.pointsData[i],
            xAxisScale: this.options.chart.xAxisOptions.scale,
            yAxisScale: this.options.chart.yAxisOptions.scale
          }));
        }
        return this.points;
      }
      render() {
        return [...this.getPoints()];
      }
      onMount() {
        this.options.chart.addZoomListener(() => {
          this.redraw();
        });
      }
    };
    const BasePointPlot = PointPlot(PointPlotElement);

    function ascending$1(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending(a, b) {
      return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function bisector(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We cant do this
      // for a comparator (except for specific, known comparators) because we cant
      // tell if the comparator is symmetric, and an asymmetric comparator cant be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$1;
        compare2 = (d, x) => ascending$1(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$1 || f === descending ? f : zero$1;
        compare2 = f;
        delta = f;
      }
      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = lo + hi >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = lo + hi >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }
      return {
        left,
        center,
        right
      };
    }
    function zero$1() {
      return 0;
    }

    function number$2(x) {
      return x === null ? NaN : +x;
    }

    const ascendingBisect = bisector(ascending$1);
    const bisectRight = ascendingBisect.right;
    bisector(number$2).center;

    const e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);
    function tickSpec(start, stop, count) {
      const step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log10(step)),
        error = step / Math.pow(10, power),
        factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
      }
      if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
      return [i1, i2, inc];
    }
    function ticks(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      if (!(count > 0)) return [];
      if (start === stop) return [start];
      const reverse = stop < start,
        [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
      if (!(i2 >= i1)) return [];
      const n = i2 - i1 + 1,
        ticks = new Array(n);
      if (reverse) {
        if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
      } else {
        if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
      }
      return ticks;
    }
    function tickIncrement(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      return tickSpec(start, stop, count)[2];
    }
    function tickStep(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      const reverse = stop < start,
        inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
      return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(domain);
          break;
        default:
          this.range(range).domain(domain);
          break;
      }
      return this;
    }

    function define (constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
      reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
      reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
      reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
      reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
      reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };
    define(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
      : null // invalid hex
      ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }
    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }
    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl();
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }
    define(Hsl, hsl, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }

    var constant$2 = (x => () => x);

    function linear$1(a, d) {
      return function (t) {
        return a + t * d;
      };
    }
    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
        return Math.pow(a + t * b, y);
      };
    }
    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function (a, b) {
        return b - a ? exponential(a, b, y) : constant$2(isNaN(a) ? b : a);
      };
    }
    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$1(a, d) : constant$2(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);
      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
      rgb$1.gamma = rgbGamma;
      return rgb$1;
    })(1);

    function numberArray (a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
      return function (t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }
    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;
      for (i = 0; i < na; ++i) x[i] = interpolate$1(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];
      return function (t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1 (a, b) {
      var d = new Date();
      return a = +a, b = +b, function (t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber (a, b) {
      return a = +a, b = +b, function (t) {
        return a * (1 - t) + b * t;
      };
    }

    function object (a, b) {
      var i = {},
        c = {},
        k;
      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};
      for (k in b) {
        if (k in a) {
          i[k] = interpolate$1(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }
      return function (t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");
    function zero(b) {
      return function () {
        return b;
      };
    }
    function one(b) {
      return function (t) {
        return b(t) + "";
      };
    }
    function interpolateString (a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0,
        // scan index for next number in b
        am,
        // current match in a
        bm,
        // current match in b
        bs,
        // string preceding current number in b, if any
        i = -1,
        // index in s
        s = [],
        // string constants and placeholders
        q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else {
          // interpolate non-matching numbers
          s[++i] = null;
          q.push({
            i: i,
            x: interpolateNumber(am, bm)
          });
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
        for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      });
    }

    function interpolate$1 (a, b) {
      var t = typeof b,
        c;
      return b == null || t === "boolean" ? constant$2(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
    }

    function interpolateRound (a, b) {
      return a = +a, b = +b, function (t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees = 180 / Math.PI;
    var identity$3 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose (a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$3 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }
    function parseSvg(value) {
      if (value == null) return identity$3;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$3;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {
      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }
      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({
            i: i - 4,
            x: interpolateNumber(xa, xb)
          }, {
            i: i - 2,
            x: interpolateNumber(ya, yb)
          });
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }
      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path
          q.push({
            i: s.push(pop(s) + "rotate(", null, degParen) - 2,
            x: interpolateNumber(a, b)
          });
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }
      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({
            i: s.push(pop(s) + "skewX(", null, degParen) - 2,
            x: interpolateNumber(a, b)
          });
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }
      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: interpolateNumber(xa, xb)
          }, {
            i: i - 2,
            x: interpolateNumber(ya, yb)
          });
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }
      return function (a, b) {
        var s = [],
          // string constants and placeholders
          q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function (t) {
          var i = -1,
            n = q.length,
            o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }
    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2 = 1e-12;
    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {
      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0],
          uy0 = p0[1],
          w0 = p0[2],
          ux1 = p1[0],
          uy1 = p1[1],
          w1 = p1[2],
          dx = ux1 - ux0,
          dy = uy1 - uy0,
          d2 = dx * dx + dy * dy,
          i,
          S;

        // Special case for u0  u1.
        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;
          i = function (t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
            b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function (t) {
            var s = t * S,
              coshr0 = cosh(r0),
              u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
          };
        }
        i.duration = S * 1000 * rho / Math.SQRT2;
        return i;
      }
      zoom.rho = function (_) {
        var _1 = Math.max(1e-3, +_),
          _2 = _1 * _1,
          _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom;
    })(Math.SQRT2, 2, 4);

    function constants(x) {
      return function () {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];
    function identity$2(x) {
      return x;
    }
    function normalize(a, b) {
      return (b -= a = +a) ? function (x) {
        return (x - a) / b;
      } : constants(isNaN(b) ? NaN : 0.5);
    }
    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function (x) {
        return Math.max(a, Math.min(b, x));
      };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0],
        d1 = domain[1],
        r0 = range[0],
        r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function (x) {
        return r0(d0(x));
      };
    }
    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }
      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }
      return function (x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }
    function copy(source, target) {
      return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
    }
    function transformer() {
      var domain = unit,
        range = unit,
        interpolate = interpolate$1,
        transform,
        untransform,
        unknown,
        clamp = identity$2,
        piecewise,
        output,
        input;
      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$2) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }
      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }
      scale.invert = function (y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };
      scale.domain = function (_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };
      scale.range = function (_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };
      scale.rangeRound = function (_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };
      scale.clamp = function (_) {
        return arguments.length ? (clamp = _ ? true : identity$2, rescale()) : clamp !== identity$2;
      };
      scale.interpolate = function (_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };
      scale.unknown = function (_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      return function (t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }
    function continuous() {
      return transformer()(identity$2, identity$2);
    }

    function formatDecimal (x) {
      return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
      var i,
        coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
    }

    function exponent (x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup (grouping, thousands) {
      return function (value, width) {
        var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;
        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
      };
    }

    function formatNumerals (numerals) {
      return function (value) {
        return value.replace(/[0-9]/g, function (i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }
    FormatSpecifier.prototype.toString = function () {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim (s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;
          default:
            if (!+s[i]) break out;
            if (i0 > 0) i0 = 0;
            break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;
    function formatPrefixAuto (x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
      return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded (x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
        exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": x => Math.round(x).toString(2),
      "c": x => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": x => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": x => Math.round(x).toString(16).toUpperCase(),
      "x": x => Math.round(x).toString(16)
    };

    function identity$1 (x) {
      return x;
    }

    var map = Array.prototype.map,
      prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$1 (locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";
      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format(value) {
          var valuePrefix = prefix,
            valueSuffix = suffix,
            i,
            n,
            c;
          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer value part that can be
            // grouped, and fractional or exponential suffix part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<":
              value = valuePrefix + value + valueSuffix + padding;
              break;
            case "=":
              value = valuePrefix + padding + value + valueSuffix;
              break;
            case "^":
              value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
              break;
            default:
              value = padding + valuePrefix + value + valueSuffix;
              break;
          }
          return numerals(value);
        }
        format.toString = function () {
          return specifier + "";
        };
        return format;
      }
      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
        return function (value) {
          return f(k * value) + prefix;
        };
      }
      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;
    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed (step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix (step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound (step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
        precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s":
          {
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
            return formatPrefix(specifier, value);
          }
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
          {
            if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
            break;
          }
        case "f":
        case "%":
          {
            if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
            break;
          }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;
      scale.ticks = function (count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };
      scale.tickFormat = function (count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };
      scale.nice = function (count) {
        if (count == null) count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }
        return scale;
      };
      return scale;
    }
    function linear() {
      var scale = continuous();
      scale.copy = function () {
        return copy(scale, linear());
      };
      initRange.apply(scale, arguments);
      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();
      var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;
      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }
      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    const t0 = new Date(),
      t1 = new Date();
    function timeInterval(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
      }
      interval.floor = date => {
        return floori(date = new Date(+date)), date;
      };
      interval.ceil = date => {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };
      interval.round = date => {
        const d0 = interval(date),
          d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };
      interval.offset = (date, step) => {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };
      interval.range = (start, stop, step) => {
        const range = [];
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        let previous;
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);
        return range;
      };
      interval.filter = test => {
        return timeInterval(date => {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, (date, step) => {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };
      if (count) {
        interval.count = (start, end) => {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };
        interval.every = step => {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? d => field(d) % step === 0 : d => interval.count(0, d) % step === 0);
        };
      }
      return interval;
    }

    const millisecond = timeInterval(() => {
      // noop
    }, (date, step) => {
      date.setTime(+date + step);
    }, (start, end) => {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = k => {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return timeInterval(date => {
        date.setTime(Math.floor(date / k) * k);
      }, (date, step) => {
        date.setTime(+date + step * k);
      }, (start, end) => {
        return (end - start) / k;
      });
    };
    millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    const second = timeInterval(date => {
      date.setTime(date - date.getMilliseconds());
    }, (date, step) => {
      date.setTime(+date + step * durationSecond);
    }, (start, end) => {
      return (end - start) / durationSecond;
    }, date => {
      return date.getUTCSeconds();
    });
    second.range;

    const timeMinute = timeInterval(date => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, (date, step) => {
      date.setTime(+date + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, date => {
      return date.getMinutes();
    });
    timeMinute.range;
    const utcMinute = timeInterval(date => {
      date.setUTCSeconds(0, 0);
    }, (date, step) => {
      date.setTime(+date + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, date => {
      return date.getUTCMinutes();
    });
    utcMinute.range;

    const timeHour = timeInterval(date => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, (date, step) => {
      date.setTime(+date + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, date => {
      return date.getHours();
    });
    timeHour.range;
    const utcHour = timeInterval(date => {
      date.setUTCMinutes(0, 0, 0);
    }, (date, step) => {
      date.setTime(+date + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, date => {
      return date.getUTCHours();
    });
    utcHour.range;

    const timeDay = timeInterval(date => date.setHours(0, 0, 0, 0), (date, step) => date.setDate(date.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, date => date.getDate() - 1);
    timeDay.range;
    const utcDay = timeInterval(date => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, date => {
      return date.getUTCDate() - 1;
    });
    utcDay.range;
    const unixDay = timeInterval(date => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, date => {
      return Math.floor(date / durationDay);
    });
    unixDay.range;

    function timeWeekday(i) {
      return timeInterval(date => {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setDate(date.getDate() + step * 7);
      }, (start, end) => {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }
    const timeSunday = timeWeekday(0);
    const timeMonday = timeWeekday(1);
    const timeTuesday = timeWeekday(2);
    const timeWednesday = timeWeekday(3);
    const timeThursday = timeWeekday(4);
    const timeFriday = timeWeekday(5);
    const timeSaturday = timeWeekday(6);
    timeSunday.range;
    timeMonday.range;
    timeTuesday.range;
    timeWednesday.range;
    timeThursday.range;
    timeFriday.range;
    timeSaturday.range;
    function utcWeekday(i) {
      return timeInterval(date => {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, (start, end) => {
        return (end - start) / durationWeek;
      });
    }
    const utcSunday = utcWeekday(0);
    const utcMonday = utcWeekday(1);
    const utcTuesday = utcWeekday(2);
    const utcWednesday = utcWeekday(3);
    const utcThursday = utcWeekday(4);
    const utcFriday = utcWeekday(5);
    const utcSaturday = utcWeekday(6);
    utcSunday.range;
    utcMonday.range;
    utcTuesday.range;
    utcWednesday.range;
    utcThursday.range;
    utcFriday.range;
    utcSaturday.range;

    const timeMonth = timeInterval(date => {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setMonth(date.getMonth() + step);
    }, (start, end) => {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, date => {
      return date.getMonth();
    });
    timeMonth.range;
    const utcMonth = timeInterval(date => {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, (start, end) => {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, date => {
      return date.getUTCMonth();
    });
    utcMonth.range;

    const timeYear = timeInterval(date => {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setFullYear(date.getFullYear() + step);
    }, (start, end) => {
      return end.getFullYear() - start.getFullYear();
    }, date => {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    timeYear.every = k => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval(date => {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    timeYear.range;
    const utcYear = timeInterval(date => {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, (start, end) => {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, date => {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = k => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval(date => {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    utcYear.range;

    function ticker(year, month, week, day, hour, minute) {
      const tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];
      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }
      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }
      return [ticks, tickInterval];
    }
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate(y, m, d) {
      return {
        y: y,
        m: m,
        d: d,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      };
    }
    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;
      var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);
      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);
      function newFormat(specifier, formats) {
        return function (date) {
          var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;
          if (!(date instanceof Date)) date = new Date(+date);
          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }
          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }
      function newParse(specifier, Z) {
        return function (string) {
          var d = newDate(1900, undefined, 1),
            i = parseSpecifier(d, specifier, string += "", 0),
            week,
            day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }
      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;
        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || (j = parse(d, string, j)) < 0) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }
        return j;
      }
      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }
      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }
      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }
      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }
      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }
      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }
      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }
      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }
      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }
      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }
      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }
      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }
      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }
      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }
      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }
      return {
        format: function (specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function () {
            return specifier;
          };
          return f;
        },
        parse: function (specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function () {
            return specifier;
          };
          return p;
        },
        utcFormat: function (specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function () {
            return specifier;
          };
          return f;
        },
        utcParse: function (specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function () {
            return specifier;
          };
          return p;
        }
      };
    }
    var pads = {
        "-": "",
        "_": " ",
        "0": "0"
      },
      numberRe = /^\s*\d+/,
      // note: ignores next directive
      percentRe = /^%/,
      requoteRe = /[\\^$*+?|[\]().{}]/g;
    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }
    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }
    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }
    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }
    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }
    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }
    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }
    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }
    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }
    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }
    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }
    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }
    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }
    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday(d, p) {
      return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
    }
    function dISO(d) {
      var day = d.getDay();
      return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    }
    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }
    function formatWeekNumberMonday(d, p) {
      return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
    }
    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }
    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }
    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }
    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }
    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }
    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }
    function UTCdISO(d) {
      var day = d.getUTCDay();
      return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    }
    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }
    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCZone() {
      return "+0000";
    }
    function formatLiteralPercent() {
      return "%";
    }
    function formatUnixTimestamp(d) {
      return +d;
    }
    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      locale.parse;
      locale.utcFormat;
      locale.utcParse;
      return locale;
    }

    function date(t) {
      return new Date(t);
    }
    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }
    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
        invert = scale.invert,
        domain = scale.domain;
      var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");
      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
      }
      scale.invert = function (y) {
        return new Date(invert(y));
      };
      scale.domain = function (_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };
      scale.ticks = function (interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };
      scale.tickFormat = function (count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };
      scale.nice = function (interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };
      scale.copy = function () {
        return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };
      return scale;
    }
    function time$1() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    var xhtml = "http://www.w3.org/1999/xhtml";
    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace (name) {
      var prefix = name += "",
        i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {
        space: namespaces[prefix],
        local: name
      } : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function () {
        var document = this.ownerDocument,
          uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
      };
    }
    function creatorFixed(fullname) {
      return function () {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator (name) {
      var fullname = namespace(name);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }

    function none() {}
    function selector (selector) {
      return selector == null ? none : function () {
        return this.querySelector(selector);
      };
    }

    function selection_select (select) {
      if (typeof select !== "function") select = selector(select);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we dont ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty() {
      return [];
    }
    function selectorAll (selector) {
      return selector == null ? empty : function () {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function () {
        return array(select.apply(this, arguments));
      };
    }
    function selection_selectAll (select) {
      if (typeof select === "function") select = arrayAll(select);else select = selectorAll(select);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }
      return new Selection$1(subgroups, parents);
    }

    function matcher (selector) {
      return function () {
        return this.matches(selector);
      };
    }
    function childMatcher(selector) {
      return function (node) {
        return node.matches(selector);
      };
    }

    var find = Array.prototype.find;
    function childFind(match) {
      return function () {
        return find.call(this.children, match);
      };
    }
    function childFirst() {
      return this.firstElementChild;
    }
    function selection_selectChild (match) {
      return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;
    function children() {
      return Array.from(this.children);
    }
    function childrenFilter(match) {
      return function () {
        return filter.call(this.children, match);
      };
    }
    function selection_selectChildren (match) {
      return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter (match) {
      if (typeof match !== "function") match = matcher(match);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }

    function sparse (update) {
      return new Array(update.length);
    }

    function selection_enter () {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function (child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function (child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function (selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function (selector) {
        return this._parent.querySelectorAll(selector);
      }
    };

    function constant$1 (x) {
      return function () {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that dont fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }
    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
        node,
        nodeByKeyValue = new Map(),
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
          exit[i] = node;
        }
      }
    }
    function datum(node) {
      return node.__data__;
    }
    function selection_data (value, key) {
      if (!arguments.length) return Array.from(this, datum);
      var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;
      if (typeof value !== "function") value = constant$1(value);
      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);
        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }
      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isnt worried about live collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // dont; wed rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data ? data // Array, TypedArray, NodeList, array-like
      : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit () {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join (onenter, onupdate, onexit) {
      var enter = this.enter(),
        update = this,
        exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove();else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge (context) {
      var selection = context.selection ? context.selection() : context;
      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection$1(merges, this._parents);
    }

    function selection_order () {
      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }
      return this;
    }

    function selection_sort (compare) {
      if (!compare) compare = ascending;
      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }
      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection$1(sortgroups, this._parents).order();
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call () {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes () {
      return Array.from(this);
    }

    function selection_node () {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }
      return null;
    }

    function selection_size () {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty () {
      return !this.node();
    }

    function selection_each (callback) {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }
      return this;
    }

    function attrRemove$1(name) {
      return function () {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS$1(fullname) {
      return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant$1(name, value) {
      return function () {
        this.setAttribute(name, value);
      };
    }
    function attrConstantNS$1(fullname, value) {
      return function () {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }
    function attrFunction$1(name, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
      };
    }
    function attrFunctionNS$1(fullname, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr (name, value) {
      var fullname = namespace(name);
      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }
      return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
    }

    function defaultView (node) {
      return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
      || node.document && node // node is a Window
      || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function () {
        this.style.removeProperty(name);
      };
    }
    function styleConstant$1(name, value, priority) {
      return function () {
        this.style.setProperty(name, value, priority);
      };
    }
    function styleFunction$1(name, value, priority) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
      };
    }
    function selection_style (name, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
    }
    function styleValue(node, name) {
      return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function () {
        delete this[name];
      };
    }
    function propertyConstant(name, value) {
      return function () {
        this[name] = value;
      };
    }
    function propertyFunction(name, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];else this[name] = v;
      };
    }
    function selection_property (name, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }
    function classList(node) {
      return node.classList || new ClassList(node);
    }
    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }
    ClassList.prototype = {
      add: function (name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function (name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function (name) {
        return this._names.indexOf(name) >= 0;
      }
    };
    function classedAdd(node, names) {
      var list = classList(node),
        i = -1,
        n = names.length;
      while (++i < n) list.add(names[i]);
    }
    function classedRemove(node, names) {
      var list = classList(node),
        i = -1,
        n = names.length;
      while (++i < n) list.remove(names[i]);
    }
    function classedTrue(names) {
      return function () {
        classedAdd(this, names);
      };
    }
    function classedFalse(names) {
      return function () {
        classedRemove(this, names);
      };
    }
    function classedFunction(names, value) {
      return function () {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }
    function selection_classed (name, value) {
      var names = classArray(name + "");
      if (arguments.length < 2) {
        var list = classList(this.node()),
          i = -1,
          n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }
      return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }
    function textConstant$1(value) {
      return function () {
        this.textContent = value;
      };
    }
    function textFunction$1(value) {
      return function () {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text (value) {
      return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }
    function htmlConstant(value) {
      return function () {
        this.innerHTML = value;
      };
    }
    function htmlFunction(value) {
      return function () {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html (value) {
      return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }
    function selection_raise () {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower () {
      return this.each(lower);
    }

    function selection_append (name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function () {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }
    function selection_insert (name, before) {
      var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function () {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }
    function selection_remove () {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false),
        parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep() {
      var clone = this.cloneNode(true),
        parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone (deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum (value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }

    function contextListener(listener) {
      return function (event) {
        listener.call(this, event, this.__data__);
      };
    }
    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "",
          i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {
          type: t,
          name: name
        };
      });
    }
    function onRemove(typename) {
      return function () {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;else delete this.__on;
      };
    }
    function onAdd(typename, value, options) {
      return function () {
        var on = this.__on,
          o,
          listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {
          type: typename.type,
          name: typename.name,
          value: value,
          listener: listener,
          options: options
        };
        if (!on) this.__on = [o];else on.push(o);
      };
    }
    function selection_on (typename, value, options) {
      var typenames = parseTypenames$1(typename + ""),
        i,
        n = typenames.length,
        t;
      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }
      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
        event = window.CustomEvent;
      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
      }
      node.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
      return function () {
        return dispatchEvent(this, type, params);
      };
    }
    function dispatchFunction(type, params) {
      return function () {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }
    function selection_dispatch (type, params) {
      return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
    }

    function* selection_iterator () {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root = [null];
    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection() {
      return new Selection$1([[document.documentElement]], root);
    }
    function selection_selection() {
      return this;
    }
    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select (selector) {
      return typeof selector === "string" ? new Selection$1([[document.querySelector(selector)]], [document.documentElement]) : new Selection$1([[selector]], root);
    }

    function sourceEvent (event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer (event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    var noop = {
      value: () => {}
    };
    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }
    function Dispatch(_) {
      this._ = _;
    }
    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "",
          i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {
          type: t,
          name: name
        };
      });
    }
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function (typename, callback) {
        var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }
        return this;
      },
      copy: function () {
        var copy = {},
          _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function (type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function (type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };
    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }
    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({
        name: name,
        value: callback
      });
      return type;
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassivecapture = {
      capture: true,
      passive: false
    };
    function noevent$1 (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable (view) {
      var root = view.document.documentElement,
        selection = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$1, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }
    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
        selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$1, nonpassivecapture);
        setTimeout(function () {
          selection.on("click.drag", null);
        }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var frame = 0,
      // is an animation frame pending?
      timeout$1 = 0,
      // is a timeout pending?
      interval = 0,
      // are any timers active?
      pokeDelay = 1000,
      // how frequently we check for clock skew
      taskHead,
      taskTail,
      clockLast = 0,
      clockNow = 0,
      clockSkew = 0,
      clock = typeof performance === "object" && performance.now ? performance : Date,
      setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
        setTimeout(f, 17);
      };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }
    function clearNow() {
      clockNow = 0;
    }
    function Timer() {
      this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function (callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function () {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer(callback, delay, time) {
      var t = new Timer();
      t.restart(callback, delay, time);
      return t;
    }
    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend weve set an alarm, if we havent already.
      var t = taskHead,
        e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }
    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }
    function poke() {
      var now = clock.now(),
        delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }
    function nap() {
      var t0,
        t1 = taskHead,
        t2,
        time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }
    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout (callback, delay, time) {
      var t = new Timer();
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule (node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index,
        // For context during callback.
        group: group,
        // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }
    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }
    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }
    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }
    function create(node, id, self) {
      var schedules = node.__transition,
        tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);
      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }
      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();
        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function () {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }
      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
          i = -1,
          n = tween.length;
        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }
      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt (node, name) {
      var schedules = node.__transition,
        schedule,
        active,
        empty = true,
        i;
      if (!schedules) return;
      name = name == null ? null : name + "";
      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) {
          empty = false;
          continue;
        }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }
      if (empty) delete node.__transition;
    }

    function selection_interrupt (name) {
      return this.each(function () {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function () {
        var schedule = set(this, id),
          tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }
        schedule.tween = tween1;
      };
    }
    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error();
      return function () {
        var schedule = set(this, id),
          tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {
              name: name,
              value: value
            }, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }
        schedule.tween = tween1;
      };
    }
    function transition_tween (name, value) {
      var id = this._id;
      name += "";
      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }
      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }
    function tweenValue(transition, name, value) {
      var id = transition._id;
      transition.each(function () {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });
      return function (node) {
        return get(node, id).value[name];
      };
    }

    function interpolate (a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function () {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS(fullname) {
      return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant(name, interpolate, value1) {
      var string00,
        string1 = value1 + "",
        interpolate0;
      return function () {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
      };
    }
    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
        string1 = value1 + "",
        interpolate0;
      return function () {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
      };
    }
    function attrFunction(name, interpolate, value) {
      var string00, string10, interpolate0;
      return function () {
        var string0,
          value1 = value(this),
          string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }
    function attrFunctionNS(fullname, interpolate, value) {
      var string00, string10, interpolate0;
      return function () {
        var string0,
          value1 = value(this),
          string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }
    function transition_attr (name, value) {
      var fullname = namespace(name),
        i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function (t) {
        this.setAttribute(name, i.call(this, t));
      };
    }
    function attrInterpolateNS(fullname, i) {
      return function (t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }
    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function transition_attrTween (name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error();
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function () {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }
    function delayConstant(id, value) {
      return value = +value, function () {
        init(this, id).delay = value;
      };
    }
    function transition_delay (value) {
      var id = this._id;
      return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function () {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }
    function durationConstant(id, value) {
      return value = +value, function () {
        set(this, id).duration = value;
      };
    }
    function transition_duration (value) {
      var id = this._id;
      return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error();
      return function () {
        set(this, id).ease = value;
      };
    }
    function transition_ease (value) {
      var id = this._id;
      return arguments.length ? this.each(easeConstant(id, value)) : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error();
        set(this, id).ease = v;
      };
    }
    function transition_easeVarying (value) {
      if (typeof value !== "function") throw new Error();
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter (match) {
      if (typeof match !== "function") match = matcher(match);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge (transition) {
      if (transition._id !== this._id) throw new Error();
      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function (t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }
    function onFunction(id, name, listener) {
      var on0,
        on1,
        sit = start(name) ? init : set;
      return function () {
        var schedule = sit(this, id),
          on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
        schedule.on = on1;
      };
    }
    function transition_on (name, listener) {
      var id = this._id;
      return arguments.length < 2 ? get(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function () {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }
    function transition_remove () {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select (select) {
      var name = this._name,
        id = this._id;
      if (typeof select !== "function") select = selector(select);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }
      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll (select) {
      var name = this._name,
        id = this._id;
      if (typeof select !== "function") select = selectorAll(select);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }
      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;
    function transition_selection () {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00, string10, interpolate0;
      return function () {
        var string0 = styleValue(this, name),
          string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }
    function styleRemove(name) {
      return function () {
        this.style.removeProperty(name);
      };
    }
    function styleConstant(name, interpolate, value1) {
      var string00,
        string1 = value1 + "",
        interpolate0;
      return function () {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
      };
    }
    function styleFunction(name, interpolate, value) {
      var string00, string10, interpolate0;
      return function () {
        var string0 = styleValue(this, name),
          value1 = value(this),
          string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }
    function styleMaybeRemove(id, name) {
      var on0,
        on1,
        listener0,
        key = "style." + name,
        event = "end." + key,
        remove;
      return function () {
        var schedule = set(this, id),
          on = schedule.on,
          listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
        schedule.on = on1;
      };
    }
    function transition_style (name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function (t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }
    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }
    function transition_styleTween (name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error();
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function () {
        this.textContent = value;
      };
    }
    function textFunction(value) {
      return function () {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }
    function transition_text (value) {
      return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function (t) {
        this.textContent = i.call(this, t);
      };
    }
    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function transition_textTween (value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error();
      return this.tween(key, textTween(value));
    }

    function transition_transition () {
      var name = this._name,
        id0 = this._id,
        id1 = newId();
      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }
      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end () {
      var on0,
        on1,
        that = this,
        id = that._id,
        size = that.size();
      return new Promise(function (resolve, reject) {
        var cancel = {
            value: reject
          },
          end = {
            value: function () {
              if (--size === 0) resolve();
            }
          };
        that.each(function () {
          var schedule = set(this, id),
            on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and were done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }
          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;
    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }
    function newId() {
      return ++id;
    }
    var selection_prototype = selection.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }
    function selection_transition (name) {
      var id, timing;
      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }
      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }
      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var constant = (x => () => x);

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {
          value: type,
          enumerable: true,
          configurable: true
        },
        sourceEvent: {
          value: sourceEvent,
          enumerable: true,
          configurable: true
        },
        target: {
          value: target,
          enumerable: true,
          configurable: true
        },
        transform: {
          value: transform,
          enumerable: true,
          configurable: true
        },
        _: {
          value: dispatch
        }
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }
    Transform.prototype = {
      constructor: Transform,
      scale: function (k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function (x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function (point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function (x) {
        return x * this.k + this.x;
      },
      applyY: function (y) {
        return y * this.k + this.y;
      },
      invert: function (location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function (x) {
        return (x - this.x) / this.k;
      },
      invertY: function (y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function (x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function (y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function () {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    var identity = new Transform(1, 0, 0);
    Transform.prototype;

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }
    function noevent (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }
    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }
    function defaultTransform() {
      return this.__zoom || identity;
    }
    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }
    function defaultTouchable() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }
    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
        dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
        dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
        dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
    }
    function zoom () {
      var filter = defaultFilter,
        extent = defaultExtent,
        constrain = defaultConstrain,
        wheelDelta = defaultWheelDelta,
        touchable = defaultTouchable,
        scaleExtent = [0, Infinity],
        translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
        duration = 250,
        interpolate = interpolateZoom,
        listeners = dispatch("start", "zoom", "end"),
        touchstarting,
        touchfirst,
        touchending,
        touchDelay = 500,
        wheelDelay = 150,
        clickDistance2 = 0,
        tapDistance = 10;
      function zoom(selection) {
        selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {
          passive: false
        }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }
      zoom.transform = function (collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function () {
            gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
          });
        }
      };
      zoom.scaleBy = function (selection, k, p, event) {
        zoom.scaleTo(selection, function () {
          var k0 = this.__zoom.k,
            k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };
      zoom.scaleTo = function (selection, k, p, event) {
        zoom.transform(selection, function () {
          var e = extent.apply(this, arguments),
            t0 = this.__zoom,
            p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
            p1 = t0.invert(p0),
            k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };
      zoom.translateBy = function (selection, x, y, event) {
        zoom.transform(selection, function () {
          return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };
      zoom.translateTo = function (selection, x, y, p, event) {
        zoom.transform(selection, function () {
          var e = extent.apply(this, arguments),
            t = this.__zoom,
            p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
        }, p, event);
      };
      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }
      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k,
          y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }
      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }
      function schedule(transition, transform, point, event) {
        transition.on("start.zoom", function () {
          gesture(this, arguments).event(event).start();
        }).on("interrupt.zoom end.zoom", function () {
          gesture(this, arguments).event(event).end();
        }).tween("zoom", function () {
          var that = this,
            args = arguments,
            g = gesture(that, args).event(event),
            e = extent.apply(that, args),
            p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
            w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
            a = that.__zoom,
            b = typeof transform === "function" ? transform.apply(that, args) : transform,
            i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function (t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else {
              var l = i(t),
                k = w / l[2];
              t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
            }
            g.zoom(null, t);
          };
        });
      }
      function gesture(that, args, clean) {
        return !clean && that.__zooming || new Gesture(that, args);
      }
      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }
      Gesture.prototype = {
        event: function (event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function () {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function (key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function () {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function (type) {
          var d = select(this.that).datum();
          listeners.call(type, this.that, new ZoomEvent(type, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type,
            transform: this.that.__zoom,
            dispatch: listeners
          }), d);
        }
      };
      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
          t = this.__zoom,
          k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
          p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event wont trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }
        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }
      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
          g = gesture(this, args, true).event(event),
          v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
          p = pointer(event, currentTarget),
          x0 = event.clientX,
          y0 = event.clientY;
        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();
        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0,
              dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }
        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }
      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
          p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
          p1 = t0.invert(p0),
          k1 = t0.k * (event.shiftKey ? 0.5 : 2),
          t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);else select(this).call(zoom.transform, t1, p0, event);
      }
      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
          n = touches.length,
          g = gesture(this, args, event.changedTouches.length === n).event(event),
          started,
          i,
          t,
          p;
        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }
        if (touchstarting) touchstarting = clearTimeout(touchstarting);
        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function () {
            touchstarting = null;
          }, touchDelay);
          interrupt(this);
          g.start();
        }
      }
      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
          touches = event.changedTouches,
          n = touches.length,
          i,
          t,
          p,
          l;
        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0],
            l0 = g.touch0[1],
            p1 = g.touch1[0],
            l1 = g.touch1[1],
            dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
            dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;
        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }
      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
          touches = event.changedTouches,
          n = touches.length,
          i,
          t;
        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }
      zoom.wheelDelta = function (_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };
      zoom.filter = function (_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };
      zoom.touchable = function (_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };
      zoom.extent = function (_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };
      zoom.scaleExtent = function (_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };
      zoom.translateExtent = function (_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };
      zoom.constrain = function (_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };
      zoom.duration = function (_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };
      zoom.interpolate = function (_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };
      zoom.on = function () {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };
      zoom.clickDistance = function (_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };
      zoom.tapDistance = function (_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };
      return zoom;
    }

    // TODO: This file desperately needs a refactoring.

    class AxisTick extends SVG.Group {
      getDefaultOptions() {
        return {
          gridLineLength: 0,
          axisLineLength: 6,
          gridLineStroke: "rgba(255, 255, 255, .7)",
          labelPadding: 6,
          labelStrokeWidth: 0.5,
          labelFontFamily: "'Helvetica Neue', Helvetica, Arial, sans-serif"
        };
      }
      getLabel() {
        let labelOptions = {
          text: "" + this.options.label,
          strokeWidth: this.options.labelStrokeWidth
        };
        if (this.options.orientation === Direction.DOWN) {
          Object.assign(labelOptions, {
            textAnchor: "middle",
            dy: ".71em",
            y: this.options.labelPadding + this.options.axisLineLength
          });
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(labelOptions, {
            textAnchor: "end",
            dy: ".35em",
            x: -1 * (this.options.labelPadding + this.options.axisLineLength)
          });
        }
        return UI$1.createElement(SVG.Text, _extends({
          ref: this.refLink("label")
        }, labelOptions));
      }
      getGridLine() {
        let gridLineOptions = {
          fill: this.options.gridLineStroke,
          stroke: this.options.gridLineStroke
        };
        if (this.axisPosition === this.options.scale.range()[0]) {
          return;
        }
        if (this.options.orientation === Direction.DOWN) {
          Object.assign(gridLineOptions, {
            y2: -1 * this.options.chartOptions.height
          });
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(gridLineOptions, {
            x2: this.options.chartOptions.width
          });
        }
        return UI$1.createElement(SVG.Line, _extends({
          ref: this.refLink("gridLine")
        }, gridLineOptions));
      }
      getAxisLine() {
        let axisLineOptions = {};
        if (this.options.orientation === Direction.DOWN) {
          Object.assign(axisLineOptions, {
            y2: this.options.axisLineLength
          });
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(axisLineOptions, {
            x2: -1 * this.options.axisLineLength
          });
        }
        return UI$1.createElement(SVG.Line, _extends({
          ref: this.refLink("axisLine")
        }, axisLineOptions));
      }
      render() {
        this.axisPosition = this.options.scale(this.options.value);
        if (this.options.orientation === Direction.DOWN) {
          this.translate(this.axisPosition, 0);
        } else if (this.options.orientation === Direction.LEFT) {
          this.translate(0, this.axisPosition);
        }
        return [this.getGridLine(), this.getAxisLine(), this.getLabel()];
      }
      showGridLine() {
        if (this.axisPosition === this.options.scale.range()[0]) {
          this.gridLine.hide();
        } else {
          this.gridLine.show();
        }
      }
      hideGridLine() {
        this.gridLine.hide();
      }
    }
    class BasicAxis extends SVG.Group {
      getDefaultOptions() {
        return {
          labelFormatFunction: x => {
            return x;
          }
        };
      }
      getAxisLine() {
        let axisLineOptions = {};
        if (this.options.orientation === Direction.DOWN) {
          Object.assign(axisLineOptions, {
            x2: this.options.chartOptions.width
          });
          this.axisLength = this.options.chartOptions.width;
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(axisLineOptions, {
            y2: this.options.chartOptions.height
          });
          this.axisLength = this.options.chartOptions.height;
        }
        return UI$1.createElement(SVG.Line, _extends({
          ref: this.refLink("axisLine")
        }, axisLineOptions));
      }
      getTicks() {
        this.ticks = [];
        this.tickValues = this.options.scale.ticks(this.options.ticks);
        for (let i = 0; i < this.tickValues.length; i += 1) {
          let tickValue = this.tickValues[i];
          this.ticks[i] = UI$1.createElement(AxisTick, {
            ref: this.refLinkArray("ticks", i),
            chartOptions: this.options.chartOptions,
            scale: this.options.scale,
            orientation: this.options.orientation,
            value: tickValue,
            label: this.options.labelFormatFunction(tickValue)
          });
        }
        return this.ticks;
      }
      render() {
        if (this.options.orientation === Direction.DOWN) {
          this.translate(0, this.options.chartOptions.height);
        }
        return [...this.getTicks(), this.getAxisLine()];
      }
      showGridLines() {
        for (let tick of this.ticks) {
          tick.showGridLine();
        }
      }
      hideGridLines() {
        for (let tick of this.ticks) {
          tick.hideGridLine();
        }
      }
    }
    class BasicChart extends SVG.Group {
      getDefaultOptions() {
        return {
          enableZoom: true,
          margin: {
            top: 20,
            bottom: 30,
            left: 50,
            right: 20
          },
          domainPadding: [0],
          xAxisDomain: [0, 160],
          yAxisDomain: [0, 100],
          xAxisScaleType: "linear",
          yAxisScaleType: "linear",
          cursorStyle: "move"
        };
      }
      normalizePadding(padding) {
        if (!Array.isArray(padding)) {
          return null;
        }
        if (padding.length === 1) {
          return [padding[0], padding[0], padding[0], padding[0]];
        } else if (padding.length === 2) {
          return [padding[0], padding[1], padding[0], padding[1]];
        } else if (padding.length === 3) {
          return [padding[0], padding[1], padding[2], padding[1]];
        } else if (padding.length === 4) {
          return padding;
        } else {
          error("BasicChart.normalizePadding receives invalid padding array: ", padding);
          return null;
        }
      }
      getPaddedDomain(domain, padding) {
        let domainLength = domain[1] - domain[0];
        return [domain[0] - padding[0] * domainLength, domain[1] + padding[1] * domainLength];
      }
      getScaleType(type) {
        if (type === "linear") {
          return linear();
        } else if (type === "time") {
          return time$1();
        }
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.chartOptions.width -= this.options.margin.left + this.options.margin.right;
        this.options.chartOptions.height -= this.options.margin.top + this.options.margin.bottom;
        this.options.domainPadding = this.normalizePadding(this.options.domainPadding);
        this.options.xAxisDomain = this.getPaddedDomain(this.options.xAxisDomain, [this.options.domainPadding[3], this.options.domainPadding[1]]);
        this.options.yAxisDomain = this.getPaddedDomain(this.options.yAxisDomain, [this.options.domainPadding[2], this.options.domainPadding[0]]);
        this.xAxisOptions = {
          orientation: Direction.DOWN,
          ticks: 8,
          scale: this.getScaleType(this.options.xAxisScaleType).domain(this.options.xAxisDomain).range([0, this.options.chartOptions.width])
        };
        this._initialXScale = this.xAxisOptions.scale.copy();
        if (this.options.xAxisLabelFormatFunction) {
          this.xAxisOptions.labelFormatFunction = this.options.xAxisLabelFormatFunction;
        }
        this.yAxisOptions = {
          orientation: Direction.LEFT,
          ticks: 5,
          scale: this.getScaleType(this.options.yAxisScaleType).domain(this.options.yAxisDomain).range([this.options.chartOptions.height, 0])
        };
        this._initialYScale = this.yAxisOptions.scale.copy();
        if (this.options.yAxisLabelFormatFunction) {
          this.yAxisOptions.labelFormatFunction = this.options.yAxisLabelFormatFunction;
        }
      }
      getBackground() {
        return UI$1.createElement(SVG.Group, {
          ref: this.refLink("background")
        });
      }
      getAxes() {
        return [UI$1.createElement(BasicAxis, _extends({
          ref: this.refLink("xAxis"),
          chartOptions: this.options.chartOptions
        }, this.xAxisOptions)), UI$1.createElement(BasicAxis, _extends({
          ref: this.refLink("yAxis"),
          chartOptions: this.options.chartOptions
        }, this.yAxisOptions))];
      }
      render() {
        let interactiveLayer = UI$1.createElement(SVG.Rect, {
          ref: this.refLink("interactiveLayer"),
          height: this.options.chartOptions.height,
          width: this.options.chartOptions.width,
          style: {
            cursor: this.options.cursorStyle
          },
          opacity: 0
        });
        // Add a clipPath
        let clipPathDef = UI$1.createElement(SVG.Defs, {
          ref: "defs"
        }, UI$1.createElement(SVG.ClipPath, {
          id: "chartClipPath" + uniqueId(this)
        }, UI$1.createElement(SVG.Rect, {
          width: this.options.chartOptions.width,
          height: this.options.chartOptions.height
        })));
        this.clipPath = "url(#chartClipPath" + uniqueId(this) + ")";
        this.translate(this.options.margin.left, this.options.margin.right);
        return [this.getBackground(), ...this.getAxes(), interactiveLayer, ...super.render(), clipPathDef];
      }
      redraw() {
        this.options.children.forEach(child => {
          child.options.chart = this;
        });
        super.redraw();
      }
      initZoom() {
        this.options.applyZoom = true;
        let zoomNode = select(this.interactiveLayer.node);
        this.zoomListener = event => {
          if (this.options.applyZoom) {
            this.xAxisOptions.scale = event.transform.rescaleX(this._initialXScale);
            this.yAxisOptions.scale = event.transform.rescaleY(this._initialYScale);
            this.redraw();
            if (!event.sourceEvent) {
              // Custom zoom event
              this.interactiveLayer.node.__zoom = event.transform;
            }
          }
        };
        this.zoomBehavior = zoom().on("zoom", this.zoomListener);
        zoomNode.call(this.zoomBehavior);
      }
      disableZoom() {
        this.options.applyZoom = false;
      }
      onMount() {
        if (this.options.enableZoom) {
          this.initZoom();
        }
      }
      addZoomListener(func) {
        this.addListener("zoom", func);
      }
    }
    class TimeChart extends BasicChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          xAxisScaleType: "time",
          paddingXOnNoPoints: 1000 * 60 * 60 * 24 * 30 * 3,
          paddingYOnNoPoints: 50,
          zoomScaleExtent: [1, 20]
        });
      }
      getTimeFormat() {
        return unixTime => {
          let date = new StemDate(unixTime);
          var formatTypes = [{
            name: "Seconds",
            continueSubdivisionOnValue: 0,
            format: "HH:mm:ss"
          }, {
            name: "Minutes",
            continueSubdivisionOnValue: 0,
            format: "HH:mm"
          }, {
            name: "Hours",
            continueSubdivisionOnValue: 0,
            format: "HH:mm"
          }, {
            name: "Date",
            continueSubdivisionOnValue: 1,
            format: "DD/MMM"
          }, {
            name: "Month",
            continueSubdivisionOnValue: 0,
            format: "MMM"
          }];
          for (let i = 0; i < formatTypes.length; i += 1) {
            // TODO: this is a bit hacky, should be cleaner (maybe included in Date)
            let subdivisionValue = date["get" + formatTypes[i].name]();
            if (subdivisionValue !== formatTypes[i].continueSubdivisionOnValue) {
              return date.format(formatTypes[i].format);
            }
          }
          return date.format("YYYY");
        };
      }
      getMinMaxDomain(points, coordinateAlias, padding) {
        let domain = [coordinateAlias(points[0]), coordinateAlias(points[0])];
        points.forEach(point => {
          domain[0] = Math.min(domain[0], coordinateAlias(point));
          domain[1] = Math.max(domain[1], coordinateAlias(point));
        });
        if (domain[0] === domain[1]) {
          domain[0] -= padding;
          domain[1] += padding;
        }
        return domain;
      }
      defaultXNoPoints(padding = this.options.paddingXOnNoPoints) {
        return [+StemDate.now() - padding, +StemDate.now() + padding];
      }
      getXAxisDomain(points, coordinateAlias, padding = this.options.paddingXOnNoPoints) {
        if (!Array.isArray(points) || points.length === 0) {
          return this.defaultXNoPoints(padding);
        }
        return this.getMinMaxDomain(points, coordinateAlias, padding);
      }
      defaultYNoPoints(padding) {
        return [-padding, padding];
      }
      getYAxisDomain(points, coordinateAlias, padding = this.options.paddingYOnNoPoints) {
        if (!Array.isArray(points) || points.length === 0) {
          return this.defaultYNoPoints(padding);
        }
        return this.getMinMaxDomain(points, coordinateAlias, padding);
      }
      setOptions(options) {
        options.xAxisLabelFormatFunction = this.getTimeFormat();

        // TODO: This REALLY needs a refactoring.
        let paddingXOnNoPoints = options.paddingXOnNoPoints;
        if (paddingXOnNoPoints == null) {
          paddingXOnNoPoints = this.getDefaultOptions().paddingXOnNoPoints;
        }
        let paddingYOnNoPoints = options.paddingYOnNoPoints;
        if (paddingYOnNoPoints == null) {
          paddingYOnNoPoints = this.getDefaultOptions().paddingYOnNoPoints;
        }
        options.xAxisDomain = this.getXAxisDomain(options.plotOptions.pointsAlias(options.data), options.plotOptions.xCoordinateAlias, paddingXOnNoPoints);
        options.yAxisDomain = this.getYAxisDomain(options.plotOptions.pointsAlias(options.data), options.plotOptions.yCoordinateAlias, paddingYOnNoPoints);
        super.setOptions(options);
      }
      initZoom(infinite = false) {
        this.options.applyZoom = true;
        let zoomNode = select(this.interactiveLayer.node);
        this.zoomListener = event => {
          if (this.options.applyZoom) {
            let x = event.transform.x,
              y = event.transform.y,
              k = event.transform.k;
            event.transform.x = Math.min(0, Math.max(x, this.options.chartOptions.width * (1 - k)));
            event.transform.y = Math.min(0, Math.max(y, this.options.chartOptions.height * (1 - k)));
            this.xAxisOptions.scale = event.transform.rescaleX(this._initialXScale);
            this.yAxisOptions.scale = event.transform.rescaleY(this._initialYScale);
            this.redraw();
            this.interactiveLayer.node.__zoom = event.transform;
          }
        };
        this.zoomBehavior = zoom();
        if (!infinite) {
          this.zoomBehavior = this.zoomBehavior.scaleExtent(this.options.zoomScaleExtent);
        }
        this.zoomBehavior = this.zoomBehavior.on("zoom", this.zoomListener);
        zoomNode.call(this.zoomBehavior);

        // Simulate a center zoom
        let factor = 1.2;
        let centerZoom = {
          k: factor,
          x: this.options.chartOptions.width / 2 * (1 - factor),
          y: this.options.chartOptions.height / 2 * (1 - factor)
        };
        centerZoom.__proto__ = identity.__proto__;
        zoomNode.dispatch("zoom", {
          transform: centerZoom
        });
      }
    }
    class ChartSVG extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          height: options.height || 500,
          width: options.width || 790
        };
        this.plotOptions = {
          pointsAlias: data => {
            return data.points;
          },
          xCoordinateAlias: data => {
            return data.x;
          },
          yCoordinateAlias: data => {
            return data.y;
          }
        };
        this.data = {
          points: [{
            "x": 30,
            "y": 60,
            "label": "A"
          }, {
            "x": 100,
            "y": 55,
            "label": "C"
          }, {
            "x": 130,
            "y": 55,
            "label": "E"
          }, {
            "x": 115,
            "y": 20,
            "label": "D"
          }, {
            "x": 75,
            "y": 70,
            "label": "B"
          }]
        };

        // Benchmark - 400 points 26 FPS, 1000 points 13 FPS
        //this.data = {
        //    points: []
        //};
        //for (let i = 0; i <= 400; i += 1) {
        //    this.data.points.push({x: Math.random() * 200, y: Math.random() * 100});
        //}
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("height", this.chartOptions.height);
        attr.setAttribute("width", this.chartOptions.width);
        return attr;
      }
      render() {
        return [UI$1.createElement(BasicChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain
        }, UI$1.createElement(LinePlot, {
          plotOptions: this.plotOptions,
          data: this.data
        }), UI$1.createElement(BasePointPlot, {
          plotOptions: this.plotOptions,
          data: this.data
        }))];
      }
    }

    const SINGLE_CLICK_EVENT = "SingleClick";
    const DOUBLE_CLICK_EVENT = "DoubleClick";
    const DoubleClickable = BaseClass => class DoubleClickable extends BaseClass {
      constructor(...args) {
        super(...args);
        this.uniqueClickListener = null;
        this.singleClickTimeout = null;
        this.singleClickedAt = null;
      }
      clearSingleClickTimeout() {
        clearTimeout(this.singleClickTimeout);
        this.singleClickTimeout = null;
        this.singleClickedAt = null;
      }
      ensureClickListener() {
        this.uniqueClickListener = this.uniqueClickListener || super.addClickListener((...args) => {
          const haveDoubleClickListeners = this.getDispatcher(DOUBLE_CLICK_EVENT, false)?.listeners?.length > 0;
          const doubleClickTimeout = haveDoubleClickListeners ? this.options.doubleClickTimeout || 250 : 0;
          const currentTime = Date.now();
          if (this.singleClickTimeout && currentTime - this.singleClickedAt < doubleClickTimeout) {
            this.clearSingleClickTimeout();
            this.dispatch(DOUBLE_CLICK_EVENT, ...args);
            return;
          }
          this.clearSingleClickTimeout(); // Could it actually happen that a timeout would have remained unexecuted?

          this.singleClickedAt = Date.now();
          this.singleClickTimeout = setTimeout(() => {
            this.clearSingleClickTimeout();
            this.dispatch(SINGLE_CLICK_EVENT, ...args);
          }, doubleClickTimeout);
        });
      }
      addClickListener(callback) {
        this.ensureClickListener();
        return this.addListener(SINGLE_CLICK_EVENT, callback);
      }
      removeClickListener(callback) {
        this.removeListener(SINGLE_CLICK_EVENT, callback);
      }
      addDoubleClickListener(callback) {
        this.addListener(DOUBLE_CLICK_EVENT, callback);
      }
      removeDoubleClickListener(callback) {
        this.removeListener(DOUBLE_CLICK_EVENT, callback);
      }
    };

    function formatCoord(value, scale, decimals = -1) {
      let size = Math.abs(scale.domain()[0] - scale.domain()[1]);
      //not very ethic way of doing this, but it should work fine...
      if (decimals === -1) {
        //default
        let d = 0;
        if (size > 1000) {
          d = 0;
        } else if (size > 1) {
          let exp = 0,
            pwr = 1;
          while (pwr < size) {
            exp += 1;
            pwr *= 10;
          }
          d = 4 - exp;
        } else {
          let exp = 0,
            pwr = 1;
          while (pwr * 0.1 > size) {
            exp += 1;
            pwr *= 0.1;
          }
          d = 3 + exp;
        }
        value = "" + value.toFixed(d);
      } else {
        value = "" + value.toFixed(decimals);
      }
      while (value.indexOf(".") !== -1 && value.endsWith('0')) {
        value = value.slice(0, value.length - 1);
      }
      if (value.endsWith('.')) {
        value = value.slice(0, value.length - 1);
      }
      return value;
    }
    function scaleCoord(scale, dataCoord) {
      let d = scale.domain();
      let r = scale.range();
      return r[0] + (r[1] - r[0]) * (dataCoord - d[0]) / (d[1] - d[0]);
    }
    function getLineAndSegmIntersection(a, b, c, x1, y1, x2, y2) {
      if (x1 === x2) {
        if (Math.abs(b) < 0.000001) {
          return undefined;
        }
        let y = -(a * x1 + c) / b;
        if (Math.min(y1, y2) > y || Math.max(y1, y2) < y) {
          return undefined;
        }
        return {
          x: x1,
          y: y
        };
      }
      if (Math.abs(a) < 0.000001) {
        return undefined;
      }
      let x = -(b * y1 + c) / a;
      if (Math.min(x1, x2) > x || Math.max(x1, x2) < x) {
        return undefined;
      }
      return {
        x: x,
        y: y1
      };
    }
    function getLineAndRectIntersection(a, b, c, rectX, rectY) {
      let p1 = getLineAndSegmIntersection(a, b, c, rectX[0], rectY[0], rectX[0], rectY[1]);
      let p2 = getLineAndSegmIntersection(a, b, c, rectX[1], rectY[0], rectX[1], rectY[1]);
      let p3 = getLineAndSegmIntersection(a, b, c, rectX[0], rectY[0], rectX[1], rectY[0]);
      let p4 = getLineAndSegmIntersection(a, b, c, rectX[0], rectY[1], rectX[1], rectY[1]);
      if (p1) {
        if (p2) {
          return [p1.x, p1.y, p2.x, p2.y];
        }
        if (p3) {
          return [p1.x, p1.y, p3.x, p3.y];
        }
        if (p4) {
          return [p1.x, p1.y, p4.x, p4.y];
        }
        return [p1.x, p1.y, p1.x, p1.y];
      }
      if (p2) {
        if (p3) {
          return [p2.x, p2.y, p3.x, p3.y];
        }
        if (p4) {
          return [p2.x, p2.y, p4.x, p4.y];
        }
        return [p2.x, p2.y, p2.x, p2.y];
      }
      if (p3) {
        if (p4) {
          return [p3.x, p3.y, p4.x, p4.y];
        }
        return [p3.x, p3.y, p3.x, p3.y];
      }
      if (p4) {
        return [p4.x, p4.y, p4.x, p4.y];
      }
      return [0, 0, 0, 0];
    }
    let InvisibleCircleClass = DoubleClickable(Draggable(SVG.Circle));
    class DraggablePointWithCoords extends SVG.Group {
      setOptions(options) {
        super.setOptions(options);
        this.options.center = {};
        this.options.center.x = this.options.data.x / this.getXScale();
        this.options.center.y = this.options.data.y / this.getYScale();
        this.options.color = this.options.data.color || this.options.color || "black";
      }
      getXScale() {
        let scale = this.options.chart.xAxisOptions.scale;
        return Math.abs(scale.domain()[1] - scale.domain()[0]) / Math.abs(scale.range()[1] - scale.range()[0]);
      }
      getYScale() {
        let scale = this.options.chart.yAxisOptions.scale;
        return Math.abs(scale.domain()[1] - scale.domain()[0]) / Math.abs(scale.range()[1] - scale.range()[0]);
      }
      formatCoords() {
        let x = this.options.data.x;
        let y = this.options.data.y;
        let decimals = -1;
        if (this.options.widget) {
          decimals = this.options.widget.decimals;
        }
        x = formatCoord(x, this.options.chart.xAxisOptions.scale, decimals);
        y = formatCoord(y, this.options.chart.yAxisOptions.scale, decimals);
        return (this.options.label ? this.options.data.label : "") + (this.options.coords ? "(" + x + "," + y + ")" : "");
      }
      render() {
        return [UI$1.createElement(SVG.Circle, {
          ref: "realPoint",
          radius: "5",
          fill: this.options.color,
          parent: this,
          style: {
            cursor: "move"
          },
          center: this.options.center
        }), UI$1.createElement(SVG.Text, {
          ref: "coords",
          textAnchor: "left",
          x: this.options.center.x + 4,
          y: this.options.center.y + 10,
          style: {
            "-webkit-user-select": "none"
          },
          text: this.formatCoords()
        }), UI$1.createElement(SVG.Line, {
          ref: "lineDown",
          x1: this.options.center.x,
          y1: this.options.center.y,
          strokeWidth: 1,
          strokeDasharray: "3,3",
          stroke: "grey",
          fill: "grey",
          x2: this.options.center.x,
          y2: this.options.chart.yAxisOptions.scale.range()[0]
        }), UI$1.createElement(SVG.Line, {
          ref: "lineLeft",
          x1: this.options.center.x,
          y1: this.options.center.y,
          strokeWidth: 1,
          strokeDasharray: "3,3",
          stroke: "grey",
          fill: "grey",
          x2: this.options.chart.xAxisOptions.scale.range()[0],
          y2: this.options.center.y
        }),
        //the circle we actually use for drags and clicks
        UI$1.createElement(InvisibleCircleClass, {
          ref: "point",
          opacity: "0",
          fill: "transparent",
          radius: "15",
          style: {
            cursor: "move"
          },
          parent: this,
          stroke: "red",
          strokeWidth: "2",
          center: this.options.center,
          editable: this.options.editable
        })];
      }
      onMount() {
        this.point.addNodeListener("mouseover", () => {
          this.point.setOpacity(1);
        });
        this.point.addNodeListener("mouseout", () => {
          this.point.setOpacity(0);
        });
        this.realPoint.addNodeListener("mouseover", () => {
          this.point.setOpacity(1);
        });
        this.realPoint.addNodeListener("mouseout", () => {
          this.point.setOpacity(0);
        });
        this.addClickListener(event => {
          this.clickFunc();
          event.stopPropagation();
          event.preventDefault();
        });
        if (this.options.editable) {
          this.dragFunc = {
            onStart: () => {
              this.dragging = true;
              this.prevCoords = this.options.coords;
            },
            onDrag: (deltaX, deltaY) => {
              this.showCoords(false);
              this.dragged = true;
              this.options.data.x += deltaX * this.getXScale();
              this.options.data.y -= deltaY * this.getYScale();
              this.options.center.x += deltaX;
              this.options.center.y -= deltaY;
              if (this.hasPopup) {
                this.popup.hide();
                this.hasPopup = false;
              }
              this.redraw();
            },
            onEnd: () => {
              if (this.dragging && this.dragged) {
                this.options.coords = this.prevCoords;
                let decimals = -1;
                if (this.options.widget && this.options.widget.hasOwnProperty("decimals")) {
                  decimals = this.options.widget.decimals;
                }
                this.options.data.x = parseFloat(formatCoord(this.options.data.x, this.options.chart.xAxisOptions.scale, decimals));
                this.options.data.y = parseFloat(formatCoord(this.options.data.y, this.options.chart.yAxisOptions.scale, decimals));
                this.redraw();
                this.dispatch("dataChanged");
                this.hasPopup = true;
                this.dragged = false;
                setTimeout(() => {
                  this.hasPopup = false;
                }, 0);
              }
              this.dragging = false;
            }
          };
          this.point.addDragListener(this.dragFunc);
        }
      }
      redraw() {
        this.options.center = {
          x: scaleCoord(this.options.chart.xAxisOptions.scale, this.options.data.x),
          y: scaleCoord(this.options.chart.yAxisOptions.scale, this.options.data.y)
        };
        if (this.coords) {
          this.coords.options.text = this.formatCoords();
        }
        super.redraw();
        if (!this.options.coords && !this.options.label) {
          this.node.removeChild(this.coords.node);
        }
        if (!this.options.OxParallel) {
          this.node.removeChild(this.lineLeft.node);
        }
        if (!this.options.OyParallel) {
          this.node.removeChild(this.lineDown.node);
        }
        if (this.hasPopup) {
          if (this.popup.isInDocument()) {
            this.popup.setCenter(this.getPopupPosition());
          }
          if (!this.isPopupVisible()) {
            this.popup.hide();
          }
        }
      }
      showCoords(prev = true) {
        if (!this.options.coords) {
          this.options.coords = true;
          if (prev) {
            this.prevCoords = true;
          }
          this.redraw();
        }
      }
      hideCoords(prev = true) {
        if (this.options.coords) {
          this.options.coords = false;
          if (prev) {
            this.prevCoords = false;
          }
          this.redraw();
        }
      }
      showLabel() {
        if (!this.options.label) {
          this.options.label = true;
          this.redraw();
        }
      }
      hideLabel() {
        if (this.options.label) {
          this.options.label = false;
          this.redraw();
        }
      }
      showOxParallel() {
        if (!this.options.OxParallel) {
          this.options.OxParallel = true;
          this.redraw();
        }
      }
      hideOxParallel() {
        if (this.options.OxParallel) {
          this.options.OxParallel = false;
          this.redraw();
        }
      }
      showOyParallel() {
        if (!this.options.OyParallel) {
          this.options.OyParallel = true;
          this.redraw();
        }
      }
      hideOyParallel() {
        if (this.options.OyParallel) {
          this.options.OyParallel = false;
          this.redraw();
        }
      }
      changeLabelFunc() {
        this.popup.setTitle(UI$1.createElement(TextInput, {
          ref: this.refLink("inputLabel"),
          value: this.options.data.label,
          style: {
            width: "60px"
          }
        }));
        this.inputLabel.node.focus();
        this.inputLabel.node.select();
        let func = () => {
          this.options.data.label = this.inputLabel.getValue().trim();
          this.dispatch("dataChanged");
          this.popup.setTitle(this.getPopupTitle());
          this.changeLabel.addClickListener(event => {
            event.stopPropagation();
            this.changeLabelFunc();
          });
          if (this.coords) {
            this.coords.options.text = this.formatCoords();
            this.coords.redraw();
          }
          if (!Device.supportsEvent("click")) {
            window.removeEventListener("touchstart", func);
          } else {
            window.removeEventListener("click", func);
          }
          this.popup.removeClickListener(func);
        };
        this.inputLabel.node.addEventListener("keypress", event => {
          let key = event.which || event.keyCode;
          if (key === 13) {
            // 13 is enter
            func();
          }
        });
        if (!Device.supportsEvent("click")) {
          window.addEventListener("touchstart", func);
        } else {
          window.addEventListener("click", func);
        }
        this.inputLabel.addClickListener(event => {
          event.stopPropagation();
        });
        ///a timeout is needed in order to actually change the current state of the title,
        ///otherwise the click on the edit button itself will trigger, changing it back
        setTimeout(() => {
          this.popup.addClickListener(func);
        }, 0);
      }
      clickFunc(changeLabel = false) {
        if (this.hasPopup) {
          if (this.popup) {
            this.popup.hide();
          }
          this.hasPopup = false;
        } else {
          if (!this.dragged) {
            this.popup = Popup.create(document.body, Object.assign({
              title: this.getPopupTitle(),
              children: this.getPopupContent(),
              transitionTime: 300,
              titleFontSize: "9pt",
              contentFontSize: "9pt",
              style: {
                maxWidth: "270px"
              }
            }, this.getPopupPosition()));
            this.seeCoordsButton.addClickListener(() => {
              if (this.seeCoordsButton.getValue()) {
                this.showCoords();
              } else {
                this.hideCoords();
              }
            });
            this.seeLabelButton.addClickListener(() => {
              if (this.seeLabelButton.getValue()) {
                this.showLabel();
              } else {
                this.hideLabel();
              }
            });
            this.seeOxButton.addClickListener(() => {
              if (this.seeOxButton.getValue()) {
                this.showOxParallel();
              } else {
                this.hideOxParallel();
              }
            });
            this.seeOyButton.addClickListener(() => {
              if (this.seeOyButton.getValue()) {
                this.showOyParallel();
              } else {
                this.hideOyParallel();
              }
            });
            this.changeLabel.addClickListener(() => {
              this.changeLabelFunc();
            });
            this.hasPopup = true;
            if (changeLabel) {
              this.changeLabelFunc();
              this.inputLabel.node.focus();
              this.inputLabel.node.select();
            }
          }
        }
      }
      getPopupTitle() {
        let decimals = -1;
        if (this.options.widget) {
          decimals = this.options.widget.decimals || -1;
        }
        return [this.options.data.label + " (" + formatCoord(this.options.data.x, this.options.chart.xAxisOptions.scale, decimals) + ", " + formatCoord(this.options.data.y, this.options.chart.yAxisOptions.scale, decimals) + ")", UI$1.createElement("div", {
          ref: this.refLink("changeLabel"),
          className: "pull-right",
          style: {
            marginRight: "4px",
            marginLeft: "4px"
          }
        }, UI$1.createElement("i", {
          className: "fa fa-pencil-square-o",
          "aria-hidden": "true",
          style: {
            cursor: "pointer"
          }
        }))];
      }
      getPopupContent() {
        return [UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          label: "Coordinates",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI$1.createElement(RawCheckboxInput, {
          ref: this.refLink("seeCoordsButton"),
          initialValue: this.options.coords
        })), UI$1.createElement(FormField, {
          label: "Point Label",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI$1.createElement(RawCheckboxInput, {
          ref: this.refLink("seeLabelButton"),
          initialValue: this.options.label
        })), UI$1.createElement(FormField, {
          label: "Parallel to Ox",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI$1.createElement(RawCheckboxInput, {
          ref: this.refLink("seeOxButton"),
          initialValue: this.options.OxParallel
        })), UI$1.createElement(FormField, {
          label: "Parallel to Oy",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI$1.createElement(RawCheckboxInput, {
          ref: this.refLink("seeOyButton"),
          initialValue: this.options.OyParallel
        })))];
      }
      getPopupPosition() {
        let boundingRect = this.point.getBoundingClientRect();
        return {
          x: boundingRect.left + boundingRect.width / 2,
          y: boundingRect.bottom - boundingRect.height * 0.1
        };
      }
      isPopupVisible() {
        let chartBoundingRect = this.parent.options.chart.interactiveLayer.getBoundingClientRect();
        let popupPosition = this.getPopupPosition();
        return chartBoundingRect.left <= popupPosition.x && popupPosition.x <= chartBoundingRect.right && chartBoundingRect.top <= popupPosition.y && popupPosition.y <= chartBoundingRect.bottom;
      }
    }
    class GeometryLine extends SVG.Line {
      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        let intersection = getLineAndRectIntersection(this.options.data.a, this.options.data.b, this.options.data.c, xScale.domain(), yScale.domain());
        this.options.x1 = scaleCoord(xScale, intersection[0]);
        this.options.y1 = scaleCoord(yScale, intersection[1]);
        this.options.x2 = scaleCoord(xScale, intersection[2]);
        this.options.y2 = scaleCoord(yScale, intersection[3]);
        super.redraw();
      }
    }
    class GeometrySegment extends SVG.Line {
      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        this.options.x1 = scaleCoord(xScale, this.options.data.x1);
        this.options.y1 = scaleCoord(yScale, this.options.data.y1);
        this.options.x2 = scaleCoord(xScale, this.options.data.x2);
        this.options.y2 = scaleCoord(yScale, this.options.data.y2);
        super.redraw();
      }
    }
    class GeometryPolygon extends SVG.Group {
      render() {
        let segments = [];
        for (let i = 1; i < this.points.length; i += 1) {
          segments.push(UI$1.createElement(SVG.Line, {
            x1: this.points[i - 1].x,
            y1: this.points[i - 1].y,
            x2: this.points[i].x,
            y2: this.points[i].y
          }));
        }
        segments.push(UI$1.createElement(SVG.Line, {
          x1: this.points[this.points.length - 1].x,
          y1: this.points[this.points.length - 1].y,
          x2: this.points[0].x,
          y2: this.points[0].y
        }));
        return segments;
      }
      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        this.points = this.points || [];
        this.points.splice(0, this.points.length);
        for (let i = 0; i < this.options.data.length; i += 1) {
          this.points.push({
            x: scaleCoord(xScale, this.options.data[i].x),
            y: scaleCoord(yScale, this.options.data[i].y)
          });
        }
        super.redraw();
      }
    }
    class GeometryCircle extends SVG.Circle {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          fill: "none",
          stroke: "black"
        });
      }
      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        this.options.center.x = scaleCoord(xScale, this.options.data.x);
        this.options.center.y = scaleCoord(yScale, this.options.data.y);
        let range = Math.abs(yScale.range()[1] - yScale.range()[0]);
        let domain = Math.abs(yScale.domain()[1] - yScale.domain()[0]);
        this.options.radius = this.options.data.r * range / domain;
        super.redraw();
      }
    }

    var _class$16, _descriptor$x;

    // TODO WTF why is this called this?
    let DropdownListStyle = (_class$16 = class DropdownListStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "default", _descriptor$x, this);
      }
    }, (_descriptor$x = _applyDecoratedDescriptor(_class$16.prototype, "default", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            padding: "7px",
            cursor: "pointer",
            backgroundColor: "#eeeeee",
            width: "100%",
            ":hover": {
              backgroundColor: "#dddddd"
            }
          }
        };
      }
    })), _class$16);

    const dropdownList = DropdownListStyle.getInstance();
    const defaultData = {
      points: [{
        "x": 30,
        "y": 60,
        "label": "A"
      }, {
        "x": 100,
        "y": 55,
        "label": "C"
      }, {
        "x": 130,
        "y": 55,
        "label": "E"
      }, {
        "x": 115,
        "y": 20,
        "label": "D"
      }, {
        "x": 75,
        "y": 70,
        "label": "B"
      }],
      lines: [{
        a: 1,
        b: 1,
        c: 0
      }],
      segments: [{
        "x1": 5,
        "y1": 7,
        "x2": 15,
        y2: 20
      }],
      circles: [{
        "x": 25,
        "y": 25,
        "r": 15
      }],
      polygons: [[{
        "x": 25,
        "y": 25
      }, {
        "x": 40,
        "y": 40
      }, {
        "x": 40,
        "y": 0
      }]]
    };
    const decimalOptions = [{
      value: -1,
      toString: function toString() {
        return "Auto";
      }
    }, {
      value: 0,
      toString: function toString() {
        return "None";
      }
    }, {
      value: 1,
      toString: function toString() {
        return "One";
      }
    }, {
      value: 2,
      toString: function toString() {
        return "Two";
      }
    }, {
      value: 3,
      toString: function toString() {
        return "Three";
      }
    }, {
      value: 4,
      toString: function toString() {
        return "Four";
      }
    }, {
      value: 5,
      toString: function toString() {
        return "Five";
      }
    }, {
      value: 6,
      toString: function toString() {
        return "Six";
      }
    }];
    const objects = ["point", "segment", "line", "circle", "polygon"];
    const objectClasses = [DraggablePointWithCoords, GeometrySegment, GeometryLine, GeometryCircle, GeometryPolygon];
    class Stringifier {
      static c(value) {
        return formatCoord(parseFloat(value), this.scale, this.decimals);
      }
      static point(point) {
        let text = this.c(point.x) + " " + this.c(point.y);
        if (point.label) {
          text += " " + point.label;
        }
        return text + "\n";
      }
      static line(line) {
        return "Line " + this.c(line.a) + " " + this.c(line.b) + " " + this.c(line.c) + "\n";
      }
      static segment(segment) {
        return "Segment " + this.c(segment.x1) + " " + this.c(segment.y1) + " " + this.c(segment.x2) + " " + this.c(segment.y2) + "\n";
      }
      static circle(circle) {
        return "Circle " + this.c(circle.x) + " " + this.c(circle.y) + " " + this.c(circle.r) + "\n";
      }
      static polygon(polygon) {
        let text = "Polygon\n";
        for (let point of polygon) {
          text += this.c(point.x) + " " + this.c(point.y) + "\n";
        }
        text += "...\n";
        return text;
      }
    }
    Stringifier.decimals = -1;
    Stringifier.scale = {
      domain: () => {
        return [0, 160];
      }
    };
    function getGeometryText(data) {
      let text = "";
      for (let i = 0; i < objects.length; i += 1) {
        for (let obj of data[objects[i] + "s"] || []) {
          text += Stringifier[objects[i]](obj);
        }
      }
      return text;
    }
    function Plot(BaseClass, className) {
      class ClassPlot extends SVG.Group {
        getNodeAttributes() {
          let attr = super.getNodeAttributes();
          attr.setAttribute("clip-path", this.options.chart.clipPath);
          return attr;
        }
        render() {
          this[className + "s"] = [];
          for (let i = 0; i < this.options.data[className + "s"].length; i += 1) {
            this[className + "s"][i] = UI$1.createElement(BaseClass, {
              ref: this.refLinkArray(className + "s", i),
              data: this.options.data[className + "s"][i],
              coords: false,
              label: true,
              chart: this.options.chart,
              widget: this.options.widget,
              editable: this.options.editable
            });
          }
          return this[className + "s"];
        }
        redraw() {
          if (!this[className + "s"]) {
            super.redraw();
          } else {
            for (let element of this[className + "s"]) {
              element.redraw();
            }
          }
        }
        onMount() {
          this.options.chart.addZoomListener(() => {
            this.redraw();
          });
        }
        remove(element) {
          let newElements = [];
          for (let i = 0; i < this[className + "s"].length; i += 1) {
            if (this[className + "s"][i] !== element) {
              newElements.push(this[className + "s"][i]);
            }
          }
          delete this[className + "s"];
          this[className + "s"] = newElements;
          element.destroyNode();
        }
      }
      return ClassPlot;
    }
    let PlotClasses = [];
    for (let i = 0; i < objects.length; i += 1) {
      PlotClasses.push(Plot(objectClasses[i], objects[i]));
    }
    class CSAGeometryWidgetSVG extends ChartSVG {
      getDefaultOptions() {
        return {
          editable: false,
          points: defaultData.points,
          lines: defaultData.lines,
          segments: defaultData.segments,
          circles: defaultData.circles,
          polygons: defaultData.polygons,
          xDomain: [0, 160],
          yDomain: [0, 100],
          width: 320,
          height: 200
        };
      }
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          width: this.options.width + 70,
          height: this.options.height + 50
        };
        this.options.data = {};
        for (let objectName of objects) {
          this.options[objectName + "s"] = options[objectName + "s"] || this.options[objectName + "s"];
          this.options.data[objectName + "s"] = this.options[objectName + "s"];
        }
      }
      render() {
        let plots = [];
        for (let i = 0; i < objects.length; i += 1) {
          let PlotClass = PlotClasses[i];
          plots.push(UI$1.createElement(PlotClass, {
            editable: this.options.editable,
            ref: this.refLink(objects[i] + "Plot"),
            data: this.options.data,
            widget: this.options.widget
          }));
        }
        return [UI$1.createElement(BasicChart, {
          ref: this.refLink("chart"),
          cursorStyle: "pointer",
          chartOptions: Object.assign({}, this.chartOptions),
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain
        }, plots)];
      }
      getCoords() {
        let xMin = Infinity,
          xMax = -Infinity,
          yMin = Infinity,
          yMax = -Infinity;
        let ok = false;
        let update = (x, y) => {
          ok = true;
          xMin = Math.min(xMin, x);
          yMin = Math.min(yMin, y);
          xMax = Math.max(xMax, x);
          yMax = Math.max(yMax, y);
        };
        for (let point of this.pointPlot.points) {
          update(point.options.data.x, point.options.data.y);
        }
        for (let segm of this.segmentPlot.segments) {
          update(segm.options.data.x1, segm.options.data.y1);
          update(segm.options.data.x2, segm.options.data.y2);
        }
        for (let circle of this.circlePlot.circles) {
          update(circle.options.data.x - circle.options.data.r, circle.options.data.y - circle.options.data.r);
          update(circle.options.data.x + circle.options.data.r, circle.options.data.y + circle.options.data.r);
        }
        for (let polygon of this.polygonPlot.polygons) {
          for (let point of polygon.options.data) {
            update(point.x, point.y);
          }
        }
        if (!ok) {
          return null;
        }
        let diffX = xMax - xMin,
          diffY = yMax - yMin;
        if (Math.abs(diffX) < 0.001 && Math.abs(diffY) <= 0.001) {
          xMin -= 0.1;
          xMax += 0.1;
          yMin -= 0.1;
          yMax += 0.1;
        } else if (Math.abs(diffX) < 0.001) {
          xMin -= 0.25 * diffY;
          xMax += 0.25 * diffY;
        } else if (Math.abs(diffY) < 0.001) {
          yMin -= 0.25 * diffX;
          yMax += 0.25 * diffX;
        }
        xMin = xMin - 0.25 * diffX;
        xMax = xMax + 0.25 * diffX;
        yMin = yMin - 0.25 * diffY;
        yMax = yMax + 0.25 * diffY;
        let chart = this.chart;
        let rangeX = Math.abs(chart.xAxisOptions.scale.range()[0] - chart.xAxisOptions.scale.range()[1]);
        let rangeY = Math.abs(chart.yAxisOptions.scale.range()[0] - chart.yAxisOptions.scale.range()[1]);
        if ((xMax - xMin) / (yMax - yMin) < rangeX / rangeY) {
          diffX = rangeX / rangeY * (yMax - yMin);
          let midX = (xMin + xMax) * 0.5;
          xMin = midX - diffX / 2;
          xMax = midX + diffX / 2;
        } else {
          diffY = rangeY / rangeX * (xMax - xMin);
          let midY = (yMin + yMax) * 0.5;
          yMin = midY - diffY / 2;
          yMax = midY + diffY / 2;
        }
        return [xMin, xMax, yMin, yMax];
      }
      setDomain(x1, x2, y1, y2) {
        let chart = this.chart;
        chart.options.xAxisDomain = chart.getPaddedDomain([x1, x2], [chart.options.domainPadding[3], chart.options.domainPadding[1]]);
        chart.options.yAxisDomain = chart.getPaddedDomain([y1, y2], [chart.options.domainPadding[2], chart.options.domainPadding[0]]);
        chart.xAxisOptions.scale = linear().domain(chart.options.xAxisDomain).range([0, chart.options.chartOptions.width]);
        chart.yAxisOptions.scale = linear().domain(chart.options.yAxisDomain).range([chart.options.chartOptions.height, 0]);
        chart._initialXScale = chart.xAxisOptions.scale.copy();
        chart._initialYScale = chart.yAxisOptions.scale.copy();
        chart.redraw();
        chart.interactiveLayer.node.__zoom = identity;
      }
      onMount() {
        this.addListener("centerPoints", () => {
          let coords = this.getCoords();
          if (!coords) {
            this.setDomain(0, 160, 0, 100);
          } else {
            this.setDomain(coords[0], coords[1], coords[2], coords[3]);
          }
        });
        for (let i = 0; i < objects.length; i += 1) {
          this.addListener("add" + objects[i][0].toUpperCase() + objects[i].slice(1, objects[i].length), options => {
            let Class = objectClasses[i];
            let object = UI$1.createElement(Class, _extends({}, options, {
              chart: this.chart,
              widget: this.options.widget,
              editable: true
            }));
            this[objects[i] + "Plot"][objects[i] + "s"].push(object);
            object.mount(this[objects[i] + "Plot"]);
            options[objects[i]] = object;
          });
        }
        this.addListener("resize", (height, width) => {
          this.chartOptions = {
            width: width + 70,
            height: height + 50
          };
          this.redraw();
          this.chart.initZoom();
          this.dispatch("centerPoints");
        });
        this.addListener("inputProvided", data => {
          let options = {};
          this.dispatch("needPointOptions", options);
          for (let i = 0; i < objects.length; i += 1) {
            let Class = objectClasses[i];
            let object = objects[i];
            let newObjects = data[object + "s"] || [];
            let oldObjects = this[object + "Plot"][object + "s"];
            for (let j = 0; j < Math.min(newObjects.length, oldObjects.length); j += 1) {
              oldObjects[j].options.data = newObjects[j];
              oldObjects[j].redraw();
            }
            while (newObjects.length < oldObjects.length) {
              this[object + "Plot"].remove(oldObjects[oldObjects.length - 1]);
              oldObjects.pop();
            }
            for (let j = oldObjects.length; j < newObjects.length; j += 1) {
              let newObject = UI$1.createElement(Class, {
                data: newObjects[j],
                chart: this.chart,
                widget: this.options.widget,
                editable: this.options.editable
              });
              if (object === "point") {
                Object.assign(newObject.options, options);
              }
              oldObjects.push(newObject);
              newObject.mount(this[object + "Plot"]);
            }
          }
        });
        this.addListener("updateDomain", event => {
          if (event.xDomain) {
            this.options.xDomain = event.xDomain;
          }
          if (event.yDomain) {
            this.options.yDomain = event.yDomain;
          }
          this.setDomain(this.options.xDomain[0], this.options.xDomain[1], this.options.yDomain[0], this.options.yDomain[1]);
        });
      }
    }
    class GeometryWidgetLegend extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("position", "relative");
      }
      render() {
        return [UI$1.createElement("div", {
          className: "hidden",
          ref: "settings",
          style: {
            position: "absolute",
            zIndex: "2016",
            right: "80px",
            top: "40px",
            boxShadow: "0 5px 15px rgba(0,0,0,.5)",
            backgroundColor: "#fff",
            padding: "5px",
            width: "200px"
          }
        }, UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          label: "Decimals"
        }, UI$1.createElement(Select, {
          options: decimalOptions,
          ref: "decimalsSelect"
        })), UI$1.createElement(FormField, {
          label: "Coordinates",
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "seeCoords"
        })), UI$1.createElement(FormField, {
          label: "Point Labels",
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "seeLabels"
        })), UI$1.createElement(FormField, {
          label: "Ox parallels",
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "seeOxParallels"
        })), UI$1.createElement(FormField, {
          label: "Oy parallels",
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "seeOyParallels"
        })))), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          size: Size.SMALL,
          level: Level.INFO,
          label: UI$1.T("View All"),
          icon: "eye",
          ref: "viewAllButton",
          style: {
            display: "inline",
            marginTop: "10px"
          }
        }), UI$1.createElement(Button$1, {
          size: Size.SMALL,
          level: Level.INFO,
          label: UI$1.T("Settings"),
          icon: "bars",
          ref: "settingsButton",
          style: {
            display: "inline",
            marginTop: "10px"
          }
        })), UI$1.createElement("div", {
          style: {
            height: "500px",
            "overflow-y": "scroll"
          }
        }, UI$1.createElement("h4", null, "Geometry Widget"), UI$1.createElement("p", null, "Using this tool, you can easily manipulate a plane and any objects on it, like points, segments, circles, polygons and so on. You can use the export button to generate a mark-up tag that renders a copy of your plane anywhere on our website like in chats, comments or articles. The left-side text panel and the middle graphic panel are kept in sync at all times, so you can input any set of objects to draw them, or draw using the panel and then take the text version on the left."), UI$1.createElement("p", null, "Ways you can interact with the widget:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, "Points support drag and drop."), UI$1.createElement("li", null, "You can toggle certain options for all points, or by clicking on a point you can display a menu, for that point's individual settings."), UI$1.createElement("li", null, "Any point can be given a label, and it's label and coordinates can be manually changed from the same menu as above.")))];
      }
      getPointOptions() {
        return {
          coords: this.seeCoords.getValue(),
          label: this.seeLabels.getValue(),
          OxParallel: this.seeOxParallels.getValue(),
          OyParallel: this.seeOyParallels.getValue()
        };
      }
      onMount() {
        let hideSettingsTab = () => {
          this.settings.addClass("hidden");
          document.body.removeEventListener("click", hideSettingsTab);
        };
        this.settingsButton.addClickListener(event => {
          if (this.settings.hasClass("hidden")) {
            this.settings.removeClass("hidden");
            document.body.addEventListener("click", hideSettingsTab);
          } else {
            hideSettingsTab();
          }
          event.stopPropagation();
        });
        this.settings.addClickListener(event => {
          event.stopPropagation();
        });
        this.seeCoords.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeCoords.getValue() ? point.showCoords() : point.hideCoords();
          }
          event.stopPropagation();
        });
        this.seeLabels.setValue(true);
        this.seeLabels.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeLabels.getValue() ? point.showLabel() : point.hideLabel();
          }
          event.stopPropagation();
        });
        this.seeOxParallels.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeOxParallels.getValue() ? point.showOxParallel() : point.hideOxParallel();
          }
          event.stopPropagation();
        });
        this.seeOyParallels.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeOyParallels.getValue() ? point.showOyParallel() : point.hideOyParallel();
          }
          event.stopPropagation();
        });
        this.addListener("needPointOptions", options => {
          Object.assign(options, this.getPointOptions());
        });
        this.decimalsSelect.addChangeListener(() => {
          Stringifier.decimals = this.decimalsSelect.get().value;
          this.options.widget.dispatch("decimalsChange", this.decimalsSelect.get().value);
        });
        this.viewAllButton.addClickListener(() => {
          this.options.svg.dispatch("centerPoints");
        });
      }
    }
    class GeometryCodeEditor extends CodeEditor {
      static getPoint(tokens) {
        if (tokens.length === 2) {
          let x = parseFloat(tokens[0]),
            y = parseFloat(tokens[1]);
          if (!isNaN(x) && !isNaN(y)) {
            return {
              x: x,
              y: y,
              label: ""
            };
          }
        }
        if (tokens.length === 3 && tokens[0] === "Point") {
          let x = parseFloat(tokens[1]),
            y = parseFloat(tokens[2]);
          if (!isNaN(x) && !isNaN(y)) {
            return {
              x: x,
              y: y,
              label: ""
            };
          }
        }
        if (tokens.length === 3) {
          let x = parseFloat(tokens[0]),
            y = parseFloat(tokens[1]);
          if (!isNaN(x) && !isNaN(y)) {
            return {
              x: x,
              y: y,
              label: tokens[2]
            };
          }
        }
        return null;
      }
      static getSegment(tokens) {
        if (tokens.length === 4) {
          let x1 = parseFloat(tokens[0]),
            y1 = parseFloat(tokens[1]),
            x2 = parseFloat(tokens[2]),
            y2 = parseFloat(tokens[3]);
          if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
            return {
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            };
          }
        }
        if (tokens.length >= 5 && tokens[0] === "Segment") {
          let x2 = parseFloat(tokens[1]),
            y2 = parseFloat(tokens[2]),
            x3 = parseFloat(tokens[3]),
            y3 = parseFloat(tokens[4]);
          if (!isNaN(x2) && !isNaN(y2) && !isNaN(x3) && !isNaN(y3)) {
            return {
              x1: x2,
              y1: y2,
              x2: x3,
              y2: y3
            };
          }
        }
        return null;
      }
      static getLine(tokens) {
        if (tokens.length === 3) {
          let a = parseFloat(tokens[0]),
            b = parseFloat(tokens[1]),
            c = parseFloat(tokens[2]);
          if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
            return {
              a: a,
              b: b,
              c: c
            };
          }
        }
        if (tokens.length >= 4 && tokens[0] === "Line") {
          let a = parseFloat(tokens[1]),
            b = parseFloat(tokens[2]),
            c = parseFloat(tokens[3]);
          if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
            return {
              a: a,
              b: b,
              c: c
            };
          }
        }
        return null;
      }
      static getCircle(tokens) {
        if (tokens.length === 3) {
          let x = parseFloat(tokens[0]),
            y = parseFloat(tokens[1]),
            r = parseFloat(tokens[2]);
          if (!isNaN(x) && !isNaN(y) && !isNaN(r)) {
            return {
              x: x,
              y: y,
              r: r
            };
          }
        }
        if (tokens.length >= 4 && tokens[0] === "Circle") {
          let x4 = parseFloat(tokens[1]),
            y4 = parseFloat(tokens[2]),
            r = parseFloat(tokens[3]);
          if (!isNaN(x4) && !isNaN(y4) && !isNaN(r)) {
            return {
              x: x4,
              y: y4,
              r: r
            };
          }
        }
        return null;
      }
      setNewData(text, dispatch = true) {
        var data = {
          points: [],
          segments: [],
          lines: [],
          circles: [],
          polygons: []
        };
        text = text.split('\n');
        for (let i = 0; i < text.length; i += 1) {
          if (!text[i]) {
            continue;
          }
          let tokens;
          try {
            tokens = consoleTokenizer(text[i]);
          } catch (message) {
            continue;
          }
          if (!tokens || !tokens.length) {
            continue;
          }
          let isPoint = this.constructor.getPoint(tokens),
            isSegment = this.constructor.getSegment(tokens),
            isLine = this.constructor.getLine(tokens),
            isCircle = this.constructor.getCircle(tokens);
          if (isPoint) {
            data.points.push(isPoint);
          } else if (isSegment) {
            data.segments.push(isSegment);
          } else if (isLine) {
            data.lines.push(isLine);
          } else if (isCircle) {
            data.circles.push(isCircle);
          } else {
            if (tokens[0] === "Polygon") {
              let j = i + 1;
              let polygon = [];
              while (j < text.length) {
                if (text[j] === "...") {
                  break;
                }
                try {
                  let point = this.constructor.getPoint(consoleTokenizer(text[j]));
                  if (point) {
                    polygon.push(point);
                  }
                } catch (message) {}
                j += 1;
              }
              if (text[j] === "..." && polygon.length >= 3) {
                data.polygons.push(polygon);
              }
              i = j;
            }
          }
        }
        if (dispatch) {
          this.dispatch("inputProvided", data);
        }
      }
      onMount() {
        super.onMount();
        // Disable the indexing on the left margin
        this.setAceRendererOption("showLineNumber", false);
        this._timeout = null;
        this.addAceSessionChangeListener(() => {
          /// If the change is created by editing the widget
          if (this._selfChanged) {
            return;
          }
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          this._timeout = setTimeout(() => {
            this.setNewData(this.getValue());
            this._timeout = null;
          }, 500);
        });
        this.addListener("addObject", (type, object) => {
          this._selfChanged = true;
          let text = Stringifier[type](object.options.data);
          let editor = this.ace;
          let column = editor.session.getLine(0).length;
          editor.gotoLine(0, column);
          this.insert(text);
          this._selfChanged = false;
        });
        this.addListener("redraw", data => {
          this._selfChanged = true;
          this.setValue(getGeometryText(data));
          this._selfChanged = false;
        });
      }
    }
    class CSAGeometryWidget extends UI$1.Element {
      render() {
        return [UI$1.createElement("div", {
          ref: "widgetBlock",
          style: {
            margin: "0 auto"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-right": "30px",
            float: "left"
          }
        }, UI$1.createElement("label", null, " Input: "), UI$1.createElement(GeometryCodeEditor, {
          ref: this.refLink("textPanel"),
          value: getGeometryText(defaultData),
          style: {
            width: "100%",
            height: "300px"
          }
        })), UI$1.createElement("div", {
          ref: "svgBlock",
          style: {
            width: "600px",
            height: "500px",
            display: "inline-block",
            "position": "relative"
          }
        }, UI$1.createElement("div", {
          style: {
            position: "absolute",
            top: "20px",
            left: "70px"
          }
        }, UI$1.createElement(Button$1, {
          ref: "plusButton",
          level: Level.INFO,
          icon: "plus",
          size: Size.LARGE,
          style: {
            "border-radius": "0"
          }
        }), UI$1.createElement("div", {
          ref: "commandsList",
          className: `${dropdownList.default} hidden`,
          style: {
            width: "3.1em"
          }
        }, UI$1.createElement("div", {
          ref: "drawPoint",
          className: "fa fa-circle",
          style: {
            "text-align": "center",
            "height": "40px",
            "line-height": "25px"
          }
        }, " "), UI$1.createElement("div", {
          ref: "drawSegment",
          className: "fa fa-minus fa-2x",
          style: {
            "text-align": "center"
          }
        }, " "), UI$1.createElement("div", {
          ref: "drawLine",
          style: {
            "text-align": "center"
          }
        }, "/"), UI$1.createElement("div", {
          ref: "drawCircle",
          className: "fa fa-circle-o fa-2x",
          style: {
            "text-align": "center"
          }
        }, " "), UI$1.createElement("div", {
          ref: "drawPolygon",
          className: "fa fa-square-o fa-2x",
          style: {
            "text-align": "center"
          }
        }, " "))), UI$1.createElement(CSAGeometryWidgetSVG, _extends({
          ref: "svg",
          textPanel: this.textPanel
        }, this.options, {
          data: defaultData,
          widget: this
        }))), UI$1.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-left": "30px",
            float: "right"
          }
        }, UI$1.createElement(GeometryWidgetLegend, {
          ref: "geometryWidgetLegend",
          widget: this,
          editable: true
        })))];
      }
      resize(newHeight, newWidth) {
        newWidth = Math.max(newWidth, 500);
        newHeight = newWidth * 472.66 / 754;
        this.widgetBlock.setStyle("width", newWidth + 770 + "px");
        this.svgBlock.setStyle("width", newWidth + "px");
        this.svgBlock.setStyle("height", newHeight + "px");
        this.svg.setAttribute("width", newWidth + "px");
        this.svg.setAttribute("height", newHeight + "px");
        this.svg.dispatch("resize", newHeight, newWidth); // no clue why i need to subtract 70...
      }
      addDrawListeners() {
        let startDraw = () => {
          if (this._isDrawing) {
            this._forceEndDraw();
          }
          this._isDrawing = true;
          for (let point of this.svg.pointPlot.points) {
            point.removeClickListener(point.clickCallback);
            point.point.removeDragListener(point.dragFunc);
          }
          document.body.style["cursor"] = "crosshair";
          this.svg.chart.disableZoom();
          this.svg.chart.interactiveLayer.setStyle("cursor", "crosshair");
        };
        let endDraw = (type, object) => {
          this._isDrawing = false;
          for (let point of this.svg.pointPlot.points) {
            point.addClickListener(point.clickCallback);
            point.point.addDragListener(point.dragFunc);
          }
          document.body.style["cursor"] = "default";
          this.svg.chart.initZoom();
          this.svg.chart.interactiveLayer.setStyle("cursor", "move");
          if (type) {
            this.textPanel.dispatch("addObject", type, object);
          }
        };
        let rect = this.svg.chart.interactiveLayer;
        let getPoint = event => {
          let offsets = rect.node.getBoundingClientRect();
          let xDomain = this.svg.chart.xAxisOptions.scale.domain();
          let yDomain = this.svg.chart.yAxisOptions.scale.domain();
          let xRange = this.svg.chart.xAxisOptions.scale.range();
          let xRangeLength = Math.abs(xRange[0] - xRange[1]);
          let yRange = this.svg.chart.yAxisOptions.scale.range();
          let yRangeLength = Math.abs(yRange[0] - yRange[1]);
          return {
            x: xDomain[0] + (xDomain[1] - xDomain[0]) * (Device.getEventX(event) - offsets.left) / xRangeLength,
            y: yDomain[1] + (yDomain[0] - yDomain[1]) * (Device.getEventY(event) - offsets.top) / yRangeLength,
            label: ""
          };
        };
        let drawPointFunc = event => {
          event.stopPropagation();
          startDraw();
          let options = {
            data: getPoint(event)
          };
          this.geometryWidgetLegend.dispatch("needPointOptions", options);
          let originalCoords = options.coords;
          options.coords = true;
          this.svg.dispatch("addPoint", options);
          let point = options.point;
          point.removeClickListener(point.clickCallback);
          point.point.removeDragListener(point.dragFunc);
          let movePoint = event => {
            if (!point.node) {
              return;
            }
            point.options.data = getPoint(event);
            point.redraw();
          };
          let addPointCallback = () => {
            window.removeEventListener("click", addPointCallback);
            if (!originalCoords) {
              point.hideCoords();
            }
            window.removeEventListener("mousemove", movePoint);
            point.clickFunc(true);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            endDraw("point", point);
            point.addListener("dataChanged", () => {
              this.textPanel.dispatch("redraw", this.getData());
            });
          };
          this._forceEndDraw = event => {
            window.removeEventListener("click", addPointCallback);
            window.removeEventListener("mousemove", movePoint);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            this.svg.pointPlot.remove(point);
            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };
          window.addEventListener("click", addPointCallback);
          window.addEventListener("mousemove", movePoint);
          window.addEventListener("contextmenu", this._forceEndDraw);
        };
        let drawSegmentFunc = event => {
          event.stopPropagation();
          startDraw();
          let rectClickListener = event => {
            event.stopPropagation();
            let data = getPoint(event);
            let options = {
              data: {
                x1: data.x,
                y1: data.y,
                x2: data.x,
                y2: data.y
              }
            };
            this.svg.dispatch("addSegment", options);
            let segment = options.segment;
            rect.removeClickListener(rectClickListener);
            let moveSegmentCallback = event => {
              let newData = getPoint(event);
              segment.options.data.x2 = newData.x;
              segment.options.data.y2 = newData.y;
              segment.redraw();
            };
            let addSegmentCallback = () => {
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", moveSegmentCallback);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              endDraw("segment", segment);
            };
            window.removeEventListener("contextmenu", this._forceEndDraw);
            this._forceEndDraw = event => {
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", moveSegmentCallback);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              this.svg.segmentPlot.remove(segment);
              if (event) {
                endDraw();
                event.preventDefault();
                return false;
              }
            };
            window.addEventListener("click", addSegmentCallback);
            window.addEventListener("mousemove", moveSegmentCallback);
            window.addEventListener("contextmenu", this._forceEndDraw);
          };
          rect.addClickListener(rectClickListener);
          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };
          window.addEventListener("contextmenu", this._forceEndDraw);
        };
        let drawCircleFunc = event => {
          event.stopPropagation();
          startDraw();
          let rectClickListener = event => {
            event.stopPropagation();
            let options = {
              data: getPoint(event)
            };
            options.data.r = 0;
            this.svg.dispatch("addCircle", options);
            let circle = options.circle;
            rect.removeClickListener(rectClickListener);
            let changeRadius = event => {
              let newData = getPoint(event);
              circle.options.data.r = Math.sqrt((newData.x - circle.options.data.x) * (newData.x - circle.options.data.x) + (newData.y - circle.options.data.y) * (newData.y - circle.options.data.y));
              circle.redraw();
            };
            let addCircleCallback = () => {
              window.removeEventListener("click", addCircleCallback);
              window.removeEventListener("mousemove", changeRadius);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              endDraw("circle", circle);
            };
            window.removeEventListener("contextmenu", this._forceEndDraw);
            this._forceEndDraw = event => {
              window.removeEventListener("click", addCircleCallback);
              window.removeEventListener("mousemove", changeRadius);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              this.svg.circlePlot.remove(circle);
              if (event) {
                endDraw();
                event.preventDefault();
                return false;
              }
            };
            window.addEventListener("click", addCircleCallback);
            window.addEventListener("mousemove", changeRadius);
            window.addEventListener("contextmenu", this._forceEndDraw);
          };
          rect.addClickListener(rectClickListener);
          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };
          window.addEventListener("contextmenu", this._forceEndDraw);
        };
        let drawLineFunc = event => {
          event.stopPropagation();
          startDraw();
          let rectClickListener = event => {
            event.stopPropagation();
            let originalData = getPoint(event);
            let options = {
              data: {
                a: 0,
                b: 1 / originalData.y,
                c: -1
              }
            };
            this.svg.dispatch("addLine", options);
            let line = options.line;
            rect.removeClickListener(rectClickListener);
            let changeLine = event => {
              let data = getPoint(event);
              line.options.data.a = data.y - originalData.y;
              line.options.data.b = originalData.x - data.x;
              line.options.data.c = data.x * originalData.y - data.y * originalData.x;
              line.redraw();
            };
            let addLineCallback = () => {
              window.removeEventListener("click", addLineCallback);
              window.removeEventListener("mousemove", changeLine);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              endDraw("line", line);
            };
            window.removeEventListener("contextmenu", this._forceEndDraw);
            this._forceEndDraw = event => {
              window.removeEventListener("click", addLineCallback);
              window.removeEventListener("mousemove", changeLine);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              this.svg.linePlot.remove(line);
              if (event) {
                endDraw();
                event.preventDefault();
                return false;
              }
            };
            window.addEventListener("click", addLineCallback);
            window.addEventListener("mousemove", changeLine);
            window.addEventListener("contextmenu", this._forceEndDraw);
          };
          rect.addClickListener(rectClickListener);
          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };
          window.addEventListener("contextmenu", this._forceEndDraw);
        };
        let drawPolygonFunc = event => {
          event.stopPropagation();
          startDraw();
          let rectClickListener = event => {
            event.stopPropagation();
            let data = getPoint(event);
            let options = {
              data: [{
                x: data.x,
                y: data.y
              }, {
                x: data.x,
                y: data.y
              }]
            };
            this.svg.dispatch("addPolygon", options);
            let polygon = options.polygon;
            rect.removeClickListener(rectClickListener);
            let changePolygon = event => {
              let newData = getPoint(event);
              polygon.options.data[polygon.options.data.length - 1].x = newData.x;
              polygon.options.data[polygon.options.data.length - 1].y = newData.y;
              polygon.redraw();
            };
            let addSegmentCallback = event => {
              polygon.options.data.push(getPoint(event));
              polygon.redraw();
            };
            let rightClickFunc = event => {
              event.preventDefault();
              window.removeEventListener("contextmenu", rightClickFunc);
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", changePolygon);
              polygon.options.data.pop();
              polygon.redraw();
              endDraw("polygon", polygon);
            };
            window.removeEventListener("contextmenu", this._forceEndDraw);
            window.addEventListener("contextmenu", rightClickFunc);
            window.addEventListener("click", addSegmentCallback);
            window.addEventListener("mousemove", changePolygon);
            this._forceEndDraw = () => {
              window.removeEventListener("contextmenu", rightClickFunc);
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", changePolygon);
              this.svg.polygonPlot.remove(polygon);
            };
          };
          rect.addClickListener(rectClickListener);
          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };
          window.addEventListener("contextmenu", this._forceEndDraw);
        };
        this.drawPoint.addClickListener(drawPointFunc);
        this.drawSegment.addClickListener(drawSegmentFunc);
        this.drawCircle.addClickListener(drawCircleFunc);
        this.drawLine.addClickListener(drawLineFunc);
        this.drawPolygon.addClickListener(drawPolygonFunc);
      }
      getData() {
        let data = {
          points: [],
          segments: [],
          lines: [],
          circles: [],
          polygons: []
        };
        for (let i = 0; i < objects.length; i += 1) {
          for (let obj of this.svg[objects[i] + "Plot"][objects[i] + "s"]) {
            data[objects[i] + "s"].push(obj.options.data);
          }
        }
        return data;
      }
      onMount() {
        this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
        window.addEventListener("resize", () => {
          this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
        });
        Stringifier.scale = this.svg.chart.xAxisOptions.scale;
        this.geometryWidgetLegend.options.svg = this.svg;
        this.decimals = -1;
        this.addListener("decimalsChange", decimals => {
          if (this.decimals !== decimals) {
            this.decimals = decimals;
            this.textPanel.dispatch("redraw", this.getData());
            this.svg.pointPlot.redraw();
          }
        });
        this.textPanel.addListener("inputProvided", data => {
          this.svg.dispatch("inputProvided", data);
        });
        this.svg.addListener("needPointOptions", options => {
          this.geometryWidgetLegend.dispatch("needPointOptions", options);
        });
        for (let point of this.svg.pointPlot.points) {
          point.addListener("dataChanged", () => {
            this.textPanel.dispatch("redraw", this.getData());
          });
        }
        this.plusButton.addClickListener(() => {
          this.commandsList.toggleClass("hidden");
        });
        this.addDrawListeners();
      }
    }

    class GraphNode extends DoubleClickable(Draggable(SVG.Group)) {
      getDefaultOptions() {
        return {
          color: "black",
          innerColor: "white",
          circleAttr: {
            radius: 19,
            strokeWidth: 2
          },
          textAttr: {
            text: "N/A",
            dy: ".35em",
            textAnchor: "middle",
            strokeWidth: 1,
            fontSize: 14
          },
          fixed: false,
          dragging: false,
          secondLabelSign: 1,
          //whether the label NEXT to the node should be above or below
          secondLabelPadding: 10 //distance from node
        };
      }
      render() {
        let children = [UI$1.createElement(SVG.Circle, _extends({
          ref: "circle"
        }, this.options.circleAttr, {
          fill: this.options.innerColor,
          stroke: this.options.color,
          center: this.options.data.center
        })), UI$1.createElement(SVG.Text, _extends({
          ref: "label"
        }, this.options.textAttr, {
          fill: this.options.color,
          stroke: this.options.color,
          text: this.options.data.label + "",
          x: this.options.data.center.x,
          y: this.options.data.center.y
        }))];
        if (this.options.data.hasOwnProperty("secondLabel")) {
          children.push(UI$1.createElement(SVG.Text, _extends({
            ref: "secondLabel"
          }, this.options.textAttr, {
            fill: this.options.color,
            stroke: this.options.color,
            text: this.options.data.secondLabel + "",
            x: this.options.data.center.x,
            y: this.options.data.center.y + this.options.secondLabelSign * (this.options.circleAttr.radius + this.options.secondLabelPadding)
          })));
        }
        return children;
      }
      onMount() {
        if (this.getRadius() < 7) {
          this.label.setOpacity(0);
          this.circle.setAttribute("fill", this.options.color);
        }
        this.setStyle("cursor", "pointer");

        // this is required for graph editor, so entering "edit" mode removes these listeners
        this._fixNodeCallback = () => {
          if (this.isFixed()) {
            this.setFixed(false);
          } else {
            this.setFixed(true);
          }
        };
        this.addClickListener(this._fixNodeCallback);
        this.addDragListener({
          onStart: () => {
            this.dragging = true;
            // this.getGraph().setFrictionCoef(0.01);
          },
          onDrag: (deltaX, deltaY) => {
            let x = this.getCenter().x + deltaX;
            let y = this.getCenter().y + deltaY;
            this.setCenter({
              x: x,
              y: y
            });
          },
          onEnd: () => {
            this.dragging = false;
            // this.getGraph().setFrictionCoef(this.getGraph().getDefaultOptions().frictionCoef);
          }
        });
      }
      getGraph() {
        return this.options.graph;
      }
      getMarkup(scaleX = 1, scaleY = 1) {
        let options = {};
        let defaultOptions = this.getDefaultOptions();
        if (this.options.color !== defaultOptions.color) {
          options.options = options.options || {};
          options.options.color = this.options.color;
        }
        if (this.options.innerColor !== defaultOptions.innerColor) {
          options.options = options.options || {};
          options.options.innerColor = this.options.innerColor;
        }
        if (this.getRadius() !== defaultOptions.circleAttr.radius) {
          options.options = options.options || {};
          options.options.circleAttr = options.options.circleAttr || {};
          options.options.circleAttr.radius = this.getRadius();
        }
        if (this.options.circleAttr.strokeWidth !== defaultOptions.circleAttr.strokeWidth) {
          options.options = options.options || {};
          options.options.circleAttr = options.options.circleAttr || {};
          options.options.circleAttr.strokeWidth = this.circle.getAttribute("stroke-width");
        }
        if (this.options.fixed) {
          options.options = options.options || {};
          options.options.fixed = true;
        }
        options.label = this.getLabel();
        options.center = {};
        options.center.x = Formatter.truncate(this.getCenter().x * scaleX, 1);
        options.center.y = Formatter.truncate(this.getCenter().y * scaleY, 1);
        return JSON.stringify(options).replace(/\"[^\"]*\":/g, str => {
          return str.substring(1, str.length - 2) + ":";
        });
      }
      getOutgoingEdges() {
        let graph = this.getGraph();
        let edges = [];
        for (let i = 0; i < graph.edges.length; i += 1) {
          let edge = graph.edges[i];
          if (edge.getSource() === this || !edge.isDirected && edge.getTarget() === this) {
            edges.push(edge);
          }
        }
        return edges;
      }
      getIngoingEdges() {
        let graph = this.getGraph();
        let edges = [];
        for (let i = 0; i < graph.edges.length; i += 1) {
          let edge = graph.edges[i];
          if (edge.getTarget() === this || !edge.isDirected() && edge.getSource() === this) {
            edges.push(edge);
          }
        }
        return edges;
      }
      getIncidentEdges() {
        let graph = this.getGraph();
        let edges = [];
        for (let i = 0; i < graph.edges.length; i += 1) {
          let edge = graph.edges[i];
          if (edge.getSource() === this || edge.getTarget() === this) {
            edges.push(edge);
          }
        }
        return edges;
      }
      setInnerColor(color) {
        this.options.innerColor = color;
        this.circle.setAttribute("fill", this.options.innerColor);
      }
      getInnerColor() {
        return this.options.innerColor;
      }
      setColor(color) {
        this.options.color = color;
        this.circle.setAttribute("stroke", this.options.color);
        this.label.setAttribute("stroke", this.options.color);
        this.label.setAttribute("fill", this.options.color);
        if (this.secondLabel) {
          this.secondLabel.setAttribute("stroke", this.options.color);
          this.secondLabel.setAttribute("fill", this.options.color);
        }
      }
      getColor() {
        return this.options.color;
      }
      setLabel(label) {
        this.options.data.label = label;
        this.getGraph().options.nodes[this.getGraph().nodes.indexOf(this)].label = label;
        this.label.setText(label);
      }
      getLabel() {
        return this.options.data.label;
      }
      boundCoords(coords) {
        let box = this.getGraph().getBox();
        let radius = this.getRadius();
        let x = coords.x;
        if (x < box.x + radius) {
          x = box.x + radius;
        }
        if (x > box.x + box.width - radius) {
          x = box.x + box.width - radius;
        }
        let y = coords.y;
        if (y < box.y + radius) {
          y = box.y + radius;
        }
        if (y > box.y + box.height - radius) {
          y = box.y + box.height - radius;
        }
        return {
          x: x,
          y: y
        };
      }
      setCenter(coords, updateEdges = true) {
        coords = this.boundCoords(coords);
        this.options.data.center = coords;
        this.circle.setCenter(coords.x, coords.y);
        this.label.setPosition(coords.x, coords.y);
        if (this.secondLabel) {
          this.secondLabel.setPosition(coords.x, coords.y + this.options.secondLabelSign * (this.getRadius() + this.options.secondLabelPadding));
        }
        if (updateEdges) {
          let edges = this.getIncidentEdges();
          for (let i = 0; i < edges.length; i += 1) {
            let edge = edges[i];
            edge.update();
          }
        }
        this.getGraph().nodeCenterChanged(this, coords);
      }
      getCenter() {
        return this.options.data.center;
      }
      get x() {
        return this.options.data.center.x;
      }
      get y() {
        return this.options.data.center.y;
      }
      setFixed(value, highlight = true) {
        this.options.fixed = value;
        if (highlight === true) {
          if (value === true) {
            this.circle.setAttribute("stroke-width", 5);
          } else {
            this.circle.setAttribute("stroke-width", 2);
          }
        }
      }
      isFixed() {
        return this.options.fixed;
      }
      setRadius(radius) {
        this.circle.setRadius(radius);
        if (radius < 7) {
          this.label.setOpacity(0);
          this.circle.setAttribute("fill", this.options.color);
        } else {
          this.label.setOpacity(1);
          this.circle.setAttribute("fill", this.options.innerColor);
        }
      }
      getRadius() {
        return this.circle.getRadius();
      }
      getPopupPosition(deltaX = 0, deltaY = 0, forceTransition = null) {
        if (forceTransition && forceTransition.points.has(this)) {
          let result;
          let coords = forceTransition.points.get(this);
          result = {
            x: coords.x + deltaX,
            y: coords.y + deltaY
          };
          return result;
        }
      }

      // Transitions start here
      changeColorTransition(color, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setColor(Color$1.interpolate(context.color, color, t));
          },
          context: {
            color: this.options.color
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
      moveTransition(options) {
        return new Transition$1({
          func: (t, context) => {
            this.setCenter({
              x: (1 - t) * context.coords.x + t * options.newCoords.x,
              y: (1 - t) * context.coords.y + t * options.newCoords.y
            });
          },
          context: {
            coords: this.getCenter()
          },
          duration: options.duration,
          startTime: options.startTime,
          dependsOn: options.dependsOn
        });
      }
    }

    class GraphEdge extends SVG.Group {
      getDefaultOptions() {
        return {
          color: "black",
          pathAttr: {
            fill: "none",
            strokeWidth: 2
          },
          invisiblePathAttr: {
            opacity: 0,
            fill: "none",
            strokeWidth: 30
          },
          curveArcRadius: 0,
          supportsBending: true
        };
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.color = this.options.color || this.getDefaultOptions().color;
      }
      render() {
        let sourceCenter = this.getGraph().options.nodes[this.options.data.source].center;
        if (this.getSource()) {
          // If this is not the first time drawing the edge, take the data from the node itself,
          // as the options of the graph might be outdated
          sourceCenter = this.getSource().getCenter();
        }
        let targetCenter = this.getGraph().options.nodes[this.options.data.target].center;
        if (this.getTarget()) {
          // Same as above
          targetCenter = this.getTarget().getCenter();
        }
        this.options.children = [UI$1.createElement(SVG.Path, _extends({
          ref: "path",
          d: "M " + sourceCenter.x + " " + sourceCenter.y + " L " + targetCenter.x + " " + targetCenter.y
        }, this.options.pathAttr, {
          stroke: this.options.color
        })), UI$1.createElement(SVG.Path, _extends({
          ref: "invisiblePath",
          d: "M " + sourceCenter.x + " " + sourceCenter.y + " L " + targetCenter.x + " " + targetCenter.y
        }, this.options.invisiblePathAttr, {
          stroke: this.options.color
        }))];
        this.arrow = UI$1.createElement(SVG.Polygon, {
          ref: "arrow",
          points: [{
            x: -15,
            y: 7.5
          }, {
            x: 0,
            y: 0
          }, {
            x: -15,
            y: -7.5
          }],
          stroke: this.options.color,
          fill: this.options.color
        });
        if (this.options.label) {
          this.options.children.push(UI$1.createElement(SVG.Text, {
            ref: "costLabel",
            text: this.options.label
          }));
        }
        if (this.options.directed) {
          this.options.children.push(this.arrow);
        }
        return this.options.children;
      }
      getLabel() {
        return this.options.label;
      }
      setLabel(label) {
        if (!this.costLabel) {
          this.costLabel = UI$1.createElement(SVG.Text, {
            text: label
          });
          this.costLabel.mount(this);
          this.drawCost(true);
        }
        this.costLabel.setText(label);
        this.options.label = label;
        this.update();
      }
      drawCost(forced = false) {
        if (!this.getLabel() && !forced) {
          return;
        }
        let costLabelPadding = 5;
        let pathLength = this.path.node.getTotalLength();
        let midPoint = this.path.node.getPointAtLength(pathLength / 2);
        let vector;
        if (midPoint.x <= 0 || midPoint.y <= 0) {
          return;
        }
        vector = this.computeBisectorVector(pathLength, midPoint);
        this.costLabel.setPosition(midPoint.x + vector.x * (this.costLabel.getWidth() / 2 + costLabelPadding), midPoint.y + vector.y * (this.costLabel.getHeight() / 2 + costLabelPadding));
      }
      computeBisectorVector(pathLength = this.path.node.getTotalLength(), midPoint = this.path.node.getPointAtLength(pathLength / 2)) {
        const EPS = 1;
        const SLOPE_EPS = 0.15;
        let normalizationUnit;
        // Take a the vector characterizing the slope at the midpoint of the path
        let auxiliaryPoint = this.path.node.getPointAtLength(pathLength / 2 + EPS);
        let vector = normalizeVector({
          x: auxiliaryPoint.x - midPoint.x,
          y: auxiliaryPoint.y - midPoint.y
        });

        // Get the perpendicular vector
        vector = rotatePoint(vector, 0, Math.PI / 2);
        // Negate the vector if it doesn't have the right orientation (we want to bring the text ABOVE the edge)
        if (vector.y >= 0) {
          vector = rotatePoint(vector, 0, Math.PI);
        }
        // The biggest direction vector will be set to 1 in its absolute value, and so the values must be normalized
        normalizationUnit = Math.max(Math.abs(vector.x), Math.abs(vector.y));

        // If the path has length 0, the vector is null
        if (pathLength === 0) {
          return {
            x: 0,
            y: 1
          };
        }
        vector.x /= normalizationUnit;
        vector.y /= normalizationUnit;

        // For paths with small slope the x coordinate is calculated using a linear function.
        // For paths with bigger slope the x coordinate is a constant.
        if (Math.abs(vector.x) < SLOPE_EPS) {
          vector.x = Math.sign(vector.x) * (1 - (SLOPE_EPS - Math.abs(vector.x)) / SLOPE_EPS);
        } else {
          vector.x = Math.sign(vector.x);
        }
        return vector;
      }
      getArrowStartPercent() {
        let totalLen = this.path.getLength();
        const EPS = 0.1;
        for (let curLen = this.getSource().getRadius(); curLen < totalLen; curLen += EPS) {
          let point = this.path.getPointAtLength(curLen);
          if (distance(this.getSource().getCenter(), point) > this.getSource().getRadius()) {
            return curLen / totalLen;
          }
        }
        return 1;
      }
      getMarkup() {
        let options = {};
        let defaultOptions = this.getDefaultOptions();
        if (this.options.color !== defaultOptions.color) {
          options.color = this.options.color;
        }
        if (this.options.pathAttr.strokeWidth !== defaultOptions.pathAttr.strokeWidth) {
          options.pathAttr = options.pathAttr || {};
          options.pathAttr.strokeWidth = this.options.pathAttr.strokeWidth;
        }
        if (this.getLabel()) {
          options.label = this.getLabel();
        }
        options.source = this.getSourceIndex();
        options.target = this.getTargetIndex();
        return JSON.stringify(options).replace(/\"[^\"]*\":/g, str => {
          return str.substring(1, str.length - 2) + ":";
        });
      }
      getArrowEndPercent() {
        let totalLen = this.path.getLength();
        const EPS = 0.1;
        for (let curLen = totalLen - this.getTarget().getRadius(); curLen >= 0; curLen -= EPS) {
          let point = this.path.node.getPointAtLength(curLen);
          if (distance(this.getTarget().getCenter(), point) > this.getTarget().getRadius()) {
            return curLen / totalLen;
          }
        }
        return 0;
      }
      setDirected(boolFlag) {
        if (this.options.directed === boolFlag) {
          return;
        }
        this.options.directed = boolFlag;
        if (!this.options.directed) {
          this.eraseChild(this.arrow, false);
        } else {
          this.appendChild(this.arrow);
          this.setArrowOnPath(1);
        }
      }
      getPathString() {
        if (this.options.curveArcRadius === 0) {
          // If the curve ratio is 0, the path is a line
          return "M " + this.getSource().x + " " + this.getSource().y + " L " + this.getTarget().x + " " + this.getTarget().y;
        } else {
          // Draw a quadratic Bezier curve
          // Compute Bezier control point
          let edgeMidPoint = {
            x: (this.getSource().x + this.getTarget().x) / 2,
            y: (this.getSource().y + this.getTarget().y) / 2
          };
          let bezierControlPoint = addVectors(scaleVector(normalizeVector(subtractVectors(rotatePoint(this.getSource().getCenter(), edgeMidPoint, Math.PI / 2), edgeMidPoint)), this.options.curveArcRadius * 2), edgeMidPoint);
          return "M" + this.getSource().x + "," + this.getSource().y + "Q" + bezierControlPoint.x + "," + bezierControlPoint.y + "," + this.getTarget().x + "," + this.getTarget().y;
        }
      }
      setArrowOnPath(percent) {
        let endPercent = this.getArrowEndPercent();
        let startPercent = this.getArrowStartPercent();
        let length = (startPercent + percent * (endPercent - startPercent)) * this.path.getLength();
        let point = this.path.getPointAtLengthWithAngle(length);
        this.arrow.node.setAttribute("transform", "translate (" + point.x + " " + point.y + ") " + "rotate(" + (point.alpha + 180) + ")");
      }
      setCurveArcRadius(newCurveArcRadius) {
        this.options.curveArcRadius = newCurveArcRadius;
      }
      getCurveArcRadius() {
        return this.options.curveArcRadius;
      }
      setBendingSupport(value) {
        this.options.supportsBending = value;
      }
      update() {
        let newPath = this.getPathString();
        this.path.setPath(newPath);
        this.invisiblePath.setPath(newPath);
        this.drawCost();
        if (this.options.directed) {
          this.setArrowOnPath(1);
        }
      }
      getGraph() {
        return this.options.graph;
      }
      delete() {
        eraseFirst(this.getGraph().options.edges, this.data);
        this.getGraph().edgeGroup.eraseChild(this);
      }
      reverse() {
        let aux = this.options.data.source;
        this.options.data.source = this.options.data.target;
        this.options.data.target = aux;
      }
      getSourceIndex() {
        return this.options.data.source;
      }
      getTargetIndex() {
        return this.options.data.target;
      }
      getSource() {
        return this.getGraph().nodes[this.options.data.source];
      }
      getTarget() {
        return this.getGraph().nodes[this.options.data.target];
      }
      getColor() {
        return this.options.color;
      }
      isDirected() {
        return this.options.directed;
      }
      setColor(color) {
        this.options.color = color;
        if (this.node) {
          this.path.setAttribute("stroke", color);
          this.invisiblePath.setAttribute("stroke", color);
          if (this.arrow.node) {
            this.arrow.setAttribute("stroke", color);
            this.arrow.setAttribute("fill", color);
          }
        }
      }
      onMount() {
        super.onMount();
        this.drawCost();
      }

      // Transitions start here
      changeColorTransition(color, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setColor(Color$1.interpolate(context.color, color, t));
          },
          context: {
            color: this.options.color
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
      bendingTransition(targetCurveArcRadius, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setCurveArcRadius(context.curveArcRadius + t * (targetCurveArcRadius - context.curveArcRadius));
            this.update();
          },
          context: {
            curveArcRadius: this.options.curveArcRadius
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
      arrowTravelTransition(duration, dependsOn = [], startTime = 0, keepArrow = false) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        // Make the edge undirected
        let currentDependencies = [];
        if (this.isDirected()) {
          let modifier = new Modifier({
            func: () => {
              this.setDirected(false);
            },
            reverseFunc: () => {
              this.setDirected(true);
            }
          });
          transitionList.push(modifier, false);
          currentDependencies = [modifier];
        }

        // Append the arrow
        let appendArrowModifier = new Modifier({
          func: () => {
            this.appendChild(this.arrow);
          },
          reverseFunc: () => {
            this.eraseChild(this.arrow, false);
          },
          dependsOn: currentDependencies
        });
        transitionList.push(appendArrowModifier, false);

        // Move the arrow
        let moveArrowTransition = new Transition$1({
          func: t => {
            this.setArrowOnPath(t);
          },
          duration: duration,
          dependsOn: [appendArrowModifier]
        });
        transitionList.push(moveArrowTransition, false);

        // Remove the arrow
        let removeArrowModifier = new Modifier({
          func: () => {
            this.eraseChild(this.arrow, false);
          },
          reverseFunc: () => {
            this.appendChild(this.arrow);
          },
          dependsOn: [moveArrowTransition]
        });
        transitionList.push(removeArrowModifier, false);
        transitionList.push(new Transition$1({
          func: () => {},
          duration: 1
        }), false);

        // Make the edge directed
        if (keepArrow) {
          transitionList.push(new Modifier({
            func: () => {
              this.setDirected(true);
            },
            reverseFunc: () => {
              this.setDirected(false);
            },
            dependsOn: [removeArrowModifier]
          }), false);
        }
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      getPopupPosition(deltaX = 0, deltaY = 0, forceTransition = null) {
        if (forceTransition && forceTransition.lines.has(this)) {
          let options = forceTransition.lines.get(this);
          this.setCurveArcRadius(options.curveArcRadius);
          this.getSource().setCenter(forceTransition.points.get(this.getSource()));
          this.getTarget().setCenter(forceTransition.points.get(this.getTarget()));
          this.update();
        }
        let midpoint = this.path.node.getPointAtLength(this.path.node.getTotalLength() / 2);
        return {
          x: midpoint.x + deltaX,
          y: midpoint.y + deltaY
        };
      }

      // Only works for straight-line edges
      turnToDashesTransition(duration, dashArray = "3,3", forceTransition = null, dependsOn = [], startTime = 0) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let appendDummy = new Modifier({
          func: () => {
            let sourceCenter;
            let targetCenter;
            if (!forceTransition) {
              sourceCenter = this.getSource().getCenter();
              targetCenter = this.getTarget().getCenter();
            } else {
              sourceCenter = forceTransition.points.get(this.getSource());
              targetCenter = forceTransition.points.get(this.getTarget());
            }
            // Append the dummy line
            let dummyPath = UI$1.createElement(SVG.Line, _extends({
              x1: sourceCenter.x,
              x2: sourceCenter.x,
              y1: sourceCenter.y,
              y2: sourceCenter.y,
              ref: this.refLink("dummyPath"),
              strokeDasharray: dashArray
            }, this.options.pathAttr));
            let fakePath = UI$1.createElement(SVG.Line, _extends({
              x1: sourceCenter.x,
              x2: targetCenter.x,
              y1: sourceCenter.y,
              y2: targetCenter.y,
              ref: this.refLink("fakePath")
            }, this.options.pathAttr));
            this.appendChild(dummyPath);
            this.appendChild(fakePath);
            this.path.setAttribute("opacity", 0);
          },
          reverseFunc: () => {
            this.eraseChild(this.dummyPath, true);
            this.eraseChild(this.fakePath, true);
            this.path.setAttribute("opacity", 1);
          }
        });
        transitionList.push(appendDummy, false);

        // Dash the dummy path
        let strokeDummy = new Transition$1({
          func: t => {
            let sourceCenter = this.getSource().getCenter();
            let targetCenter = this.getTarget().getCenter();
            let x2 = (1 - t) * sourceCenter.x + t * targetCenter.x;
            let y2 = (1 - t) * sourceCenter.y + t * targetCenter.y;
            this.dummyPath.setAttribute("x2", x2);
            this.dummyPath.setAttribute("y2", y2);
            this.fakePath.setAttribute("x1", x2);
            this.fakePath.setAttribute("y1", y2);
          },
          dependsOn: [appendDummy],
          duration: duration
        });
        transitionList.push(strokeDummy, false);

        // Remove the dummy and dash the path itself
        let removeDummy = new Modifier({
          func: () => {
            this.path.setAttribute("stroke-dasharray", dashArray);
            this.path.setAttribute("opacity", 1);
            this.eraseChild(this.dummyPath, false);
            this.eraseChild(this.fakePath, false);
          },
          reverseFunc: () => {
            this.path.setAttribute("stroke-dasharray", null);
            this.path.setAttribute("opacity", 0);
            this.appendChild(this.dummyPath);
            this.appendChild(this.fakePath);
          },
          dependsOn: [strokeDummy]
        });
        transitionList.push(removeDummy, false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
    }

    class CSAForceLayout {
      getDefaultOptions() {
        return {
          chargeStrength: 10,
          edgeStrength: 15,
          gravityStrength: 0.007,
          idealEdgeDistance: 140,
          // it used to be 140
          repulsionDistance: 140
        };
      }
      constructor(options) {
        this.setOptions(options);
      }
      setOptions(options) {
        this.options = Object.assign(this.getDefaultOptions(), options);
        this.points = this.options.points;
        this.edges = this.options.edges;
        this.gravityCenter = this.options.gravityCenter;
        this.adjMatrix = this.buildAdjacencyMatrix();
      }
      buildAdjacencyMatrix() {
        // Create a bi-dimensional matrix, initialize with false
        let adjMatrix = Array(this.points.length).fill().map(() => Array(this.points.length).fill(false));
        for (let i = 0; i < this.edges.length; i += 1) {
          adjMatrix[this.edges[i].first][this.edges[i].second] = true;
          adjMatrix[this.edges[i].second][this.edges[i].first] = true;
        }
        return adjMatrix;
      }
      idealEdgeDistance() {
        return this.options.idealEdgeDistance;
      }
      repulsionDistance() {
        return this.options.repulsionDistance;
      }
      updateVectors(point1, point2, attractionForce) {
        let dx = point2.x - point1.x;
        let dy = point2.y - point1.y;
        let vectorSize = Math.sqrt(dx * dx + dy * dy);
        if (vectorSize < 1e-9) {
          let angle = Math.random() * 2 * Math.PI;
          dx = Math.sin(angle);
          dy = Math.cos(angle);
          vectorSize = 1;
        }
        point1.dx += attractionForce * dx / vectorSize;
        point1.dy += attractionForce * dy / vectorSize;
        point2.dx += -attractionForce * dx / vectorSize;
        point2.dy += -attractionForce * dy / vectorSize;
      }
      calculateAttractions(points) {
        for (let i = 0; i < points.length; i += 1) {
          for (let j = i + 1; j < points.length; j += 1) {
            let dist = distance(points[i], points[j]);
            // If there is an edge between the points try to bring the distance between them closer to the ideal edge distance
            if (this.adjMatrix[i][j]) {
              let force = dist < 1e-9 ? 1000 : this.options.edgeStrength * (dist - this.idealEdgeDistance()) / dist;
              this.updateVectors(points[i], points[j], force);
            }
            // If there is no edge between the points, they mustn't be closer than the repulsionDistance.
            else {
              if (dist < this.repulsionDistance()) {
                let force = dist < 1e-9 ? 1000 : this.options.chargeStrength * (dist - this.repulsionDistance()) / dist;
                this.updateVectors(points[i], points[j], force);
              }
            }
          }
        }
      }
      gravitateTowards(points, center) {
        for (let i = 0; i < points.length; i += 1) {
          let dist = distance(points[i], center);
          this.updateVectors(points[i], center, dist * this.options.gravityStrength);
        }
      }
      calculateVectors(numIterations) {
        let points = [];
        for (let i = 0; i < this.points.length; i += 1) {
          points.push({
            x: this.points[i].x,
            y: this.points[i].y,
            dx: 0,
            dy: 0
          });
        }
        numIterations = numIterations || 1;
        for (let iter = 0; iter < numIterations; iter += 1) {
          for (let i = 0; i < points.length; i += 1) {
            points[i].x += points[i].dx;
            points[i].y += points[i].dy;
            points[i].dx = 0;
            points[i].dy = 0;
          }
          this.calculateAttractions(points);
          if (this.options.gravityCenter) {
            this.gravitateTowards(points, this.options.gravityCenter);
          }
        }
        return points;
      }
    }

    class Graph extends SVG.Group {
      getDefaultOptions() {
        return {
          nodes: [],
          edges: [],
          gravityCenterXPercentage: 0.5,
          gravityCenterYPercentage: 0.5,
          box: {
            x: 0,
            y: 0,
            width: 400,
            height: 400
          },
          indexType: "0",
          directed: false,
          forcePaused: false,
          bendEdgesIfForcePaused: false,
          idlePaused: false,
          idlePauseThreshold: 0.05,
          idealEdgeDistance: CSAForceLayout.prototype.getDefaultOptions().idealEdgeDistance,
          nodeOptions: GraphNode.prototype.getDefaultOptions(),
          supportsBending: true
        };
      }
      populateNodeData() {
        for (let i = 0; i < this.options.nodes.length; i += 1) {
          let nodeData = this.options.nodes[i];
          // Set label
          if (this.options.indexType === "0") {
            nodeData.label = i;
          } else if (this.options.indexType === "1") {
            nodeData.label = i + 1;
          } else if (this.options.indexType === "custom") {
            if (!nodeData.hasOwnProperty("label") || nodeData.label === "") {
              nodeData.label = i + 1;
            }
          } else {
            nodeData.label = "";
          }

          // Set center
          nodeData.center = nodeData.center || {
            x: Math.random() * this.options.box.width + this.options.box.x,
            y: Math.random() * this.options.box.height + this.options.box.y
          };
        }
      }
      setOptions(options) {
        super.setOptions(options);
        this.populateNodeData();
        this.options.gravityCenter = {
          x: this.options.gravityCenterXPercentage * this.options.box.width + this.options.box.x,
          y: this.options.gravityCenterYPercentage * this.options.box.height + this.options.box.y
        };
      }
      getMarkup() {
        let markup = "<Graph indexType=\"custom\" height=\"400\" width=\"400\" ";
        markup += "nodes={[";
        for (let node of this.nodes) {
          if (node !== this.nodes[0]) {
            markup += ",";
          }
          markup += node.getMarkup(400 / this.options.box.width, 400 / this.options.box.height);
        }
        markup += "]} edges={[";
        for (let edge of this.edges) {
          if (edge !== this.edges[0]) {
            markup += ",";
          }
          markup += edge.getMarkup();
        }
        markup += "]} />";
        return markup;
      }
      render() {
        let nodes = [];
        for (let i = 0; i < this.options.nodes.length; i += 1) {
          let nodeData = this.options.nodes[i];
          let nodeOptions = Object.assign({}, this.options.nodeOptions, nodeData.options);
          nodes.push(UI$1.createElement(GraphNode, _extends({
            graph: this,
            data: nodeData
          }, nodeOptions)));
        }
        let edges = [];
        for (let i = 0; i < this.options.edges.length; i += 1) {
          let edgeData = this.options.edges[i];
          let data = {
            source: edgeData.source,
            target: edgeData.target
          };
          let directed = edgeData.hasOwnProperty("directed") ? edgeData.directed : this.options.directed;
          let color = edgeData.color;
          edges.push(UI$1.createElement(GraphEdge, _extends({
            graph: this,
            label: edgeData.label,
            data: data,
            directed: directed,
            color: color
          }, edgeData.options)));
        }
        return [UI$1.createElement(SVG.Group, {
          ref: "edgeGroup"
        }, edges), UI$1.createElement(SVG.Group, {
          ref: "nodeGroup"
        }, nodes)];
      }
      redraw() {
        super.redraw();
        // HACK for bending edges to work if force is paused
        if (this.options.forcePaused && this.options.bendEdgesIfForcePaused) {
          this.getEdgeBendingTransitions().start();
        }
        for (let i = 0; i < this.edges.length; i += 1) {
          this.edges[i].update();
        }
        if (!this.options.forcePaused && !this.options.idlePaused) {
          this.startPerpetualForce();
        }
      }
      pauseForce() {
        this.options.forcePaused = true;
      }
      unpauseForce() {
        let initialValue = this.options.forcePaused;
        this.options.forcePaused = false;
        if (initialValue) {
          this.startPerpetualForce();
        }
      }
      pauseIdle() {
        this.options.idlePaused = true;
      }
      unpauseIdle() {
        let initialValue = this.options.idlePaused;
        this.options.idlePaused = false;
        if (initialValue) {
          this.startPerpetualForce();
        }
      }
      startPerpetualForce() {
        let updateForces = () => {
          if (this.isInDocument()) {
            this.runForces();
          }
          if (!this.options.forcePaused && !this.options.idlePaused) {
            requestAnimationFrame(updateForces);
          } else if (this.options.forcePaused) {
            // Straighten any bended edges
            requestAnimationFrame(() => {
              for (let i = 0; i < this.edges.length; ++i) {
                this.edges[i].setCurveArcRadius(0);
                this.edges[i].update();
              }
            });
          }
        };
        requestAnimationFrame(updateForces);
      }

      // TODO(@mikester): This shouldn't call setOptions
      setData(nodes, edges) {
        this.options.nodes = nodes;
        this.options.edges = edges;
        this.setOptions(this.options);
        this.redraw();
      }
      get nodes() {
        if (!this.nodeGroup) {
          return false;
        }
        return this.nodeGroup.children;
      }
      get edges() {
        if (!this.edgeGroup) {
          return false;
        }
        return this.edgeGroup.children;
      }
      removeNode(node) {
        for (let edge of node.getIncidentEdges()) {
          this.removeEdge(edge);
        }
        // TODO bad practice to directly edit options
        eraseFirst(this.options.nodes, node.options.data);
        let oldIndices = new Map(),
          i = 0;
        for (let oldNode of this.nodes) {
          oldIndices.set(i++, oldNode);
        }
        this.nodeGroup.eraseChild(node);

        // After erasing a node, all edges must be updated so the indices of their source and target
        // remain correct
        for (let edge of this.edges) {
          let source = oldIndices.get(edge.getSourceIndex());
          let target = oldIndices.get(edge.getTargetIndex());
          for (i = 0; i < this.nodes.length; i += 1) {
            if (this.nodes[i] === source) {
              edge.options.data.source = i;
            } else if (this.nodes[i] === target) {
              edge.options.data.target = i;
            }
          }
        }
      }
      addNode(node) {
        node.options.data = node.options.data || {};
        node.options.data.center = node.options.data.center || {
          x: Math.random() * this.options.box.width + this.options.box.x,
          y: Math.random() * this.options.box.height + this.options.box.y
        };
        node.options.circleAttr = node.options.circleAttr || {};
        if (this.options.nodeRadius) {
          node.options.circleAttr.radius = this.options.nodeRadius;
        }
        if (this.options.nodeFill) {
          node.options.innerColor = this.options.nodeFill;
        }
        if (this.options.nodeStroke) {
          node.options.color = this.options.nodeStroke;
        }
        node.options.graph = this;
        this.nodeGroup.appendChild(node);
        this.options.nodes.push(node.options.data);
        return node;
      }
      removeEdge(edge) {
        eraseFirst(this.options.edges, edge.options.data);
        this.edgeGroup.eraseChild(edge);
      }
      addEdge(edge) {
        edge.options.graph = this;
        if (this.options.edgeColor) {
          edge.options.color = this.options.edgeColor;
        }
        this.edgeGroup.appendChild(edge);
        this.options.edges.push(edge.options.data);
        if (this.isDirected()) {
          edge.setArrowOnPath(1);
        }
        return edge;
      }
      nodeCenterChanged(node, coords) {
        this.unpauseIdle();

        // Uncomment this if you ever need to listen on node center change
        // this.dispatch("setNodeCenter", {node: node, coords: coords});
      }
      getBox() {
        return this.options.box;
      }
      setBox(newBox) {
        this.options.box = newBox;
      }
      setAllCenters(forces) {
        // This function is implemented in order to cut the number of
        // edge redraws in half on a cycle of the forces

        // if (!this._lastForcesFrameTime) {
        //     this._lastForcesFrameTime = 16;
        // }
        // let equilibrium = true;
        for (let i = 0; i < this.nodes.length; i += 1) {
          let node = this.nodes[i];
          if (!node.isFixed() && !node.dragging) {
            // // The forces acting on nodes are NOT the the correct scale
            // // of how much they should move. Since the force is mass times
            // // acceleration, and considering all nodes have mass 1, the
            // // forces give the nodes a vectorial acceleration.
            // node.velocity = node.velocity || {x: 3, y: 3};
            //
            // // This is the time elapsed since the last frame, in seconds.
            // // We will consider that forces run at 5x the natural speed, so
            // // the movement seems more smooth and the equilibrium is reached faster
            // let time = this._lastForcesFrameTime / 1000 * 5;
            //
            // // The new velocity of the node, in ideal conditions, would be the old one
            // // + time * acceleration. Since in ideal conditions the equilibrium is never
            // // reached, we will introduce a force of friction between the nodes and the
            // // canvas itself. This force will make the nodes reach an equilibrium point
            // // faster or slower, depending on the coefficient of friction.
            // let applyFriction = (x) => {
            //     let u = this.options.frictionCoef;
            //     return x >= u ? x - u : (x <= -u ? x + u : x);
            // };
            // if (Math.abs(node.velocity.x) <= 1.5) {
            //     forces[i].dx *= 10;
            // }
            // if (Math.abs(node.velocity.y) <= 1.5) {
            //     forces[i].dy *= 10;
            // }
            // node.velocity.x = applyFriction(node.velocity.x + forces[i].dx * time);
            // node.velocity.y = applyFriction(node.velocity.y + forces[i].dy * time);
            //
            // if (Math.abs(node.velocity.x) > 30) {
            //     node.velocity.x = 30 * (node.velocity.x > 0 ? 1 : -1);
            // } else if (Math.abs(node.velocity.x) < 0.03) {
            //     node.velocity.x = 0;
            // }
            // if (Math.abs(node.velocity.y) > 30) {
            //     node.velocity.y = 30 * (node.velocity.y > 0 ? 1 : -1);
            // } else if (Math.abs(node.velocity.y) < 0.03) {
            //     node.velocity.y = 0;
            // }

            node.setCenter({
              x: node.getCenter().x + forces[i].dx,
              y: node.getCenter().y + forces[i].dy
            }, false);

            // if (node.velocity.x || node.velocity.y) {
            //     equilibrium = false;
            // }
          }
        }
        for (let i = 0; i < this.edges.length; i += 1) {
          this.edges[i].update();
        }

        // if (equilibrium) {
        //     this.setFrictionCoef(0.035);
        // }
      }

      // setFrictionCoef(frictionCoef) {
      //     this.options.frictionCoef = frictionCoef;
      // }

      runForces() {
        let forcesStartTime = performance.now();
        if (!this.nodes || !this.edges) {
          return;
        }
        let forceOptions = {
          idealEdgeDistance: this.options.idealEdgeDistance,
          points: this.nodes.map(node => {
            return node.getCenter();
          }),
          edges: this.edges.map(edge => {
            return {
              first: edge.options.data.source,
              second: edge.options.data.target
            };
          }),
          gravityCenter: this.getGravityCenter()
        };
        for (let node of this.nodes) {
          if (node.dragging) {
            forceOptions.gravityStrength = 0;
            break;
          }
        }
        let forceLayout = new CSAForceLayout(forceOptions);
        let points = forceLayout.calculateVectors(1);
        this.setAllCenters(points);
        let maxDelta = 0;
        for (let i = 0; i < this.nodes.length; i += 1) {
          if (!this.nodes[i].isFixed() && !this.nodes[i].dragging) {
            maxDelta = Math.max(maxDelta, vectorLength({
              x: points[i].dx,
              y: points[i].dy
            }));
          }
        }
        if (maxDelta < this.options.idlePauseThreshold) {
          this.pauseIdle();
        }
        if (this.options.supportsBending) {
          this.getEdgeBendingTransitions().start();
        }

        // This is the time it took to redraw the graph in the last frame
        // Needed to that on higher scale graphs the equilibrium will be reached
        // In the same time, not in the same number of frames
        this._lastForcesFrameTime = performance.now() - forcesStartTime;
      }
      getEdge(a, b) {
        for (let edge of this.edges) {
          if (edge.getSource().getLabel() === "" + a && edge.getTarget().getLabel() === "" + b) {
            return edge;
          }
          if (edge.getSource().getLabel() === "" + b && edge.getTarget().getLabel() === "" + a) {
            return edge;
          }
        }
      }
      getEdgeBendingTransitions() {
        let transitions = new TransitionList();
        for (let i = 0; i < this.edges.length; i += 1) {
          let edge = this.edges[i];
          if (!edge.options.supportsBending) {
            return;
          }
          let edgeStartCoords = edge.getSource().getCenter();
          let edgeEndCoords = edge.getTarget().getCenter();
          let edgeLine = lineEquation(edgeStartCoords, edgeEndCoords);
          let biggestNode = null;
          for (let i = 0; i < this.nodes.length; i += 1) {
            if (this.nodes[i] === edge.getSource() || this.nodes[i] === edge.getTarget()) {
              continue;
            }
            let nodeCoords = this.nodes[i].getCenter();

            // Take the node's projection on this line
            let nodeProjection = perpendicularFoot(nodeCoords, edgeLine);

            // If the node almost intersects the line and
            // If the node's projection si on the segment determined by the edge points
            // In other words, if the node almost intersects the segemnt determined by the edge
            if (distancePointLine(nodeCoords, edgeLine) <= this.nodes[i].getRadius() + 10 && pointOnSegment(nodeProjection, edgeStartCoords, edgeEndCoords)) {
              // Store the node with the biggest radius out of all the ones that respect the above restrictions
              if (biggestNode === null || this.nodes[i].getRadius() > biggestNode.getRadius()) {
                biggestNode = this.nodes[i];
              }
            }
          }

          // Note that the code below is a little different than the one in CSAForceTransition
          // This one moves faster, it's more responsive to movement

          //If there exists a node that almost intersects the edge and current arc radius is 0
          if (biggestNode !== null && edge.options.curveArcRadius === 0) {
            let targetCurveArcRadius = 2.5 * biggestNode.getRadius() * (signedDistancePointLine(biggestNode.getCenter(), edgeLine) > 0 ? -1 : 1);
            // Transition the edge(in 200 ms) to a bended state, in the direction opposite of where
            // the node is coming from and with a curve arc radius proportional to the incoming node's radius
            transitions.add(edge.bendingTransition(targetCurveArcRadius, 200), false);
          } else if (biggestNode === null && edge.options.curveArcRadius !== 0) {
            // Otherwise, if there is no obstruction but the edge isn't straight
            // Transition the edge(in 200 ms) to be straight
            transitions.add(edge.bendingTransition(0, 200), false);
          }
        }
        return transitions;
      }
      getIndexType() {
        return this.options.indexType;
      }
      isDirected() {
        return this.options.directed;
      }
      setDirected(value) {
        this.options.directed = value;
        for (let i = 0; i < this.edges.length; i += 1) {
          this.edges[i].setDirected(value);
        }
      }
      setFixed(value, highlight = true) {
        this.fixed = value;
        for (let i = 0; i < this.nodes.length; i += 1) {
          let node = this.nodes[i];
          node.setFixed(value, highlight);
        }
      }
      setGravityCenter(newCenter) {
        this.options.gravityCenter = newCenter;
      }
      getGravityCenter() {
        return {
          x: this.options.gravityCenter.x,
          y: this.options.gravityCenter.y
        };
      }
      nodeCount() {
        return this.options.nodes.length;
      }
      getNodeIndex(node) {
        return this.nodes.indexOf(node);
      }
      getNode(label) {
        for (let i = 0; i < this.nodes.length; i += 1) {
          if (this.nodes[i].getLabel() === label) {
            return this.nodes[i];
          }
        }
      }
      computeVector(node1, node2, way) {
        const SLOPE_EPS = 0.15;
        let pathLength = distance(node1.getCenter(), node2.getCenter());
        let normalizationUnit;
        // Take a the vector characterizing the slope at the midpoint of the path
        let midPoint = {
          x: (node1.x + node2.x) * 0.5,
          y: (node1.y + node2.y) * 0.5
        };
        let auxiliaryPoint = {
          x: node1.x * 0.55 + node2.x * 0.45,
          y: node1.y * 0.55 + node2.y * 0.45
        };
        let vector = normalizeVector({
          x: auxiliaryPoint.x - midPoint.x,
          y: auxiliaryPoint.y - midPoint.y
        });

        // Get the perpendicular vector
        vector = rotatePoint(vector, 0, Math.PI / 2);
        // The biggest direction vector will be set to 1 in its absolute value, and so the values must be normalized
        normalizationUnit = Math.max(Math.abs(vector.x), Math.abs(vector.y));

        // If the path has length 0, the vector is null
        if (pathLength === 0) {
          return {
            x: 0,
            y: 1
          };
        }
        vector.x /= normalizationUnit;
        vector.y /= normalizationUnit;

        // For paths with small slope the x coordinate is calculated using a linear function.
        // For paths with bigger slope the x coordinate is a constant.
        if (Math.abs(vector.x) < SLOPE_EPS) {
          vector.x = Math.sign(vector.x) * (1 - (SLOPE_EPS - Math.abs(vector.x)) / SLOPE_EPS);
        } else {
          vector.x = Math.sign(vector.x);
        }
        return vector;
      }
      getBentPosition(node1, node2, t, way = 1) {
        let midPoint = {
          x: node1.x * t + node2.x * (1 - t),
          y: node1.y * t + node2.y * (1 - t)
        };
        let vector = this.computeVector(node1, node2, way);
        if (t > 0.5) {
          t = 1 - t;
        }
        return {
          x: midPoint.x + vector.x * t * 40,
          y: midPoint.y + vector.y * t * 40
        };
      }

      // The Transitions start here
      changeColorTransition(color, duration, dependsOn = [], startTime = 0) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        for (let i = 0; i < this.nodes.length; i += 1) {
          let node = this.nodes[i];
          transitionList.add(node.changeColorTransition(color, duration), false);
        }
        for (let i = 0; i < this.edges.length; i += 1) {
          let edge = this.edges[i];
          transitionList.add(edge.changeColorTransition(color, duration), false);
        }
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      mergeNodesAnimated(toMerge = [], duration, dependsOn = [], startTime = 0) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let centerX = 0;
        let centerY = 0;
        for (let i of toMerge) {
          this.nodes[i].setFixed(true);
          centerX += this.nodes[i].x;
          centerY += this.nodes[i].y;
        }
        centerX /= toMerge.length;
        centerY /= toMerge.length;
        let moveStartTime = transitionList.getLength();
        for (let i of toMerge) {
          transitionList.add(this.nodes[i].moveTransition({
            newCoords: {
              x: centerX,
              y: centerY
            },
            duration: duration,
            startTime: moveStartTime,
            dependsOn: dependsOn
          }));
        }
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      swapNodeLabelsTransition(node1, node2, duration, dependsOn = [], startTime = 0) {
        let label1 = node1.label;
        let label2 = node2.label;
        let swap = () => {
          let dataLabel1 = node1.options.data.label;
          let dataLabel2 = node2.options.data.label;
          node1.setLabel(dataLabel2);
          node2.setLabel(dataLabel1);
          let node1LabelX = node1.label.options.x;
          let node1LabelY = node1.label.options.y;
          let node2LabelX = node1.label.options.x;
          let node2LabelY = node1.label.options.y;
          node1.label.setPosition(node2LabelX, node2LabelY);
          node2.label.setPosition(node1LabelX, node1LabelY);
        };
        let firstHalf = new Transition$1({
          func: t => {
            t = 1 - t * 0.5;
            label1.setPosition(this.getBentPosition(node1, node2, t).x, this.getBentPosition(node1, node2, t).y);
            label2.setPosition(this.getBentPosition(node2, node1, t).x, this.getBentPosition(node2, node1, t).y);
          },
          duration: duration / 2,
          startTime: 0
        });
        let modifier = new Modifier({
          func: () => {
            swap();
          },
          reverseFunc: () => {
            swap();
          },
          startTime: duration / 2,
          dependsOn: [firstHalf]
        });
        let secondHalf = new Transition$1({
          func: t => {
            t = 0.5 - t * 0.5;
            label2.setPosition(this.getBentPosition(node1, node2, t).x, this.getBentPosition(node1, node2, t).y);
            label1.setPosition(this.getBentPosition(node2, node1, t).x, this.getBentPosition(node2, node1, t).y);
          },
          duration: duration / 2,
          startTime: duration / 2,
          dependsOn: [modifier]
        });
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        result.push(firstHalf, false);
        result.push(modifier, false);
        result.push(secondHalf, false);
        result.setStartTime(startTime);
        return result;
      }
      addEdgeTransition(edgeData, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let edge = UI$1.createElement(GraphEdge, _extends({
          graph: this,
          data: edgeData
        }, edgeData.options, {
          opacity: 0
        }));
        let addEdgeModifier = new Modifier({
          func: () => {
            this.options.edges.push(edge.options.data);
            this.edgeGroup.appendChild(edge);
          },
          reverseFunc: () => {
            eraseFirst(this.options.edges, edge.options.data);
            this.edgeGroup.eraseChild(edge, !inMovie);
          },
          startTime: transitionList.getLength()
        });
        transitionList.add(addEdgeModifier, false);
        transitionList.add(edge.changeOpacityTransition(1, duration, [addEdgeModifier], transitionList.getLength()), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      addNodeTransition(nodeData, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        nodeData = nodeData || {};
        nodeData.center = nodeData.center || {
          x: Math.random() * this.options.box.width + this.options.box.x,
          y: Math.random() * this.options.box.height + this.options.box.y
        };
        let nodeOptions = Object.assign({}, this.options.nodeOptions, nodeData.options);
        let node = UI$1.createElement(GraphNode, _extends({
          graph: this,
          data: nodeData
        }, nodeOptions, {
          opacity: 0
        }));
        let addNodeModifier = new Modifier({
          func: () => {
            this.options.nodes.push(node.options.data);
            this.nodeGroup.appendChild(node);
          },
          reverseFunc: () => {
            eraseFirst(this.options.nodes, node.options.data);
            this.nodeGroup.eraseChild(node, !inMovie);
          },
          startTime: transitionList.getLength()
        });
        transitionList.add(addNodeModifier, false);
        transitionList.add(node.changeOpacityTransition(1, duration, [addNodeModifier], transitionList.getLength()), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      removeEdgeTransition(edge, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let changeOpacityTransition = edge.changeOpacityTransition(0, duration, [], transitionList.getLength());
        transitionList.add(changeOpacityTransition, false);
        transitionList.add(new Modifier({
          func: () => {
            eraseFirst(this.options.edges, edge.options.data);
            this.edgeGroup.eraseChild(edge, !inMovie);
          },
          reverseFunc: () => {
            this.options.edges.unshift(edge.options.data);
            this.edgeGroup.appendChild(edge);
          },
          dependsOn: [changeOpacityTransition],
          startTime: transitionList.getLength()
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      removeNodeTransition(node, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;

        // Remove incident edges
        let edges = node.getIncidentEdges();
        let edgeOpacityStartTime = transitionList.getLength();
        for (let edge of edges) {
          transitionList.add(this.removeEdgeTransition(edge, duration, [], edgeOpacityStartTime, inMovie), false);
        }

        // Change node opacity
        let nodeOpacityTransition = node.changeOpacityTransition(0, duration, [], transitionList.getLength());
        transitionList.add(nodeOpacityTransition, false);
        transitionList.add(new Modifier({
          func: context => {
            context["nodeIndex"] = this.nodes.indexOf(node);
            eraseFirst(this.options.nodes, node.options.data);
            this.nodeGroup.eraseChild(node, !inMovie);
            for (let edge of this.edges) {
              if (edge.options.data.source > context["nodeIndex"]) {
                edge.options.data.source -= 1;
              }
              if (edge.options.data.target > context["nodeIndex"]) {
                edge.options.data.target -= 1;
              }
            }
          },
          reverseFunc: context => {
            this.options.nodes.splice(context["nodeIndex"], 0, node.options.data);
            this.nodeGroup.options.children.splice(context["nodeIndex"], 0, node);
            node.mount(this.nodeGroup, null);
            for (let edge of this.edges) {
              if (edge.options.data.source >= context["nodeIndex"]) {
                edge.options.data.source += 1;
              }
              if (edge.options.data.target >= context["nodeIndex"]) {
                edge.options.data.target += 1;
              }
            }
          },
          context: {},
          dependsOn: [nodeOpacityTransition],
          startTime: transitionList.getLength()
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      showLabelsTransition(duration, dependsOn = [], startTime = 0) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let showLabelsStartTime = transitionList.getLength();
        for (let node of this.nodes) {
          transitionList.add(node.label.changeOpacityTransition(1, duration, [], showLabelsStartTime), false);
        }
        transitionList.setStartTime(startTime);
        return transitionList;
      }
    }
    class GraphSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 300,
          height: 200
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }
      setOptions(options) {
        super.setOptions(options);
      }
      render() {
        //TODO: do NOT use {...this.options} in a new object
        return [UI$1.createElement(Graph, _extends({
          ref: "graph"
        }, this.options, {
          box: {
            x: 0,
            y: 0,
            width: this.options.width,
            height: this.options.height
          }
        }))];
      }
    }

    class PieChartSector extends SVG.Group {
      getDefaultOptions() {
        return {
          startOpacity: 0.65,
          endOpacity: 1,
          hoverTime: 250,
          displayPercent: true
        };
      }
      setOptions(options) {
        super.setOptions(options);
        // This is overwritten to make opacity attribute the same as the startOpacity option
        this.options.opacity = this.options.opacity || this.options.startOpacity;
      }
      getArcPoint(angle, radius, orientation) {
        let spacing = this.options.spacing;
        let center = this.options.center;
        let line = lineEquation(center, polarToCartesian(angle, radius, center));

        // TODO: This binary search can be replaced by O(1) formula
        let left = 0,
          right = Math.PI / 2;
        for (let step = 0; step < 20; ++step) {
          let mid = (left + right) / 2;
          let dist = distancePointLine(polarToCartesian(angle + (orientation === 1 ? 1 : -1) * mid, radius, center), line);
          if (dist > spacing / 2) {
            right = mid;
          } else {
            left = mid;
          }
        }
        return polarToCartesian(angle + (orientation === 1 ? 1 : -1) * left, radius, center);
      }
      getPath(outerExtra = 0, innerExtra = -1) {
        if (innerExtra === -1) {
          innerExtra = outerExtra / 2;
        }
        let startAngle = this.options.startAngle;
        let angleSpan = this.options.angleSpan;
        let innerRadius = this.options.innerRadius + innerExtra;
        let outerRadius = this.options.outerRadius + outerExtra;
        let innerStartPoint = this.getArcPoint(startAngle, innerRadius, 1);
        let innerEndPoint = this.getArcPoint(startAngle + angleSpan, innerRadius, -1);
        let outerStartPoint = this.getArcPoint(startAngle, outerRadius, 1);
        let outerEndPoint = this.getArcPoint(startAngle + angleSpan, outerRadius, -1);
        let largeArcFlag = angleSpan <= Math.PI ? 0 : 1;
        return "M " + innerStartPoint.x + " " + innerStartPoint.y + " " + "A " + innerRadius + " " + innerRadius + " 0 " + largeArcFlag + " 1 " + innerEndPoint.x + " " + innerEndPoint.y + "L " + outerEndPoint.x + " " + outerEndPoint.y + " " + "A " + outerRadius + " " + outerRadius + " 0 " + largeArcFlag + " 0 " + outerStartPoint.x + " " + outerStartPoint.y + "Z";
      }
      getMiddlePoint(outerExtra = 0, innerExtra = -1) {
        if (innerExtra === -1) {
          innerExtra = outerExtra / 2;
        }
        let startAngle = this.options.startAngle;
        let angleSpan = this.options.angleSpan;
        let innerRadius = this.options.innerRadius + innerExtra;
        let outerRadius = this.options.outerRadius + outerExtra;
        return this.getArcPoint(startAngle + angleSpan / 2, (innerRadius + outerRadius) / 2, -1);
      }
      changeRadiusTransition(extra, duration) {
        return new Transition$1({
          func: t => {
            this.path.setPath(this.getPath(t * extra));
            let middlePoint = this.getMiddlePoint(t * extra);
            if (this.options.displayPercents) {
              this.label.setPosition(middlePoint.x, middlePoint.y);
            }
          },
          duration: duration
        });
      }
      render() {
        let children = [UI$1.createElement(SVG.Path, {
          ref: "path",
          d: this.getPath(),
          fill: this.options.pathFill
        })];
        if (this.options.displayPercents) {
          children.push(UI$1.createElement(SVG.Text, _extends({
            ref: "label",
            text: this.options.label || (this.options.percent * 100).toFixed(1) + "%"
          }, this.getMiddlePoint(), {
            color: "white",
            fill: "white"
          })));
        }
        return children;
      }
      onMount() {
        this.addNodeListener("mouseenter", () => {
          this.changeOpacityTransition(this.options.endOpacity, this.options.hoverTime).start();
          this.changeRadiusTransition(this.options.hoverExpandRadius, this.options.hoverTime).start();
          if (typeof this.options.mouseenterCallback === "function") {
            this.options.mouseenterCallback();
          }
        });
        this.addNodeListener("mouseout", () => {
          this.changeOpacityTransition(this.options.startOpacity, this.options.hoverTime).start();
          this.changeRadiusTransition(0, this.options.hoverTime).start();
          if (typeof this.options.mouseoutCallback === "function") {
            this.options.mouseoutCallback();
          }
        });
      }
    }
    class PieChart extends SVG.Group {
      getDefaultOptions() {
        return {
          innerRadius: 40,
          outerRadius: 60,
          hoverExpandRadius: 10,
          startAngle: Math.PI * 3 / 2,
          spacing: 2,
          sectorExtraOptions: {}
        };
      }
      render() {
        let pieChartSectors = [];
        let totalSize = 0;
        for (let sector of this.options.sectors) {
          totalSize += sector.size;
        }
        let currentAngle = this.options.startAngle;
        for (let sector of this.options.sectors) {
          let angleSpan = 2 * Math.PI * sector.size / totalSize;
          pieChartSectors.push(UI$1.createElement(PieChartSector, _extends({
            startAngle: currentAngle,
            angleSpan: angleSpan,
            innerRadius: this.options.innerRadius,
            outerRadius: this.options.outerRadius,
            hoverExpandRadius: this.options.hoverExpandRadius,
            center: this.options.center,
            spacing: this.options.spacing,
            pathFill: sector.color,
            percent: sector.size / totalSize
          }, this.options.sectorExtraOptions, sector)));
          currentAngle += angleSpan;
        }
        return pieChartSectors;
      }
    }
    class PieChartSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 240,
          height: 240,
          innerRadius: 50,
          outerRadius: 100,
          hoverExpandRadius: 20,
          sectorExtraOptions: {}
        };
      }
      extraNodeAttributes(attr) {
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
      }
      render() {
        return [UI$1.createElement(PieChart, {
          center: {
            x: this.options.width / 2,
            y: this.options.height / 2
          },
          innerRadius: this.options.innerRadius,
          outerRadius: this.options.outerRadius,
          hoverExpectedRadius: this.options.hoverExpandRadius,
          sectorExtraOptions: this.options.sectorExtraOptions,
          sectors: this.options.sectors
        })];
      }
    }

    class SVGHandDrawnCircle extends SVG.Element {
      getNodeType() {
        return "path";
      }
      getDefaultOptions() {
        return {
          minDeltaR: 0.1,
          // When the circle overlaps, the R decides the
          maxDeltaR: 0.1,
          // ratio between the diameter of the circle and the
          // "imperfection" at its union, and DeltaR is the
          // difference between R and 1 (bigger -> more like a spiral)

          minStartingAngle: 0,
          // Where the overlapping starts (0-360)
          maxStartingAngle: 0,
          minOverlap: 0.15,
          // How much the circle goes over itself (ratio to circumference)
          maxOverlap: 0.15,
          minSquash: 0.7,
          // How alike it is to an ellipse (1 is perfectly circular)
          maxSquash: 0.7,
          minSquashAngle: 150,
          // Angle of the axis by which its elliptical
          maxSquashAngle: 150,
          r: 19,
          // Radius

          x: 0,
          // Center
          y: 0,
          fill: "transparent",
          stroke: "black",
          strokeWidth: "2px"
        };
      }
      setParameters(parameters) {
        Object.assign(this.options, parameters);
        this.setAttribute("d", this.getPath());
        this.setAttribute("transform", this.getTransform());
      }
      setCenter(x, y) {
        this.options.x = x;
        this.options.y = y;
        this.setAttribute("transform", this.getTransform());
      }
      setRadius(r) {
        this.options.r = r;
        this.setAttribute("d", this.getPath());
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getPath());
        attr.setAttribute("transform", this.getTransform());
        return attr;
      }
      getPath() {
        let r = this.options.r;
        let dR1 = this.options.minDeltaR;
        let dR2 = this.options.maxDeltaR;
        let minAngle = this.options.minStartingAngle;
        let maxAngle = this.options.maxStartingAngle;
        let minDAngle = this.options.minOverlap;
        let maxDAngle = this.options.maxOverlap;
        let c = 0.551915024494;
        let beta = Math.atan(c);
        let d = Math.sqrt(c * c + 1);
        let alpha = (minAngle + Math.random() * (maxAngle - minAngle)) * Math.PI / 180;
        let path = 'M' + [r * Math.sin(alpha), r * Math.cos(alpha)];
        path += ' C' + [d * r * Math.sin(alpha + beta), d * r * Math.cos(alpha + beta)];
        for (let i = 0; i < 4; i += 1) {
          let dAngle = minDAngle + Math.random() * (maxDAngle - minDAngle);
          alpha += Math.PI / 2 * (1 + dAngle);
          r *= 1 + dR1 + Math.random() * (dR2 - dR1);
          path += ' ' + (i ? 'S' : '') + [d * r * Math.sin(alpha - beta), d * r * Math.cos(alpha - beta)];
          path += ' ' + [r * Math.sin(alpha), r * Math.cos(alpha)];
        }
        return path;
      }
      getTransform() {
        let minL = this.options.minSquash;
        let maxL = this.options.maxSquash;
        let minAlpha = this.options.minSquashAngle;
        let maxAlpha = this.options.maxSquashAngle;
        let alpha = minAlpha + Math.random() * (maxAlpha - minAlpha);
        let lambda = minL + Math.random() * (maxL - minL);
        return 'translate(' + [this.options.x, this.options.y] + ') ' + 'rotate(' + alpha + ') scale(1, ' + lambda + ') rotate(' + -alpha + ')';
      }
    }
    class SVGPartiallyFilledCircle extends SVG.Group {
      getDefaultOptions() {
        return {
          strokeWidth: 1,
          angle: 0
        };
      }
      getTransform() {
        return "translate(" + this.options.circleAttr.center.x + "," + this.options.circleAttr.center.y + ") " + "rotate(" + this.options.angle + ")" + "translate(-" + this.options.circleAttr.center.x + ",-" + this.options.circleAttr.center.y + ") ";
      }
      render() {
        return [UI$1.createElement(SVG.Circle, _extends({}, this.options.circleAttr, {
          stroke: this.options.color,
          fill: this.options.color
        })), UI$1.createElement(SVG.ClipPath, {
          id: "clipPath"
        }, UI$1.createElement(SVG.Rect, {
          fill: this.options.color,
          x: this.options.circleAttr.center.x - this.options.circleAttr.radius,
          y: this.options.circleAttr.center.y - this.options.circleAttr.radius,
          height: 2 * this.options.circleAttr.radius * (1 - this.options.percent),
          width: 2 * this.options.circleAttr.radius
        })), UI$1.createElement(SVG.Circle, {
          clipPath: "url(#clipPath)",
          radius: this.options.circleAttr.radius - 2 * this.options.strokeWidth,
          center: this.options.circleAttr.center,
          fill: "#FFF"
        })];
      }
    }
    class SVGVisualMatrix extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          cellSize: 45,
          n: 0,
          m: 0,
          matrix: [],
          rectAttr: {
            fill: "transparent",
            stroke: "black"
          },
          textAttr: {}
        };
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.height = this.options.cellSize * this.options.n;
        this.options.width = this.options.cellSize * this.options.m;
        for (let i = 0; i < this.options.matrix.length; i += 1) {
          while (this.options.matrix[i].length < this.options.m) {
            this.options.matrix[i].push(0);
          }
        }
        if (this.options.matrix.length < this.options.n) {
          for (let i = this.options.matrix.length; i <= this.options.n; i += 1) {
            this.options.matrix.push(new Array(this.options.m));
            this.options.matrix[i].fill(0);
          }
        }
      }
      render() {
        let n = this.options.n,
          m = this.options.m,
          cellSize = this.options.cellSize;
        let cells = [];
        for (let i = 0; i < n; i += 1) {
          for (let j = 0; j < m; j += 1) {
            cells.push(UI$1.createElement(SVG.Group, null, UI$1.createElement(SVG.Rect, _extends({
              x: j * cellSize,
              y: i * cellSize,
              width: cellSize,
              height: cellSize
            }, this.options.rectAttr)), UI$1.createElement(SVG.Text, _extends({
              x: (j + 0.5) * cellSize,
              y: (i + 0.5) * cellSize,
              text: this.options.matrix[i][j]
            }, this.options.textAttr))));
          }
        }
        return UI$1.createElement(SVG.Group, null, cells);
      }
    }
    class SVGGrid extends SVG.Group {
      getDefaultOptions() {
        return {
          xZones: 1,
          yZones: 1,
          rectAttr: {
            fill: "transparent",
            stroke: "black"
          },
          axisAttr: {
            stroke: "grey",
            strokeWidth: 1
          }
        };
      }
      render() {
        let children = [UI$1.createElement(SVG.Rect, _extends({}, this.options.rectAttr, {
          x: this.options.x,
          y: this.options.y,
          height: this.options.height,
          width: this.options.width
        }))];
        let xZoneSize = this.options.width / this.options.xZones;
        let yZoneSize = this.options.height / this.options.yZones;
        for (let i = 1; i < this.options.yZones; i += 1) {
          children.push(UI$1.createElement(SVG.Line, _extends({
            x1: this.options.x,
            x2: this.options.x + this.options.width,
            y1: this.options.y + i * yZoneSize,
            y2: this.options.y + i * yZoneSize
          }, this.options.axisAttr)));
        }
        for (let i = 1; i < this.options.xZones; i += 1) {
          children.push(UI$1.createElement(SVG.Line, _extends({
            y1: this.options.y,
            y2: this.options.y + this.options.height,
            x1: this.options.x + i * xZoneSize,
            x2: this.options.x + i * xZoneSize
          }, this.options.axisAttr)));
        }
        return children;
      }
    }

    MarkupClassMap.addClass("LocalizedTime", LocalizedTime);
    MarkupClassMap.addClass("Definition", Definition);
    MarkupClassMap.addClass("Graph", GraphSVG);
    MarkupClassMap.addClass("User", UserHandle$1);
    MarkupClassMap.addClass("Submission", SubmissionSummaryMarkup);
    MarkupClassMap.addClass("Emoji", Emoji);
    MarkupClassMap.addClass("Latex", Latex);
    MarkupClassMap.addClass("Geometry", CSAGeometryWidgetSVG);
    MarkupClassMap.addClass("Table", MarkupTable);

    // TODO: this should be added only in about page ( & Analysis article )
    MarkupClassMap.addClass("PLTable", ProgrammingLanguageTable);
    MarkupClassMap.addClass("DemoMarkupEditor", DemoMarkupEditor);
    MarkupClassMap.addClass("EvalTasksSolutionsWidget", EvalTasksSolutionsWidget);
    MarkupClassMap.addClass("QuestionnaireButton", QuestionnaireButton);
    MarkupClassMap.addClass("YoutubeVideo", YoutubeIframe);
    MarkupClassMap.addClass("PieChart", PieChartSVG);
    MarkupClassMap.addClass("HandDrawnCircle", SVGHandDrawnCircle);
    MarkupClassMap.addClass("PartiallyFilledCircle", SVGPartiallyFilledCircle);
    MarkupClassMap.addClass("VisualMatrix", SVGVisualMatrix);
    MarkupClassMap.addClass("Grid", SVGGrid);

    class ChatGraph extends Graph {
      setOptions(options) {
        let maxAllowedNodes = 16;
        if (options.nodes) {
          while (options.nodes.length > maxAllowedNodes) {
            options.nodes.pop();
          }
        }
        if (options.edges) {
          for (let i = 0; i < options.edges.length; ++i) {
            if (options.edges[i].source >= maxAllowedNodes || options.edges[i].target >= maxAllowedNodes) {
              options.edges.splice(i, 1);
              --i;
            }
          }
        }
        options.idlePauseThreshold = 1;
        super.setOptions(options);
      }
    }
    class ChatGraphSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 300,
          height: 300
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }
      setOptions(options) {
        delete options.style;
        super.setOptions(options);
        this.options.height = Math.min(this.options.height, 400);
        this.options.width = Math.min(this.options.width, 400);
      }
      render() {
        return [UI$1.createElement(SVG.Rect, {
          ref: "borderRect",
          x: 0,
          y: 0,
          width: this.options.width,
          height: this.options.height,
          stroke: "gray",
          fill: "white"
        }), UI$1.createElement(ChatGraph, _extends({
          ref: "graph"
        }, this.options, {
          box: {
            x: 0,
            y: 0,
            width: this.options.width,
            height: this.options.height
          }
        }))];
      }
      onMount() {}
    }
    ChatMarkupRenderer.classMap.addClass("Graph", ChatGraphSVG);

    const Logout = {
      logout: () => {
        Ajax.postJSON("/accounts/logout/", {}).then(() => location.reload());
      }
    };

    const FRONT_PAGE_CHAT_ID = 2;
    const INTERVIEWS_ARCHIVE_ID = 3;
    const ALGORITHMS_ARCHIVE_ID = 1;
    const ABOUT_ARTICLES = [{
      articleId: 141,
      title: "Environment",
      url: "environment"
    }, {
      articleId: 137,
      title: "Markup",
      url: "markup"
    }, {
      articleId: 147,
      title: "Contests",
      url: "contests"
    }, {
      articleId: 149,
      title: "Workspace Tutorial",
      url: "workspace-tutorial"
    }, {
      articleId: 148,
      title: "Rating",
      url: "rating"
    }, {
      articleId: 1124,
      title: "Problem Setting",
      url: "problem-setting"
    }, {
      articleId: 354,
      title: "T&C",
      url: "terms-and-conditions"
    }];

    // Social authentication app settings
    window.FACEBOOK_MANAGER_OPTIONS = {
      appId: "375510855971020"
    };
    window.GOOGLE_MANAGER_OPTIONS = {
      clientId: "469601560740-qk0ngdqb8fl07thec3jq9cpjt4k7ver2.apps.googleusercontent.com"
    };

    class LoadingPoints extends UI$1.Primitive("span") {
      getContent() {
        let content = "";
        for (let i = 0; i < this.points; i += 1) {
          content += ".";
        }
        return content;
      }
      onMount() {
        this.points = 1;
        this.node.textContent = this.getContent();
        this.intervalId = setInterval(() => {
          this.points = this.points % 4 + 1;
          this.node.textContent = this.getContent();
        }, 350);
      }
      onUnmount() {
        clearInterval(this.intervalId);
      }
    }
    class NavGroupChatWidget extends GroupChatWidget {
      render() {
        return [UI$1.createElement("div", {
          ref: "messageContainer",
          style: {
            flex: "5",
            overflowY: "auto"
          }
        }, this.renderMessageView()), this.renderMessageBox()];
      }
      renderMessageBox() {
        let messageBox = super.renderMessageBox();
        messageBox.setStyle({
          flex: "1",
          minHeight: "50px",
          maxHeight: "100px",
          height: ""
        });
        return messageBox;
      }
      observeMutations() {
        let node = this.messageContainer.node;
        let observer = new MutationObserver(mutations => {
          for (let mutation of mutations) {
            if (mutation.addedNodes.length) {
              if (node.scrollHeight - node.scrollTop - this.messageContainer.getHeight() < 100) {
                setTimeout(() => {
                  node.scrollTop = node.scrollHeight;
                }, 10);
                return;
              }
            }
          }
        });
        observer.observe(node, {
          subtree: true,
          childList: true
        });
      }
      handleResize() {
        let scroll = false;
        if (this.messageContainer.node.scrollHeight - this.messageContainer.node.scrollTop - this.messageContainer.getHeight() < 100) {
          scroll = true;
        }
        if (scroll) {
          this.messageContainer.node.scrollTop = this.messageContainer.node.scrollHeight;
        }
      }
      addResizeListeners() {
        this.handleResize();
        NavManager.Global.addListener("changedAccordion", () => {
          this.handleResize();
        });
        window.addEventListener("resize", () => {
          this.handleResize();
        });
        this.observeMutations();
      }
      onMount() {
        super.onMount();
        this.chatInput.setStyle("height", "100%");
        this.applyScrollPosition();
      }
    }
    class NavGlobalChat extends DelayedElement(UI$1.Element) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("position", "relative");
      }
      beforeRedrawNotLoaded() {
        Dispatcher.Global.addListener("initNavManagerDone", () => {
          if (NavManager.Global.rightSidePanel.visible) {
            this.setLoaded();
          }
          NavManager.Global.addListener("toggledRightSide", visible => {
            if (visible) {
              this.setLoaded();
            }
          });
        });
      }
      renderNotLoaded() {
        return [UI$1.createElement("div", {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            textTransform: "uppercase"
          }
        }, UI$1.createElement(LoadingPoints, {
          style: {
            opacity: 0
          }
        }), " Loading ", UI$1.createElement(LoadingPoints, null))];
      }
      renderLoaded() {
        let messageThread = GroupChatStore.get(FRONT_PAGE_CHAT_ID).getMessageThread();
        let groupChatStyle = {
          marginLeft: "0px",
          marginRight: "0px",
          width: "100%",
          height: "100%",
          overflow: "hidden",
          position: "absolute"
        };
        return [UI$1.createElement(NavGroupChatWidget, {
          style: groupChatStyle,
          extraHeightOffset: 75,
          ref: "chat",
          chatId: FRONT_PAGE_CHAT_ID,
          messageThread: messageThread
        })];
      }
      setLoaded() {
        if (this._loaded) {
          return;
        }
        GroupChatStore.fetch(FRONT_PAGE_CHAT_ID, () => {
          super.setLoaded();
        });
      }
      onDelayedMount() {
        this.chat.messageContainer.node.scrollTop = this.chat.messageContainer.node.scrollHeight;
        this.onlineUsers = this.chat.messageThread.online || new Set();
        this.dispatch("updateOnlineUsers");
        this.attachChangeListener(this.chat.messageThread, () => {
          this.onlineUsers = this.chat.messageThread.online;
          this.dispatch("updateOnlineUsers");
        });
      }
    }

    class BlogEntry extends StoreObject {
      getArticle() {
        return ArticleStore.get(this.articleId);
      }
    }
    class BlogEntryStoreClass extends GenericObjectStore {
      constructor(objectType = "BlogEntry", ObjectClass = BlogEntry) {
        super(objectType, ObjectClass, {
          dependencies: ["Article"]
        });
      }
      getEntryForURL(urlName) {
        return this.all().find(blogEntry => blogEntry.urlName === urlName);
      }
    }
    const BlogEntryStore = new BlogEntryStoreClass();

    class Forum extends StoreObject {
      constructor() {
        super(...arguments);
        this.forumThreads = new Map();
        // TODO: not appropriate to register to streams here
        GlobalState$1.registerStream(this.getStreamName());
        ForumThreadStore.addDeleteListener(forumThread => {
          if (forumThread.parentId === this.id && this.forumThreads.has(forumThread.id)) {
            this.deleteForumThread(forumThread);
          }
        });
      }
      getStreamName() {
        return "forum-" + this.id;
      }
      getForumThreads() {
        let forumThreads = Array.from(this.forumThreads.values());
        // Filter out hidden forum threads
        forumThreads = forumThreads.filter(forumThread => forumThread.isVisible());
        forumThreads.sort((a, b) => {
          return b.id - a.id;
        });
        return forumThreads;
      }
      addForumThread(forumThread, event) {
        this.forumThreads.set(forumThread.id, forumThread);
        this.dispatch("newForumThread", event);
      }
      deleteForumThread(forumThread) {
        this.forumThreads.delete(forumThread.id);
        this.dispatch("deleteForumThread", forumThread);
      }
    }
    var ForumStore = new GenericObjectStore("forum", Forum);
    class ForumThread extends StoreObject {
      constructor(obj) {
        super(obj);
        let parent = this.getParent();
        parent && parent.addForumThread(this);
      }
      getAuthor() {
        return PublicUserStore.get(this.authorId);
      }
      isPinned() {
        return this.pinnedIndex != null;
      }
      getPinIndex() {
        return this.pinnedIndex;
      }
      getTitle() {
        return this.title;
      }
      getContentMessage() {
        return MessageInstanceStore.get(this.contentMessageId);
      }
      getVotesBalance() {
        let message = this.getContentMessage();
        if (message) {
          return message.getVotesBalance();
        }
        return this.votesBalance;
      }
      getParent() {
        return ForumStore.get(this.parentId);
      }
      getMessageThread() {
        return MessageThreadStore.get(this.messageThreadId);
      }
      getTimeAdded() {
        // TODO: maybe return formatted time
        return this.timeAdded;
      }
      getLastActive() {
        return this.lastActive;
      }
      getNumReplies() {
        return this.getNumMessages() - 1;
      }
      deleteThread(onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/forum/edit_forum_thread/", {
          forumThreadId: this.id,
          hidden: true
        }).then(onSuccess, onError);
      }
      getNumMessages() {
        return this.numMessages;
      }
      isVisible() {
        return !this.hidden;
      }
      isLoaded() {
        // TODO: this needs to be fixed to support dynamic loading
        // console.warn(this.getNumReplies(), this.getMessageThread().getNumMessages());
        return this.getMessageThread() != null && this.getNumReplies() === this.getMessageThread().getNumMessages() - 1;
      }
    }
    const ForumThreadStore = new GenericObjectStore("forumthread", ForumThread, {
      dependencies: ["forum", "messageinstance"]
    });

    class Lesson extends StoreObject {
      getArticle() {
        let baseArticle = ArticleStore.get(this.articleId);
        return baseArticle.getTranslation();
      }
    }
    const LessonStore = new GenericObjectStore("lesson", Lesson, {
      dependencies: ["article", "lessonSection"]
    });
    class LessonSection extends StoreObject {
      getLessons() {
        return LessonStore.all().filter(lesson => lesson.sectionId === this.id);
      }
    }
    const LessonSectionStore = new GenericObjectStore("lessonSection", LessonSection);

    var _class$15, _descriptor$w, _descriptor2$t, _descriptor3$o, _descriptor4$l, _descriptor5$j, _descriptor6$g, _descriptor7$c;
    let NavRecentActivityStyle = (_class$15 = class NavRecentActivityStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.sectionHeight = "20px";
        this.fontFamily = "lato, open sans";
        this.defaultFontSize = ".9em";
        this.pinnedIconFontSize = "1em";
        this.titleFontSize = "1.2em";
        this.activityFontSize = ".9em";
        this.hoverBackgroundColor = "#f8f8f8";
        _initializerDefineProperty(this, "panel", _descriptor$w, this);
        _initializerDefineProperty(this, "pinnedIcon", _descriptor2$t, this);
        _initializerDefineProperty(this, "title", _descriptor3$o, this);
        _initializerDefineProperty(this, "type", _descriptor4$l, this);
        _initializerDefineProperty(this, "bottomSection", _descriptor5$j, this);
        _initializerDefineProperty(this, "timeStamp", _descriptor6$g, this);
        _initializerDefineProperty(this, "bottomRightSection", _descriptor7$c, this);
      }
    }, (_descriptor$w = _applyDecoratedDescriptor(_class$15.prototype, "panel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          border: "1px solid #ddd",
          borderTop: "0px",
          borderLeft: "0",
          borderRight: "0",
          backgroundColor: "#fff",
          fontFamily: this.fontFamily,
          fontSize: this.defaultFontSize,
          display: "block",
          ":hover": {
            backgroundColor: this.hoverBackgroundColor
          }
        };
      }
    }), _descriptor2$t = _applyDecoratedDescriptor(_class$15.prototype, "pinnedIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          display: "inline-block",
          float: "left",
          height: "60px",
          paddingTop: "28px",
          paddingRight: "8px",
          fontSize: this.pinnedIconFontSize
        };
      }
    }), _descriptor3$o = _applyDecoratedDescriptor(_class$15.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "12px",
          paddingBottom: "0",
          display: "flex",
          justifyContent: "flex-start",
          alignItems: "center",
          fontSize: this.titleFontSize
        };
      }
    }), _descriptor4$l = _applyDecoratedDescriptor(_class$15.prototype, "type", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "block"
        };
      }
    }), _descriptor5$j = _applyDecoratedDescriptor(_class$15.prototype, "bottomSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            display: "inline-block !important"
          },
          ">:first-child": {
            marginRight: "4px"
          },
          position: "relative",
          marginTop: "8px",
          marginBottom: "8px",
          padding: "0px 14px"
        };
      }
    }), _descriptor6$g = _applyDecoratedDescriptor(_class$15.prototype, "timeStamp", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.activityFontSize,
          height: this.sectionHeight,
          color: "#aaa !important",
          textStyle: "italic",
          marginRight: "6px"
        };
      }
    }), _descriptor7$c = _applyDecoratedDescriptor(_class$15.prototype, "bottomRightSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "right"
        };
      }
    })), _class$15);

    var _dec$M, _class$14, _dec2$g, _class2$z;
    let ActivityEntry = (_dec$M = registerStyle(NavRecentActivityStyle), _dec$M(_class$14 = class ActivityEntry extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.panel);
      }
      getTitle() {
        return this.options.title;
      }
      getPreview() {
        return this.options.preview;
      }
      getAuthorId() {
        return this.options.authorId;
      }
      getTimeStamp() {
        return this.options.timeStamp;
      }
      getType() {
        return this.options.type;
      }
      render() {
        const author = this.getAuthorId() ? UI$1.createElement(UserHandle$1, {
          userId: this.getAuthorId()
        }) : null;
        return [UI$1.createElement("div", {
          className: this.styleSheet.title,
          ref: "title"
        }, this.getTitle()), this.getPreview(), UI$1.createElement("div", {
          className: this.styleSheet.bottomSection
        }, UI$1.createElement("span", {
          className: this.styleSheet.type
        }, this.getType()), author, UI$1.createElement("span", {
          className: this.styleSheet.bottomRightSection
        }, UI$1.createElement(TimePassedSpan, {
          timeStamp: this.getTimeStamp(),
          className: this.styleSheet.timeStamp
        })))];
      }
      onMount() {
        const navManagerInstance = NavManager.Global;
        this.title.addClickListener(() => {
          if (navManagerInstance.rightSidePanel && navManagerInstance.rightSidePanel.visible) {
            navManagerInstance.toggleRightSidePanel();
          }
        });
      }
    }) || _class$14);
    let MiniForumThread = (_dec2$g = registerStyle(NavRecentActivityStyle), _dec2$g(_class2$z = class MiniForumThread extends ActivityEntry {
      getThread() {
        return this.options.thread;
      }
      getTitle() {
        let pinned;
        if (this.getThread().isPinned()) {
          pinned = UI$1.createElement("span", {
            className: "fa fa-thumb-tack " + this.styleSheet.pinnedIcon,
            "aria-hidden": "true",
            style: {
              paddingTop: "0",
              lineHeight: "20px",
              height: "20px"
            }
          });
        }
        return [pinned, UI$1.createElement(Link, {
          href: "/forum/" + this.getThread().id + "/" + slugify(this.getThread().title),
          value: this.getThread().title
        })];
      }
      getAuthorId() {
        return this.getThread().authorId;
      }
      getTimeStamp() {
        return this.getThread().getLastActive();
      }
      getType() {
        return UI$1.createElement(Label, {
          level: Level.SUCCESS,
          label: "Forum"
        });
      }
    }) || _class2$z);
    class MiniBlogEntry extends ActivityEntry {
      getEntry() {
        return this.options.entry;
      }
      getTitle() {
        return UI$1.createElement(Link, {
          href: "/blog/" + this.getEntry().urlName + "/",
          value: this.getEntry().getArticle().name
        });
      }
      getAuthorId() {
        return this.getEntry().getArticle().userCreatedId;
      }
      getTimeStamp() {
        return this.getEntry().lastActive;
      }
      getType() {
        return UI$1.createElement(Label, {
          level: Level.PRIMARY,
          label: "Blog"
        });
      }
    }
    class MiniEvalTask extends ActivityEntry {
      getTask() {
        return this.options.task;
      }
      getTitle() {
        return UI$1.createElement(Link, {
          href: "/contest/" + this.getTask().archiveName + "/task/" + this.getTask().urlName + "/discussion/",
          value: this.getTask().toString()
        });
      }
      getTimeStamp() {
        return this.getTask().lastActive;
      }
      getType() {
        return UI$1.createElement(Label, {
          level: Level.WARNING,
          label: "Task"
        });
      }
      onMount() {
        super.onMount();
        this.title.addClickListener(() => {
          window.taskView = true;
        });
      }
    }
    class MiniLesson extends ActivityEntry {
      getLesson() {
        return this.options.lesson;
      }
      getTitle() {
        return UI$1.createElement(Link, {
          href: "/lesson/" + this.getLesson().urlName + "/",
          value: this.getLesson().name
        });
      }
      getTimeStamp() {
        return this.getLesson().lastActive;
      }
      getType() {
        return UI$1.createElement(Label, {
          level: Level.PRIMARY,
          label: "Lesson"
        });
      }
    }
    class NavRecentActivity extends DelayedElement(UI$1.Element) {
      getActivityPosts() {
        const recentForumActivity = ForumThreadStore.all().filter(thread => {
          return thread.getLastActive() > 0;
        }).sort((thread1, thread2) => {
          return -thread1.getLastActive() + thread2.getLastActive();
        }).slice(0, 5).map(thread => {
          return {
            uiElement: UI$1.createElement(MiniForumThread, {
              thread: thread
            }),
            time: thread.getLastActive()
          };
        });
        const recentBlogActivity = BlogEntryStore.all().filter(entry => {
          return entry.lastActive > 0;
        }).sort((entry1, entry2) => {
          return -entry1.lastActive + entry2.lastActive;
        }).slice(0, 5).map(entry => {
          return {
            uiElement: UI$1.createElement(MiniBlogEntry, {
              entry: entry
            }),
            time: entry.lastActive
          };
        });
        const recentEvalTasksActivity = EvalTaskStore.all().filter(task => {
          return task.lastActive > 0;
        }).sort((task1, task2) => {
          return -task1.lastActive + task2.lastActive;
        }).slice(0, 5).map(task => {
          return {
            uiElement: UI$1.createElement(MiniEvalTask, {
              task: task
            }),
            time: task.lastActive
          };
        });
        const recentLessonsActivity = LessonStore.all().filter(lesson => {
          return lesson.lastActive > 0;
        }).sort((lesson1, lesson2) => {
          return -lesson1.lastActive + lesson2.lastActive;
        }).slice(0, 5).map(lesson => {
          return {
            uiElement: UI$1.createElement(MiniLesson, {
              lesson: lesson
            }),
            time: lesson.lastActive
          };
        });
        return recentForumActivity.concat(recentBlogActivity).concat(recentEvalTasksActivity).concat(recentLessonsActivity).sort((element1, element2) => {
          return -element1.time + element2.time;
        }).map(element => element.uiElement);
      }
      beforeRedrawNotLoaded() {
        Dispatcher.Global.addListener("initNavManagerDone", () => {
          if (NavManager.Global.rightSidePanel.visible) {
            this.setLoaded();
          }
          NavManager.Global.addListener("toggledRightSide", visible => {
            if (visible) {
              this.setLoaded();
            }
          });
        });
      }
      renderLoaded() {
        return this.getActivityPosts();
      }
      renderNotLoaded() {
        return UI$1.createElement(ConcentricCirclesLoadingScreen, null);
      }
      setLoaded() {
        if (this._loaded) {
          return;
        }
        Ajax.getJSON("/recent_activity/", {}).then(() => super.setLoaded(), () => super.setLoaded());
      }
    }

    class ArticleTabArea extends TabArea {
      getDefaultOptions() {
        return {
          autoActive: false,
          path: "/"
        };
      }
      getArticleUrl(articleEntry) {
        let url = this.options.path;
        if (!url.endsWith("/")) {
          url += "/";
        }
        return url + articleEntry.url + "/";
      }
      onSetActive(articleEntry) {
        this.switcherArea.setActiveArticleId(articleEntry.articleId);
        Router.changeURL(this.getArticleUrl(articleEntry));
      }
      getInitialPanel() {
        return UI$1.createElement("h3", null, "Welcome to the \"About\" page. Click on any of the above tabs to find more information on the desired topic.");
      }
      getSwitcher(tabPanels) {
        return UI$1.createElement(ArticleSwitcher, {
          ref: "switcherArea",
          lazyRender: this.options.lazyRender,
          style: {
            margin: "1em"
          }
        }, this.getInitialPanel());
      }
      createTabPanel(articleEntry) {
        let tab = UI$1.createElement(BasicTabTitle, {
          panel: articleEntry,
          title: articleEntry.title,
          activeTabDispatcher: this.activeTabDispatcher,
          href: this.getArticleUrl(articleEntry),
          styleSheet: this.styleSheet
        });
        return [tab, articleEntry];
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.children = this.options.children.map(x => Object.assign(new Dispatchable(), x));
      }
      setURL(urlParts) {
        for (let articleEntry of this.options.children) {
          if (articleEntry.url === urlParts[0]) {
            articleEntry.dispatch("show"); // so that the tab title also known to set itself active
            return;
          }
        }
      }
    }

    var _dec$L, _class$13, _dec2$f, _class2$y;

    // TODO move this to the regular markup class
    let BlogArticleRenderer = (_dec$L = registerStyle(BlogArticleRendererStyle), _dec$L(_class$13 = class BlogArticleRenderer extends ArticleRenderer {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.blogArticleRenderer);
      }
    }) || _class$13);
    let BlogQuote = (_dec2$f = registerStyle(BlogArticleRendererStyle), _dec2$f(_class2$y = class BlogQuote extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          marginTop: 20,
          marginBottom: 20
        });
      }
      render() {
        const {
          value,
          source
        } = this.options;
        return [UI$1.createElement("div", {
          className: this.styleSheet.quote
        }, UI$1.createElement("div", {
          style: {
            "flex-grow": "1000000",
            "min-width": "10%",
            "display": "inline-block"
          }
        }), UI$1.createElement("div", {
          style: {
            "flex-grow": "1",
            display: "inline-block"
          }
        }, value)), source && UI$1.createElement("div", {
          style: {
            textAlign: "right"
          }
        }, source)];
      }
    }) || _class2$y);
    MarkupClassMap.addClass("Quote", BlogQuote);

    class LogoElectron extends SVG.Circle {
      updateCenter(baseAngle) {
        let angle = baseAngle + this.options.angleOffset;
        let x = this.options.nucleusCenter.x + Math.sin(angle) * this.options.outerRadius;
        let y = this.options.nucleusCenter.y + Math.cos(angle) * this.options.outerRadius;
        this.setCenter(x, y);
      }
    }
    class OuterLayer extends SVG.Group {
      getElectrons() {
        let electrons = [];
        for (let i = 0; i < this.options.electronCount; i += 1) {
          electrons.push(UI$1.createElement(LogoElectron, {
            ref: this.refLinkArray("electrons", i),
            radius: this.options.electronRadius,
            angleOffset: i * Math.PI * 2 / this.options.electronCount,
            outerRadius: this.options.radius,
            nucleusCenter: this.options.center,
            fill: "black"
          }));
        }
        return electrons;
      }
      render() {
        return [UI$1.createElement(SVG.Circle, {
          radius: this.options.radius,
          center: this.options.center,
          fill: "transparent",
          stroke: "black",
          strokeWidth: this.options.strokeWidth
        }), this.getElectrons()];
      }
      recalcElectrons(seed) {
        const angleOffset = this.options.radius * Math.PI % 1; //randomish
        let baseAngle = -(seed * this.options.electronSpeed) / 2000 + angleOffset;
        for (let electron of this.electrons) {
          electron.updateCenter(baseAngle);
        }
      }
    }
    class CSAAtomLogo extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.options = Object.assign({
          version: 7,
          electronSpeed: [1, 0.8, 0.5, 0.24, 0.1]
        }, this.options);
        const LAYER_MAX_SIZE = [2, 8, 18, 18, 18];
        let electronCount = [],
          numElectrons = this.options.version;
        let ringCount = 0;
        for (; ringCount < LAYER_MAX_SIZE.length && numElectrons; ringCount += 1) {
          const numElectronsOnLayer = Math.min(numElectrons, LAYER_MAX_SIZE[ringCount]);
          electronCount.push(numElectronsOnLayer);
          numElectrons -= numElectronsOnLayer;
        }
        this.options.ringCount = ringCount;
        this.options.electronCount = electronCount;
        this.setSize(this.options.size);
      }
      setSize(size, doRedraw) {
        if (!size) {
          console.error("You need to specify a size for the logo!");
        }
        this.size = size;
        this.nucleusCenter = {
          x: size / 2,
          y: size / 2
        };
        const scalingFactor = Math.log2(this.options.ringCount + 1);
        this.nucleusRadius = 0.08 * size / scalingFactor;
        this.electronRadius = 0.034 * size / scalingFactor;
        this.electronRingStrokeWidth = 0.01 * size / scalingFactor;
        this.maxRadius = 0.4 * size;
        if (doRedraw) {
          this.redraw();
        }
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.size + "px");
        attr.setStyle("width", this.size + "px");
        return attr;
      }
      getRings() {
        let rings = [];
        for (let i = 0; i < this.options.ringCount; i += 1) {
          rings.push(UI$1.createElement(OuterLayer, {
            ref: this.refLinkArray("rings", i),
            center: this.nucleusCenter,
            radius: (i + 1) * this.maxRadius / this.options.ringCount,
            strokeWidth: this.electronRingStrokeWidth,
            electronRadius: this.electronRadius,
            electronCount: this.options.electronCount[i],
            electronSpeed: this.options.electronSpeed[i]
          }));
        }
        return rings;
      }
      render() {
        return [this.getRings(), UI$1.createElement(SVG.Circle, {
          ref: "nucleusCircle",
          center: this.nucleusCenter,
          radius: this.nucleusRadius,
          fill: "black"
        })];
      }
      onMount() {
        this.redrawOrbitAnimation = () => {
          if (!this.isInDocument()) {
            return;
          }
          let seed = Date.now();
          for (let ring of this.rings) {
            ring.recalcElectrons(seed);
          }
          requestAnimationFrame(this.redrawOrbitAnimation);
        };
        requestAnimationFrame(this.redrawOrbitAnimation);
      }
    }
    class CSALogo extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          size: 500,
          color: Theme.props.COLOR_PRIMARY || "black",
          background: "transparent"
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setAttribute("height", this.options.size + "px");
        attr.setAttribute("width", this.options.size + "px");
        attr.setAttribute("preserveAspectRatio", "none");
        attr.setAttribute("viewBox", "0 0 500 500");
      }
      render() {
        let scale = 50;
        let center = 250;
        return [UI$1.createElement(SVG.Group, {
          ref: "circlesGroup"
        }, UI$1.createElement(SVG.Circle, {
          radius: 1.15 * scale,
          center: {
            x: 5 * scale,
            y: 1.25 * scale
          },
          strokeWidth: "0",
          stroke: this.options.color,
          fill: this.options.color
        }), UI$1.createElement(SVG.Circle, {
          radius: 1.15 * scale,
          center: {
            x: 5 * scale,
            y: 1.25 * scale
          },
          strokeWidth: "0",
          stroke: this.options.color,
          fill: this.options.color,
          transform: `rotate(240,${center},${center})`
        }), UI$1.createElement(SVG.Circle, {
          radius: 1.15 * scale,
          center: {
            x: 5 * scale,
            y: 1.25 * scale
          },
          strokeWidth: "0",
          stroke: this.options.color,
          fill: this.options.color,
          transform: `rotate(120,${center},${center})`
        })), UI$1.createElement(SVG.Group, {
          ref: "triangleGroup"
        }, UI$1.createElement(SVG.Path, {
          stroke: this.options.color,
          strokeWidth: scale,
          d: `M${5 * scale},${(5 - 1.6 * Math.sqrt(3) * 2 / 3) * scale}L${(5 - 1.6 * 1) * scale},${(5 + 1.6 * Math.sqrt(3) / 3) * scale}L${(5 + 1.6) * scale},${(5 + 1.6 * Math.sqrt(3) / 3) * scale}z`,
          fill: this.options.background
        })), UI$1.createElement(SVG.Group, {
          ref: "linesGroup"
        }, UI$1.createElement(SVG.Rect, {
          stroke: this.options.color,
          strokeWidth: "0",
          x: 4.5 * scale,
          y: 1 * scale,
          width: 1 * scale,
          height: 3 * scale,
          fill: this.options.color
        }), UI$1.createElement(SVG.Rect, {
          stroke: this.options.color,
          strokeWidth: "0",
          x: 4.5 * scale,
          y: 1 * scale,
          width: 1 * scale,
          height: 3 * scale,
          fill: this.options.color,
          transform: `rotate(240,${center},${center})`
        }), UI$1.createElement(SVG.Rect, {
          stroke: this.options.color,
          strokeWidth: "0",
          x: 4.5 * scale,
          y: 1 * scale,
          width: 1 * scale,
          height: 3 * scale,
          fill: this.options.color,
          transform: `rotate(120,${center},${center})`
        }))];
      }
    }
    class CSALoadingLogo extends CSALogo {
      easeFunction(t) {
        if (t < 0) {
          t = 0;
        }
        if (t > 1) {
          t = 1;
        }
        t *= 2.0;
        if (t < 1) return 0.5 * t * t + 0;
        t--;
        return -0.5 * (t * (t - 2) - 1) + 0;
      }
      onMount() {
        let speed = 0.05;
        let totalRotation = 0;
        let totalEase = 0;
        let animateRotation = () => {
          totalRotation += speed;
          if (totalRotation >= 1) {
            totalRotation = 0;
            totalEase += 60;
            // change = true;
          }
          let currentEase = this.easeFunction(totalRotation) * 60;
          let center = 250;
          this.circlesGroup.setAttribute("transform", `rotate(${totalEase + currentEase},${center},${center})`);
          this.triangleGroup.setAttribute("transform", `rotate(${-(totalEase + currentEase)},${center},${center})`);
          this.linesGroup.setAttribute("transform", `rotate(${totalEase + currentEase},${center},${center})`);
          {
            this.animationFrame = requestAnimationFrame(animateRotation);
          }
        };
        this.animationFrame = requestAnimationFrame(animateRotation);
      }
      onUnmount() {
        cancelAnimationFrame(this.animationFrame);
      }
    }
    class CSAAboutPage extends UI$1.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.EXTRA_SMALL);
      }
      render() {
        return [UI$1.createElement(ArticleTabArea, {
          variableHeightPanels: true,
          ref: "articleTabArea",
          path: "/about"
        }, ABOUT_ARTICLES), UI$1.createElement("hr", null), UI$1.createElement("div", {
          style: {
            "text-align": "center"
          }
        }, UI$1.createElement("h2", null, "CS Academy version ", UI$1.createElement("strong", null, "Nitrogen")), UI$1.createElement(CSAAtomLogo, {
          size: 300
        }))];
      }
      setURL(urlParts) {
        this.articleTabArea.setURL(urlParts);
      }
    }
    class BlogAtomLogo extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center"
        });
      }
      render() {
        return UI$1.createElement(CSAAtomLogo, this.options);
      }
    }
    BlogArticleRenderer.markupClassMap.addClass("CSAAtomLogo", BlogAtomLogo);

    class Notification extends UI$1.Element {
      getNodeType() {
        return "li";
      }
      getNotificationClass() {
        return "";
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("padding", "10px");
        attr.setStyle("borderBottom", "1px solid #ddd");
        attr.setStyle("textAlign", "right");
        attr.addClass(this.getNotificationClass());
        return attr;
      }
      getChildrenToRender() {
        return [UI$1.createElement("div", {
          style: {
            textAlign: "initial"
          }
        }, this.render()), UI$1.createElement(TimePassedSpan, {
          timeStamp: this.options.notification.dateCreated
        })];
      }
    }
    class RatingNotification extends Notification {
      getNotificationClass() {
        return "ratingNotification";
      }
      render() {
        let oldRating = this.options.notification.data.oldRating;
        let newRating = this.options.notification.data.newRating;
        if (oldRating < newRating) {
          return ["Congratulations! Your rating has increased by ", UI$1.createElement("span", {
            style: {
              color: "green"
            }
          }, newRating - oldRating), " points ", UI$1.createElement(Emoji, {
            value: "smile"
          }), ". Keep it up!"];
        } else {
          return ["Your rating has decreased by ", UI$1.createElement("span", {
            style: {
              color: "red"
            }
          }, oldRating - newRating), " points ", UI$1.createElement(Emoji, {
            value: "disappointed"
          }), ". Better luck next time!", UI$1.createElement(Emoji, {
            value: "smiley"
          })];
        }
      }
    }
    class AnnouncementNotification extends Notification {
      getNotificationClass() {
        return "announcementNotification";
      }
      render() {
        return UI$1.createElement(MarkupRenderer, {
          value: this.options.notification.data.value
        });
      }
    }
    class NotificationsList extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%",
          width: "100%",
          lineHeight: "normal",
          overflow: "auto",
          backgroundColor: "#fff",
          // padding: "8px",
          color: "#262626"
        });
      }
      constructor(options) {
        super(options);
        this.unreadNotificationsCount = 0;
        this.notificationsCount = 0;
        this.displayedNotifications = new Set();
      }
      render() {
        if (this.options.children.length == 0) {
          this.options.children.push(UI$1.createElement("div", {
            style: {
              cursor: "default",
              textAlign: "center",
              fontSize: "1.05em",
              height: "30px",
              lineHeight: "30px"
            }
          }, "You don't have any notifications."));
        }
        return this.options.children;
      }
      getStoredNotifications() {
        Ajax.getJSON("/accounts/get_user_notifications/", {});
      }
      insertChild(child, position) {
        position = position || 0;
        this.options.children.splice(position, 0, child);
        child.mount(this, position + 1 < this.options.children.length ? this.children[position + 1].node : null);
        return child;
      }
      handleNewNotification(notification) {
        if (this.displayedNotifications.has(notification)) {
          return;
        }
        if (!notification.isRead()) {
          this.options.icon.increaseUnreadNotificationsCount();
        }
        let NotificationClass = this.constructor.NotificationClassMap.get(notification.type);
        if (!NotificationClass) {
          console.error("There is no notification class for ", notification.type);
          return;
        }
        let notificationElement = UI$1.createElement(NotificationClass, {
          notification: notification
        });
        this.notificationsCount += 1;
        if (this.notificationsCount === 1) {
          this.options.children = [notificationElement];
          this.redraw();
        } else {
          this.insertChild(notificationElement, 0);
        }
        this.displayedNotifications.add(notification);
      }
      onMount() {
        this.getStoredNotifications();
        for (let notification of UserNotificationStore.all().sort((x, y) => {
          return x.dateCreated - y.dateCreated;
        })) {
          this.handleNewNotification(notification);
        }
        this.attachCreateListener(UserNotificationStore, notification => {
          this.handleNewNotification(notification);
        });
      }
    }
    NotificationsList.NotificationClassMap = new Map([["ratingsChange", RatingNotification], ["announcement", AnnouncementNotification]]);

    var _class$12, _descriptor$v, _descriptor2$s;
    let MessagesPanelListStyle = (_class$12 = class MessagesPanelListStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.descriptionFontSize = "1.05em";
        _initializerDefineProperty(this, "messagesPanelList", _descriptor$v, this);
        _initializerDefineProperty(this, "textInputStyle", _descriptor2$s, this);
      }
    }, (_descriptor$v = _applyDecoratedDescriptor(_class$12.prototype, "messagesPanelList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#fff",
          display: "flex",
          flexDirection: "column"
        };
      }
    }), _descriptor2$s = _applyDecoratedDescriptor(_class$12.prototype, "textInputStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#eee",
          border: "0",
          width: "85%",
          height: "30px",
          lineHeight: "30px",
          display: "inline-block",
          float: "left",
          outline: "none"
        };
      }
    })), _class$12);

    var _dec$K, _class$11;
    const formatMiniMessageLastTime = timeStamp => {
      const presentTimeStamp = StemDate.now();
      const fullDateFormat = "DD/MM/YYYY";
      if (presentTimeStamp.format(fullDateFormat) === timeStamp.format(fullDateFormat)) {
        return timeStamp.format("HH:mm");
      } else if (presentTimeStamp.getYear() === timeStamp.getYear()) {
        if (presentTimeStamp.getWeekInYear() === timeStamp.getWeekInYear()) {
          return timeStamp.format("ddd");
        } else {
          return timeStamp.format("MMM Do");
        }
      } else {
        return timeStamp.format(fullDateFormat);
      }
    };
    function getUserMessagesUrl(userId) {
      return "/messages/" + userId + "/";
    }
    class MiniMessage extends UI$1.Element {
      getDefaultOptions() {
        return {
          hoverColor: "rgba(0, 0, 0, .05)",
          backgroundColorActive: "#3373b7"
        };
      }
      getPrivateChat() {
        return PrivateChatStore.get(this.options.privateChatId);
      }
      getMessageThread() {
        return this.getPrivateChat().getMessageThread();
      }
      getLastMessage() {
        return this.getMessageThread().getLastMessage() || {
          content: "",
          timeAdded: 0,
          id: "0"
        };
      }
      getUserId() {
        return this.getPrivateChat().getOtherUserId();
      }
      isLastMessageRead() {
        return !this.getPrivateChat().firstUnreadMessage[USER.id];
      }
      extraNodeAttributes(attr) {
        attr.setStyle({
          padding: "10px",
          borderBottom: "1px solid #ddd",
          whiteSpace: "nowrap",
          color: this.isLastMessageRead() ? this.options.active ? "white" : "black" : this.options.active ? "white" : "red",
          backgroundColor: this.options.active ? this.options.backgroundColorActive : ""
        });
      }
      render() {
        return [UI$1.createElement(UserHandle$1, {
          ref: "userHandle",
          id: this.getUserId(),
          noPopup: true,
          color: this.options.active ? "white" : null
        }), UI$1.createElement("div", {
          ref: "timeAttribute",
          className: "pull-right",
          style: {
            color: this.options.active ? "white" : "#888"
          }
        }, this.getLastMessage().timeAdded !== 0 ? formatMiniMessageLastTime(new StemDate(this.getLastMessage().timeAdded)) : ""), UI$1.createElement("div", {
          style: {
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            paddingTop: "8px"
          }
        }, this.getLastMessage().content)];
      }
      setActive(active = true) {
        if (this.options.active === active) {
          return;
        }
        this.updateOptions({
          active
        });
      }
      setAsRead(forceAjax = false) {
        if (!forceAjax && this.isLastMessageRead()) {
          return;
        }
        Ajax.postJSON("/chat/private_chat_mark_read/", {
          privateChatId: this.options.privateChatId
        }).then(() => {}, () => {});
      }
      onMount() {
        this.addClickListener(() => {
          this.setAsRead();
          this.options.list.dispatch("messageSelected", this.getUserId());
        });
        this.attachListener(this.getMessageThread(), "newMessage", () => {
          this.redraw();
          this.options.list.redraw();
          if (this.options.active) {
            this.setAsRead(true);
          } else {
            this.options.list.recalculateTotalUnread();
          }
        });
        this.attachEventListener(this.getPrivateChat(), "updateFirstUnreadMessage", () => {
          this.redraw();
          this.options.list.recalculateTotalUnread();
        });
      }
    }
    class UserSearchInput extends UI$1.Element {
      getDefaultOptions() {
        return {
          style: {
            width: "100%"
          }
        };
      }
      render() {
        let windowStyle = {
          position: "absolute",
          maxWidth: "300px",
          maxHeight: "300px",
          overflow: "auto",
          marginTop: "30px",
          backgroundColor: "#eee"
        };
        return [UI$1.createElement(FAIcon, {
          icon: "search",
          style: {
            display: "inline-block",
            backgroundColor: "#eee",
            color: "#999",
            width: "15%",
            height: "30px",
            textAlign: "center",
            float: "left",
            lineHeight: "30px",
            cursor: "pointer"
          },
          onClick: () => {
            this.input.node.focus();
            this.input.node.select();
          }
        }), UI$1.createElement(TextInput, {
          ref: "input",
          className: this.options.textInputStyle || "",
          placeholder: this.options.placeholder || ""
        }), UI$1.createElement(VolatileFloatingWindow, {
          className: "searchList",
          style: windowStyle,
          ref: "window"
        })];
      }
      updateList(listItems) {
        if (!listItems) {
          this.window.options.children = "";
          this.window.redraw();
          return;
        }
        let divStyle = {
          paddingLeft: "7px",
          paddingRight: "7px",
          paddingTop: "2px",
          paddingBottom: "2px"
        };
        let list = [];
        for (let i = 0; i < listItems.length; i += 1) {
          let chooseUser = () => {
            this.input.setValue(listItems[i].username);
            this.window.hide();
            this.dispatch("userChosen", listItems[i].id);
          };
          list.push(UI$1.createElement("div", {
            style: divStyle,
            onClick: chooseUser
          }, listItems[i].username));
        }
        this.window.options.children = list;
        this.window.redraw();
      }
      onMount() {
        this.input.addNodeListener("keyup", () => {
          this.window.show();
          if (this.input.getValue()) {
            Ajax.getJSON(PublicUserStore.fetchURL, {
              usernamePrefix: this.input.getValue()
            }).then(data => this.updateList(data.state.publicuser), () => {});
          } else {
            this.updateList();
          }
        });
      }
    }
    class MessagesList extends UI$1.Element {
      constructor(options) {
        super(options);
        this.miniMessages = [];
        this.unreadMessages = 0;
      }
      getMiniMessages() {
        this.miniMessages = [];
        for (let privateChat of PrivateChatStore.all()) {
          let userId = privateChat.getOtherUserId();
          let miniMessage = UI$1.createElement(MiniMessage, {
            active: userId === this.activeUserId,
            list: this,
            privateChatId: privateChat.id
          });
          this.miniMessages.push(miniMessage);
        }
        this.miniMessages.sort((a, b) => {
          return -parseInt(a.getLastMessage().timeAdded) + parseInt(b.getLastMessage().timeAdded);
        });
        return this.miniMessages;
      }
      render() {
        return UI$1.createElement("div", {
          style: {
            width: "100%",
            height: "100%",
            position: "relative"
          }
        }, UI$1.createElement("div", {
          ref: "miniMessagesList",
          style: {
            position: "absolute",
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          }
        }, this.getMiniMessages()));
      }
      setActiveMiniMessage(userId) {
        this.activeUserId = userId;
        this.redraw();
      }
      recalculateTotalUnread() {
        this.unreadMessages = 0;
        for (let miniMessage of this.miniMessages) {
          if (!miniMessage.isLastMessageRead()) {
            this.unreadMessages += 1;
          }
        }
        this.dispatch("unreadCountChanged", this.unreadMessages);
      }
      refreshList() {
        Ajax.getJSON("/chat/private_chat_list/", {}).then(() => {
          this.redraw();
          this.recalculateTotalUnread();
        });
      }
      onMount() {
        this.refreshList();
      }
    }
    class IconMessagesList extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          lineHeight: "normal",
          backgroundColor: "#fff",
          width: "100%",
          height: "100%",
          overflow: "auto",
          maxWidth: "100%",
          position: "absolute",
          right: "0px",
          display: "flex",
          flexDirection: "column"
        });
      }
      render() {
        return [UI$1.createElement(MessagesList, {
          ref: "messagesList",
          style: {
            flex: "1",
            overflow: "auto"
          }
        }), UI$1.createElement("div", {
          style: {
            textAlign: "center",
            width: "100%",
            padding: "0.5em",
            borderTop: "1px solid #ddd"
          }
        }, UI$1.createElement(Link, {
          href: "/messages/",
          newTab: false,
          value: "View all messages"
        }))];
      }
      onMount() {
        this.attachListener(this.messagesList, "unreadCountChanged", value => {
          this.dispatch("unreadCountChanged", value);
        });
        this.attachListener(this.messagesList, "messageSelected", userId => {
          window.open(getUserMessagesUrl(userId));
        });
      }
    }
    let MessagesPanelList = (_dec$K = registerStyle(MessagesPanelListStyle), _dec$K(_class$11 = class MessagesPanelList extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.messagesPanelList);
      }
      render() {
        return [UI$1.createElement("div", {
          style: {
            padding: "16px",
            paddingRight: "50px",
            height: "62px",
            borderBottom: "1px solid #ddd"
          }
        }, UI$1.createElement(UserSearchInput, {
          ref: "userSearchInput",
          textInputStyle: this.styleSheet.textInputStyle,
          placeholder: "Search for user"
        })), UI$1.createElement(MessagesList, {
          ref: "messagesList",
          style: {
            flex: "1",
            overflow: "auto"
          }
        })];
      }
      setActiveMiniMessage(userId) {
        this.messagesList.setActiveMiniMessage(userId);
      }
      routeToUser(userId) {
        Router.changeURL(getUserMessagesUrl(userId));
      }
      onMount() {
        this.attachListener(this.userSearchInput, "userChosen", userId => {
          this.routeToUser(userId);
          this.messagesList.refreshList();
        });
        this.attachListener(this.messagesList, "messageSelected", userId => {
          this.setActiveMiniMessage(userId);
          this.dispatch("userChanged", userId);
          this.routeToUser(userId);
        });
      }
    }) || _class$11);
    class PrivateChatWidgetWrapper extends UI$1.Element {
      render() {
        const privateChat = PrivateChatStore.getChatWithUser(parseInt(this.options.userId));
        if (privateChat) {
          let widgetStyle = {
            marginLeft: "0px",
            marginRight: "0px",
            width: "100%",
            paddingLeft: "0px !important",
            paddingRight: "0px !important",
            height: "100%"
          };
          if (this.options.style && this.options.style.height) {
            widgetStyle.height = this.options.style.height;
          }
          return UI$1.createElement(PrivateChatWidget, {
            ref: "chat",
            style: widgetStyle,
            extraHeightOffset: 75,
            privateChat: privateChat
          });
        }
        PrivateChatStore.fetchForUser(this.options.userId, privateChat => {
          this.updateOptions({
            privateChat
          });
          this.chat.messageWindow.scrollToBottom();
        });
        return [UI$1.createElement("h3", null, "Chat loading..."), UI$1.createElement("span", {
          className: "fa fa-spinner fa-spin"
        })];
      }
      onMount() {
        this.addListener("hide", () => {
          this.chat && this.chat.dispatch("hide");
        });
        this.addListener("show", () => {
          this.chat && this.chat.dispatch("show");
        });
      }
    }
    class DelayedPrivateChat extends Router {
      getNoChat() {
        return UI$1.createElement("h3", {
          style: {
            marginTop: "40px",
            textAlign: "center"
          }
        }, "Click on a chat box to start a conversation.");
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getNoChat(), [new Route("%s", options => {
          return UI$1.createElement(PrivateChatWidgetWrapper, {
            userId: parseInt(options.args[0]),
            style: {
              height: "100%"
            }
          });
        })]);
        return this.routes;
      }
    }
    class MessagesPanel extends UI$1.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          border: "1px solid #ddd",
          height: "100%",
          maxWidth: "1280px",
          margin: "0 auto",
          position: "relative"
        });
      }
      setURL(urlParts) {
        this.messagesPanelList.setActiveMiniMessage(parseInt(urlParts[0]));
        this.chatWidget.setURL(urlParts);
      }
      render() {
        return [UI$1.createElement("div", {
          style: {
            display: "inline-flex",
            height: "100%",
            overflow: "hidden",
            position: "relative"
          }
        }, UI$1.createElement(MessagesPanelList, {
          ref: "messagesPanelList",
          style: {
            height: "100%",
            overflow: "auto",
            width: "250px",
            borderRight: "1px solid #ddd",
            transition: "margin .7s ease"
          }
        })), UI$1.createElement(Button$1, {
          ref: "collapseButton",
          size: Size.SMALL,
          icon: "chevron-left",
          level: Level.PRIMARY,
          style: {
            position: "absolute",
            top: "15px",
            left: "208px",
            zIndex: "2017",
            transition: "all .7s ease"
          }
        }), UI$1.createElement(DelayedPrivateChat, {
          style: {
            display: "inline-block",
            flex: "1",
            width: "calc(100% - 250px)",
            height: "100%",
            transition: "width .7s ease",
            verticalAlign: "top"
          },
          ref: "chatWidget"
        })];
      }
      onMount() {
        //TODO: use classes here
        this.collapseButton.addClickListener(() => {
          if (!this.collapsed) {
            this.messagesPanelList.setStyle("marginLeft", "-250px");
            this.collapseButton.setIcon("chevron-right");
            this.collapseButton.setStyle("left", "8px");
            this.collapseButton.setStyle("opacity", ".3");
            this.chatWidget.setWidth("100%");
            this.collapsed = true;
          } else {
            this.messagesPanelList.setStyle("marginLeft", "0");
            this.collapseButton.setIcon("chevron-left");
            this.collapseButton.setStyle("left", "208px");
            this.collapseButton.setStyle("opacity", "1");
            this.chatWidget.setWidth("calc(100% - 250px)");
            this.collapsed = false;
          }
        });
      }
    }

    class MessagesIcon extends NavIcon {
      setOptions(options) {
        super.setOptions(options);
        this.count = 0;
      }
      render() {
        this.iconMessagesList = this.iconMessagesList || UI$1.createElement(IconMessagesList, null);
        return [this.iconMessagesList];
      }
      getIcon() {
        return UI$1.createElement(FAIcon, {
          icon: "envelope",
          size: Size.LARGE
        });
      }
      getContent() {
        return UI$1.createElement(Badge, {
          ref: this.refLink("messagesCount"),
          style: {
            backgroundColor: "crimson",
            bottom: "5px",
            marginLeft: "-9px",
            marginTop: "15px",
            position: "absolute"
          },
          className: "hidden"
        });
      }
      updateUnreadCount(count) {
        if (!this.messagesCount) {
          return;
        }
        this.count = count;
        this.messagesCount.options.children = count;
        this.messagesCount.options.className = count ? "" : "hidden";
        this.messagesCount.redraw();
        this.dispatch("changeTabCount");
      }
      onMount() {
        super.onMount();
        this.iconMessagesList.addListener("unreadCountChanged", value => {
          this.updateUnreadCount(value);
        });
        this.addClickListener(() => {
          this.parent.dispatch("changeSwitcher", this.iconMessagesList || UI$1.createElement(IconMessagesList, null), this);
        });
      }
    }
    class NotificationsIcon extends NavIcon {
      setOptions(options) {
        super.setOptions(options);
        this.unreadNotificationsCount = 0;
        this.count = 0;
      }
      render() {
        return [UI$1.createElement(NotificationsList, {
          icon: this
        })];
      }
      getIcon() {
        return UI$1.createElement(FAIcon, {
          icon: "bell",
          size: Size.LARGE
        });
      }
      getContent() {
        return UI$1.createElement(Badge, {
          ref: this.refLink("notificationsCount"),
          style: {
            backgroundColor: "crimson",
            bottom: "5px",
            marginLeft: "-9px",
            marginTop: "15px",
            position: "absolute"
          },
          className: "hidden"
        });
      }
      setUnreadNotificationsCount(count) {
        if (!this.notificationsCount) {
          return;
        }
        this.count = count;
        this.notificationsCount.options.children = count;
        this.notificationsCount.options.className = count ? "" : "hidden";
        this.notificationsCount.redraw();
        this.dispatch("changeTabCount");
      }
      setNotificationsAsRead() {
        Ajax.postJSON("/accounts/set_user_notifications_read", {}).then(() => this.setUnreadNotificationsCount(0), () => {});
      }
      increaseUnreadNotificationsCount() {
        if (this.isToggled) {
          this.setNotificationsAsRead();
        } else {
          this.unreadNotificationsCount += 1;
          this.setUnreadNotificationsCount(this.unreadNotificationsCount);
        }
      }
      onMount() {
        super.onMount();
        this.attachChangeListener(UserStore.getCurrentUser(), event => {
          if (event.type === "lastReadNotification") {
            this.unreadNotificationsCount = 0;
            this.setUnreadNotificationsCount(this.unreadNotificationsCount);
          }
        });
        this.addClickListener(() => {
          this.notificationsList = this.notificationsList || UI$1.createElement(NotificationsList, {
            icon: this
          });
          this.isToggled = !this.isToggled;
          this.parent.dispatch("changeSwitcher", this.notificationsList, this);
          if (this.isToggled) {
            this.setNotificationsAsRead();
          }
        });
      }
    }
    class LanguagesIcon extends NavElement {
      static addLanguage(language, flagEmoji) {
        if (!language) {
          return;
        }
        if (isString(language)) {
          language = Language.getLanguageForCode(language);
        }
        if (flagEmoji) {
          language.flagEmoji = flagEmoji;
        }
        this.Languages.push(language);
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("white-space", "nowrap");
      }
      getDefaultOptions() {
        return {
          value: UI$1.createElement(Emoji, {
            height: "1.8em",
            width: "1.8em",
            value: Language.Locale.flagEmoji
          })
        };
      }
      render() {
        let languagesList = [];
        for (let language of this.constructor.Languages) {
          let onLanguageSelect = () => {
            this.setLanguage(language);
            this.options.value = UI$1.createElement(Emoji, {
              height: "1.8em",
              width: "1.8em",
              value: language.flagEmoji
            });
            this.redraw();
          };
          languagesList.push(UI$1.createElement(NavElement, {
            onClick: onLanguageSelect,
            value: [UI$1.createElement(Emoji, {
              height: "1.8em",
              width: "1.8em",
              value: language.flagEmoji
            }), language.toString()]
          }));
        }
        // TODO: this is done like this since orientation isn't passed along the context (like theme should be).
        return UI$1.createElement(BasicOrientedElement, {
          style: {
            marginLeft: -40
          }
        }, languagesList);
      }
      setLanguage(language) {
        Language.setLocale(language);
        let request = {
          localeLanguageId: language.id
        };
        Ajax.postJSON("/accounts/profile_changed/", request).then(() => {}, () => {});
      }
      onMount() {
        super.onMount();
        setTimeout(() => {
          this.options.value = UI$1.createElement(Emoji, {
            height: "1.8em",
            width: "1.8em",
            value: Language.Locale.flagEmoji
          });
          this.redraw();
        });
      }
    }
    LanguagesIcon.Languages = [];
    window.GLOBAL_LANGUAGES = window.GLOBAL_LANGUAGES || [[Language.ENGLISH, "flag_gb"], [Language.ROMANIAN, "flag_ro"], [Language.RUSSIAN, "flag_ru"], [Language.ARABIC, "flag_ara"]];
    window.GLOBAL_LANGUAGES.forEach(args => LanguagesIcon.addLanguage(...args));
    class WebsocketStatusIcon extends NavElement {
      setOptions(options) {
        options.value = [UI$1.createElement(FAIcon, {
          icon: "circle",
          style: {
            color: "#d99a01",
            marginRight: "10px"
          }
        }), UI$1.T("Connecting")];
        super.setOptions(options);
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("cursor", "default");
        return attr;
      }
      onMount() {
        let setIconStatus = () => {
          let connectionStatus = WebsocketSubscriber.Global.connectionStatus;
          let statusTypes = WebsocketSubscriber.ConnectionStatus;
          switch (connectionStatus) {
            case statusTypes.CONNECTED:
              {
                this.options.value[0].setStyle("color", "#417a5a");
                this.options.value[1] = UI$1.T("Connected");
                break;
              }
            case statusTypes.CONNECTING:
              {
                this.options.value[0].setStyle("color", "#d99a01");
                this.options.value[1] = UI$1.T("Connecting");
                break;
              }
            case statusTypes.DISCONNECTED:
              {
                this.options.value[0].setStyle("color", "#d64144");
                this.options.value[1] = UI$1.T("Disconnected");
              }
          }
          this.redraw();
        };
        WebsocketSubscriber.Global.addListener("connectionStatus", () => {
          setIconStatus();
        });
        setIconStatus();
      }
    }

    var _class$10, _descriptor$u, _dec$J, _class2$x, _class3$f, _descriptor2$r;
    let PersistentAccordionStyle = (_class$10 = class PersistentAccordionStyle extends AccordionStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "accordion", _descriptor$u, this);
      }
    }, (_descriptor$u = _applyDecoratedDescriptor(_class$10.prototype, "accordion", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:nth-of-type(odd)": {
            color: NavStyle.getInstance().colors.text,
            transition: `background-color ${NavStyle.getInstance().dimensions.backgroundTransitionDuration}`,
            ":hover": {
              backgroundColor: NavStyle.getInstance().colors.sidepanelHover
            }
          }
        };
      }
    })), _class$10);
    let PersistentAccordion = (_dec$J = registerStyle(PersistentAccordionStyle), _dec$J(_class2$x = class PersistentAccordion extends Accordion {
      constructor(...args) {
        super(...args);
        this.sessionManager = navSessionManager;
      }
      onMount() {
        super.onMount();
        let childrenStatus = this.sessionManager.get(this.options.sessionKey);
        if (childrenStatus) {
          this.setChildrenStatus(childrenStatus);
        } else {
          this.setChildrenStatus(this.getDefaultChildrenStatus());
        }
        this.addListener("childrenStatusChange", () => {
          this.sessionManager.set(this.options.sessionKey, this.getChildrenStatus());
          NavManager.Global.dispatch("changedAccordion");
        });
        this.addListener("dragging", () => {
          NavManager.Global.dispatch("changedAccordion");
        });
      }
    }) || _class2$x);
    let OnlineButtonStyle = (_class3$f = class OnlineButtonStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "online", _descriptor2$r, this);
      }
    }, (_descriptor2$r = _applyDecoratedDescriptor(_class3$f.prototype, "online", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          height: "calc(1em + 16px)",
          padding: "8px",
          top: 0,
          position: "absolute",
          right: 0,
          color: enhance(this.themeProps.COLOR_PRIMARY, 1),
          cursor: "pointer",
          backgroundColor: enhance(this.themeProps.COLOR_PRIMARY, .2),
          ":hover": {
            backgroundColor: enhance(this.themeProps.COLOR_PRIMARY, .3)
          }
        };
      }
    })), _class3$f);
    class CSANavManager extends NavManager {
      getRightFixed() {
        if (USER.isAuthenticated) {
          return [UI$1.createElement(NavAnchoredNotifications, {
            anchor: Direction.RIGHT
          }, UI$1.createElement(LanguagesIcon, null), UI$1.createElement(MessagesIcon, null), UI$1.createElement(NotificationsIcon, null))];
        } else {
          return [UI$1.createElement(NavSection, {
            anchor: Direction.RIGHT
          }, UI$1.createElement(LanguagesIcon, null), UI$1.createElement(NavElement, {
            value: [UI$1.createElement(FAIcon, {
              icon: "sign-in",
              style: Object.assign({}, {
                fontSize: "170%",
                paddingRight: "6px",
                width: "auto",
                verticalAlign: "middle"
              })
            }), UI$1.T("Sign in")],
            style: {
              textTransform: "uppercase"
            },
            onClick: () => LoginModal.show()
          }))];
        }
      }
      getSuperUserArea() {
        if (!USER.isSuperUser && !USER.isProblemsetter) {
          return [];
        }
        let problemsetterLinks = [UI$1.createElement(NavLinkElement, {
          value: [UI$1.T("Eval Tasks")],
          href: "/eval/manager/"
        }), UI$1.createElement(NavLinkElement, {
          value: [UI$1.T("My Contests")],
          href: "/contest/manager/"
        })];
        if (USER.isSuperUser) {
          const serverAdminSection = USER.isStaff && UI$1.createElement(NavElement, {
            value: UI$1.T("Server (Admin)"),
            persistent: true,
            sessionKey: "server"
          }, UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Machines")],
            href: "/manage/icarus/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Analytics")],
            href: "/analytics/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Users")],
            href: "/manage/users/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Commands")],
            href: "/baseconfig/command/manager/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Testing")],
            href: "/testing/"
          }));
          return [UI$1.createElement("hr", {
            className: this.styleSheet.hrStyle
          }), UI$1.createElement(NavSection, null, serverAdminSection, UI$1.createElement(NavElement, {
            value: UI$1.T("Content (Admin)"),
            persistent: true,
            sessionKey: "content"
          }, [...problemsetterLinks, UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Checkers")],
            href: "/eval/checkers/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Private Archives")],
            href: "/private-archives/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Eval Jobs")],
            href: "/eval/global/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Articles")],
            href: "/article/manager/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Raw Ratings")],
            href: "/real_ratings/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Reputation")],
            href: "/reputations/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("File Storage")],
            href: "/storage/manager/"
          })]))];
        }
        return [UI$1.createElement("hr", {
          className: this.styleSheet.hrStyle
        }), UI$1.createElement(NavElement, {
          value: UI$1.T("Content (Admin)"),
          persistent: true,
          sessionKey: "content"
        }, problemsetterLinks)];
      }
      getLeftSidePanelFixedChildren() {
        return [];
      }
      getLeftSidePanelChildren() {
        let userArea = [];
        if (USER.isAuthenticated) {
          const currentUser = UserStore.getCurrentUser();
          const myProfileLink = USER.username ? "/user/" + USER.username : "/userid/" + USER.id;
          let currentUserDisplay = currentUser.displayName ? currentUser.firstName + " " + currentUser.lastName : currentUser.username;
          currentUserDisplay = currentUserDisplay || UI$1.createElement("em", {
            style: {
              color: "red"
            }
          }, UI$1.createElement("strong", null, "no username set"));
          userArea.push(UI$1.createElement(NavElement, {
            value: ["Profile (", currentUserDisplay, ")"],
            persistent: true,
            sessionKey: "user",
            defaultToggled: true
          }, UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("My Profile")],
            href: myProfileLink
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Account Settings")],
            href: "/accounts/settings/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Workspace Settings")],
            href: "/accounts/workspace_settings/"
          }), UI$1.createElement(NavLinkElement, {
            value: [UI$1.T("Messages")],
            href: "/messages/"
          })));
          userArea.push(UI$1.createElement(NavElement, {
            value: [UI$1.T("Logout")],
            onClick: () => Logout.logout()
          }));
        }
        userArea.push(UI$1.createElement(WebsocketStatusIcon, null));
        return [UI$1.createElement(NavSection, null, UI$1.createElement(NavLinkElement, {
          value: [UI$1.createElement(CSALogo, {
            style: {
              marginRight: "6px",
              verticalAlign: "middle"
            },
            size: "14",
            color: getTextColor(Theme.Global.properties.COLOR_PRIMARY),
            background: "transparent"
          }), UI$1.T("Home")],
          href: "/"
        }), !isSepi() && UI$1.createElement(NavElement, {
          value: UI$1.T("Interviews"),
          persistent: true,
          sessionKey: "interviews",
          defaultToggled: true
        }, UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Tasks"),
          href: "/contest/interview-archive/"
        }), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("My Interviews"),
          href: "/interview/"
        })), UI$1.createElement(NavElement, {
          value: UI$1.T("Algorithms"),
          persistent: true,
          sessionKey: "algorithms",
          defaultToggled: true
        }, UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Tasks"),
          href: "/contest/archive/"
        }), !isSepi() && UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Lessons"),
          href: "/lessons/"
        }), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Contests"),
          href: "/contests/"
        }), !isSepi() && UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Leaderboard"),
          href: "/ratings/"
        })), UI$1.createElement(NavElement, {
          value: UI$1.T("Apps"),
          persistent: true,
          sessionKey: "apps"
        }, UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Graph Editor"),
          href: "/app/graph_editor/"
        }), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Geometry Widget"),
          href: "/app/geometry_widget/"
        }), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Diff Tool"),
          href: "/app/diffing_tool/"
        })), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Workspace"),
          href: "/workspace/"
        })), UI$1.createElement("hr", {
          className: this.styleSheet.hrStyle
        }), !isSepi() && [UI$1.createElement(NavSection, null, UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Forum"),
          href: "/forum/"
        }), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("Blog"),
          href: "/blog/"
        }), UI$1.createElement(NavLinkElement, {
          value: UI$1.T("About"),
          href: "/about/"
        })), UI$1.createElement("hr", {
          className: this.styleSheet.hrStyle
        })], UI$1.createElement(NavSection, null, userArea), ...this.getSuperUserArea()];
      }
      getRightSidePanelChildren() {
        const onlineButton = UI$1.createElement("div", {
          ref: this.refLink("onlineButton"),
          onClick: () => this.togglePopup(this.navChat.onlineUsers),
          className: OnlineButtonStyle.getInstance().online
        });
        return [UI$1.createElement(NavSection, {
          style: {
            height: "100%",
            position: "relative"
          }
        }, UI$1.createElement(PersistentAccordion, {
          ref: this.refLink("accordion"),
          style: {
            height: "100%",
            bottom: "0"
          },
          sessionKey: "accordion"
        }, UI$1.createElement(NavGlobalChat, {
          ref: this.refLink("navChat"),
          style: {
            backgroundColor: "#fafafa"
          },
          title: [UI$1.T("Chat"), onlineButton]
        }), UI$1.createElement(NavRecentActivity, {
          title: UI$1.T("Activity"),
          style: {
            backgroundColor: "#fafafa"
          }
        })), onlineButton)];
      }
      initRightSidePanel() {
        if (isSepi()) {
          return;
        }
        super.initRightSidePanel();
      }
      initGlobalRouterListener() {
        Router.Global.addListener("change", () => {
          // TODO: This needs rethinking
          setTimeout(() => {
            this.checkForWrap();
          }, 0);
        });
      }
      onMount() {
        super.onMount();

        // This is also dispatched on url change
        document.body.addEventListener("click", () => {
          if (this.leftSidePanel && this.leftSidePanel.visible) {
            this.toggleLeftSidePanel();
          }
        });
        this.navChar && this.attachListener(this.navChat, "updateOnlineUsers", () => this.onlineButton.setChildren([UI$1.createElement(FAIcon, {
          icon: "users",
          style: {
            marginRight: "5px"
          }
        }), this.navChat.onlineUsers.size + " online"]));
      }
      togglePopup(onlineUsers) {
        if (this.onlineUsersPopup && this.onlineUsersPopup.isInDocument()) {
          this.onlineUsersPopup.hide();
          delete this.onlineUsersPopup;
          return;
        }
        if (onlineUsers.size) {
          this.onlineUsersPopup = BasePopup.create(document.body, {
            target: this.onlineButton,
            children: Array.from(onlineUsers).map(userId => UI$1.createElement("div", {
              style: {
                width: "100%"
              }
            }, UI$1.createElement(UserHandle$1, {
              userId: userId
            }))),
            arrowDirection: Direction.UP,
            bodyPlaced: true,
            style: {
              zIndex: 3000
            }
          });
        }
      }
    }

    class ContestUser extends StoreObject {
      constructor(obj) {
        super(obj);
        const contest = this.getContest();
        if (contest) {
          contest.addContestUser(this);
          contest.dispatch("contestUserUpdate", {
            contestUser: this
          });
        }
      }
      applyEvent(event) {
        super.applyEvent(event);
        this.getContest()?.dispatch("contestUserUpdate", {
          contestUser: this,
          event: event
        });
      }
      getPublicUser() {
        return PublicUserStore.get(this.userId);
      }
      getContest() {
        return ContestStore.get(this.contestId);
      }
      getOriginalRating() {
        if (this.hasOwnProperty("oldRating")) {
          return this.oldRating;
        }
        let publicUser = this.getPublicUser();
        if (publicUser) {
          return publicUser.getRating();
        }
        return 1500;
      }
      isOfficial() {
        if (this.getContest().isVirtual()) {
          return false;
        }
        let rating = this.getOriginalRating();
        if (!rating) {
          return true;
        }
        let minRating = this.getContest().minRating || -Infinity;
        let maxRating = this.getContest().maxRating || Infinity;
        return minRating <= rating && rating < maxRating;
      }
      getBaseContest() {
        return this.getContest().getBaseContest();
      }
      getContestStartTime() {
        return this.getContest().getStartTime(this);
      }
      getContestEndTime() {
        return this.getContest().getEndTime(this);
      }
      recalculateTotalScore() {
        this.totalScore = 0;
        for (let contestTaskId in this.scores) {
          const contestTaskScore = this.scores[contestTaskId];
          if (!contestTaskScore.score > 0) {
            continue;
          }
          const contestTask = ContestTaskStore.get(contestTaskId);
          if (contestTask) {
            this.totalScore += contestTask.getBaseTask().pointsWorth * contestTaskScore.score;
          }
        }
        return this.totalScore;
      }
      recalculateMetaScore() {
        const relatedContests = this.getContest().getRelatedContests();
        this.metaScore = this.recalculateTotalScore();
        for (const linkedContest of relatedContests) {
          const relatedContestUser = linkedContest.getUser(this.userId);
          if (relatedContestUser) {
            this.metaScore += relatedContestUser.recalculateTotalScore();
          }
        }
        return this.metaScore;
      }
      getRawContestTaskScore(contestTask) {
        return this.scores[contestTask.id]?.score;
      }
      getContestTaskScore(contestTask) {
        return contestTask.getBaseTask().pointsWorth * (this.getRawContestTaskScore(contestTask) || 0);
      }
      solvedTask(contestTask) {
        const score = this.getRawContestTaskScore(contestTask);
        return score === 1;
      }
      triedTask(contestTask) {
        const score = this.getRawContestTaskScore(contestTask);
        return score && score !== 1;
      }
      resetScore() {
        this.scoresBackup = this.scores;
        this.scores = {};
        this.numSubmissions = 0;
        this.penalty = 0;
      }
      haveSubmitted() {
        return this.numSubmissions > 0;
      }
      isDisqualified() {
        return this.disqualified;
      }
    }
    class ContestUserStoreClass extends GenericObjectStore {
      constructor() {
        super("ContestUser", ContestUser, {
          dependencies: ["contest", "publicuser"]
        });
      }
      applyEvent(event) {
        let obj = this.get(event.objectId);
        if (!obj) {
          obj = event.data;
          obj.id = event.objectId;
          let user = this.create(obj);
          user.applyEvent(event);
          if (event.user) {
            PublicUserStore.create(event.user);
          }
        } else {
          super.applyEvent(event);
        }
      }
    }
    const ContestUserStore = new ContestUserStoreClass();

    class PopupSpan extends UI$1.Primitive("span") {
      getChildrenToRender() {
        return [UI$1.createElement("div", {
          ref: "content"
        }, this.render())];
      }
      onMount() {
        this.content.addNodeListener("mouseover", () => {
          let content = this.options.popupContent;
          if (typeof content === "function") {
            content = content();
          }
          this.popup = BasePopup.create(this.content, Object.assign({
            target: this.content,
            children: content,
            transitionTime: 300,
            titleFontSize: "10pt",
            contentStyle: {
              padding: "0 0 0 5px",
              textAlign: "left"
            },
            style: {
              minWidth: "100px",
              maxWidth: "300px"
            }
          }, this.options.popupOptions || {}));
        });
        this.content.addNodeListener("mouseout", () => {
          if (this.popup) {
            this.popup.hide();
          }
        });
      }
    }

    class ContestTimeCounter extends UI$1.Primitive("span") {
      updateTimer() {
        const contest = this.options.contest;
        let currentServerTime = ServerTime.now();
        let value;
        if (contest.getStartTime() && !contest.hasStarted()) {
          let contestStartTime = new StemDate(contest.getStartTime());
          let timeDifference = currentServerTime.diffDuration(contestStartTime);
          let diffFormat = timeDifference.format("h:mm:ss");
          if (timeDifference >= 24 * Duration.HOUR) {
            diffFormat = Formatter.duration(timeDifference, {
              days: true,
              hours: true,
              lastSeparator: " and "
            });
          }
          value = "Starts in " + diffFormat;
        } else if (contest.getEndTime() && !contest.hasFinished()) {
          let contestEndTime = new StemDate(contest.getEndTime());
          let timeDifference = currentServerTime.diffDuration(contestEndTime);
          let diffFormat = timeDifference.format("h:mm:ss");
          if (timeDifference >= 24 * Duration.HOUR) {
            diffFormat = Formatter.duration(timeDifference, {
              days: true,
              hours: true,
              lastSeparator: " and "
            });
          }
          value = "Ends in " + diffFormat;
        } else {
          value = "Server time: " + currentServerTime.utc().format("HH:mm:ss");
        }
        this.setChildren([value]);
        this.dispatchChange();
      }
      onMount() {
        this.updateTimer();
        this.intervalId = setInterval(() => this.updateTimer(), 1000);
      }
      onUnmount() {
        clearInterval(this.intervalId);
      }
    }

    class HourlyContestWidget extends UI$1.Element {
      getContests() {
        let hourlyContests = ContestStore.all().filter(contest => contest.systemGenerated && !contest.hasFinished() && contest.originArchiveId === this.options.originArchiveId).sort((a, b) => {
          return a.getStartTime() - b.getStartTime();
        });
        if (hourlyContests.length === 0) {
          return null;
        }
        return hourlyContests;
      }
      goToContest(contest) {
        if (contest.isRunning() || contest.getUser(USER.id)) {
          Router.changeURL(["contest", contest.name]);
          return;
        }
        if (!USER.isAuthenticated) {
          LoginModal.show();
          return;
        }
        let request = {
          contestId: contest.id
        };
        Ajax.postJSON("/contest/register/", request).then(() => this.redraw());
      }
      render() {
        let nextContests = this.getContests();
        let children = [UI$1.createElement("div", {
          style: {
            "width": "100%",
            "font-size": ".9em",
            textTransform: "uppercase",
            height: "28px",
            fontWeight: "bold"
          }
        }, this.options.name)];
        let containerStyle = {
          flex: "1",
          padding: "4px",
          minHeight: "120px",
          verticalAlign: "middle",
          position: "relative"
        };
        let emStyle = {
          position: "absolute",
          width: "100%",
          left: "50%",
          top: "50%",
          transform: "translate(-50%, -50%)"
        };
        if (!nextContests) {
          children.push(UI$1.createElement("div", {
            style: containerStyle
          }, UI$1.createElement("em", {
            style: emStyle
          }, UI$1.T("No contest scheduled"))));
        } else {
          if (nextContests.length === 1 && !nextContests[0].isRunning()) {
            children.push(UI$1.createElement("div", {
              style: containerStyle
            }, UI$1.createElement("em", {
              style: emStyle
            }, UI$1.T("No contest running"))));
          }
          for (let nextContest of nextContests) {
            let label = UI$1.T("Register"),
              title = UI$1.T("Next contest");
            let usersRegistered, usersRegisteredSpan;
            if (nextContest.isRunning()) {
              title = UI$1.T("Current contest");
            } else {
              usersRegistered = ContestUserStore.all().filter(contestUser => contestUser.contestId === nextContest.id);
              if (usersRegistered.length > 0) {
                usersRegisteredSpan = UI$1.createElement("div", {
                  style: {
                    "display": "block",
                    "position": "relative"
                  }
                }, UI$1.createElement(PopupSpan, {
                  style: {
                    position: "relative",
                    overflow: "hidden",
                    "cursor": "pointer",
                    "color": "blue"
                  },
                  popupContent: () => usersRegistered.map(user => UI$1.createElement("div", {
                    style: {
                      "width": "100%",
                      "height": "25px",
                      "line-height": "25px"
                    }
                  }, UI$1.createElement(UserHandle$1, {
                    userId: user.userId
                  })))
                }, UI$1.T("Users registered"), ": ", usersRegistered.length));
              }
            }
            if (nextContest.isRunning() || nextContest.getUser(USER.id)) {
              label = UI$1.T("Go to contest");
            }
            children.push(UI$1.createElement("div", {
              style: containerStyle
            }, UI$1.createElement("h5", {
              style: {
                textTransform: "uppercase",
                fontWeight: "bold",
                fontSize: "90%"
              }
            }, title), UI$1.createElement("div", null, UI$1.createElement(ContestTimeCounter, {
              contest: nextContest
            })), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
              onClick: () => {
                this.goToContest(nextContest);
              },
              level: Level.PRIMARY,
              size: Size.SMALL
            }, label)), usersRegisteredSpan));
          }
        }
        return UI$1.createElement("div", {
          style: {
            width: "100%",
            display: "flex",
            flexDirection: "column",
            textAlign: "center"
          }
        }, children);
      }
      onMount() {
        super.onMount();
        ContestStore.addCreateListener(() => {
          this.redraw();
        });
        ContestUserStore.addCreateListener(contestUser => {
          let contest = contestUser.getContest();
          if (contest && contest.systemGenerated && !contest.hasFinished() && contest.originArchiveId === this.options.originArchiveId) {
            this.redraw();
          }
        });
        ContestStore.addDeleteListener(() => {
          this.redraw();
        });
      }
    }
    class HourlyContestsPanel extends UI$1.Element {
      render() {
        let panelStyle = {
          flex: "1",
          paddingTop: "8px",
          paddingBottom: "8px"
        };
        return [UI$1.createElement(CardPanel, {
          title: UI$1.T("Hourly Contests"),
          style: {
            display: "flex",
            flexDirection: "column"
          },
          bodyStyle: {
            display: "flex",
            flex: "1"
          }
        }, UI$1.createElement(HourlyContestWidget, {
          originArchiveId: ALGORITHMS_ARCHIVE_ID,
          name: UI$1.T("Algorithms"),
          style: panelStyle
        }), UI$1.createElement(HourlyContestWidget, {
          originArchiveId: INTERVIEWS_ARCHIVE_ID,
          name: UI$1.T("Interviews"),
          style: panelStyle
        }))];
      }
    }

    class Archive extends StoreObject {
      constructor(obj) {
        super(obj);
        this.archiveUsers = new Map();
        this.users = new Map();
        this.addListener("archiveUserUpdate", event => {
          this.dispatch("rankingsChange", event);
          this.recalculateUsers();
        });
      }
      getBaseContest() {
        return ContestStore.get(this.baseContestId);
      }
      addArchiveUser(archiveUser) {
        this.archiveUsers.set(archiveUser.id, archiveUser);
        this.users.set(archiveUser.userId, archiveUser);
      }
      getUser(userId) {
        return this.users.get(userId);
      }
      getUsers() {
        return Array.from(this.archiveUsers.values());
      }
      getContestTasks() {
        let result = [];
        for (let contestTask of ContestTaskStore.all()) {
          if (contestTask.contestId === this.baseContestId) {
            result.push(contestTask);
          }
        }
        result.sort((a, b) => {
          if (a.contestIndex === b.contestIndex) {
            return a.getBaseTask().id - b.getBaseTask().id;
          }
          return a.contestIndex - b.contestIndex;
        });
        return result;
      }
      getNumUsers() {
        return this.archiveUsers.size;
      }
      static calculateRanks(users) {
        users.sort(compareTotalScoreAndPenalty);

        //Recalculate ranks
        for (let i = 0; i < users.length; i += 1) {
          if (i > 0 && users[i].totalScore === users[i - 1].totalScore) {
            users[i].rank = users[i - 1].rank;
          } else {
            users[i].rank = i + 1;
          }
        }
      }
      recalculateUsers() {
        if (this.recalculatingUserInProgress) {
          return;
        }
        this.recalculatingUserInProgress = true;
        setTimeout(() => {
          let users = this.getUsers();
          this.constructor.calculateRanks(users);
          this.dispatch("rankingsChange");
          this.recalculatingUserInProgress = false;
        }, 500);
      }
      getChat() {
        return GroupChatStore.get(this.chatId);
      }
      toString() {
        return this.longName;
      }
      getCountries() {
        let countryIds = new Set();
        for (let user of this.getUsers()) {
          if (user && user.countryId && !countryIds.has(user.countryId)) {
            countryIds.add(user.countryId);
          }
        }
        return CountryStore.getCountriesFromIds(countryIds);
      }
    }
    const ArchiveStore = new GenericObjectStore("Archive", Archive);
    class ArchiveUser extends StoreObject {
      constructor(obj) {
        super(obj);
        this.metaContest = ArchiveStore.get(this.archiveId);
        if (this.metaContest) {
          this.metaContest.addArchiveUser(this);
        }
      }
      applyEvent(event) {
        super.applyEvent(event);
        this.metaContest.dispatch("archiveUserUpdate", {
          metaContestUser: this,
          event: event
        });
        this.metaContest.dispatch("contestUserUpdate", {
          metaContestUser: this,
          event: event
        });
      }
      solvedTask(task) {
        let user = UserStore.get(this.userId);
        if (user) {
          return user.taskSummaries.has(task.evalTaskId) && user.taskSummaries.get(task.evalTaskId).bestScore === 100.0;
        }
        return false;
      }
      triedTask(task) {
        let user = UserStore.get(this.userId);
        if (user) {
          return user.taskSummaries.has(task.evalTaskId);
        }
        return false;
      }
      getPublicUser() {
        return PublicUserStore.get(this.userId);
      }
    }
    const ArchiveUserStore = new GenericObjectStore("ArchiveUser", ArchiveUser, {
      dependencies: ["Archive", "PublicUser"]
    });

    class ContestChat extends UI$1.Element {
      getMessageThread() {
        const groupChat = GroupChatStore.get(this.options.chatId);
        return groupChat?.getMessageThread();
      }
      render() {
        const messageThread = this.getMessageThread();
        if (messageThread) {
          return UI$1.createElement(GroupChatWidget, {
            ref: "chatWidget",
            className: GlobalStyle.Container.MEDIUM,
            style: {
              height: window.innerHeight - 70
            },
            chatId: this.options.chatId,
            messageThread: messageThread
          });
        } else if (this.options.error) {
          return StateDependentElement.renderError(this.options.error);
        }
        return [UI$1.createElement("h3", null, "Chat loading..."), UI$1.createElement("span", {
          className: "fa fa-spinner fa-spin"
        })];
      }
      onMount() {
        this.addListener("hide", () => {
          this.chatWidget?.dispatch("hide");
        });
        this.addListener("show", () => {
          this.chatWidget?.dispatch("show");
        });
      }
    }

    class WorkspaceFile extends VirtualStoreObjectMixin(StoreObject) {
      getWorkspace() {
        return WorkspaceStore.get(this.workspaceId);
      }
      getName() {
        return this.name;
      }
      toString() {
        return this.getName();
      }
      isSaved() {
        return !this.isUnsaved;
      }
      getBrowserStorageMaps() {
        return this.getWorkspace().getBrowserStorageMaps();
      }
      saveBrowserVersion() {
        let savedLocally = false;
        for (let storage of this.getBrowserStorageMaps()) {
          savedLocally = savedLocally || storage.set(this.getName(), {
            // TODO: this should include the current server version
            serverTime: ServerTime.now().toUnix(),
            localTime: StemDate.now().toUnix(),
            value: this.content
          });
        }
        return savedLocally;
      }
      getBrowserVersion() {
        for (let storage of this.getBrowserStorageMaps()) {
          let version = storage.get(this.getName());
          if (version) {
            return version;
          }
        }
        return null;
      }
      deleteBrowserVersion() {
        for (let storage of this.getBrowserStorageMaps()) {
          storage.delete(this.getName());
        }
      }
      isSavedInBrowser() {
        let browserVersion = this.getBrowserVersion();
        return browserVersion && browserVersion.value == this.getValue();
      }
      setValue(newValue) {
        this.isUnsaved = true;
        this.content = newValue;
        this.saveBrowserVersion();
        this.dispatch("unsaved", {});
      }
      getValue() {
        return this.content;
      }
      applyEvent(event) {
        if (event.sessionId == this.getWorkspace().sessionId) {
          this.updateFromCurrentSession(event);
        } else {
          this.updateFromDifferentSession(event);
        }
      }
      updateFromCurrentSession(event) {
        //This gets called when the server confirms our events, don't need to do anything
      }
      updateFromDifferentSession(event) {
        console.log("Update from another session: ", event);
        super.applyEvent(event);
        this.dispatch("updateExternal", event);
      }
      updateId(newId) {
        if (this.id == newId) {
          return;
        }
        let oldId = this.id;
        super.updateId(newId);
        let workspace = this.getWorkspace();
        workspace.files.delete(oldId);
        workspace.files.set(this.id, this);
      }
      save() {
        //TODO: should this method be implemented here?
        if (!this.isUnsaved) {
          return;
        }
        if (!USER.isAuthenticated) {
          //TODO: save to local storage instead
          return;
        }
        let request = this.getWorkspace().getBaseRequest();
        request.fileName = this.getName();
        request.fileContent = this.getValue();
        if (this.hasTemporaryId()) {
          request.virtualId = this.id;
        } else {
          request.fileId = this.id;
        }
        this.isSaving = true;
        this.dispatch("saving", {});
        const timeSaveSent = StemDate.now();
        Ajax.postJSON("/workspace/save_workspace_file/", request).then(data => {
          this.isUnsaved = false;
          this.dispatch("saved", Object.assign({
            timeSaveSent: timeSaveSent
          }, data));
          if (timeSaveSent >= this.getBrowserVersion().localTime) {
            this.deleteBrowserVersion();
          }
          if (this.id != data.id) {
            this.updateId(data.id);
          }
          this.serverLastSaved = data.serverLastSaved;
          this.isSaving = false;
        }, error => {
          //TODO: in case we have modification between the time we sent this req and now, take this into account
          this.isSaving = false;
        });
      }
    }
    class WorkspaceObject extends StoreObject {
      constructor(obj) {
        super(obj);
        this.files = new Map();
        setInterval(() => {
          this.saveAllFiles();
        }, 20000 + 12000 * Math.random());
      }
      getStorageName() {
        return "WorkspaceStoredFiles-" + this.id;
      }
      getSessionStorageMap() {
        return new SessionStorageMap(this.getStorageName());
      }
      getLocalStorageMap() {
        return new LocalStorageMap(this.getStorageName());
      }
      getBrowserStorageMaps() {
        return [this.getSessionStorageMap(), this.getLocalStorageMap()];
      }
      getBaseRequest() {
        return {
          workspaceId: this.getNormalizedId(),
          sessionId: this.sessionId
        };
      }
      getNormalizedId() {
        let workspaceId = this.id + "";
        if (workspaceId.startsWith("temp-")) {
          // Remove "temp-"
          workspaceId = workspaceId.substr(5);
        }
        return parseInt(workspaceId);
      }
      getLastUpdate() {
        let lastUpdate = parseFloat(this.lastModified);
        for (let file of this.files.values()) {
          lastUpdate = Math.max(lastUpdate, parseFloat(file.serverLastSaved));
        }
        return lastUpdate;
      }
      addFile(workspaceFile, createEvent) {
        this.files.set(workspaceFile.id, workspaceFile);
        this.dispatch("newFile", workspaceFile);
      }
      removeFile(workspaceFile, deleteEvent) {
        if (this.files.has(workspaceFile.id)) {
          this.files.delete(workspaceFile.id);
          this.dispatch("deletedFile", workspaceFile);
        }
      }
      getOrCreateFile(fileName, defaultContent) {
        let workspaceFile = this.getFileByName(fileName);
        if (workspaceFile) {
          return workspaceFile;
        }
        return this.createFile(fileName, defaultContent || "");
      }
      getFiles() {
        return Array.from(this.files.values());
      }

      // TODO: if you ever just need a getFileForLanguage, just implement it here
      getOrCreateFileForLanguage(programmingLanguage, defaultCode) {
        // TODO: this needs to be fixed to support languages with the same extension (py2 vs py3)
        let fileName = "Main" + programmingLanguage.id + "." + programmingLanguage.extension;
        return this.getOrCreateFile(fileName, defaultCode || programmingLanguage.getDefaultSource());
      }
      saveAllFiles() {
        for (let workspaceFile of this.files.values()) {
          workspaceFile.save();
        }
      }
      streamName() {
        return "workspace-" + this.userId + "-" + this.getNormalizedId();
      }
      getFileByName(fileName) {
        for (let workspaceFile of this.files.values()) {
          if (workspaceFile.name === fileName) {
            return workspaceFile;
          }
        }
        return null;
      }
      renameFile(fileName, newFileName) {
        throw Exception("Implement me!");
      }
      createFile(fileName, fileContent) {
        if (this.getFileByName(fileName)) {
          console.error("Trying to create a file that exists already!");
          return;
        }
        // create a virtual file
        return WorkspaceFileStore.createVirtualFile(fileName, fileContent, this);
      }
    }
    class WorkspaceStoreClass extends GenericObjectStore {
      constructor() {
        super("workspace", WorkspaceObject);
      }
      getUserWorkspaces(userId = USER.id) {
        return this.filterBy({
          userId,
          systemCreated: false
        });
      }
      createVirtualWorkspace() {
        //let virtualId = WorkspaceStore.generateVirtualId() + "-" + Math.random();
        let virtualId = Math.random().toString().substr(2);
        let virtualWorkspace = {
          id: "temp-" + virtualId,
          userId: 0,
          files: []
        };
        return this.create(virtualWorkspace, {
          isVirtual: true
        });
      }
    }
    var WorkspaceStore = new WorkspaceStoreClass();
    class WorkspaceFileStoreClass extends VirtualStoreMixin(GenericObjectStore) {
      constructor() {
        super("workspacefile", WorkspaceFile, {
          dependencies: ["workspace"]
        });
      }
      createVirtualFile(fileName, fileContent, workspace) {
        //let virtualId = WorkspaceFileStore.generateVirtualId() + "-" + Math.random();
        const virtualId = Math.random().toString().substr(2);
        const virtualWorkspaceFile = {
          id: "temp-" + virtualId,
          name: fileName,
          content: fileContent,
          workspaceId: workspace.id,
          systemCreated: false,
          lastModified: StemDate.now() / 1000
        };
        return this.create(virtualWorkspaceFile, {
          isVirtual: true
        });
      }
      getVirtualObject(event) {
        return this.objects.get("temp-" + event.virtualId) || WorkspaceStore.get(event.data.workspaceId).getFileByName(event.data.name);
      }
    }
    var WorkspaceFileStore = new WorkspaceFileStoreClass();
    WorkspaceFileStore.addCreateListener((workspaceFile, createEvent) => {
      workspaceFile.getWorkspace().addFile(workspaceFile, createEvent);
    });
    WorkspaceFileStore.addDeleteListener((workspaceFile, deleteEvent) => {
      workspaceFile.getWorkspace().removeFile(workspaceFile, deleteEvent);
    });

    class EvalTaskUserSummary extends StoreObject {
      constructor(obj) {
        super(obj);
        let user = this.getUser();
        if (user) {
          user.taskSummaries.set(this.evalTaskId, this);
        }
      }
      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }
      getUser() {
        return UserStore.get(this.userId);
      }
      getWorkspace() {
        return WorkspaceStore.get(this.workspaceId);
      }
      getUserAndEvalTaskKey() {
        return String(this.evalTaskId) + "-" + String(this.userId);
      }
    }
    class EvalTaskUserSummaryStoreClass extends GenericObjectStore {
      constructor() {
        super("evaltaskusersummary", EvalTaskUserSummary, {
          dependencies: ["user", "evaltask", "contesttask"]
        });
        this.fetchedEvalTasks = new Set();
        this.userAndEvalTaskMap = new Map();
        this.addCreateListener(userSummary => {
          this.userAndEvalTaskMap.set(userSummary.getUserAndEvalTaskKey(), userSummary);
        });
      }
      fetchEvalTask(evalTaskId, successCallback = NOOP_FUNCTION, errorCallback = NOOP_FUNCTION) {
        if (this.fetchedEvalTasks.has(evalTaskId)) {
          successCallback(this.getByEvalTaskId(evalTaskId));
          return;
        }
        Ajax.getJSON("/eval/fetch_task_summaries/", {
          evalTaskId: evalTaskId
        }).then(data => {
          this.fetchedEvalTasks.add(evalTaskId);
          successCallback(data);
        }, errorCallback);
      }
      getByEvalTaskId(evalTaskId) {
        let answer = [];
        for (let summary of this.all()) {
          if (summary.evalTaskId === evalTaskId) {
            answer.push(summary);
          }
        }
        return answer;
      }
      getMapKey(evalTaskId, userId) {
        return String(evalTaskId) + "-" + String(userId);
      }
      getByEvalTaskAndUserId(evalTaskId, userId) {
        return this.userAndEvalTaskMap.get(this.getMapKey(evalTaskId, userId)) || null;
      }
    }
    const EvalTaskUserSummaryStore = new EvalTaskUserSummaryStoreClass();

    var _class$$, _descriptor$t, _descriptor2$q, _descriptor3$n, _descriptor4$k, _descriptor5$i, _descriptor6$f, _descriptor7$b, _descriptor8$b, _dec$I, _class2$w;
    const tasksTagsDispatcher = new Dispatcher();
    class TagsHiddenLabel extends Label {
      render() {
        return [UI$1.createElement(UI$1.TextElement, {
          ref: this.refLink("content"),
          value: this.getLabel() || "show tags"
        })];
      }
      onMount() {
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();
          this.options.bubble.updateOptions({
            showTags: true
          });
        });
      }
    }
    let ContestTaskBubbleStyle = (_class$$ = class ContestTaskBubbleStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        this.fontColor = "rgb(55, 55, 55)";
        // default CSAcademy navbar color
        this.height = 110;
        _initializerDefineProperty(this, "className", _descriptor$t, this);
        _initializerDefineProperty(this, "tags", _descriptor2$q, this);
        _initializerDefineProperty(this, "userScore", _descriptor3$n, this);
        _initializerDefineProperty(this, "taskDescription", _descriptor4$k, this);
        _initializerDefineProperty(this, "taskName", _descriptor5$i, this);
        _initializerDefineProperty(this, "originalContest", _descriptor6$f, this);
        _initializerDefineProperty(this, "taskDifficulty", _descriptor7$b, this);
        _initializerDefineProperty(this, "taskStatistics", _descriptor8$b, this);
      }
    }, (_descriptor$t = _applyDecoratedDescriptor(_class$$.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          boxShadow: "0px 0px 1px " + this.fontColor,
          width: "99%",
          marginLeft: "0.5%",
          marginRight: "0.5%",
          height: this.height,
          fontColor: this.fontColor,
          display: "block",
          marginTop: "20px",
          whiteSpace: "nowrap",
          userSelect: "none",
          ":hover": {
            transition: "0.23s",
            boxShadow: "0px 0px 5px " + this.fontColor,
            textDecoration: "none"
          },
          ">*": {
            verticalAlign: "top",
            display: "inline-block",
            height: "100%",
            lineHeight: this.height,
            textAlign: "center",
            float: "initial !important"
          }
        };
      }
    }), _descriptor2$q = _applyDecoratedDescriptor(_class$$.prototype, "tags", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "22%",
          padding: this.height / 6,
          paddingLeft: this.height / 12,
          paddingRight: this.height / 12
        };
      }
    }), _descriptor3$n = _applyDecoratedDescriptor(_class$$.prototype, "userScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "11%",
          color: this.fontColor,
          fontSize: "20px"
        };
      }
    }), _descriptor4$k = _applyDecoratedDescriptor(_class$$.prototype, "taskDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "35%",
          paddingLeft: "6%"
        };
      }
    }), _descriptor5$i = _applyDecoratedDescriptor(_class$$.prototype, "taskName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50%",
          lineHeight: this.height / 2,
          width: "100%",
          fontSize: "130%",
          color: "black",
          textAlign: "left"
        };
      }
    }), _descriptor6$f = _applyDecoratedDescriptor(_class$$.prototype, "originalContest", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50%",
          width: "100%",
          fontSize: "100%",
          lineHeight: this.height / 2,
          textAlign: "left"
        };
      }
    }), _descriptor7$b = _applyDecoratedDescriptor(_class$$.prototype, "taskDifficulty", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "9%",
          fontSize: "16px"
        };
      }
    }), _descriptor8$b = _applyDecoratedDescriptor(_class$$.prototype, "taskStatistics", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "20%"
        };
      }
    })), _class$$);
    let ContestTaskBubble = (_dec$I = registerStyle(ContestTaskBubbleStyle), _dec$I(_class2$w = class ContestTaskBubble extends Link {
      getDefaultOptions() {
        return {
          svgColor: "#337AB7",
          showTags: true,
          circleStrokeWidth: 5,
          revealedTagIds: [],
          circlePadding: 15
        };
      }
      getContestTask() {
        return this.options.contestTask;
      }
      getEvalTaskSummary() {
        return EvalTaskStatisticsStore.getByEvalTaskId(this.getContestTask().evalTaskId);
      }
      getTagIds() {
        return this.getContestTask().tagIds || [];
      }
      getTags() {
        return this.getTagIds().map(tagId => TagStore.get(tagId));
      }
      getRevealedTags() {
        return this.options.revealedTagIds.map(tagId => TagStore.get(tagId));
      }
      recalculateStatistics() {
        let usersTried = 0,
          usersSolved = 0;
        const updateUser = (user, contestTask) => {
          if (user.scores[contestTask.id]) {
            usersTried += 1;
            if (user.scores[contestTask.id].score == 1) {
              usersSolved += 1;
            }
          }
        };

        /// used only if not in archive but during contest
        const contestTask = this.getContestTask();
        const contestUsers = contestTask.getContest().getUsers();
        for (const contestUser of contestUsers) {
          updateUser(contestUser, contestTask);
        }
        if (contestTask.getContest().isVirtual()) {
          const baseContestTask = contestTask.getContest().getBaseContest().getMatchingContestTask(contestTask);
          const baseContestUsers = contestTask.getContest().getBaseContest().getUsers();
          for (const user of baseContestUsers) {
            updateUser(user, baseContestTask);
          }
        }
        this.usersTried = usersTried;
        this.usersSolved = usersSolved;
      }
      getUsersTried() {
        if (this.options.isArchive) {
          return this.getEvalTaskSummary().usersTried || 0;
        } else {
          return this.usersTried || 0;
        }
      }
      getUsersSolved() {
        if (this.options.isArchive) {
          return this.getEvalTaskSummary().usersSolved || 0;
        } else {
          return this.usersSolved || 0;
        }
      }
      getSuccessRate() {
        const usersTried = this.getUsersTried();
        const usersSolved = this.getUsersSolved();
        if (usersTried) {
          return parseInt(usersSolved / usersTried * 100);
        }
        return 0;
      }
      setOptions(options) {
        options.href = options.href || options.contestTask.getFullURL();
        super.setOptions(options);
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }
      getTaskDescriptionSection() {
        let originalContest = this.getContestTask().getOriginalContest();
        if (originalContest) {
          originalContest = UI$1.createElement(Link, {
            href: "/contest/" + originalContest.name,
            value: originalContest.longName
          });
        } else {
          originalContest = this.getContestTask().originalContestName;
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.taskDescription
        }, UI$1.createElement("div", {
          className: this.styleSheet.taskName
        }, UI$1.T(this.getContestTask().longName)), UI$1.createElement("div", {
          className: this.styleSheet.originalContest
        }, originalContest));
      }
      getUserScoreSection() {
        let points;
        let getPoints = points => [Formatter.truncate(points, 2), UI$1.createElement("span", {
          style: {
            "font-size": "13px"
          }
        }, "pts")];
        let getSolvedIcon = () => UI$1.createElement("span", {
          className: "fa fa-check fa-lg",
          style: {
            color: "green"
          }
        });
        let getUnsolvedIcon = () => UI$1.createElement("span", {
          className: "fa fa-times fa-lg",
          style: {
            color: "red"
          }
        });
        if (this.options.isArchive) {
          let summary = EvalTaskUserSummaryStore.getByEvalTaskAndUserId(this.getContestTask().evalTaskId, USER.id);
          if (summary && summary.tried) {
            points = summary.solved ? getSolvedIcon() : getPoints(summary.bestScore);
          }
        } else {
          let contestTask = this.getContestTask();
          let contestUser = contestTask.getContest().getUser(USER.id);
          if (contestUser && contestUser.scores && contestUser.scores[contestTask.id]) {
            let score = contestUser.scores[contestTask.id].score;
            if (score == 1) {
              points = getSolvedIcon();
            } else if (contestTask.hasPartialScore()) {
              points = getPoints(score * contestTask.pointsWorth);
            } else {
              points = getUnsolvedIcon();
            }
          }
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.userScore
        }, points);
      }
      getTagsSection() {
        let result = [];
        let tags = [];
        if (this.options.isArchive && !this.options.showTags) {
          tags = this.getRevealedTags();
          result.push(UI$1.createElement(TagsHiddenLabel, {
            bubble: this,
            label: tags.length ? "show all tags" : null,
            style: {
              display: "inline-block",
              float: "left",
              margin: ".1em"
            }
          }));
        } else {
          tags = this.getTags();
        }
        result = [tags.map(tag => tag && UI$1.createElement(Label, {
          level: Level.SUCCESS,
          style: {
            display: "inline-block",
            float: "left",
            margin: ".1em"
          },
          onClick: () => {
            window.event.preventDefault();
            window.event.stopPropagation();
            tasksTagsDispatcher.dispatch(tag);
          }
        }, tag.name)), ...result];
        return UI$1.createElement("div", {
          className: this.styleSheet.tags
        }, result);
      }
      getTaskDifficultySection() {
        let taskDifficulty = Difficulty.get(this.getContestTask().getDifficulty());
        if (!taskDifficulty) {
          return UI$1.createElement("div", {
            className: this.styleSheet.taskDifficulty
          });
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.taskDifficulty,
          style: {
            "color": taskDifficulty.color
          }
        }, taskDifficulty.toString());
      }
      getCircleArgs() {
        return {
          strokeWidth: this.options.circleStrokeWidth,
          radius: (this.styleSheet.height - this.options.circleStrokeWidth) / 2 - this.options.circlePadding,
          fill: "transparent",
          center: {
            x: this.styleSheet.height / 2,
            y: this.styleSheet.height / 2
          },
          stroke: this.options.svgColor
        };
      }
      getCircleArc(ratio) {
        if (ratio === 1) {
          return UI$1.createElement(SVG.Circle, this.getCircleArgs());
        } else {
          return UI$1.createElement(SVG.CircleArc, _extends({}, this.getCircleArgs(), {
            startAngle: Math.PI * 1.5,
            endAngle: Math.PI * (1.5 + 2 * ratio)
          }));
        }
      }
      getTaskStatisticsSection() {
        return UI$1.createElement("div", {
          className: this.styleSheet.taskStatistics
        }, UI$1.createElement(SVG.SVGRoot, {
          height: this.styleSheet.height,
          width: this.styleSheet.height
        }, this.getCircleArc(this.getSuccessRate() / 100), UI$1.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 - 9,
          text: this.getSuccessRate() + "%",
          fontSize: "20",
          fill: "#337AB7"
        }), UI$1.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 + 9,
          text: this.getUsersSolved() + "/" + this.getUsersTried(),
          fontSize: "10",
          fill: "#337AB7"
        })));
      }
      render() {
        if (!this.options.isArchive) {
          this.recalculateStatistics();
        }
        return [this.getTaskDescriptionSection(), this.getUserScoreSection(), this.getTagsSection(), this.getTaskDifficultySection(), this.getTaskStatisticsSection()];
      }
      onMount() {
        super.onMount();
        if (this.options.isArchive) {
          let statistics = EvalTaskStatisticsStore.getByEvalTaskId(this.getContestTask().evalTaskId);
          statistics?.addChangeListener(() => {
            this.redraw();
          });
          EvalTaskUserSummaryStore.addChangeListener(data => {
            if (data.evalTaskId === this.getContestTask().evalTaskId) {
              this.redraw();
            }
          });
        } else {
          this.attachChangeListener(this.getContestTask().getContest(), () => {
            this.redraw();
          });
          const redrawThrottler = new CallThrottler({
            throttle: 300
          });
          const redrawThrottled = redrawThrottler.wrap(() => {
            this.redraw();
          });
          this.attachListener(this.getContestTask().getContest(), "contestUserUpdate", redrawThrottled);
        }
      }
    }) || _class2$w);

    var _class$_, _descriptor$s, _descriptor2$p, _descriptor3$m, _descriptor4$j, _descriptor5$h, _descriptor6$e, _descriptor7$a, _descriptor8$a, _dec$H, _class2$v;
    function cmp(a, b, isArchive, getKey, fallbackComparer) {
      let keyA = getKey(a, isArchive);
      let keyB = getKey(b, isArchive);
      if (keyA < keyB) {
        return -1;
      }
      if (keyA > keyB) {
        return 1;
      }
      // The 4th argument can be the next function to call in case of equality
      if (fallbackComparer) {
        return fallbackComparer(a, b, isArchive);
      }
      return 0;
    }
    class ColumnContentGetters {
      static getName(contestTask, isArchive) {
        return contestTask.longName;
      }
      static getContest(contestTask, isArchive) {
        let contest = contestTask.getOriginalContest();
        return contest ? contest.name : contestTask.originalContestName;
      }
      static getScore(contestTask, isArchive) {
        if (isArchive) {
          let evalTaskUserSummary = EvalTaskUserSummaryStore.getByEvalTaskAndUserId(contestTask.evalTaskId, USER.id);
          if (evalTaskUserSummary && evalTaskUserSummary.bestScore) {
            return evalTaskUserSummary.bestScore;
          }
          return 0;
        }
        let user = contestTask.getContest().getUser(USER.id);
        if (user && user.scores && user.scores[contestTask.id]) {
          return user.scores[contestTask.id].score * contestTask.pointsWorth;
        }
        return 0;
      }
      static getTags(contestTask, isArchive) {
        let str = [];
        for (let tagId of contestTask.tagIds || []) {
          str.push(TagStore.get(tagId).name);
        }
        return str.sort().join(" ");
      }
      static getDifficulty(contestTask, isArchive) {
        return contestTask.getDifficulty();
      }
      static getSolved(contestTask, isArchive) {
        if (isArchive) {
          return (EvalTaskStatisticsStore.getByEvalTaskId(contestTask.evalTaskId) || {}).usersSolved || 0;
        }
        let users = contestTask.getContest().getUsers();
        let solved = 0;
        for (let user of users) {
          if (user.scores && user.scores[contestTask.id] && user.scores[contestTask.id].score == 1) {
            solved += 1;
          }
        }
        return solved;
      }
      static getTried(contestTask, isArchive) {
        if (isArchive) {
          return (EvalTaskStatisticsStore.getByEvalTaskId(contestTask.evalTaskId) || {}).usersTried || 0;
        }
        let users = contestTask.getContest().getUsers();
        let tried = 0;
        for (let user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            tried += 1;
          }
        }
        return tried;
      }
      static getRatio(contestTask, isArchive) {
        let solved = this.getSolved(contestTask, isArchive);
        let tried = this.getTried(contestTask, isArchive);
        return tried ? solved / tried : 0;
      }
    }
    const SortableHeaderMixin = (parent, compareFunction, fallbackCompareFunction) => class SortableHeader extends UI$1.Element {
      static cmp(a, b) {
        return cmp(a, b, parent.options.isArchive, compareFunction, fallbackCompareFunction);
      }
      getDefaultOptions() {
        return {
          state: 0,
          style: {
            display: "inline-block",
            cursor: "pointer"
          }
        };
      }
      render() {
        return [UI$1.createElement(FASortIcon, {
          ref: "icon",
          style: {
            display: "inline-block",
            opacity: 0
          }
        }), UI$1.createElement("div", {
          ref: "header",
          style: {
            marginRight: "7.44px",
            display: "inline-block"
          }
        }, this.options.name)];
      }
      updateIcon() {
        let direction;
        if (this.options.state === 1) {
          direction = Direction.DOWN;
        }
        if (this.options.state === -1) {
          direction = Direction.UP;
        }
        if (direction) {
          this.icon.updateOptions({
            direction
          });
          this.icon.setStyle("opacity", 1);
        } else {
          this.icon.setStyle("opacity", 0);
        }
      }
      setState(state) {
        // console.warn("Setting state of", this.options.name.value, "from", this.options.state, "to", state);
        this.options.state = state;
        this.updateIcon();
      }
      onMount() {
        this.updateIcon();
        if (this.options.state === 1 || this.options.state === -1) {
          setTimeout(() => parent.promoteCmp(this));
        }
        this.addClickListener(() => {
          this.setState(this.options.state === 1 ? -1 : 1);
          parent.promoteCmp(this);
          this.updateIcon();
        });
      }
    };
    let ContestTaskListHeaderStyle = (_class$_ = class ContestTaskListHeaderStyle extends ContestTaskBubbleStyle {
      constructor(...args) {
        super(...args);
        this.height = 35;
        _initializerDefineProperty(this, "className", _descriptor$s, this);
        _initializerDefineProperty(this, "taskDescription", _descriptor2$p, this);
        _initializerDefineProperty(this, "userScore", _descriptor3$m, this);
        _initializerDefineProperty(this, "tags", _descriptor4$j, this);
        _initializerDefineProperty(this, "taskDifficulty", _descriptor5$h, this);
        _initializerDefineProperty(this, "taskStatistics", _descriptor6$e, this);
        _initializerDefineProperty(this, "taskStatisticsTitle", _descriptor7$a, this);
        _initializerDefineProperty(this, "taskStatisticsSubtitle", _descriptor8$a, this);
      }
    }, (_descriptor$s = _applyDecoratedDescriptor(_class$_.prototype, "className", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          pointerEvents: "cursor"
        };
      }
    }), _descriptor2$p = _applyDecoratedDescriptor(_class$_.prototype, "taskDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          lineHeight: () => this.height + "px",
          fontSize: "13px",
          paddingLeft: "5.25%",
          textAlign: "left"
        };
      }
    }), _descriptor3$m = _applyDecoratedDescriptor(_class$_.prototype, "userScore", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor4$j = _applyDecoratedDescriptor(_class$_.prototype, "tags", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          textAlign: "center",
          lineHeight: () => this.height + "px"
        };
      }
    }), _descriptor5$h = _applyDecoratedDescriptor(_class$_.prototype, "taskDifficulty", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor6$e = _applyDecoratedDescriptor(_class$_.prototype, "taskStatistics", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "auto"
        };
      }
    }), _descriptor7$a = _applyDecoratedDescriptor(_class$_.prototype, "taskStatisticsTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => this.height / 2 + "px",
          width: "100%",
          fontSize: "12px",
          textAlign: "center",
          lineHeight: () => this.height / 2 + "px"
        };
      }
    }), _descriptor8$a = _applyDecoratedDescriptor(_class$_.prototype, "taskStatisticsSubtitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => this.height / 2 + "px",
          lineHeight: () => this.height / 2 + "px",
          width: "100%",
          fontSize: "12px",
          textAlign: "center"
        };
      }
    })), _class$_);
    let ContestTaskListHeader = (_dec$H = registerStyle(ContestTaskListHeaderStyle), _dec$H(_class2$v = class ContestTaskListHeader extends UI$1.Element {
      constructor(obj) {
        super(obj);
        this.createSortableHeaders();
        this.headers = [];
      }
      createSortableHeaders() {
        this.NameSort = SortableHeaderMixin(this, ColumnContentGetters.getName);
        this.ContestSort = SortableHeaderMixin(this, ColumnContentGetters.getContest, this.NameSort.cmp);
        this.ScoreSort = SortableHeaderMixin(this, ColumnContentGetters.getScore, this.NameSort.cmp);
        this.TagsSort = SortableHeaderMixin(this, ColumnContentGetters.getTags, this.NameSort.cmp);
        this.DifficultySort = SortableHeaderMixin(this, ColumnContentGetters.getDifficulty, this.NameSort.cmp);
        this.SolvedSort = SortableHeaderMixin(this, ColumnContentGetters.getSolved, this.NameSort.cmp);
        this.TriedSort = SortableHeaderMixin(this, ColumnContentGetters.getTried, this.NameSort.cmp);
        this.RatioSort = SortableHeaderMixin(this, ColumnContentGetters.getRatio, this.NameSort.cmp);
      }
      render() {
        let archiveChildren;
        this.headers = [];
        if (this.options.isArchive || !this.options.contest.isRunning()) {
          archiveChildren = [UI$1.createElement(this.TagsSort, {
            name: UI$1.T("Tags"),
            className: this.styleSheet.tags
          }), UI$1.createElement(this.DifficultySort, {
            name: UI$1.T("Difficulty"),
            className: this.styleSheet.taskDifficulty
          })];
          this.headers.push(...archiveChildren);
        } else {
          archiveChildren = UI$1.createElement("div", {
            style: {
              width: "31%",
              height: "100%",
              display: "inline-block",
              float: "left"
            }
          });
        }
        const name = UI$1.createElement(this.NameSort, {
          name: UI$1.T("Task"),
          style: {
            marginRight: "2px",
            display: "inline-block"
          }
        });
        const contest = UI$1.createElement(this.ContestSort, {
          name: UI$1.T("Contest"),
          style: {
            marginLeft: "2px",
            display: "inline-block"
          }
        });
        const score = UI$1.createElement(this.ScoreSort, {
          name: UI$1.T("Score"),
          className: this.styleSheet.userScore
        });
        const solved = UI$1.createElement(this.SolvedSort, {
          name: UI$1.T("Solved")
        });
        const tried = UI$1.createElement(this.TriedSort, {
          name: UI$1.T("Tried")
        });
        const ratio = UI$1.createElement(this.RatioSort, {
          name: UI$1.T("Ratio")
        });
        this.headers.push(...[name, contest, score, solved, tried, ratio]);
        return [UI$1.createElement("div", {
          className: this.styleSheet.className
        }, UI$1.createElement("div", {
          className: this.styleSheet.taskDescription
        }, name, "|", contest), score, archiveChildren, UI$1.createElement("div", {
          className: this.styleSheet.taskStatistics
        }, UI$1.createElement("div", {
          className: this.styleSheet.taskStatisticsTitle,
          style: {
            paddingLeft: 2 * 6.86 + "px"
          }
        }, UI$1.T("Stats")), UI$1.createElement("div", {
          className: this.styleSheet.taskStatisticsSubtitle
        }, solved, "|", tried, "|", ratio)))];
      }
      promoteCmp(selectedHeader) {
        for (let header of this.headers) {
          if (header !== selectedHeader) {
            header.setState(0);
          }
        }
        this.dispatch("setOrderCriterion", (a, b) => selectedHeader.options.state * selectedHeader.constructor.cmp(a, b));
      }
    }) || _class2$v);

    var _class$Z, _descriptor$r, _descriptor2$o, _descriptor3$l, _dec$G, _class2$u, _class3$e, _descriptor4$i, _descriptor5$g, _descriptor6$d, _descriptor7$9, _descriptor8$9, _descriptor9$8, _dec2$e, _class4$7, _class5$3;
    class ContestTaskList extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.bubbles = [];
      }
      getTasks() {
        return this.getContest().getContestTasks();
      }
      getContest() {
        return this.options.contest;
      }
      getContestTaskBubble(task, revealedTagIds = []) {
        return UI$1.createElement(ContestTaskBubble, {
          key: task.id,
          isArchive: this.options.isArchive,
          contestTask: task,
          showTags: this.options.showTags,
          revealedTagIds: revealedTagIds
        });
      }
      setShowTags(showTags) {
        this.options.showTags = showTags;
        this.refreshBubbles();
      }
      setText(text) {
        this.text = text;
        this.refreshBubbles();
      }
      getHeader() {
        return UI$1.createElement(ContestTaskListHeader, {
          ref: "header",
          isArchive: this.options.isArchive,
          contest: this.getContest()
        });
      }
      render() {
        return [this.getHeader(), UI$1.createElement("div", {
          ref: "taskList"
        }, this.bubbles)];
      }
      refreshBubbles() {
        let tasks = this.getTasks();
        if (this.options.sortingCriterion) {
          tasks.sort((a, b) => this.options.sortingCriterion(a, b));
        }
        const [tagIds, textTokens] = tokenize(this.text || "");
        if (this.text) {
          tasks = tasks.filter(task => contains(task.tagIds, tagIds) && containsTokens(task, textTokens));
        }
        const bubbles = tasks.map(task => this.getContestTaskBubble(task, tagIds));
        this.bubbles = bubbles;
        this.taskList.setChildren(bubbles);
      }
      setSortingCriterion(func) {
        this.options.sortingCriterion = func;
        this.refreshBubbles();
      }
      onMount() {
        this.refreshBubbles();
        if (this.header) {
          this.header.addListener("setOrderCriterion", func => {
            this.setSortingCriterion(func);
          });
        }
        if (!this.options.isArchive) {
          let contest = this.getContest();
          if (contest) {
            this.attachListener(this.options.contest, "addTask", () => {
              this.refreshBubbles();
            });
          }
        }
      }
    }

    // Function that splits the text of the search bar in two arrays:
    // - the tags (starting with #), returns an array of the ids
    // - the text tokens, returns an array of strings
    function tokenize(text) {
      let tokens = text.split(/[ \n]/);
      let textTokens = [];
      let tagIds = [];
      for (let token of tokens) {
        if (token.indexOf("#") === 0) {
          let tagName = token.replace("#", "").split("-").join(" ");
          let tag = TagStore.getTagByNameInsensitive(tagName, false);
          if (tag) {
            tagIds.push(tag.id);
          }
        } else if (token !== "") {
          textTokens.push(token);
        }
      }
      return [tagIds, textTokens];
    }

    // Check whether a set of tags passes the required tags.
    // For this, we must consider the given tags as well as
    // their way to their respective roots.
    function contains(entryTagIds, requiredTagIds) {
      if (!requiredTagIds || requiredTagIds.length === 0) {
        return true;
      }
      if (!entryTagIds) {
        return false;
      }
      let vis = new Set();
      for (let tag of entryTagIds) {
        let currentTag = TagStore.get(tag);
        while (currentTag) {
          vis.add(currentTag.id);
          currentTag = TagStore.get(currentTag.parentId);
        }
      }
      for (let tagId of requiredTagIds) {
        if (!vis.has(tagId)) {
          return false;
        }
      }
      return true;
    }

    // Check whether the name or tags of a given task contain a given string token
    // as a substring
    function containsTokens(task, tokens) {
      for (let token of tokens) {
        if (task.longName.toLocaleLowerCase().indexOf(token.toLocaleLowerCase()) === -1) {
          let value = false;
          if (task.tagIds) {
            for (let tagId of task.tagIds) {
              value = value || TagStore.get(tagId).name.toLocaleLowerCase().indexOf(token.toLocaleLowerCase()) !== -1;
            }
          }
          if (!value) {
            return false;
          }
        }
      }
      return true;
    }
    let TagCheckboxStyle = (_class$Z = class TagCheckboxStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "className", _descriptor$r, this);
        _initializerDefineProperty(this, "checked", _descriptor2$o, this);
        _initializerDefineProperty(this, "unchecked", _descriptor3$l, this);
      }
    }, (_descriptor$r = _applyDecoratedDescriptor(_class$Z.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          height: "25px",
          lineHeight: "25px",
          width: "100%",
          paddingLeft: "0%",
          cursor: "pointer",
          ":hover": {
            backgroundColor: "#eee"
          }
        };
      }
    }), _descriptor2$o = _applyDecoratedDescriptor(_class$Z.prototype, "checked", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "black",
          fontWeight: "bold"
        };
      }
    }), _descriptor3$l = _applyDecoratedDescriptor(_class$Z.prototype, "unchecked", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "rgb(55, 55, 55)",
          fontWeight: "initial"
        };
      }
    })), _class$Z);
    let TagCheckbox = (_dec$G = registerStyle(TagCheckboxStyle), _dec$G(_class2$u = class TagCheckbox extends UI$1.Element {
      getDefaultOptions() {
        return {
          checked: false
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
        if (this.options.checked) {
          attr.addClass(this.styleSheet.checked);
        } else {
          attr.addClass(this.styleSheet.unchecked);
        }
      }
      render() {
        return this.options.tag.name;
      }
      onMount() {
        this.addClickListener(() => {
          this.updateOptions({
            checked: !this.options.checked
          });
          this.options.tagFilters.dispatch("tagClicked", this.options.tag);
        });
      }
    }) || _class2$u);
    class TagFilters extends UI$1.Element {
      getContestTasks() {
        return this.options.contest.getContestTasks();
      }
      getAppearingTags() {
        const appearingTags = new Set();
        for (let task of this.getContestTasks()) {
          if (task.tagIds) {
            for (let tagId of task.tagIds) {
              let tag = TagStore.get(tagId);
              while (tag) {
                appearingTags.add(tag);
                tag = TagStore.get(tag.parentId);
              }
            }
          }
        }
        return appearingTags;
      }
      render() {
        let tags = Array.from(this.getAppearingTags());
        tags.sort((a, b) => {
          let categoriesA = a.toString().split("-");
          let categoriesB = b.toString().split("-");
          for (let i = 0; i < Math.min(categoriesA.length, categoriesB.length); i += 1) {
            if (categoriesA[i] !== categoriesB[i]) {
              return categoriesA[i] < categoriesB[i] ? -1 : 1;
            }
          }
          if (categoriesA.length < categoriesB.length) {
            return -1;
          }
          if (categoriesA.length > categoriesB.length) {
            return 1;
          }
          return 0;
        });
        let result = [];
        for (let tag of tags) {
          result.push(UI$1.createElement("div", {
            style: {
              paddingLeft: 18 * tag.getDepth() + "px",
              height: "25px"
            }
          }, UI$1.createElement(TagCheckbox, {
            tag: tag,
            ref: this.refLink("tagCheckbox" + tag.id),
            tagFilters: this
          })));
        }
        return result;
      }
      onMount() {
        this.addListener("textInput", text => {
          let tagIds = tokenize(text)[0];
          for (let tag of this.getAppearingTags()) {
            if (tagIds.indexOf(tag.id) !== -1) {
              this["tagCheckbox" + tag.id].updateOptions({
                checked: true
              });
            } else {
              this["tagCheckbox" + tag.id].updateOptions({
                checked: false
              });
            }
          }
        });
        this.addListener("tagClicked", tag => {
          const filterArea = this.options.filterArea;
          filterArea.changeSearchBarText(tag, filterArea.searchBar.getValue());
          filterArea.dispatch("changeText", filterArea.searchBar.getValue());
        });
      }
    }
    class FilterArea extends UI$1.Element {
      render() {
        return [UI$1.createElement(TextInput, {
          ref: "searchBar",
          placeholder: "Search here (use # for tags)",
          className: this.options.searchBarCss
        }), UI$1.createElement(TagFilters, {
          ref: "tags",
          className: this.options.tagFiltersCss,
          filterArea: this,
          contest: this.options.contest
        })];
      }
      changeSearchBarText(tag, text) {
        let tokens = text.split(" ");
        let normalText = text.toLocaleLowerCase();
        let normalTagName = "#" + tag.name.toLocaleLowerCase().split(" ").join("-");
        let normalTokens = normalText.split(" ");
        if (this.tags["tagCheckbox" + tag.id].options.checked && normalTokens.indexOf(normalTagName) === -1) {
          tokens.push("#" + tag.name.split(" ").join("-"));
        } else {
          for (let i = 0; i < normalTokens.length; i += 1) {
            if (normalTagName === normalTokens[i]) {
              normalTokens.splice(i, 1);
              tokens.splice(i, 1);
            }
          }
        }
        text = tokens.join(" ");
        this.searchBar.setValue(text);
      }
      setText(text) {
        this.searchBar.setValue(text);
        this.tags.dispatch("textInput", text);
      }
      onMount() {
        this.searchBar.addNodeListener("input", () => {
          let text = this.searchBar.getValue();
          this.tags.dispatch("textInput", text);
          this.dispatch("changeText", text);
        });
      }
    }
    let ContestTaskListWithFiltersStyle = (_class3$e = class ContestTaskListWithFiltersStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        _initializerDefineProperty(this, "searchBar", _descriptor4$i, this);
        _initializerDefineProperty(this, "tagFilters", _descriptor5$g, this);
        _initializerDefineProperty(this, "collapseFiltersButton", _descriptor6$d, this);
        _initializerDefineProperty(this, "filterArea", _descriptor7$9, this);
        _initializerDefineProperty(this, "contestTaskList", _descriptor8$9, this);
        _initializerDefineProperty(this, "className", _descriptor9$8, this);
        this.filterAreaCollapsed = Device.isMobileDevice();
        this.addBeforeUpdateListener(() => this.updateVariables());
      }
      updateVariables() {
        this.screenWidth = Math.min(256, window.innerWidth * 2 / 10);
        this.screenHeight = window.innerHeight - 60;
        // TODO: Not even Ramanujan could understand that resizeWidth formula
        // TODO: consider making it a one-liner like this.filterAreaCollapsed ? A : B;
        if (this.filterAreaCollapsed) {
          this.resizeWidth = Math.min(window.innerWidth * 9 / 10 - 30 > Math.max(0, window.innerWidth * 6 / 10) ? window.innerWidth * 9 / 10 - 30 : Math.max(0, window.innerWidth * 6 / 10), 1280 * 9 / 10 - 30);
        } else {
          this.resizeWidth = Math.min(window.innerWidth - Math.min(256, screen.width * 2 / 10) * 5 / 4, Math.min(window.innerWidth * 7 / 10 > 768 ? window.innerWidth * 7 / 10 : 768, Math.min(screen.width * 7 / 10, 1280 * 7 / 10)));
        }
        this.screenWidthBack = Math.min(256, screen.width * 2 / 10);
      }
      toggleCollapsed() {
        this.filterAreaCollapsed = !this.filterAreaCollapsed;
        this.update();
      }
    }, (_descriptor4$i = _applyDecoratedDescriptor(_class3$e.prototype, "searchBar", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "20px",
          marginBottom: "20px",
          border: "0px",
          fontSize: "85%",
          height: "25px",
          width: "85%",
          boxShadow: "0px 0px 1px rgb(55, 55, 55)",
          paddingLeft: "5%",
          lineHeight: "25px",
          outline: "none",
          ":focus": {
            textDecoration: "none",
            backgroundColor: "#f6f6f6"
          }
        };
      }
    }), _descriptor5$g = _applyDecoratedDescriptor(_class3$e.prototype, "tagFilters", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "95%",
          whiteSpace: "nowrap",
          overflowY: "auto",
          overflowX: "auto",
          maxHeight: () => this.screenHeight - 65 /* 65 from the input area */
        };
      }
    }), _descriptor6$d = _applyDecoratedDescriptor(_class3$e.prototype, "collapseFiltersButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          width: "35px",
          position: "absolute",
          overflowY: "hidden",
          textAlign: "center",
          fontSize: "14px",
          marginTop: "22.5px",
          marginLeft: () => this.screenWidth / 4 - 25,
          zIndex: "3"
        };
      }
    }), _descriptor7$9 = _applyDecoratedDescriptor(_class3$e.prototype, "filterArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: () => this.filterAreaCollapsed ? "none" : "inline-block",
          float: "left",
          width: () => this.screenWidth,
          position: "absolute",
          paddingLeft: () => 1 / 10 * this.screenWidth + "px",
          maxHeight: () => this.screenHeight + "px",
          marginLeft: () => 20 + this.screenWidth / 4 - 20 + "px"
        };
      }
    }), _descriptor8$9 = _applyDecoratedDescriptor(_class3$e.prototype, "contestTaskList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          position: "absolute",
          marginLeft: () => this.filterAreaCollapsed ? (30 + this.screenWidthBack / 4) * Math.max(0.4, window.innerWidth / screen.width) + "px" : this.screenWidth + this.screenWidth / 4 + "px",
          width: () => this.resizeWidth,
          maxHeight: () => this.screenHeight + "px",
          minHeight: () => this.screenHeight + "px",
          overflowY: "auto",
          overflowX: "auto",
          whiteSpace: "nowrap",
          paddingRight: "20px"
        };
      }
    }), _descriptor9$8 = _applyDecoratedDescriptor(_class3$e.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "auto",
          width: Math.min(1280, screen.width * 10 / 10) + "px",
          overflow: "hidden"
        };
      }
    })), _class3$e);
    let ContestTaskListWithFilters = (_dec2$e = registerStyle(ContestTaskListWithFiltersStyle), _dec2$e(_class4$7 = class ContestTaskListWithFilters extends UI$1.Element {
      getDefaultOptions() {
        return {
          showTags: USER.isAuthenticated ? UserStore.getCurrentUser().getShowTagsInArchive(this.options.contest.id) : false
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }
      render() {
        return [UI$1.createElement(Button$1, {
          ref: "collapseFiltersButton",
          className: this.styleSheet.collapseFiltersButton,
          icon: this.getCollapseFiltersButtonIcon(),
          level: Level.INFO,
          size: Size.SMALL,
          onClick: () => this.toggleFiltersCollapsed()
        }), UI$1.createElement(FilterArea, {
          ref: "filterArea",
          className: this.styleSheet.filterArea,
          tagFiltersCss: this.styleSheet.tagFilters,
          searchBarCss: this.styleSheet.searchBar,
          contest: this.options.contest
        }), UI$1.createElement("div", {
          ref: "contestTaskList",
          className: this.styleSheet.contestTaskList
        }, UI$1.createElement("div", null, UI$1.createElement("div", {
          style: {
            "display": "inline-block",
            "padding-right": "10px"
          }
        }, UI$1.T("Show tags")), UI$1.createElement("div", {
          style: {
            "display": "inline-block"
          }
        }, UI$1.createElement(RawCheckboxInput, {
          ref: this.refLink("showTagsCheckbox"),
          initialValue: this.options.showTags,
          style: {
            "display": "inline-block"
          }
        }))), UI$1.createElement(ContestTaskList, {
          ref: "table",
          contest: this.options.contest,
          isArchive: true,
          showTags: this.options.showTags,
          sortingCriterion: this.options.defaultSortingCriterion
        }))];
      }
      getCollapseFiltersButtonIcon() {
        return "chevron-" + (this.styleSheet.filterAreaCollapsed ? "right" : "left");
      }
      toggleFiltersCollapsed() {
        this.styleSheet.toggleCollapsed();
        this.collapseFiltersButton.setIcon(this.getCollapseFiltersButtonIcon());
      }
      onMount() {
        this.filterArea.addListener("changeText", text => this.table.setText(text));
        this.showTagsCheckbox.addChangeListener(() => {
          this.options.showTags = this.showTagsCheckbox.getValue();
          this.table.setShowTags(this.options.showTags);
          if (USER.isAuthenticated) {
            UserStore.getCurrentUser().saveCustomSetting("archive:showTags-" + this.options.contest.id, this.options.showTags);
          }
        });
        if (USER.isAuthenticated) {
          const getShowTags = () => {
            let newValue = UserStore.getCurrentUser().getShowTagsInArchive(this.options.contest.id);
            if (newValue !== this.options.showTags) {
              this.options.showTags = newValue;
              this.showTagsCheckbox.setValue(newValue);
              this.table.setShowTags(this.options.showTags);
            }
          };
          getShowTags();
          this.attachChangeListener(UserStore.getCurrentUser(), getShowTags);
        }
        this.addListener("setActive", active => {
          if (active) {
            this.contestTaskList.node.scrollTop = this._scrollState || 0;
          } else {
            this._scrollState = this.contestTaskList.node.scrollTop;
          }
        });
        tasksTagsDispatcher.addListener(tag => {
          const tabText = "#" + tag.name.split(" ").join("-");
          this.filterArea.setText(tabText);
          this.table.setText(tabText);
        });
      }
    }) || _class4$7);
    class BroadcastTaskNowModal extends ActionModal {
      getTitle() {
        return "Broadcast task";
      }
      getBody() {
        return "Are you sure you want to broadcast this task now?";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getActionName() {
        return "Do it!";
      }
      action() {
        const {
          contestTask
        } = this.options;
        Ajax.postJSON("/contest/change_task_delay/", {
          contestId: contestTask.contestId,
          contestTaskId: contestTask.id
        });
        this.hide();
      }
    }
    class TaskBroadcastDelayEditor extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.editMode = false;
      }
      updateEditMode(editMode) {
        this.editMode = editMode;
        this.redraw();
      }
      render() {
        let message;
        if (this.editMode) {
          message = [UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            size: Size.EXTRA_SMALL,
            style: {
              marginLeft: "3px"
            },
            icon: "floppy-o",
            onClick: () => this.save()
          }), UI$1.createElement(TextInput, {
            value: this.getTextInputValue(),
            ref: "broadcastDelayInput",
            style: {
              width: "95px",
              marginLeft: "5px"
            }
          })];
        } else {
          message = [UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            size: Size.EXTRA_SMALL,
            style: {
              marginLeft: "3px"
            },
            icon: "pencil",
            onClick: () => this.updateEditMode(true)
          }), UI$1.createElement("span", {
            style: {
              paddingLeft: "5px"
            }
          }, this.getTextValue())];
        }
        return [UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL,
          onClick: () => this.showBroadcastNowModal()
        }, "Now!"), message];
      }
      save() {
        const {
          contestTask
        } = this.options;
        const formattedDuration = this.broadcastDelayInput.getValue();
        const durationTokens = formattedDuration.split(":");
        let seconds;
        if (durationTokens.length === 1) {
          seconds = parseInt(durationTokens);
        } else if (durationTokens.length === 2) {
          seconds = parseInt(durationTokens[0]) * 60 + parseInt(durationTokens[1]);
        } else if (durationTokens.length === 3) {
          seconds = parseInt(durationTokens[0]) * 3600 + parseInt(durationTokens[1]) * 60 + parseInt(durationTokens[2]);
        } else {
          alert("Invalid duration format");
          return;
        }
        Ajax.postJSON("/contest/change_task_delay/", {
          contestId: contestTask.contestId,
          contestTaskId: contestTask.id,
          delay: seconds
        });
        this.updateEditMode(false);
      }
      getTextValue(delay) {
        delay = delay || this.options.contestTask.broadcastDelay;
        if (!delay) {
          return UI$1.createElement("em", null, "On contest start");
        }
        const duration = new Duration({
          seconds: delay
        });
        return duration.format("h:mm:ss");
      }
      getTextInputValue() {
        const duration = new Duration({
          seconds: this.options.contestTask.broadcastDelay || 0
        });
        return duration.format("h:mm:ss");
      }
      showBroadcastNowModal() {
        BroadcastTaskNowModal.show({
          contestTask: this.options.contestTask
        });
      }
    }
    let AdminContestTasksTable = autoredraw(_class5$3 = class AdminContestTasksTable extends Table {
      getContest() {
        return this.options.contest;
      }
      deleteTask(task) {
        let data = {
          contestId: this.getContest().id,
          contestTaskId: task.id
        };
        Ajax.postJSON("/contest/delete_task/", data);
      }
      getEntries() {
        return this.getContest().getContestTasks();
      }
      moveTaskUp(task) {
        const contestTasks = this.getContest().getContestTasks();
        let updates = {};
        for (let i = 0; i < contestTasks.length; i += 1) {
          updates[contestTasks[i].id] = i + 1;
          if (contestTasks[i] === task) {
            updates[contestTasks[i].id] -= 1;
            updates[contestTasks[i - 1].id] += 1;
          }
        }
        let request = {
          updates: JSON.stringify(updates),
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/update_order/", request).then(() => this.redraw());
      }
      getDefaultColumns() {
        return [{
          headerName: UI$1.T("Order"),
          value: (task, rowIndex) => rowIndex > 0 && UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            icon: "arrow-up",
            onClick: () => this.moveTaskUp(task)
          }),
          rawValue: task => task.contestIndex
        }, {
          headerName: UI$1.T("Task"),
          value: task => UI$1.createElement(Link, {
            href: "/contest/" + this.getContest().name + "/task/" + task.name + "/",
            value: task.longName
          }),
          rawValue: task => task.longName
        }, {
          headerName: UI$1.T("URL Name"),
          value: task => task.name
        }, {
          headerName: UI$1.T("Score type"),
          value: task => task.scoreTypeName
        }, {
          headerName: UI$1.T("Delay"),
          value: task => UI$1.createElement(TaskBroadcastDelayEditor, {
            contestTask: task
          })
        }, {
          headerName: UI$1.T("Delete"),
          value: task => UI$1.createElement(Button$1, {
            level: "danger",
            onClick: () => this.deleteTask(task)
          }, UI$1.T("Delete"))
        }];
      }
    }) || _class5$3;

    class CSAHorizontalOverflow extends HorizontalOverflow {
      handleEventAndHandlePositionChange(...args) {
        super.handleEventAndHandlePositionChange(...args);
        BasePopup.clearBodyPopups();
      }
    }

    var _class$Y, _descriptor$q;
    let FullScreenStyle = (_class$Y = class FullScreenStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "fullScreen", _descriptor$q, this);
      }
    }, (_descriptor$q = _applyDecoratedDescriptor(_class$Y.prototype, "fullScreen", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: "100%",
          backgroundColor: "#FFFFFF"
        };
      }
    })), _class$Y);

    /*
    * Implements a Class Factory, to be able to create element that can be easily set to full screen
    */


    // TODO: is this a good pattern, and should this method live somewhere else?
    function callFirstMethodAvailable(obj, methodNames) {
      for (let methodName of methodNames) {
        if (typeof obj[methodName] === "function") {
          obj[methodName]();
          return methodName;
        }
      }
      return null;
    }

    // TODO: might need a clean-up
    // Don't automate this, these names differ slightly (eg. moz has uppercase Screen)
    const ENTER_FULL_SCREEN_METHODS = ["requestFullscreen", "webkitRequestFullscreen", "msRequestFullscreen", "mozRequestFullScreen"];
    const EXIT_FULL_SCREEN_METHODS = ["exitFullscreen", "webkitExitFullscreen", "msExitFullscreen", "mozCancelFullScreen"];
    const FULL_SCREEN_CHANGE_EVENTS = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];

    // TODO: lowercase the s in screen?
    // TODO: this should not be directly in UI namespace
    const FullScreenable = function (BaseClass) {
      var _FullScreenable;
      return _FullScreenable = class FullScreenable extends BaseClass {
        getDefaultOptions() {
          return Object.assign({}, super.getDefaultOptions(), {
            fullContainer: true
          });
        }
        extraNodeAttributes(attr) {
          super.extraNodeAttributes(attr);
          if (this.options.fullContainer) {
            attr.addClass(GlobalStyle.Utils.fullContainer);
          } else {
            attr.setStyle("height", "100%");
          }
        }
        enterFullScreen() {
          this.attachEnterFullscreenHandler();
          if (!callFirstMethodAvailable(this.node, ENTER_FULL_SCREEN_METHODS)) {
            console.error("No valid full screen function available");
            return;
          }
          this._expectingFullScreen = true;
        }
        setFullScreenStyle() {
          this.addClass(this.constructor.fullScreenStyleSheet.fullScreen);
          if (this.options.fullContainer) {
            this.removeClass(GlobalStyle.Utils.fullContainer);
            this.setStyle("height", "100%");
          }
        }
        isFullScreen() {
          return this._isFullScreen;
        }
        exitFullScreen() {
          if (!callFirstMethodAvailable(document, EXIT_FULL_SCREEN_METHODS)) {
            console.error("No valid available function to exit fullscreen");
            return;
          }
        }
        unsetFullScreenStyle() {
          this.removeClass(this.constructor.fullScreenStyleSheet.fullScreen);
          if (this.options.fullContainer) {
            this.addClass(GlobalStyle.Utils.fullContainer);
            this.setStyle("height", null);
          }
        }
        toggleFullScreen() {
          if (this.isFullScreen()) {
            this.exitFullScreen();
          } else {
            this.enterFullScreen();
          }
        }
        attachEnterFullscreenHandler() {
          if (this._attachedFullscreenHandler) {
            return;
          }
          this._attachedFullscreenHandler = true;
          let fullScreenFunction = () => {
            if (this._expectingFullScreen) {
              this._expectingFullScreen = false;
              this._isFullScreen = true;
              this.dispatch("enterFullScreen");
              this.setFullScreenStyle();
            } else {
              if (this._isFullScreen) {
                this._isFullScreen = false;
                this.dispatch("exitFullScreen");
                this.unsetFullScreenStyle();
              }
            }
            this.dispatch("resize");
          };
          for (let eventName of FULL_SCREEN_CHANGE_EVENTS) {
            document.addEventListener(eventName, fullScreenFunction);
          }
        }
      }, _FullScreenable.fullScreenStyleSheet = FullScreenStyle.getInstance(), _FullScreenable;
    };

    var _class$X, _descriptor$p, _descriptor2$n, _descriptor3$k, _class2$t, _descriptor4$h, _descriptor5$f, _descriptor6$c, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$6, _descriptor11$5, _descriptor12$4, _class3$d, _descriptor13$4, _descriptor14$4, _descriptor15$3, _descriptor16$3, _class4$6, _descriptor17$3;
    let WorkspaceButtonStyle = (_class$X = class WorkspaceButtonStyle extends ButtonStyle {
      constructor(...args) {
        super(...args);
        this.workspaceBase = Object.assign({}, this.base, {
          border: "none",
          borderRadius: "0",
          fontSize: "14px"
        });
        _initializerDefineProperty(this, "RUN", _descriptor$p, this);
        _initializerDefineProperty(this, "COMPILE", _descriptor2$n, this);
        _initializerDefineProperty(this, "SUBMIT", _descriptor3$k, this);
      }
    }, (_descriptor$p = _applyDecoratedDescriptor(_class$X.prototype, "RUN", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.workspaceBase, this.colorStyleRule(this.themeProps.COLOR_RUN)];
      }
    }), _descriptor2$n = _applyDecoratedDescriptor(_class$X.prototype, "COMPILE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.workspaceBase, this.colorStyleRule(this.themeProps.COLOR_COMPILE)];
      }
    }), _descriptor3$k = _applyDecoratedDescriptor(_class$X.prototype, "SUBMIT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.workspaceBase, this.colorStyleRule(this.themeProps.COLOR_SUBMIT)];
      }
    })), _class$X);
    let WorkspaceStyle = (_class2$t = class WorkspaceStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.workspaceBackground = () => this.themeProps.COLOR_WORKSPACE;
        this.menuButtonSelected = () => enhance(this.workspaceBackground(), 1);
        this.menuButtonColor = () => enhance(this.workspaceBackground(), .8);
        this.menuSelectSelected = () => enhance(this.workspaceBackground(), .3);
        this.menuSelectBackground = () => enhance(this.workspaceBackground(), .2);
        this.menuButtonSelectedStyle = {
          color: this.menuButtonSelected,
          background: "none"
        };
        this.menuSelectSelectedStyle = {
          color: this.menuButtonSelected,
          background: this.menuSelectSelected
        };
        this.menuSelectBackgroundStyle = {
          background: this.menuSelectBackground
        };
        this.menuButtonStyle = {
          fontSize: "14px",
          background: "none",
          border: "none",
          fontWeight: "bold",
          padding: "5px 10px",
          color: this.menuButtonColor,
          ":hover": this.menuButtonSelectedStyle,
          ":focus": {
            background: "none"
          },
          ":active": {
            background: "none"
          },
          ":focus:active": {
            background: "none"
          },
          ":hover:active": {
            background: "none"
          },
          outline: "0"
        };
        _initializerDefineProperty(this, "actionButtons", _descriptor4$h, this);
        _initializerDefineProperty(this, "menuButton", _descriptor5$f, this);
        _initializerDefineProperty(this, "menuSelect", _descriptor6$c, this);
        _initializerDefineProperty(this, "workspace", _descriptor7$8, this);
        _initializerDefineProperty(this, "optionButtons", _descriptor8$8, this);
        _initializerDefineProperty(this, "bottomTab", _descriptor9$7, this);
        _initializerDefineProperty(this, "tabAreaTitleArea", _descriptor10$6, this);
        _initializerDefineProperty(this, "expandTabAreaButton", _descriptor11$5, this);
        _initializerDefineProperty(this, "expandedButton", _descriptor12$4, this);
      }
    }, (_descriptor4$h = _applyDecoratedDescriptor(_class2$t.prototype, "actionButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          whiteSpace: "nowrap",
          padding: "5px 0",
          float: "right",
          ">*": {
            marginRight: "5px",
            display: "inline-block"
          },
          paddingLeft: "5px"
        };
      }
    }), _descriptor5$f = _applyDecoratedDescriptor(_class2$t.prototype, "menuButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.menuButtonStyle;
      }
    }), _descriptor6$c = _applyDecoratedDescriptor(_class2$t.prototype, "menuSelect", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({}, this.menuButtonStyle, {
          cursor: "pointer",
          ":hover": this.menuSelectSelectedStyle,
          ":focus": this.menuSelectBackgroundStyle,
          ":active": this.menuSelectBackgroundStyle,
          ":focus:active": this.menuSelectBackgroundStyle,
          ":hover:active": this.menuSelectSelectedStyle,
          ":hover:focus": this.menuSelectSelectedStyle,
          background: this.menuSelectBackground,
          marginLeft: "10px",
          height: "1.9em",
          verticalAlign: "middle"
        });
      }
    }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$t.prototype, "workspace", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.workspaceBackground
        };
      }
    }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$t.prototype, "optionButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            whiteSpace: "nowrap",
            margin: "5px 2.5px 5px 2.5px"
          },
          whiteSpace: "nowrap"
        };
      }
    }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$t.prototype, "bottomTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        };
      }
    }), _descriptor10$6 = _applyDecoratedDescriptor(_class2$t.prototype, "tabAreaTitleArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          width: "100%",
          backgroundColor: this.workspaceBackground
        };
      }
    }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$t.prototype, "expandTabAreaButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            transform: "rotate(180deg)",
            fontSize: "120%",
            position: "relative",
            width: "1em",
            height: "1em",
            borderRadius: "100%",
            transition: "transform .3s ease",
            verticalAlign: "top"
          },
          ">:first-child::before": {
            position: "absolute",
            left: 0,
            top: "-.1em"
          }
        };
      }
    }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$t.prototype, "expandedButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            transform: "rotate(0deg) !important"
          }
        };
      }
    })), _class2$t);
    let WorkspaceTabAreaStyle = (_class3$d = class WorkspaceTabAreaStyle extends DefaultTabAreaStyle {
      constructor(...args) {
        super(...args);
        this.navBackground = () => this.themeProps.COLOR_WORKSPACE;
        this.tabColor = () => enhance(this.navBackground(), .8);
        this.tabHoverBackground = () => enhance(this.navBackground(), .1);
        this.tabHoverColor = () => enhance(this.navBackground(), .9);
        this.tabActiveColor = () => enhance(this.navBackground(), 1);
        this.tabActiveBackground = () => enhance(this.navBackground(), -.2);
        this.transitionTime = .2;
        _initializerDefineProperty(this, "workspaceTab", _descriptor13$4, this);
        _initializerDefineProperty(this, "tab", _descriptor14$4, this);
        _initializerDefineProperty(this, "activeTab", _descriptor15$3, this);
        _initializerDefineProperty(this, "nav", _descriptor16$3, this);
      }
    }, (_descriptor13$4 = _applyDecoratedDescriptor(_class3$d.prototype, "workspaceTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          ">*": {
            position: "absolute",
            height: "100%",
            width: "100%"
          }
        };
      }
    }), _descriptor14$4 = _applyDecoratedDescriptor(_class3$d.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.tabColor,
          border: "none",
          borderRadius: "0",
          margin: "0",
          fontSize: "14px",
          padding: "6px",
          paddingRight: "12px",
          paddingLeft: "12px",
          transition: "padding " + this.transitionTime + "s ease",
          ":hover": {
            cursor: "pointer",
            backgroundColor: this.tabHoverBackground,
            border: "none",
            color: this.tabHoverColor
          }
        };
      }
    }), _descriptor15$3 = _applyDecoratedDescriptor(_class3$d.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          border: "none",
          color: this.tabActiveColor,
          backgroundColor: this.tabActiveBackground,
          paddingTop: "3px",
          ":hover": {
            backgroundColor: this.tabActiveBackground,
            color: this.tabActiveColor
          }
        };
      }
    }), _descriptor16$3 = _applyDecoratedDescriptor(_class3$d.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          border: "none",
          whiteSpace: "nowrap",
          backgroundColor: this.navBackground
        };
      }
    })), _class3$d);
    let WorkspaceSectionDividerStyle = (_class4$6 = class WorkspaceSectionDividerStyle extends SectionDividerStyle {
      constructor(...args) {
        super(...args);
        this.transitionTime = 0.3;
        this.barPadding = 0;
        this.barThickness = 5;
        this.dividerColor = () => enhance(this.themeProps.COLOR_WORKSPACE, .3);
        _initializerDefineProperty(this, "animatedSectionDivider", _descriptor17$3, this);
      }
    }, (_descriptor17$3 = _applyDecoratedDescriptor(_class4$6.prototype, "animatedSectionDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            transition: this.transitionTime + "s height ease"
          }
        };
      }
    })), _class4$6);
    class WorkspaceHorizontalOverflowStyle extends HorizontalOverflowStyle {
      constructor(...args) {
        super(...args);
        this.baseColor = () => this.themeProps.COLOR_WORKSPACE;
      }
    }
    const workspaceButtonStyle = new WorkspaceButtonStyle();

    var _dec$F, _class$W, _dec2$d, _class2$s, _dec3$6, _class3$c;
    class FileSavingLabel extends Label {
      constructor(options) {
        super(options);
        this.fileUnsavedListener = () => {
          this.updateLabel();
        };
        this.fileSavingListener = () => {
          this.updateLabel();
        };
        this.fileSavedListener = () => {
          this.updateLabel();
          setTimeout(() => {
            if (this.file.isSaved()) {
              this.hide();
            }
          }, 1500);
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        if (!this.file) {
          attr.addClass("hidden");
        }
      }
      updateLabel() {
        this.show();
        if (this.file.isSaved()) {
          this.setLabel(UI$1.T("Saved"));
        } else {
          if (this.file.isSavedInBrowser()) {
            this.setLabel(UI$1.T("Saved locally"));
            return;
          }
          if (this.file.isSaving) {
            this.setLabel(UI$1.T("Saving..."));
          } else {
            this.setLabel(UI$1.T("Unsaved changes"));
          }
        }
      }
      setFile(file) {
        if (this.fileListeners) {
          this.fileListeners.cleanup();
        }
        this.file = file;
        this.updateLabel();
        if (this.file.isSaved) {
          this.hide();
        }
        this.fileListeners = new CleanupJobs([this.file.addListener("unsaved", this.fileUnsavedListener), this.file.addListener("saving", this.fileSavingListener), this.file.addListener("saved", this.fileSavedListener)]);
      }
    }
    let WorkspaceTabArea = (_dec$F = registerStyle(WorkspaceTabAreaStyle), _dec$F(_class$W = class WorkspaceTabArea extends TabArea {
      getSwitcher(tabPanels) {
        let switcher = super.getSwitcher(tabPanels);
        switcher.addClass(this.styleSheet.workspaceTab);
        return switcher;
      }
      getTitleArea(tabTitles) {
        return UI$1.createElement(HorizontalOverflow, {
          ref: "titleArea",
          className: this.styleSheet.nav,
          styleSheet: WorkspaceHorizontalOverflowStyle
        }, tabTitles);
      }
    }) || _class$W);
    let WorkspaceDividerBar = (_dec2$d = registerStyle(WorkspaceSectionDividerStyle), _dec2$d(_class2$s = class WorkspaceDividerBar extends DividerBar {}) || _class2$s);
    let WorkspaceSectionDivider = (_dec3$6 = registerStyle(WorkspaceSectionDividerStyle), _dec3$6(_class3$c = class WorkspaceSectionDivider extends SectionDivider {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          autoCollapse: true
        });
      }
      getDividerBarClass() {
        return WorkspaceDividerBar;
      }
      isCollapsed(child) {
        return child.collapsed;
      }
      animateAceResize() {
        const dispatchResize = () => {
          this.panels[0].dispatch("resize");
          this.animationId = requestAnimationFrame(dispatchResize);
        };
        this.animationId = requestAnimationFrame(dispatchResize);
      }
      cancelAceResizeAnimation() {
        cancelAnimationFrame(this.animationId);
        delete this.animationId;
      }
      collapseChild(index) {
        if (index === 0) {
          return;
        }
        if (this.clearListeners) {
          this.clearListeners();
        }
        const topPanel = this.panels[0];
        const bottomPanel = this.panels[1];
        this.addClass(this.styleSheet.animatedSectionDivider);
        this.dividers[0].hide();
        this.setDimension(topPanel, "100%");
        this.setDimension(bottomPanel, 0);
        this.animateAceResize();
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.cancelAceResizeAnimation();
          bottomPanel.collapsed = true;
        }, this.styleSheet.transitionTime * 1000);
        this.dispatch("collapse");
      }
      expandChild(index) {
        if (index === 0) {
          return;
        }
        const topPanel = this.panels[0];
        const bottomPanel = this.panels[1];
        this.addClass(this.styleSheet.animatedSectionDivider);
        this.setDimension(bottomPanel, "30%");
        this.setDimension(topPanel, "70%");
        this.animateAceResize();
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.cancelAceResizeAnimation();
          this.dividers[0].show();
          bottomPanel.collapsed = false;
        }, this.styleSheet.transitionTime * 1000);
      }
    }) || _class3$c);

    class WorkspaceSettingsPanel extends UI$1.Element {
      onMount() {
        let user = UserStore.getCurrentUser();
        // TODO(@gem): Ugly hack, fix this in Select
        this.aceThemeSelect.set(AceTheme.getDefaultTheme());
        this.aceThemeSelect.addChangeListener(() => {
          user.saveCustomSetting("workspace:aceTheme", this.aceThemeSelect.get().id);
        });
        this.codeFontSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:codeFontSize", this.codeFontSizeInput.getValue());
        });
        this.fileFontSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:fileFontSize", this.fileFontSizeInput.getValue());
        });
        this.tabSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:tabSize", this.tabSizeInput.getValue());
        });
        this.showLineNumberInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:showLineNumber", this.showLineNumberInput.getValue());
        });
        this.showPrintMarginInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:showPrintMargin", this.showPrintMarginInput.getValue());
        });
        this.printMarginSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:printMarginSize", this.printMarginSizeInput.getValue());
        });
        this.enableBasicAutocompletionInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:enableBasicAutocompletion", this.enableBasicAutocompletionInput.getValue());
        });
        this.enableLiveAutocompletionInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:enableLiveAutocompletion", this.enableLiveAutocompletionInput.getValue());
        });
        this.enableSnippetsInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:enableSnippets", this.enableSnippetsInput.getValue());
        });
        this.aceKeyboardHandlerSelect.set(AceKeyboardHandler.getDefaultKeyboardHandler());
        this.aceKeyboardHandlerSelect.addChangeListener(() => {
          user.saveCustomSetting("workspace:aceKeyboardHandler", this.aceKeyboardHandlerSelect.get().id);
        });
      }
      render() {
        let user = UserStore.getCurrentUser();
        return [UI$1.createElement(Form, {
          orientation: Orientation$1.VERTICAL,
          style: {
            height: "330px",
            background: "#fff",
            display: "block",
            "overflow-y": "auto",
            "overflow-x": "hidden",
            padding: "10px"
          },
          role: "menu"
        }, UI$1.createElement(FormField, {
          label: UI$1.T("Theme")
        }, UI$1.createElement(Select, {
          options: AceTheme.all(),
          ref: "aceThemeSelect",
          selected: AceTheme.getDefaultTheme()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Keyboard handler")
        }, UI$1.createElement(Select, {
          options: AceKeyboardHandler.all(),
          ref: "aceKeyboardHandlerSelect",
          selected: AceKeyboardHandler.getDefaultKeyboardHandler()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Code font size")
        }, UI$1.createElement(NumberInput, {
          ref: "codeFontSizeInput",
          min: "6",
          max: "36",
          value: user.getCodeFontSize()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Files font size")
        }, UI$1.createElement(NumberInput, {
          ref: "fileFontSizeInput",
          min: "6",
          max: "36",
          value: user.getFileFontSize()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Tab size")
        }, UI$1.createElement(NumberInput, {
          ref: "tabSizeInput",
          min: "2",
          max: "8",
          value: user.getTabSize()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Show line number"),
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "showLineNumberInput",
          checked: user.getShowLineNumber()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Show print margin"),
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "showPrintMarginInput",
          checked: user.getShowPrintMargin()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Print margin column")
        }, UI$1.createElement(NumberInput, {
          ref: "printMarginSizeInput",
          min: "60",
          max: "180",
          value: user.getPrintMarginSize()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Enable basic autocompletion"),
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "enableBasicAutocompletionInput",
          checked: user.getBasicAutocompletionStatus()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Enable live autocompletion"),
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "enableLiveAutocompletionInput",
          checked: user.getLiveAutocompletionStatus()
        })), UI$1.createElement(FormField, {
          label: UI$1.T("Enable snippets"),
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "enableSnippetsInput",
          checked: user.getSnippetsStatus()
        })))];
      }
    }
    class ProgrammingLanguageSourceTemplate extends UI$1.Element {
      getUser() {
        return this.options.user;
      }
      getProgrammingLanguage() {
        return this.options.programmingLanguage;
      }
      render() {
        let programmingLanguage = this.getProgrammingLanguage();
        return [UI$1.createElement(CodeEditor, {
          ref: "codeEditor",
          aceMode: programmingLanguage.aceMode,
          value: programmingLanguage.getDefaultSource(),
          maxLines: 32
        }), UI$1.createElement(Button$1, {
          size: Size.SMALL,
          icon: "save",
          style: {
            marginTop: "10px"
          },
          label: [UI$1.T(" Save template for"), " " + programmingLanguage.name],
          level: Level.INFO,
          onClick: () => this.saveTemplate()
        })];
      }
      saveTemplate() {
        let user = this.getUser();
        let programmingLanguage = this.getProgrammingLanguage();
        let value = this.codeEditor.getValue();
        user.saveCustomSetting("workspace:programmingLanguage:" + programmingLanguage.id + ":defaultSource", value);
      }
    }
    class AllProgrammingLanguagesTemplateEditor extends UI$1.Element {
      setOptions(options) {
        super.setOptions(options);
        this.languageTemplatesMap = new Map();
        for (let programmingLanguage of ProgrammingLanguage.all()) {
          this.languageTemplatesMap.set(programmingLanguage, UI$1.createElement(ProgrammingLanguageSourceTemplate, {
            user: this.options.user,
            programmingLanguage: programmingLanguage
          }));
        }
      }
      render() {
        return [UI$1.createElement(FormField, {
          label: UI$1.T("Edit your default code for"),
          style: {
            maxWidth: "800px"
          }
        }, UI$1.createElement(Select, {
          ref: "programmingLanguageSelect",
          options: ProgrammingLanguage.all(),
          style: {
            maxWidth: "300px"
          }
        })), UI$1.createElement(Switcher, {
          ref: "templateSwitcher"
        }, Array.from(this.languageTemplatesMap.values()))];
      }
      onMount() {
        let defaultLanguage = ProgrammingLanguage.getDefaultLanguage();
        this.programmingLanguageSelect.addChangeListener(() => {
          let selectedProgrammingLanguage = this.programmingLanguageSelect.get();
          this.templateSwitcher.setActive(this.languageTemplatesMap.get(selectedProgrammingLanguage));
        });
        this.templateSwitcher.setActive(this.languageTemplatesMap.get(defaultLanguage));
      }
    }
    class UserWorkspaceSettingsPanel extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      savePreferredProgrammingLanguage(programmingLanguage) {
        this.options.user.saveCustomSetting("workspace:preferredProgrammingLanguage", programmingLanguage.id);
      }
      getTitle() {
        return UI$1.T("Workspace settings");
      }
      render() {
        this.options.user = UserStore.getCurrentUser();
        return [UI$1.createElement(FormField, {
          style: {
            marginTop: "5px",
            marginBottom: "5px",
            maxWidth: "800px"
          },
          label: UI$1.T("Preferred language:")
        }, UI$1.createElement(Select, {
          ref: "preferredProgrammingLanguageSelect",
          options: ProgrammingLanguage.all(),
          style: {
            maxWidth: "300px"
          }
        })), UI$1.createElement("hr", null), UI$1.createElement(AllProgrammingLanguagesTemplateEditor, {
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          },
          user: this.options.user
        })];
      }
      onMount() {
        let defaultLanguage = ProgrammingLanguage.getDefaultLanguage();
        this.preferredProgrammingLanguageSelect.set(defaultLanguage);
        this.preferredProgrammingLanguageSelect.addChangeListener(() => {
          this.savePreferredProgrammingLanguage(this.preferredProgrammingLanguageSelect.get());
        });
      }
    }

    class UserEditor extends CodeEditor {
      getDefaultOptions() {
        let user = UserStore.getCurrentUser();
        let defaultOptions = {
          aceKeyboardHandler: AceKeyboardHandler.getDefaultKeyboardHandler(),
          aceTheme: AceTheme.getDefaultTheme(),
          fontSize: user.getFileFontSize(),
          tabSize: user.getTabSize(),
          showLineNumber: user.getShowLineNumber()
        };
        return defaultOptions;
      }
      onMount() {
        let currentUser = UserStore.getCurrentUser();
        if (currentUser) {
          this.attachListener(currentUser, "updateCustomSetting", event => {
            this.dispatch(event.key, event.value);
          });
        }
        this.addListener("workspace:aceTheme", aceThemeId => {
          let aceTheme = AceTheme.get(aceThemeId);
          this.setAceTheme(aceTheme);
        });
        this.addListener("workspace:tabSize", tabSize => {
          this.setAceTabSize(tabSize);
        });
        this.addListener("workspace:showLineNumber", showLineNumber => {
          this.setAceLineNumberVisible(showLineNumber);
        });
        this.addListener("workspace:enableBasicAutocompletion", value => {
          this.setBasicAutocompletion(value);
        });
        this.addListener("workspace:enableLiveAutocompletion", value => {
          this.setLiveAutocompletion(value);
        });
        this.addListener("workspace:enableSnippets", value => {
          this.setSnippets(value);
        });
        this.addListener("workspace:aceKeyboardHandler", aceKeyboardHandlerId => {
          let aceKeyboardHandler = AceKeyboardHandler.get(aceKeyboardHandlerId);
          this.setAceKeyboardHandler(aceKeyboardHandler);
        });
        super.onMount();
      }
    }
    class UserInputEditor extends UserEditor {
      onMount() {
        this.addListener("workspace:fileFontSize", fontSize => {
          this.setAceFontSize(fontSize);
        });
        super.onMount();
      }
    }
    class UserCodeEditor extends UserEditor {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.fontSize = UserStore.getCurrentUser().getCodeFontSize();
        return options;
      }
      onMount() {
        this.addListener("workspace:codeFontSize", fontSize => {
          this.setAceFontSize(fontSize);
        });
        this.addListener("workspace:showPrintMargin", showPrintMargin => {
          this.setAcePrintMarginVisible(showPrintMargin);
        });
        this.addListener("workspace:printMarginSize", printMarginSize => {
          this.setAcePrintMarginSize(printMarginSize);
        });
        super.onMount();
      }
    }

    // Class that acts like a CodeEditor backed by a file-like object
    // The file-like object needs to support
    // - setValue(newValue, shouldSaveNow)
    // - getValue()
    // - addChangeListener(fileUpdateEvent);
    // - dispatch("changeByUser", fileUpdateEvent);
    let FileCodeEditorMixin = function (BaseCodeEditor) {
      var _class;
      return _class = class FileCodeEditor extends BaseCodeEditor {
        onDelayedMount() {
          super.onDelayedMount();
          if (this.options.file) {
            this.setFile(this.options.file);
          }
          this.addAceSessionChangeListener(event => {
            //Ignore when we're setting these values in code
            //Whoever changes the value manually should issue a custom events if he want
            if (this.apiChange) {
              return;
            }
            event.newValue = this.getValue();
            event.file = this.file;
            this.file.setValue(event.newValue, true);
            this.file.dispatch("userChanged", event);
          });
        }
        setFile(file, programmingLanguage) {
          this.file = file;
          this.setValue(file.getValue());
          if (!programmingLanguage && file.hasOwnProperty("getProgrammingLanguage")) {
            programmingLanguage = file.getProgrammingLanguage();
          }
          if (programmingLanguage) {
            this.setAceMode(programmingLanguage);
          }
          let browserFileVersion = file.getBrowserVersion();
          if (browserFileVersion && browserFileVersion.serverTime > (file.serverLastSaved || 0) && browserFileVersion.value != file.getValue()) {
            console.log("Using browser version for file ", file.getName());
            this.setValue(browserFileVersion.value);
            file.setValue(browserFileVersion.value);
          }
          if (this.fileListener) {
            this.fileListener.remove();
          }
          this.fileListener = this.file.addListener("updateExternal", event => {
            console.log("File listener for file: ", this.file);
            this.setValue(this.file.getValue());
          });
        }
        getFile() {
          return this.file;
        }
      }, (_applyDecoratedDescriptor(_class.prototype, "setFile", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class.prototype, "setFile"), _class.prototype)), _class;
    };
    let InputFileEditor = FileCodeEditorMixin(UserInputEditor);
    let FileCodeEditor = FileCodeEditorMixin(UserCodeEditor);

    var _dec$E, _class$V;
    let WorkspacePanel = (_dec$E = registerStyle(WorkspaceStyle), _dec$E(_class$V = class WorkspacePanel extends FullScreenable(UI$1.Element) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.workspace);
      }
      addFullscreenListeners() {
        this.addListener("enterFullScreen", () => {
          this.fullScreenButton.setIcon("compress");
        });
        this.addListener("exitFullScreen", () => {
          this.fullScreenButton.setIcon("expand");
        });
        this.fullScreenButton.addClickListener(() => {
          this.toggleFullScreen();
          this.resizeCodeEditor();
        });
      }
      addUploadButtonListeners() {
        if (Device.getBrowser() === "Firefox") {
          console.log("Use a different browser, for god's sake, it's for the good of the Realm.");
          this.uploadFileButton.addClickListener(event => {
            this.uploadFile.node.click(event);
          });
        }
        this.uploadFile.node.onchange = () => {
          let reader = new FileReader();
          let file = this.uploadFile.getFile();
          console.log(file);
          if (!file) {
            return;
          }
          if (file.size > 1e6) {
            this.fileWarningModal.show();
            console.warn("File ", file.name, " too large. Skipping upload.");
            this.uploadFile.setValue("");
            return;
          }
          reader.onprogress = () => {
            this.uploadFileButton.setLevel(Level.WARNING);
            this.uploadFileButton.setLabel(UI$1.T("Uploading..."));
            this.uploadFileButton.disable();
          };
          reader.onload = e => {
            this.uploadFileButton.setLevel(Level.SUCCESS);
            this.uploadFileButton.setLabel(UI$1.T("Successfully uploaded!"));
            setTimeout(() => {
              this.uploadFileButton.enable();
              this.uploadFileButton.setLevel(Level.INFO);
              this.uploadFileButton.setLabel(UI$1.T("Open file"));
            }, 700);
            let text = e.currentTarget.result;
            text.replace("\r\n", "\n");
            this.codeEditor.setValue(text, 1);
            this.uploadFile.setValue("");
            this.dispatch("finishedFileUpload");
          };
          reader.readAsText(file);
        };
      }
      addTabAreaListeners() {
        setTimeout(() => {
          this.tabArea.titleArea.appendChild(UI$1.createElement("div", {
            style: {
              flex: "1"
            }
          }));
          this.tabArea.titleArea.appendChild(UI$1.createElement(Button$1, {
            icon: "chevron-down",
            size: Size.LARGE,
            onClick: () => this.sectionDivider.collapseChild(1),
            className: this.styleSheet.menuButton
          }));
        }, 1000);
        this.expandTabAreaButton.addClickListener(() => {
          if (this.sectionDivider.panels[1].collapsed) {
            this.expandTabAreaButton.addClass(this.styleSheet.expandedButton);
          } else {
            this.expandTabAreaButton.removeClass(this.styleSheet.expandedButton);
          }
          this.sectionDivider.toggleChild(1);
        });
        this.attachListener(this.sectionDivider, "collapse", () => {
          this.expandTabAreaButton.removeClass(this.styleSheet.expandedButton);
        });
      }
      onMount() {
        super.onMount();
        this.codeSectionPanel.addListener("resize", () => this.resizeCodeEditor());
        this.addListener("resize", () => {
          this.workspaceButtons.dispatch("resize");
          this.actionButtons.dispatch("resize");
          this.tabArea.titleArea.dispatch("resize");
        });
        this.settingsButton.addClickListener(() => {
          this.workspaceSettingsWindow.toggleClass("hidden");
        });
        setTimeout(() => {
          this.addTabAreaListeners();
          this.addFullscreenListeners();
          this.addUploadButtonListeners();
        });
      }
      resizeCodeEditor() {
        this.codeEditor.dispatch("resize");
        this.tabArea.dispatch("resize");
      }
      maximizeTabSection() {
        this.expandTabAreaButton.addClass(this.styleSheet.expandedButton);
        this.sectionDivider.expandChild(1);
      }
      render() {
        let user = UserStore.getCurrentUser();
        this.codeEditorOptions = {
          aceKeyboardHandler: AceKeyboardHandler.getDefaultKeyboardHandler(),
          aceTheme: AceTheme.getDefaultTheme(),
          fontSize: user.getCodeFontSize(),
          tabSize: user.getTabSize(),
          showLineNumber: user.getShowLineNumber(),
          showPrintMargin: user.getShowPrintMargin(),
          printMarginSize: user.getPrintMarginSize(),
          enableBasicAutocompletion: user.getBasicAutocompletionStatus(),
          enableLiveAutocompletion: user.getLiveAutocompletionStatus(),
          enableSnippets: user.getSnippetsStatus()
        };
        return [
        // TODO @Andrei remove this Modal and replace with a generic error Toast/Modal
        UI$1.createElement(Modal, {
          ref: "fileWarningModal"
        }, UI$1.createElement("h5", {
          style: {
            color: "red"
          }
        }, "File is too large. Skipping upload.")), UI$1.createElement("div", {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            flexDirection: "column"
          }
        }, UI$1.createElement(WorkspaceSectionDivider, {
          ref: "sectionDivider",
          orientation: Orientation$1.VERTICAL,
          style: {
            width: "100%",
            height: "100%",
            overflow: "hidden",
            flex: "1"
          }
        }, UI$1.createElement(Panel, {
          ref: "codeSectionPanel",
          className: "row codeSection",
          style: {
            margin: "0px",
            height: "70%",
            boxSizing: "border-box",
            position: "relative",
            display: "flex",
            flexDirection: "column"
          }
        }, UI$1.createElement(CSAHorizontalOverflow, {
          ref: "workspaceButtons",
          className: this.styleSheet.topMenu,
          styleSheet: WorkspaceHorizontalOverflowStyle
        }, UI$1.createElement("div", {
          ref: "optionButtonsTopLeft",
          className: this.styleSheet.optionButtons
        }, UI$1.createElement(Button$1, {
          ref: "uploadFileButton",
          className: `${this.styleSheet.menuButton} file-upload-button`,
          label: UI$1.T("Open file"),
          icon: "upload",
          style: {
            position: "relative",
            overflow: "hidden"
          },
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + O to open file"
        }, UI$1.createElement(FileInput, {
          ref: "uploadFile",
          style: {
            position: "absolute",
            top: "0",
            right: "0",
            margin: "0",
            height: "200%",
            padding: "0",
            cursor: "pointer",
            opacity: "0",
            filter: "alpha(opacity=0)"
          }
        })), UI$1.createElement(Select, {
          ref: "programmingLanguageSelect",
          options: ProgrammingLanguage.all(),
          className: this.styleSheet.menuSelect,
          style: {
            minWidth: "auto"
          }
        })), UI$1.createElement("div", {
          style: {
            flex: 1,
            overflow: "hidden",
            marginLeft: "-5px",
            marginRight: 0
          }
        }, UI$1.createElement(FileSavingLabel, {
          ref: "saveFileStatusLabel",
          size: Size.MEDIUM,
          className: this.styleSheet.menuSelect,
          style: {
            pointerEvents: "none",
            padding: "2px 5px",
            height: "initial",
            maxWidth: "fit-content",
            width: "-webkit-fill-available",
            textOverflow: "ellipsis",
            overflow: "inherit",
            marginBottom: "-13px"
          }
        })), UI$1.createElement("div", {
          ref: "optionButtonsTopRight",
          className: this.styleSheet.optionButtons
        }, UI$1.createElement(Button$1, {
          label: UI$1.T("Settings"),
          icon: "cog",
          ref: "settingsButton",
          className: this.styleSheet.menuButton
        }), UI$1.createElement(Button$1, {
          label: UI$1.T("Fullscreen"),
          icon: "expand",
          ref: "fullScreenButton",
          className: this.styleSheet.menuButton,
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + Enter to enter/exit full screen"
        }))), UI$1.createElement("div", {
          ref: "workspaceSettingsWindow",
          className: "hidden",
          style: {
            position: "absolute",
            zIndex: "2016",
            right: "0px",
            top: "40px",
            boxShadow: this.styleSheet.themeProps.BASE_BOX_SHADOW
          }
        }, UI$1.createElement(WorkspaceSettingsPanel, null)), UI$1.createElement(FileCodeEditor, _extends({
          ref: "codeEditor",
          style: {
            flex: 1,
            height: "100%"
          }
        }, this.codeEditorOptions))), UI$1.createElement(Panel, {
          ref: "bottomArea",
          className: this.styleSheet.tabSection,
          style: {
            zIndex: "20",
            width: "100%",
            right: "0",
            bottom: "0",
            height: "30%",
            display: "flex",
            flexDirection: "column"
          },
          minHeight: 50
        }, UI$1.createElement(WorkspaceTabArea, {
          ref: "tabArea",
          className: "tabSection",
          panelClass: this.styleSheet.bottomTab,
          style: {
            flexGrow: "1",
            width: "100%",
            boxSizing: "border-box",
            fontSize: "9.5pt"
          },
          titleAreaClass: this.styleSheet.tabAreaTitleArea
        }))), UI$1.createElement(CSAHorizontalOverflow, {
          styleSheet: WorkspaceHorizontalOverflowStyle,
          ref: "actionButtons"
        }, UI$1.createElement(Button$1, {
          ref: "expandTabAreaButton",
          icon: "chevron-up",
          label: UI$1.T("Execution Details"),
          className: `${this.styleSheet.menuButton} ${this.styleSheet.expandedButton} ${this.styleSheet.expandTabAreaButton}`
        }), UI$1.createElement("div", {
          style: {
            flex: 1
          }
        }), UI$1.createElement("div", {
          ref: "optionButtonsBottom",
          className: this.styleSheet.actionButtons
        })))];
      }
    }) || _class$V);

    class WorkspacePlugin extends Plugin {
      linkToParent(parent) {
        this.workspaceIDE = parent;
      }
      refLink(name) {
        return {
          parent: this,
          name: name
        };
      }
    }

    class WorkspaceSettingsPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspaceIDE.addListener("initDone", () => {
          this.panel = this.workspaceIDE.workspaceSettings;
          this.addUserSettingsListeners();
        });
      }
      static pluginName() {
        return "SettingsManager";
      }
      addUserSettingsListeners() {
        this.attachListener(UserStore.getCurrentUser(), "updateCustomSetting", event => {
          this.dispatch(event.key, event.value);
        });
      }
    }
    WorkspaceSettingsPlugin.priorityIndex = 100;

    let ErrorMessage$1 = class ErrorMessage extends StoreObject {
      getTranslation() {
        TranslationKeyStore.get(this.translationKeyId);
      }
    };
    class ErrorMessageStoreClass extends GenericObjectStore {
      constructor() {
        super("ErrorMessage", ErrorMessage$1);
      }
    }
    const ErrorMessageStore = new ErrorMessageStoreClass();

    const ErrorHandlers = {};
    ErrorHandlers.wrapError = error => {
      if (error instanceof StoreObject) {
        return error;
      }
      if (error.id) {
        return ErrorMessageStore.create(error);
      } else {
        if (typeof error === "string" || error instanceof String) {
          error = {
            message: error
          };
        } else if (error instanceof Error) {
          error = {
            name: error.name,
            message: error.message
          };
        }
        return new ErrorMessage$1(error);
      }
    };
    ErrorHandlers.showErrorAlert = error => {
      ErrorModal.show({
        error: ErrorHandlers.wrapError(error)
      });
    };
    ErrorHandlers.PAGE_NOT_FOUND = ErrorHandlers.wrapError("Page not found.");

    class CustomRun extends BaseUserSubmission {
      buildPublicUrl() {
        return location.origin + "/code/" + this.urlHash + "/";
      }
      setPublic(callback = NOOP_FUNCTION) {
        if (this.isPublic) {
          callback();
          return;
        }
        this.makePublic(callback);
      }
      makePublic(callback = NOOP_FUNCTION) {
        let request = {
          customRunId: this.id,
          makePublic: true
        };
        Ajax.postJSON("/eval/edit_custom_run/", request).then(data => {
          // TODO: Data should be an event to trigger listeners
          this.isPublic = true;
          this.urlHash = data.urlHash;
          callback();
        }, NOOP_FUNCTION);
      }
    }
    const CustomRunStore = new (AjaxFetchMixin(GenericObjectStore))("customrun", CustomRun, {
      fetchURL: "/eval/get_custom_run/",
      maxFetchObjectCount: 1
    });

    class InQueuePopupManagerClass {
      static getTextForDuration(estimatedWait) {
        const formattedDuration = Formatter.duration(estimatedWait * 1000, {
          hours: true,
          minutes: true,
          seconds: true,
          lastSeparator: " and "
        });
        return "Your submission was received. The estimated queue time is " + formattedDuration + ".";
      }
      showPopup(target, estimatedWait) {
        this.popup = BasePopup.create(document.body, {
          target: target,
          bodyPlaced: true,
          children: this.constructor.getTextForDuration(estimatedWait),
          arrowDirection: Direction.DOWN,
          style: {
            width: "200px"
          }
        });
        const destroyPopupTimerId = setTimeout(() => {
          this.cancelInQueuePopup();
        }, this.constructor.POPUP_HANGTIME);
        this.popup.addCleanupJob(() => clearTimeout(destroyPopupTimerId));
      }
      scheduleInQueuePopup(target, estimatedWait, callback) {
        this.cancelInQueuePopup();
        this.inQueuePopupTimeout = setTimeout(() => {
          this.showPopup(target, estimatedWait);
          if (callback) {
            callback();
          }
        }, this.constructor.DELAY_BEFORE_POPUP);
      }
      cancelInQueuePopup() {
        if (this.inQueuePopupTimeout) {
          clearTimeout(this.inQueuePopupTimeout);
          delete this.inQueuePopupTimeout;
        }
        if (this.popup) {
          this.popup.destroyNode();
          delete this.popup;
        }
      }
    }
    InQueuePopupManagerClass.DELAY_BEFORE_POPUP = 1000;
    InQueuePopupManagerClass.POPUP_HANGTIME = 4000;
    const InQueuePopupManager = new InQueuePopupManagerClass();

    class WorkspaceCustomRunPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        let tabArea = workspaceIDE.tabArea;
        let codeEditorOptions = Object.assign({}, this.workspaceIDE.codeEditorOptions, {
          className: "custom-height",
          style: {
            height: "100%"
          },
          fontSize: UserStore.getCurrentUser().getFileFontSize(),
          enableBasicAutocompletion: false,
          enableLiveAutocompletion: false,
          enableSnippets: false
        });
        tabArea.appendChild(UI$1.createElement(Panel, {
          ref: this.refLink("inputEditorTab"),
          title: UI$1.T("Input"),
          active: "true"
        }, UI$1.createElement(InputFileEditor, _extends({
          ref: this.refLink("inputEditor")
        }, codeEditorOptions))));
        tabArea.appendChild(UI$1.createElement(Panel, {
          ref: this.refLink("outputEditorTab"),
          title: UI$1.T("Output")
        }, UI$1.createElement(UserInputEditor, _extends({
          ref: this.refLink("outputEditor")
        }, codeEditorOptions))));
        tabArea.appendChild(UI$1.createElement(Panel, {
          ref: this.refLink("stderrEditorTab"),
          title: UI$1.T("Stderr")
        }, UI$1.createElement(UserInputEditor, _extends({
          ref: this.refLink("stderrEditor")
        }, codeEditorOptions))));
        tabArea.appendChild(UI$1.createElement(CompilationStatusPanel, {
          ref: this.refLink("compilationStatusTab"),
          style: {
            height: "100%"
          },
          title: UI$1.T("Compilation")
        }));
        tabArea.appendChild(UI$1.createElement(ExecutionStatusPanel, {
          ref: this.refLink("executionStatusTab"),
          style: {
            height: "100%"
          },
          title: UI$1.T("Execution")
        }));
        this.workspace = workspaceIDE.workspace;
        this.workspaceIDE.optionButtonsBottom.appendChild(UI$1.createElement("span", {
          ref: this.refLink("compilePopupContainer"),
          style: {
            position: "relative"
          }
        }, UI$1.createElement(Button$1, {
          ref: this.refLink("compileButton"),
          icon: "cogs",
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + B to compile",
          className: workspaceButtonStyle.COMPILE,
          label: UI$1.T("Compile")
        })));
        this.workspaceIDE.optionButtonsBottom.appendChild(UI$1.createElement("span", {
          ref: this.refLink("runInputPopupContainer"),
          style: {
            position: "relative"
          }
        }, UI$1.createElement(Button$1, {
          ref: this.refLink("runInputButton"),
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + I to run input",
          icon: "play",
          label: UI$1.T("Run input"),
          className: workspaceButtonStyle.RUN
        })));
        this.compileButton.addClickListener(event => {
          event.stopPropagation();
          this.workspaceIDE.maximizeTabSection();
          this.compileCode();
        });
        this.runInputButton.addClickListener(event => {
          this.workspaceIDE.maximizeTabSection();
          event.stopPropagation();
          this.runCode();
        });
        this.inputEditor.setFile(this.workspace.getOrCreateFile(".stdin"));
        tabArea.addListener("resize", () => {
          this.inputEditor.dispatch("resize");
          this.outputEditor.dispatch("resize");
          this.stderrEditor.dispatch("resize");
        });
        this.exportFunctions();
        GlobalState$1.registerStream("workspacesession-" + this.workspace.userId + "-" + this.workspace.sessionId);
        CustomRunStore.addCreateListener(customRun => {
          this.compilationStatusTab.setCustomRun(customRun);
          this.executionStatusTab.setCustomRun(customRun);
        });
        WebsocketSubscriber.addListener("workspacesession-" + this.workspace.userId + "-" + this.workspace.sessionId, event => {
          if (event.type === "started") {
            this.workspaceIDE.dispatch("compileStarted", event);
          } else if (event.type === "compile_status") {
            this.workspaceIDE.dispatch("compileStatus", event);
          } else if (event.type === "runResults") {
            this.workspaceIDE.dispatch("customRunTestResult", event);
          } else if (event.type === "finished") {
            this.workspaceIDE.dispatch("customRunFinished", event);
          }
          InQueuePopupManager.cancelInQueuePopup();
        });
        this.workspaceIDE.addListener("compileStarted", event => {
          this.setCompilationStarted();
        });
        this.workspaceIDE.addListener("compileStatus", event => {
          this.setCompilationStatus(event.data);
        });
        this.workspaceIDE.addListener("customRunTestResult", event => {
          this.setCustomTestResult(event.data);
          this.stderrEditor.dispatch("resize");
        });
        this.workspaceIDE.addListener("submissionRunFinished", event => {
          this.enableSubmission();
        });
        this.workspaceIDE.addListener("customRunTestResult", event => {
          this.enableSubmissionDelayed();
        });
        this.workspaceIDE.addListener("customRunFinished", event => {
          this.enableSubmissionDelayed();
        });
        Dispatcher.Global.addListener("loadWorkspaceInput", input => {
          this.inputEditor.setValue(input);
          this.inputEditorTab.show();
          this.inputEditorTab.dispatch("show");
        });
      }
      static pluginName() {
        return "CustomRun";
      }
      setSubmissionDisabled(disabled, internal = true) {
        // TODO: This should NOT be named setSubmissionDisabled
        this.runInputButton.setEnabled(!disabled);
        this.compileButton.setEnabled(!disabled);
        if (this.workspaceIDE.getPlugin("ContestSubmit") && internal) {
          this.workspaceIDE.getPlugin("ContestSubmit").setSubmissionDisabled(disabled, false);
        }
      }
      enableSubmission() {
        this.compileButton.setLabel(UI$1.T("Compile"));
        this.compileButton.setLevel("info");
        this.setSubmissionDisabled(false);
      }
      enableSubmissionDelayed() {
        setTimeout(() => {
          this.enableSubmission();
        }, 200);
      }
      // TODO: This can be taken out and placed in an interaction layer with the website
      submitCode(workspaceFile, compileOnly) {
        this.setSubmissionDisabled(true);
        console.log("Submitting file: ", workspaceFile);
        let request = this.workspace.getBaseRequest();
        request.sourceCode = workspaceFile.getValue();
        //TODO: this should be rename to languageId
        request.programmingLanguageId = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage().id;
        if (compileOnly) {
          request.compileOnly = true;
        } else {
          request.customInput = this.getInputEditor().getValue();
        }
        if (this.workspaceIDE.options.contestTaskId) {
          request.contestTaskId = this.workspaceIDE.options.contestTaskId;
        }
        Ajax.postJSON("/eval/submit_custom_run/", request).then(data => {
          const jobId = data.customRunId;
          const customRun = CustomRunStore.get(jobId);
          if (customRun && customRun.compileStarted) {
            return; // The results through WebSocket came faster than the results through the Ajax
            // Thus, no popup needs to be shown.
          }
          let target = this.runInputButton;
          if (compileOnly) {
            target = this.compileButton;
          }
          InQueuePopupManager.scheduleInQueuePopup(target, data.estimatedWait, () => {
            this.enableSubmission();
          });
        }, error => {
          ErrorHandlers.showErrorAlert("Error in compiling/running custom code:\n" + error.message);
          this.enableSubmission();
        });
      }
      compileCode() {
        this.submitCode(this.workspaceIDE.codeEditor.getFile(), true);
        this.compilationStatusTab.show();
        this.compilationStatusTab.dispatch("show");
      }
      runCode() {
        this.submitCode(this.workspaceIDE.codeEditor.getFile(), false);
      }
      getInputEditor() {
        return this.inputEditor;
      }
      //TODO: reconsider how to allow for external input Editor access
      exportFunctions() {
        this.workspaceIDE.getInputEditor = function () {
          return this.inputEditor;
        };
      }
      setCompilationStarted() {
        this.compileButton.setLevel("warning");
        this.compileButton.setLabel(UI$1.T("Compiling..."));
        this.setSubmissionDisabled(true);
      }
      setCompilationStatus(compilationStatus) {
        if (compilationStatus.compileOK === true) {
          this.compileButton.setLabel(UI$1.T("Compiled"));
          this.compileButton.setLevel("success");
        } else {
          this.compileButton.setLabel("Compilation error!");
          this.compileButton.setLevel("danger");
          this.enableSubmissionDelayed();
          this.compilationStatusTab.show();
          this.compilationStatusTab.dispatch("show");
          // TODO: focus on the compilation results tab
        }
      }
      setCustomTestResult(data) {
        if (data.hasOwnProperty("stderr")) {
          this.stderrEditor.setValue(data.stderr);
          // TODO: show to stderr tab and focus on it
        }
        if (data.results.terminationReason) {
          this.executionStatusTab.show();
          this.executionStatusTab.dispatch("show");
        } else {
          this.outputEditorTab.show();
          this.outputEditorTab.dispatch("show");
        }
        this.outputEditor.setValue(data.stdout || "");
      }
    }
    WorkspaceCustomRunPlugin.priorityIndex = 500;

    function getDefaultContestStartDate() {
      let defaultDate = ServerTime.now().add({
        minutes: 1
      });
      let minutesToMilliseconds = 5 * 60 * 1000;
      let remainder = minutesToMilliseconds - defaultDate % minutesToMilliseconds;
      defaultDate.add(remainder, "milliseconds");
      return defaultDate;
    }
    class CreateContestModal extends ActionModal {
      getTitle() {
        return "New contest";
      }
      getActionName() {
        return "Create contest";
      }
      getDefaultValues() {
        return {
          contestName: "",
          contestLongName: "",
          startDate: getDefaultContestStartDate()
        };
      }
      getBody() {
        const defaultValue = this.getDefaultValues();
        return [
        // TODO When editing the contest name, if the current value of the url name is the normalized version of the long name, then edit the input
        UI$1.createElement(FormField, {
          label: "Contest name"
        }, UI$1.createElement(TextInput, {
          placeholder: "Contest long name",
          ref: "contestLongNameInput",
          value: defaultValue.contestLongName
        })), UI$1.createElement(FormField, {
          label: "Contest URL name"
        }, UI$1.createElement(TextInput, {
          placeholder: "Contest name",
          ref: "contestNameInput",
          value: defaultValue.contestName
        })), UI$1.createElement(FormField, {
          label: UI$1.createElement(UI$1.TextElement, {
            ref: this.refLink("timeTracker"),
            value: ""
          })
        }, UI$1.createElement(DateTimePicker, {
          ref: "startDatePicker",
          date: defaultValue.startDate
        })), UI$1.createElement(FormGroup, {
          style: {
            borderBottom: "1px solid #ddd"
          }
        }, UI$1.createElement("h4", null, "Duration:"), UI$1.createElement(FormField, {
          label: "Days"
        }, UI$1.createElement(NumberInput, {
          ref: "daysInput",
          min: "0",
          value: defaultValue.durationDays
        })), UI$1.createElement(FormField, {
          label: "Hours"
        }, UI$1.createElement(NumberInput, {
          ref: "hoursInput",
          min: "0",
          value: defaultValue.durationHours
        })), UI$1.createElement(FormField, {
          label: "Minutes"
        }, UI$1.createElement(NumberInput, {
          ref: "minutesInput",
          min: "0",
          value: defaultValue.durationMinutes
        }))), UI$1.createElement(FormField, {
          label: "Scoring"
        }, UI$1.createElement(Select, {
          ref: "scoringSelect",
          options: ContestScoringStore.all(),
          selected: ContestScoringStore.get(defaultValue.scoringId)
        })), UI$1.createElement(FormField, {
          label: "Visible"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "visibleCheckbox",
          initialValue: defaultValue.visible
        })), UI$1.createElement(FormField, {
          label: "Live scoreboard"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "liveResultsCheckbox",
          initialValue: defaultValue.liveResults
        })), UI$1.createElement(FormField, {
          label: "Rated"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "ratedCheckbox",
          initialValue: defaultValue.rated
        })), UI$1.createElement(FormField, {
          label: "Public sources"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "publicSourcesCheckbox",
          initialValue: defaultValue.publicSources
        }))];
      }
      onMount() {
        super.onMount();
        this.intervalId = setInterval(() => {
          let serverTime = ServerTime.now().format("HH:mm:ss");
          this.timeTracker.setValue(`Start/end date (Server time: ${serverTime})`);
        }, 1000);
      }
      onUnmount() {
        clearInterval(this.intervalId);
      }
      getRequest() {
        let request = {
          contestName: this.contestNameInput.getValue(),
          contestLongName: this.contestLongNameInput.getValue(),
          isVisible: this.visibleCheckbox.getValue(),
          rated: this.ratedCheckbox.getValue(),
          publicSources: this.publicSourcesCheckbox.getValue(),
          liveResults: this.liveResultsCheckbox.getValue(),
          scoringId: this.scoringSelect.get().id
        };
        const startDate = this.startDatePicker.getDate();
        if (startDate) {
          if (!startDate.isValid()) {
            return "datetime invalid";
          }
          const days = Math.max(this.daysInput.getValue(), 0) || 0;
          const hours = Math.max(this.hoursInput.getValue(), 0) || 0;
          const minutes = Math.max(this.minutesInput.getValue(), 0) || 0;
          const endDate = startDate.clone().add({
            days: days,
            hours: hours,
            minutes: minutes
          });
          request.startDate = startDate.unix();
          request.endDate = endDate.unix();
        }
        if (!request.contestLongName) {
          return "Please provide the contest long name";
        }
        return request;
      }
      getAjaxUrl() {
        return "/contest/add/";
      }
      action() {
        let request = this.getRequest();
        if (typeof request === "string") {
          // an error occured
          alert(request);
          return;
        }
        Ajax.postJSON(this.getAjaxUrl(), request).then(data => window.location.replace("/contest/" + data.contestName + "/edit/"), error => this.messageArea.showMessage(error.message, "red"));
      }
    }
    let CreateContestButton = ActionModalButton(CreateContestModal);

    class RegisterVirtualModal extends ActionModal {
      getContest() {
        return this.options.contest;
      }
      getVirtualContest() {
        return this.getContest().getVirtualContest();
      }
      getTitle() {
        return UI$1.createElement("h4", null, "Register for ", this.getVirtualContest().getName());
      }
      getDefaultStartDate() {
        let defaultDate = ServerTime.now().add({
          minutes: 1
        });
        let minutesToMilliseconds = 5 * 60 * 1000;
        let remainder = minutesToMilliseconds - defaultDate % minutesToMilliseconds;
        defaultDate.add(remainder, "milliseconds");
        return defaultDate;
      }
      getBody() {
        let alreadyRegistered = null;
        if (ContestUserStore.all().find(contestUser => contestUser.userId === USER.id && contestUser.getContest() && contestUser.getContest().getVirtualContest() === this.getVirtualContest())) {
          alreadyRegistered = UI$1.createElement("div", null, "Warning: You have another virtual participation for this contest. If you register, you will delete your past virtual participation.");
        }
        return [UI$1.createElement("label", {
          style: {
            "display": "inline-block",
            "padding-right": "8px"
          }
        }, "Start date (", UI$1.createElement("span", {
          ref: "timeTracker"
        }), ")"), UI$1.createElement(DateTimePicker, {
          style: {
            "display": "inline-block"
          },
          ref: "startDatePicker",
          date: getDefaultContestStartDate()
        }), alreadyRegistered];
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getActionName() {
        return UI$1.T("Register");
      }

      // TODO: remove this, dupplicated from ContestWidget.ContestSummary
      action() {
        let startDate = this.startDatePicker.getDate();
        let request = {
          contestId: this.getVirtualContest().id,
          startTime: startDate.unix()
        };
        Ajax.postJSON("/contest/register/", request).then(() => {
          Router.changeURL(["contest", this.getVirtualContest().name]);
          this.hide();
        });
      }
      onMount() {
        let timeTick = () => {
          let serverTime = ServerTime.now().format("HH:mm:ss");
          this.timeTracker.setChildren("Now " + serverTime);
        };
        timeTick();
        this.timerId = setInterval(timeTick, 1000);
      }
      onUnmount() {
        clearInterval(this.timerId);
        delete this.timerId;
      }
    }
    class VirtualParticipationButton extends ActionModalButton(RegisterVirtualModal) {
      getDefaultOptions() {
        return {
          level: Level.PRIMARY,
          label: UI$1.T("Virtual participation")
        };
      }
    }
    class ContestsTable extends Table {
      getDefaultColumns() {
        const numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let columns = [{
          value: contest => UI$1.createElement(Link, {
            href: "/contest/" + contest.name,
            value: contest.getName()
          }),
          headerName: UI$1.T("Contest"),
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contest => contest.getFormattedStartTime("DD/MM/YYYY, H:mm"),
          headerName: UI$1.T("Start time"),
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contest => contest.getFormattedDuration(),
          headerName: UI$1.T("Duration"),
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAllign: "middle"
          }
        }];
        if (USER.isAuthenticated && this.options.displayRank) {
          columns.push({
            value: contest => {
              let contestUser = contest.getUser(USER.id);
              if (!contestUser) {
                return "-";
              }
              return contestUser.rank;
            },
            headerName: UI$1.T("Rank"),
            headerStyle: {
              verticalAlign: "middle"
            },
            cellStyle: numberStyle
          });
        }
        if (USER.isSuperUser && this.options.displayEdit) {
          columns.push({
            value: contest => UI$1.createElement(Link, {
              href: "/contest/" + contest.name + "/edit/",
              value: UI$1.T("Edit contest")
            }),
            headerName: "",
            headerStyle: {
              verticalAlign: "middle"
            },
            cellStyle: {
              verticalAllign: "middle"
            }
          });
        }
        if (this.options.displayVirtual) {
          columns.push({
            value: contest => contest.virtualContestId ? UI$1.createElement(VirtualParticipationButton, {
              modalOptions: {
                contest
              }
            }) : null,
            headerName: "",
            headerStyle: {
              verticalAlign: "middle"
            },
            cellStyle: {
              verticalAllign: "middle"
            }
          });
        }
        return columns;
      }
    }
    class RunningContestPanel extends Panel {
      render() {
        if (this.options.contests.length) {
          return [UI$1.createElement("h3", null, UI$1.T("Running contests")), UI$1.createElement(ContestsTable, {
            entries: this.options.contests,
            displayEdit: true
          })];
        } else {
          return [
            //<h3>Running contests</h3>,
            //<h5>No running contests</h5>
          ];
        }
      }
    }
    class FutureContestsPanel extends Panel {
      render() {
        if (this.options.contests.length) {
          return [UI$1.createElement("h3", null, UI$1.T("Future contests")), UI$1.createElement(ContestsTable, {
            entries: this.options.contests,
            displayEdit: true
          })];
        } else {
          return [
            //<h3>Future contests</h3>,
            //<h5>No future contests</h5>
          ];
        }
      }
    }
    const ContestTabs = [{
      tabName: UI$1.T("CSA Rounds"),
      displayRank: true,
      displayVirtual: true,
      check: contest => {
        for (let i = 1; i < ContestTabs.length; i += 1) {
          if (ContestTabs[i].check(contest)) {
            return false;
          }
        }
        return true;
      }
    }, {
      tabName: UI$1.T("CSA Hourly"),
      check: contest => {
        return contest.systemGenerated;
      }
    }, {
      tabName: "IEEE",
      check: contest => {
        return contest.longName.indexOf("IEEE") !== -1;
      }
    }];
    class PastContestsPanel extends Panel {
      render() {
        let tabs = [];
        for (const contestTab of ContestTabs) {
          let entries = this.options.contests.filter(contest => contestTab.check(contest));
          if (entries.length) {
            tabs.push(UI$1.createElement(Panel, {
              title: UI$1.createElement("h4", null, contestTab.tabName)
            }, UI$1.createElement(ContestsTable, {
              entries: entries,
              displayRank: contestTab.displayRank,
              displayVirtual: contestTab.displayVirtual
            })));
          }
        }
        if (this.options.contests.length) {
          return [UI$1.createElement("h3", null, UI$1.T("Past contests")), UI$1.createElement(TabArea, null, tabs)];
        } else {
          return [UI$1.createElement("h3", null, UI$1.T("Past contests")), UI$1.createElement("h5", null, "No past contests")];
        }
      }
    }
    class ContestList extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.MEDIUM);
      }
      render() {
        let runningContestsPanel;
        let contests = ContestStore.all().filter(contest => {
          return contest.getStartTime() && contest.getEndTime() && !contest.isVirtual();
        });
        let virtualContests = ContestStore.all().filter(contest => {
          return contest.isVirtual() && contest.getBaseContest().hasFinished() && !contest.hasFinished();
        });
        contests = [...contests, ...virtualContests];
        let pastContests = contests.filter(contest => {
          return contest.hasFinished();
        }).sort((a, b) => {
          return b.getEndTime() - a.getEndTime();
        });
        let runningContests = contests.filter(contest => {
          return contest.isRunning() && !contest.systemGenerated;
        }).sort((a, b) => {
          return a.getStartTime() - b.getStartTime();
        });
        let futureContests = contests.filter(contest => {
          return !contest.hasStarted() && !contest.systemGenerated;
        }).sort((a, b) => {
          return a.getStartTime() - b.getStartTime();
        });
        if (runningContests.length) {
          runningContestsPanel = UI$1.createElement(RunningContestPanel, {
            contests: runningContests
          });
        }
        let createContestButton;
        if (USER.isSuperUser) {
          createContestButton = UI$1.createElement(CreateContestButton, {
            label: UI$1.T("Create contest"),
            level: Level.PRIMARY
          });
        }
        return [createContestButton, UI$1.createElement("h2", null, UI$1.T("Available contests"), ":"), runningContestsPanel, UI$1.createElement(FutureContestsPanel, {
          contests: futureContests
        }), UI$1.createElement(PastContestsPanel, {
          contests: pastContests
        })];
      }
    }

    var _class$U;
    let EvalTaskExamplesPanel = autoredraw(_class$U = class EvalTaskExamplesPanel extends Panel {
      setEvalJob(evalJob) {
        this.updateOptions({
          evalJob
        });
      }
      render() {
        const {
          evalJob
        } = this.options;
        return UI.createElement(EvalJobResultsTable, {
          evalJob: evalJob,
          examplesOnly: true
        });
      }
      redraw(event) {
        super.redraw();
        const {
          evalJob
        } = this.options;
        if (event && evalJob?.exampleTests.length > 0 && evalJob.tests.length === 0) {
          this.dispatch("show");
        }
      }
    }) || _class$U;

    class ContestNotRunningModal extends Modal {
      render() {
        return [UI$1.createElement("h3", null, "The contest is not currently running."), UI$1.createElement(VirtualParticipationButton, {
          modalOptions: {
            contest: this.options.contest
          }
        }), UI$1.createElement(Button$1, {
          label: UI$1.T(`Submit in ${this.options.archiveName}`),
          style: {
            margin: "20px"
          },
          level: Level.PRIMARY,
          onClick: () => {
            this.options.parent.submitCode(this.options.onlyExamples, this.options.archiveTaskId);
            this.hide();
          }
        }), UI$1.createElement(Link, {
          style: {
            margin: "20px"
          },
          href: `/contest/${this.options.archiveUrl}/task/` + this.options.evalTask.urlName,
          value: UI$1.T(`Open task in ${this.options.archiveName}`)
        }), UI$1.createElement("div", null, UI$1.createElement(FormField, {
          label: "Always submit in archive"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "disableCheckbox"
        })))];
      }
      onMount() {
        super.onMount();
        this.disableCheckbox.addChangeListener(() => {
          this.options.parent.contestNotRunningModalDisabled = !this.options.parent.contestNotRunningModalDisabled;
        });
      }
      hide() {
        this.options.parent.setSubmissionDisabled(false);
        super.hide();
      }
    }
    const ContestSubmitAjax = new FixedURLAjaxHandler("/eval/submit_evaljob/");
    class WorkspaceContestSubmitPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        let tabArea = workspaceIDE.tabArea;
        this.workspace = this.workspaceIDE.workspace;
        this.contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        this.evalTask = this.contestTask.getEvalTask();
        this.contest = this.contestTask.getContest();
        tabArea.appendChild(UI$1.createElement(EvalTaskExamplesPanel, {
          ref: this.refLink("examplesTab"),
          title: UI$1.T("Examples"),
          evalTask: this.evalTask
        }));

        // TODO: We want to remount this onclick
        tabArea.appendChild(UI$1.createElement(SubmissionStatusPanel, {
          ref: this.refLink("submissionTab"),
          title: UI$1.T("Submission"),
          evalTask: this.evalTask
        }));
        this.workspaceIDE.optionButtonsBottom.appendChild(UI$1.createElement("span", {
          ref: this.refLink("runExamplesPopupContainer"),
          style: {
            position: "relative"
          }
        }, UI$1.createElement(Button$1, {
          ref: this.refLink("runExamplesButton"),
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + E to run examples",
          className: workspaceButtonStyle.RUN,
          icon: "check",
          label: UI$1.T("Run examples")
        })));
        this.workspaceIDE.optionButtonsBottom.appendChild(UI$1.createElement("span", {
          ref: this.refLink("submitPopupContainer"),
          style: {
            position: "relative"
          }
        }, UI$1.createElement(Button$1, {
          ref: this.refLink("submitButton"),
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + U to submit",
          className: workspaceButtonStyle.SUBMIT,
          icon: "paper-plane",
          label: UI$1.T("Submit")
        })));
        this.submitButton.addClickListener(event => {
          event.stopPropagation();
          this.submitCode();
          this.workspaceIDE.maximizeTabSection();
        });
        this.runExamplesButton.addClickListener(() => {
          this.examplesTab.show();
          this.examplesTab.dispatch("show");
          this.submitCode(true);
          this.workspaceIDE.maximizeTabSection();
        });
        EvalJobStore.addCreateListener(evalJob => {
          if (evalJob.statusStream.endsWith(this.workspace.sessionId)) {
            this.setEvalJob(evalJob);
          }
        });
        this.workspaceIDE.addListener("submissionStarted", event => {
          this.setSubmissionDisabled(true);
          InQueuePopupManager.cancelInQueuePopup();
        });
        this.workspaceIDE.addListener("submissionRunFinished", event => {
          this.setSubmissionDisabled(false);
        });
        Dispatcher.Global.addListener("loadEvalJobSource", event => {
          let evalJob = event.evalJob;
          if (evalJob.contestTaskId != this.contestTask.id) {
            return;
          }
          let programmingLanguage = event.evalJob.getProgrammingLanguage();
          this.workspaceIDE.getPlugin("FileManager").updateProgrammingLanguage(programmingLanguage);
          this.workspaceIDE.codeEditor.setValue(evalJob.sourceText, true);
          this.workspaceIDE.resizeCodeEditor();
          Dispatcher.Global.dispatch("finishedLoadEvalJobSource");
        });
      }
      static pluginName() {
        return "ContestSubmit";
      }
      setSubmissionDisabled(disabled, internal = true) {
        this.submitButton.setEnabled(!disabled);
        this.runExamplesButton.setEnabled(!disabled);
        if (this.workspaceIDE.getPlugin("CustomRun") && internal) {
          this.workspaceIDE.getPlugin("CustomRun").setSubmissionDisabled(disabled, false);
        }
      }
      showContestNotRunningModal(archiveTaskId, archiveUrl, archiveName, onlyExamples) {
        if (this.contestNotRunningModalDisabled) {
          this.submitCode(onlyExamples, archiveTaskId);
        } else {
          ContestNotRunningModal.show({
            archiveTaskId: archiveTaskId,
            archiveUrl: archiveUrl,
            archiveName: archiveName,
            contest: this.contest,
            evalTask: this.evalTask,
            overflow: "auto",
            parent: this,
            onlyExamples: onlyExamples,
            fillScreen: true
          });
        }
      }
      getAjaxHandler() {
        return this.ajaxHandler || ContestSubmitAjax;
      }
      setAjaxHandler(ajaxHandler) {
        this.ajaxHandler = ajaxHandler;
      }
      submitCode(onlyExamples, contestTaskId = -1) {
        let workspaceFile = this.workspaceIDE.codeEditor.getFile();
        let request = this.workspace.getBaseRequest();
        if (contestTaskId === -1) {
          request.contestTaskId = this.contestTask.id;
        } else {
          request.contestTaskId = contestTaskId;
        }
        request.sourceCode = workspaceFile.getValue();
        //TODO: this should be rename to languageId
        request.programmingLanguageId = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage().id;
        if (onlyExamples) {
          request.onlyExamples = true;
        }
        this.resetStatus();
        this.setSubmissionDisabled(true);
        this.getAjaxHandler().postJSON(request).then(data => {
          const evalJobId = data.evalJobId;
          const evalJob = EvalJobStore.get(evalJobId);
          if (evalJob?.compileStarted) {
            // Results through WebSocket came before the XHR.
            // Thus, no popup needs to be displayed.
            return;
          }
          let target = this.submitButton;
          if (onlyExamples) {
            target = this.runExamplesButton;
          }
          InQueuePopupManager.scheduleInQueuePopup(target, data.estimatedWait, () => {
            this.setSubmissionDisabled(false);
          });
        }, error => {
          if (error.message === "The contest is not running" && error.archiveTask) {
            ContestTaskStore.create(error.archiveTask);
            this.showContestNotRunningModal(error.archiveTask.id, error.archiveUrl, error.archiveName, onlyExamples);
          } else {
            ErrorHandlers.showErrorAlert("Error in submitting code:\n" + error.message);
            this.setSubmissionDisabled(false);
          }
        });
      }
      setEvalJob(evalJob) {
        this.examplesTab.setEvalJob(evalJob);
        this.workspaceIDE.getPlugin("CustomRun").compilationStatusTab.setCustomRun(evalJob);
        if (!evalJob.onlyExamples) {
          this.submissionTab.setEvalJob(evalJob);
        }
        this.attachChangeListener(evalJob, event => {
          if (event.type === "started") {
            this.workspaceIDE.dispatch("compileStarted", event);
            this.workspaceIDE.dispatch("submissionStarted", event);
          } else if (event.type === "compile_status") {
            this.workspaceIDE.dispatch("compileStatus", event);
            if (!event.data.compileOK) {
              this.setSubmissionDisabled(false);
            }
          } else if (event.type === "test_results") {
            this.workspaceIDE.dispatch("submissionTestResult", event);
          } else if (event.type === "finished") {
            this.workspaceIDE.dispatch("submissionRunFinished", event);
          }
        });
      }
      resetStatus() {
        // Reset progress bar
        this.submissionTab.setEvalJob(null);

        // Reset counters
        this.numTests = 0;
        this.numTestsDone = 0;
        this.currentTest = 0;
        this.worstCPU = 0;
        this.worstMemory = 0;
      }
    }
    WorkspaceContestSubmitPlugin.priorityIndex = 600;

    // This plugin handles changing the language (is faked as opening a file)
    class WorkspaceSingleFileManagerPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspace = workspaceIDE.workspace;
        GlobalState$1.registerStream(this.workspace.streamName());
        this.workspace.addListener("updateExternal", event => {
          console.log("Workspace update event data: ", event);
        });
        this.undoManagers = new Map();
        this.programmingLanguageSelect = this.workspaceIDE.programmingLanguageSelect;
        this.changeFileCallback = () => {
          this.updateProgrammingLanguage(this.programmingLanguageSelect.get());
        };
        this.programmingLanguageSelect.addChangeListener(this.changeFileCallback);
        this.loadFiles();
      }
      // We should have a different undo manager for each different language
      updateUndoManager(workspaceFile) {
        if (!this.undoManagers.has(workspaceFile)) {
          const UndoManager = window.ace.require("ace/undomanager").UndoManager;
          this.undoManagers.set(workspaceFile, new UndoManager());
        }
        this.workspaceIDE.codeEditor.setUndoManager(this.undoManagers.get(workspaceFile));
      }
      static pluginName() {
        return "FileManager";
      }
      updateProgrammingLanguage(programmingLanguage) {
        let defaultCode;
        [programmingLanguage, defaultCode] = this.getLanguageAndCode(programmingLanguage);
        if (programmingLanguage !== this.getSelectedProgrammingLanguage()) {
          this.setSelectedProgrammingLanguage(programmingLanguage);
        }
        let workspaceFile = this.workspace.getOrCreateFileForLanguage(programmingLanguage, defaultCode);
        this.setIDEOpenFile(workspaceFile, programmingLanguage);
        this.workspaceIDE.dispatch("changeLanguage", programmingLanguage);
      }
      getSelectedProgrammingLanguage() {
        return this.programmingLanguageSelect.get();
      }
      setSelectedProgrammingLanguage(programmingLanguage) {
        this.programmingLanguageSelect.set(programmingLanguage);
      }
      setIDEOpenFile(workspaceFile, programmingLanguage, updateLanguage = true) {
        programmingLanguage = programmingLanguage || ProgrammingLanguage.getLanguageForFileName(workspaceFile.getName());

        //TODO: these should not be set here, but through a dispatcher
        this.workspaceIDE.saveFileStatusLabel.setFile(workspaceFile);
        this.workspaceIDE.codeEditor.setFile(workspaceFile);
        this.workspaceIDE.codeEditor.setAceMode(programmingLanguage);
        if (updateLanguage) {
          this.setSelectedProgrammingLanguage(programmingLanguage);
        }
        this.updateUndoManager(workspaceFile);
      }
      // This function is for eval tasks with enforced templates.
      // It checks whether the language given is among the eval task's allowed languages.
      // Also gives the default code for the language or its replacer.
      getLanguageAndCode(language) {
        let defaultCode;
        if (this.workspaceIDE.options.contestTaskId) {
          let evalTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId).getEvalTask();
          if (evalTask.hasEnforcedTemplates() && evalTask.getTemplate(language)) {
            defaultCode = evalTask.getTemplate(language);
          } else if (evalTask.hasEnforcedTemplates()) {
            defaultCode = language.getDefaultTemplateComment() + language.getDefaultSource();
          }
        }
        return [language, defaultCode];
      }
      getDefaultFile() {
        let workspace = this.workspace;
        // If there's a file, open the last modified on
        // Otherwise, open the file for the default programming language stored for this user
        // In case we don't have any file, just create one for the user's language

        let defaultFile = null;
        for (let workspaceFile of workspace.files.values()) {
          //Ignore files that start with a .
          if (!workspaceFile.name.startsWith(".") && (defaultFile == null || workspaceFile.serverLastSaved > defaultFile.serverLastSaved)) {
            defaultFile = workspaceFile;
          }
        }
        if (defaultFile) {
          return defaultFile;
        }

        // If we have an eval task that enforces templates, we want to overwrite the initial template
        let language = ProgrammingLanguage.getDefaultLanguage();
        return workspace.getOrCreateFileForLanguage(...this.getLanguageAndCode(language));
      }
      loadFiles() {
        this.setIDEOpenFile(this.getDefaultFile());
      }
    }
    WorkspaceSingleFileManagerPlugin.priorityIndex = 200;

    class WorkspaceCompilerParserPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE, "CompilerParser");
        let cppLanguage = ProgrammingLanguage.get(1);
        let javaLanguage = ProgrammingLanguage.get(2);
        let python2Language = ProgrammingLanguage.get(3);
        let python3Language = ProgrammingLanguage.get(4);

        //TODO: have a compiler parser class!
        cppLanguage.compilerParser = function () {
          var obj = {};
          obj.getCompilerAnnotations = function (compilerMessage) {
            var annotations = [];
            compilerMessage.split("\n").forEach(function (message) {
              var messageElements = message.match(/Main.cpp:(\d*)\:(\d*):\s*\w* (\w+): (.*)/);
              if (messageElements == null) {
                return;
              }
              annotations.push({
                row: parseInt(messageElements[1]) - 1,
                column: messageElements[2],
                type: messageElements[3],
                text: messageElements[4]
              });
            });
            return annotations;
          };
          return obj;
        }();
        javaLanguage.compilerParser = function () {
          var obj = {};
          obj.getCompilerAnnotations = function (compilerMessage) {
            var annotations = [];
            compilerMessage.split("\n").forEach(function (message) {
              var messageElements = message.match(/Main.java:(\d*)\:\s*\w* (\w+): (.*)/);
              if (messageElements == null) {
                return;
              }
              annotations.push({
                row: parseInt(messageElements[1]) - 1,
                column: 1,
                type: messageElements[2],
                text: messageElements[3]
              });
            });
            return annotations;
          };
          return obj;
        }();
        python2Language.compilerParser = function () {
          var obj = {};
          obj.getCompilerAnnotations = function (message) {
            var annotations = [];
            var messageElements = message.match(/File "Main.py", line (\d*)\n.*\n.*\n.*\: (.*)/);
            if (messageElements == null) {
              return;
            }
            annotations.push({
              row: parseInt(messageElements[1]) - 1,
              column: 1,
              type: "error",
              text: messageElements[2]
            });
            return annotations;
          };
          return obj;
        }();
        python3Language.compilerParser = function () {
          var obj = {};
          obj.getCompilerAnnotations = function (message) {
            var annotations = [];
            var messageElements = message.match(/File "Main.py", line (\d*)\n.*\n.*\n.*\: (.*)/);
            if (messageElements == null) {
              return;
            }
            annotations.push({
              row: parseInt(messageElements[1]) - 1,
              column: 1,
              type: "error",
              text: messageElements[2]
            });
            return annotations;
          };
          return obj;
        }();
        for (let programmingLanguage of ProgrammingLanguage.all()) {
          if (!programmingLanguage.compilerParser) {
            programmingLanguage.compilerParser = function () {
              var obj = {};
              obj.getCompilerAnnotations = function (message) {
                return [];
              };
              return obj;
            }();
          }
        }
        this.workspaceIDE.addListener("compileStatus", event => {
          let programmingLanguage = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage();
          this.workspaceIDE.codeEditor.setAnnotations(programmingLanguage.compilerParser.getCompilerAnnotations(event.data.compilerMessage));
        });
      }
    }
    WorkspaceCompilerParserPlugin.priorityIndex = 800;

    class WorkspaceKeymapPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE, "KeymapManager");
        this.keyboardShortcutsHandler = event => {
          if (!document.body.contains(this.workspaceIDE.node)) {
            return;
          }
          if (event.keyCode == 8) ;
          if (event.ctrlKey || event.metaKey) {
            let button, key, plugin;
            if (event.ctrlKey) {
              key = "Ctrl";
            } else {
              key = "Cmd";
            }
            //Enter case must be treated differently
            if (event.which === 13) {
              event.preventDefault();
              button = this.workspaceIDE.fullScreenButton;
              if (button) {
                button.node.click();
              }
            }
            switch (String.fromCharCode(event.which).toLowerCase()) {
              case 's':
                event.preventDefault();
                this.workspaceIDE.workspace.saveAllFiles();
                break;
              case 'b':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("CustomRun");
                if (plugin) {
                  plugin.compileButton.node.click();
                }
                break;
              case 'o':
                event.preventDefault();
                this.workspaceIDE.uploadFile.node.click();
                break;
              case 'i':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("CustomRun");
                if (plugin) {
                  plugin.runInputButton.node.click();
                }
                break;
              case 'u':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("ContestSubmit");
                if (plugin) {
                  plugin.submitButton.node.click();
                }
                break;
              case 'e':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("ContestSubmit");
                if (plugin) {
                  console.log(key + "+E pressed, running examples");
                  plugin.runExamplesButton.node.click();
                }
                break;
              case 'm':
                event.preventDefault();
                button = this.workspaceIDE.toggleTabAreaButton;
                if (button) {
                  button.node.click();
                }
                break;
            }
          }
          //TODO list of shortcuts to consider:
          //--Autoformat code
          //--Run lint checker
          //
        };
        window.addEventListener("keydown", this.keyboardShortcutsHandler);
      }
      register(keys, callback) {}
      unregister(keys, callback) {}
    }
    WorkspaceKeymapPlugin.priorityIndex = 700;

    // import {UI, Button, Size, Direction, Link} from "UI";
    class WorkspaceSharePlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspace = workspaceIDE.workspace;
        this.workspaceIDE.optionButtonsTopLeft.insertChild(UI$1.createElement(Button$1, {
          ref: this.refLink("shareButton"),
          icon: "share-square-o",
          HTMLtitle: "Click to share the code",
          className: this.workspaceIDE.styleSheet.menuButton,
          label: UI$1.T("Share")
        }), 0);
        this.workspaceIDE.codeEditor.file.addListener("userChanged", () => {
          this.customRun = undefined;
          this.popup && this.popup.hide();
          delete this.popup;
        });
        this.workspaceIDE.addListener("compileStarted", () => {
          this.popup && this.popup.hide();
          delete this.popup;
        });
        this.workspaceIDE.addListener("customRunFinished", event => {
          if (event.objectType !== "customrun") {
            return;
          }
          this.customRun = CustomRunStore.get(event.objectId);
          this.popup && this.popup.hide();
          delete this.popup;
        });
        this.shareButton.addClickListener(event => {
          event.stopPropagation();
          this.togglePopup();
        });
      }
      static pluginName() {
        return "Share";
      }
      getPopupContent() {
        let buildContent = () => {
          return [UI$1.createElement(Link, {
            ref: this.refLink("popupUrl"),
            newTab: true,
            href: this.customRun.buildPublicUrl(),
            value: this.customRun.buildPublicUrl()
          }), UI$1.createElement(Button$1, {
            ref: this.refLink("copyUrlButton"),
            size: Size.SMALL,
            onClick: () => this.copyUrl(),
            style: {
              marginLeft: "5px"
            },
            icon: "files-o",
            label: UI$1.T("Copy")
          })];
        };
        const updatePopup = () => {
          this.popup.setContent(buildContent());
          this.popup.bindInsideParent();
        };
        if (!this.customRun) {
          this.createCustomRun(updatePopup);
          return UI$1.createElement(FAIcon, {
            icon: "spinner fa-spin"
          });
        }
        if (this.customRun && !this.customRun.isPublic) {
          this.customRun.setPublic(updatePopup);
          return UI$1.createElement(FAIcon, {
            icon: "spinner fa-spin"
          });
        }
        return buildContent();
      }
      createCustomRun(callback) {
        const workspaceFile = this.workspaceIDE.codeEditor.getFile();
        let request = this.workspace.getBaseRequest();
        request.sourceCode = workspaceFile.getValue();
        //TODO: this should be rename to languageId
        request.programmingLanguageId = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage().id;
        Ajax.postJSON("/eval/create_share_custom_run/", request).then(data => {
          this.customRun = CustomRunStore.get(data.customRunId);
          callback();
        });
      }
      copyUrl() {
        window.getSelection().removeAllRanges();
        let range = document.createRange();
        range.selectNode(this.popupUrl.node);
        window.getSelection().addRange(range);
        let successful;
        try {
          // https://developers.google.com/web/updates/2015/04/cut-and-copy-commands?hl=en
          // Now that we've selected the anchor text, execute the copy command
          successful = document.execCommand('copy');
          let msg = successful ? 'successful' : 'unsuccessful';
          console.log('Copy command was ' + msg);
        } catch (err) {
          successful = false;
          console.log('Oops, unable to copy');
        }
        if (!successful) {
          this.copyUrlButton.hide();
          this.popup.bindInsideParent();
        }
        window.getSelection().removeAllRanges();
      }
      togglePopup() {
        if (this.popup && this.popup.isInDocument()) {
          this.popup.hide();
          delete this.popup;
          return;
        }
        this.popup = BasePopup.create(document.body, {
          target: this.shareButton,
          children: this.getPopupContent(),
          arrowDirection: Direction.UP,
          bodyPlaced: true
        });
      }
    }
    WorkspaceSharePlugin.priorityIndex = 300;

    var _class$T, _descriptor$o, _descriptor2$m;
    let EnforcedTemplateStyle = (_class$T = class EnforcedTemplateStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "readOnly", _descriptor$o, this);
        _initializerDefineProperty(this, "firstLine", _descriptor2$m, this);
      }
      static getCollapsedClassName() {
        return [this.getInstance().firstLine, "fa", "fa-caret-right"];
      }
      static getUncollapsedClassName() {
        return [this.getInstance().firstLine, "fa", "fa-caret-down"];
      }
    }, (_descriptor$o = _applyDecoratedDescriptor(_class$T.prototype, "readOnly", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "background-color": "#630707",
          "opacity": "0.2",
          "position": "absolute",
          "z-index": "10",
          "border-radius": "0"
        };
      }
    }), _descriptor2$m = _applyDecoratedDescriptor(_class$T.prototype, "firstLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ":before": {
            "margin-right": "7px",
            "font": "normal normal normal 14px/1 FontAwesome",
            "font-size": "1.1em"
          },
          "margin-left": "-7px",
          "font": "inherit"
        };
      }
    })), _class$T);
    function removeDecorations(session, row) {
      for (let className of EnforcedTemplateStyle.getCollapsedClassName()) {
        session.removeGutterDecoration(row, className);
      }
      for (let className of EnforcedTemplateStyle.getUncollapsedClassName()) {
        session.removeGutterDecoration(row, className);
      }
    }
    function decorateUncollapsed(session, range) {
      for (let className of EnforcedTemplateStyle.getCollapsedClassName()) {
        session.removeGutterDecoration(range.start.row, className);
      }
      for (let className of EnforcedTemplateStyle.getUncollapsedClassName()) {
        session.addGutterDecoration(range.start.row, className);
      }
    }
    function decorateCollapsed(session, range) {
      for (let className of EnforcedTemplateStyle.getUncollapsedClassName()) {
        session.removeGutterDecoration(range.start.row, className);
      }
      for (let className of EnforcedTemplateStyle.getCollapsedClassName()) {
        session.addGutterDecoration(range.start.row, className);
      }
    }
    function getRanges(template, code) {
      let blocks = [];
      for (let i = 0; i < template.length; i += 1) {
        if (template[i].type === "editable") {
          blocks.push(null);
        } else {
          blocks.push(template[i].lines.join("\n") + "\n");
        }
      }
      let dp = new Map();
      let getDp = (codeIndex, blockIndex) => {
        if (blockIndex === -1) {
          return codeIndex === -1;
        }
        let key = codeIndex + " " + blockIndex;
        if (dp.has(key)) {
          return dp.get(key) !== -2;
        }
        if (blocks[blockIndex]) {
          while (blocks[blockIndex].indexOf("\r") !== -1) {
            blocks[blockIndex] = blocks[blockIndex].replace("\r", "");
          }
          if (codeIndex + 1 < blocks[blockIndex].length || code.substring(codeIndex - blocks[blockIndex].length + 1, codeIndex + 1) !== blocks[blockIndex] || !getDp(codeIndex - blocks[blockIndex].length, blockIndex - 1)) {
            dp.set(key, -2);
          } else {
            dp.set(key, codeIndex - blocks[blockIndex].length);
          }
        } else {
          for (let i = 0; i <= codeIndex; i += 1) {
            if (getDp(codeIndex - i, blockIndex - 1)) {
              dp.set(key, codeIndex - i);
            }
          }
          if (!dp.has(key)) {
            dp.set(key, -2);
          }
        }
        return dp.get(key) !== -2;
      };
      let match = getDp(code.length - 1, blocks.length - 1);
      if (!match) {
        console.error("Failed to identify template.");
        return null;
      }
      let segments = [];
      let codeIndex = code.length - 1;
      for (let blockIndex = blocks.length - 1; blockIndex >= 0; blockIndex -= 1) {
        let previousCodeIndex = dp.get(codeIndex + " " + blockIndex);
        segments.push([previousCodeIndex + 1, codeIndex]);
        codeIndex = previousCodeIndex;
      }
      segments.reverse();
      let ranges = [];
      for (let i = 0; i < segments.length; i += 1) {
        if (template[i].type === "editable") {
          continue;
        }
        let segment = segments[i];
        let getLastLineCharacters = text => {
          let lastLineCharacters = 0;
          while (lastLineCharacters + 1 < text.length && text[text.length - 1 - lastLineCharacters] != '\n') {
            lastLineCharacters += 1;
          }
          return lastLineCharacters;
        };
        let firstLine = (code.substring(0, segment[0]).match(/\n/g) || []).length;
        let firstCol = getLastLineCharacters(code.substring(0, segment[0]));
        if (firstCol) {
          firstCol += 1;
        }
        let lastLine = (code.substring(0, segment[1] + 1).match(/\n/g) || []).length;
        let lastCol = getLastLineCharacters(code.substring(0, segment[1] + 1));
        if (lastCol) {
          lastCol += 1;
        }
        const Range = window.ace.require("ace/range").Range;
        ranges.push(new Range(firstLine, firstCol, lastLine, lastCol));
      }
      return ranges;
    }
    function updateAceRanges(template, code, markers, folds, session, anchors) {
      let ranges = getRanges(template, code);
      if (!ranges) {
        return null;
      }
      let next = 0;
      for (let block of template) {
        if (block.type === "editable") {
          continue;
        }
        let range = ranges[next++];
        markers.push(session.addMarker(range, EnforcedTemplateStyle.getInstance().readOnly));
        {
          range.start = session.doc.createAnchor(range.start);
          range.end = session.doc.createAnchor(range.end);
          range.end.$insertRight = true;
        }
        if (block.type === "collapsed") {
          const Range = window.ace.require("ace/range").Range;
          folds.push(session.addFold("...", new Range(range.start.row, range.start.column, range.end.row - 1, 10000)));
          folds[folds.length - 1].isFolded = true;
          decorateCollapsed(session, range);
        } else if (block.type === "collapsible") {
          folds.push({
            isFolded: false
          });
          decorateUncollapsed(session, range);
        } else if (block.type === "uncollapsible") {
          folds.push(null);
        }
      }
      return ranges;
    }

    class WorkspaceEnforcedTemplatePlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        let code = this.workspaceIDE.codeEditor.getValue();
        while (code.indexOf("\r") !== -1) {
          code = code.replace("\r", "");
        }
        this.workspaceIDE.codeEditor.setValue(code);
        let contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        let evalTask = contestTask.getEvalTask();
        if (!evalTask.hasEnforcedTemplates()) {
          return;
        }
        this.markers = [];
        this.ranges = [];
        this.workspace = workspaceIDE.workspace;
        this.programmingLanguageSelect = this.workspaceIDE.programmingLanguageSelect;
        let tryUpdateTemplate = () => {
          let matchedTemplate = this.updateTemplate(this.programmingLanguageSelect.get());
          if (matchedTemplate) {
            this.updateAceMethods();
          } else {
            this.undoUpdateAceMethods();
          }
          this.updateGutter();
        };
        this.programmingLanguageSelect.addChangeListener(() => {
          tryUpdateTemplate();
        });
        Dispatcher.Global.addListener("finishedLoadEvalJobSource", () => {
          tryUpdateTemplate();
        });
        this.workspaceIDE.addListener("finishedFileUpload", () => {
          tryUpdateTemplate();
        });
        const UndoManager = window.ace.require("ace/undomanager").UndoManager;
        const oldUndo = UndoManager.prototype.undo;
        UndoManager.prototype.undo = function () {
          let returnValue = oldUndo.call(this, ...arguments);
          if (returnValue) {
            tryUpdateTemplate();
          }
          return returnValue;
        };
        const oldRedo = UndoManager.prototype.redo;
        UndoManager.prototype.redo = function () {
          let returnValue = oldRedo.call(this, ...arguments);
          if (returnValue) {
            tryUpdateTemplate();
          }
          return returnValue;
        };
        tryUpdateTemplate();
        let ace = this.workspaceIDE.codeEditor.ace;
        this.lastCursorPosition = this.currentCursorPosition = ace.selection.getCursor();
        this.lineCount = 0;
        ace.on("change", () => {
          this.updateGutter();
        });
        ace.selection.on("changeCursor", () => {
          this.lastCursorPosition = this.currentCursorPosition;
          this.currentCursorPosition = ace.selection.getCursor();
        });
        this.workspaceIDE.resetTemplateButton = UI$1.createElement(Button$1, {
          className: this.workspaceIDE.styleSheet.menuButton,
          label: "Load template",
          icon: "refresh",
          style: {
            display: "inline-block"
          },
          onClick: () => this.resetTemplate()
        });
        this.workspaceIDE.resetTemplateButton.mount(this.workspaceIDE.optionButtonsTopRight, this.workspaceIDE.settingsButton.node);
      }
      undoUpdateAceMethods() {
        if (!this.updatedAceMethods) {
          return;
        }
        let editor = this.workspaceIDE.codeEditor;
        let ace = editor.ace;
        let session = this.session;
        editor.removeNodeListener("keypress", this.keyPressCallback);
        ace.$tryReplace = ace.old$tryReplace;
        session.insert = session.oldInsert;
        session.remove = session.oldRemove;
        session.moveTest = session.oldMoveText;
        session.off("changeFold", this.changeFoldCallback);
        ace.off("gutterclick", this.gutterClickCallback);
        let Mode = window.ace.require("ace/mode/text").Mode;
        Mode.prototype.toggleCommentLines = Mode.prototype.oldToggleCommentLines;
        this.updatedAceMethods = false;
      }
      updateAceMethods() {
        if (this.updatedAceMethods) {
          return;
        }
        let editor = this.workspaceIDE.codeEditor;
        let ace = editor.ace;
        let session = this.session;

        // HUGE HACK TO DEAL WITH ACE BULLSHIT
        // Pressing "enter" right before a space will delete the space even if it's
        // inside an un-editable area...
        this.keyPressCallback = event => {
          let cursor = ace.getCursorPosition();
          for (let range of this.ranges) {
            if (insideRange(range, cursor)) {
              event.preventDefault();
              event.stopPropagation();
              return;
            }
          }
        };
        editor.addNodeListener("keypress", this.keyPressCallback);
        let beforeRange = (range, position) => {
          let start = range.start;
          return position.row < start.row || position.row == start.row && position.column <= start.column;
        };
        let afterRange = (range, position) => {
          let end = range.end;
          return position.row > end.row || position.row == end.row && position.column >= end.column;
        };
        let insideRange = (range, position) => {
          return !beforeRange(range, position) && !afterRange(range, position);
        };
        let intersects = (range1, range2) => {
          return insideRange(range1, range2.start) || insideRange(range1, range2.end) || insideRange(range2, range1.start) || insideRange(range2, range1.end);
        };
        let allRange = (start, range, end) => {
          return start.row === range.start.row && start.column === range.start.column && end.row === range.end.row && end.column === range.end.column;
        };

        //not lambdas. Need a reference
        let self = this;
        ace.old$tryReplace = ace.$tryReplace;
        ace.$tryReplace = function (replaceRange) {
          for (let range of self.ranges) {
            if (intersects(range, replaceRange)) {
              return null;
            }
          }
          return ace.old$tryReplace(...arguments);
        };
        session.oldInsert = session.insert;
        session.insert = function (position, text) {
          let afterAll = true,
            beforeAll = true;
          for (let range of self.ranges) {
            if (insideRange(range, position) || position.column === 0 && position.row === range.start.row) {
              return;
            }
            if (beforeRange(range, position)) {
              afterAll = false;
            }
            if (afterRange(range, position)) {
              beforeAll = false;
            }
          }
          if (!afterAll && !beforeAll) {
            return session.oldInsert(...arguments);
          }
        };
        session.oldRemove = session.remove;
        session.remove = function (removeRange) {
          for (let range of self.ranges) {
            if (intersects(range, removeRange) || removeRange.end.row === range.start.row) {
              return false;
            }
          }
          for (let i = 0; i < self.ranges.length - 1; i += 1) {
            if (allRange(self.ranges[i].end, removeRange, self.ranges[i + 1].start)) {
              return false;
            }
          }
          return session.oldRemove(...arguments);
        };
        session.oldMoveText = session.moveText;
        session.moveText = function (fromRange, toPosition, copy) {
          for (let range of self.ranges) {
            if (intersects(range, fromRange) || insideRange(range, toPosition)) {
              return fromRange;
            }
          }
          return session.oldMoveText(...arguments);
        };
        this.changeFoldCallback = edit => {
          if (!edit.data || editor.getValue() === "") {
            return;
          }
          if (edit.action === "remove") {
            for (let i = 0; i < this.folds.length; i += 1) {
              if (edit.data === this.folds[i]) {
                this.folds[i] = {
                  isFolded: false
                };
                decorateUncollapsed(session, this.ranges[i]);
                this.updateGutter();
                break;
              }
            }
          }
        };
        session.on("changeFold", this.changeFoldCallback);
        this.gutterClickCallback = event => {
          let row = event.getDocumentPosition().row;
          for (let i = 0; i < this.ranges.length; i += 1) {
            if (this.ranges[i].start.row === row && this.folds[i]) {
              ace.selection.clearSelection();
              ace.selection.moveCursorTo(this.lastCursorPosition.row, this.lastCursorPosition.column);
              if (this.folds[i].isFolded) {
                session.removeFold(this.folds[i]);
              } else if (!this.folds[i].isFolded) {
                const Range = window.ace.require("ace/range").Range;
                this.folds[i] = session.addFold("...", new Range(this.ranges[i].start.row, this.ranges[i].start.column, this.ranges[i].end.row - 1, 10000));
                this.folds[i].isFolded = true;
                decorateCollapsed(session, this.ranges[i]);
              }
            }
          }
        };
        ace.on("gutterclick", this.gutterClickCallback);
        let Mode = window.ace.require("ace/mode/text").Mode;
        Mode.prototype.oldToggleCommentLines = Mode.prototype.toggleCommentLines;
        Mode.prototype.toggleCommentLines = function (state, session, startRow, endRow) {
          let language = self.programmingLanguageSelect.get();
          let contestTask = ContestTaskStore.get(self.workspaceIDE.options.contestTaskId);
          let evalTask = contestTask.getEvalTask();
          let template = evalTask.enforcedTemplates[language.id] || [];
          let ranges = getRanges(template, self.workspaceIDE.codeEditor.getValue());
          for (let range of ranges) {
            if (range.start.row <= startRow && startRow < range.end.row) {
              return;
            }
            if (range.start.row <= endRow && endRow < range.end.row) {
              return;
            }
          }
          this.oldToggleCommentLines(state, session, startRow, endRow);
        };
        this.updatedAceMethods = true;
      }
      updateGutter() {
        if (!this.workspaceIDE.codeEditor.getValue()) {
          return;
        }
        this.lineCount = Math.max(this.lineCount, this.session.doc.getLength());
        for (let i = 0; i <= this.lineCount; i += 1) {
          removeDecorations(this.session, i);
        }
        for (let i = 0; i < (this.ranges || []).length; i += 1) {
          if (this.folds[i] && this.folds[i].isFolded) {
            decorateCollapsed(this.session, this.ranges[i]);
          } else if (this.folds[i]) {
            decorateUncollapsed(this.session, this.ranges[i]);
          }
        }
      }
      updateTemplate(language) {
        let editor = this.workspaceIDE.codeEditor;
        let ace = editor.ace,
          session;
        this.session = session = ace.getSession();
        let code = editor.getValue();
        let contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        let evalTask = contestTask.getEvalTask();
        let template = evalTask.enforcedTemplates[language.id] || [];
        for (let markerId of this.markers) {
          session.removeMarker(markerId);
        }
        this.markers = [];
        for (let fold of this.folds || []) {
          if (fold && fold.isFolded) {
            session.removeFold(fold);
          }
        }
        this.folds = [];
        if (!evalTask.getTemplate(language)) {
          return;
        }
        this.ranges = updateAceRanges(template, code, this.markers, this.folds, session);
        if (this.ranges) {
          this.updateGutter();
        }
        return !!this.ranges;
      }
      resetTemplate() {
        let language = this.programmingLanguageSelect.get();
        let contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        let evalTask = contestTask.getEvalTask();
        if (evalTask.hasEnforcedTemplates() && evalTask.getTemplate(language)) {
          this.workspaceIDE.codeEditor.setValue(evalTask.getTemplate(language), 1);
          let match = this.updateTemplate(language);
          if (match) {
            this.updateAceMethods();
          } else {
            this.undoUpdateAceMethods();
          }
        } else {
          this.workspaceIDE.codeEditor.setValue(language.getDefaultTemplateComment() + language.getDefaultSource());
        }
      }
    }
    WorkspaceEnforcedTemplatePlugin.priorityIndex = 400;

    class DestroyFileModal extends ActionModal {
      getActionName() {
        return "Confirm";
      }
      getBody() {
        return [UI$1.createElement("span", null, "Are you sure you want to remove file ", UI$1.createElement("em", null, this.options.file.name), " from the workspace?")];
      }
      getCloseName() {
        return "Cancel";
      }
      action() {
        Ajax.postJSON("/workspace/delete_workspace_file/", {
          fileId: this.options.file.id
        }).then(() => {
          WorkspaceFileStore.applyDeleteEvent({
            objectId: this.options.file.id
          });
          WorkspaceFileStore.dispatch("changedFile");
          this.hide();
        });
      }
    }
    let DestroyFileButton = ActionModalButton(DestroyFileModal);
    class FileNameEditor extends UI$1.Element {
      render() {
        return [UI$1.createElement(DestroyFileButton, {
          icon: "minus",
          level: Level.DANGER,
          ref: "destroyButton",
          size: Size.EXTRA_SMALL,
          style: {
            "margin": "5px"
          },
          modalOptions: {
            file: this.options.file,
            title: "Destroy file"
          }
        }), UI$1.createElement(Button$1, {
          icon: "pencil",
          level: Level.PRIMARY,
          ref: "editButton",
          size: Size.EXTRA_SMALL,
          style: {
            "margin": "5px"
          }
        }), UI$1.createElement("span", {
          ref: "nameSpan"
        }, this.options.file.name), UI$1.createElement(TextInput, {
          ref: "fileNameInput",
          className: "hidden",
          style: {
            "padding-left": "5px"
          }
        })];
      }
      setFileName(name) {
        Ajax.postJSON("/workspace/rename_workspace_file/", {
          fileId: this.options.file.id,
          fileName: name
        }).then(() => {
          WorkspaceFileStore.dispatch("changedFile");
          this.redraw();
        });
      }
      onMount() {
        this.fileNameInput.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.setFileName(this.fileNameInput.getValue());
          }
        });
        this.editButton.addClickListener(() => {
          this.nameSpan.addClass("hidden");
          this.fileNameInput.removeClass("hidden");
          this.fileNameInput.setValue(this.options.file.name);
          this.fileNameInput.node.focus();
          this.fileNameInput.node.select();
        });
      }
    }
    class CreateFileModal extends ActionModal {
      getBody() {
        return [UI$1.createElement("div", {
          style: {
            "display": "inline-block",
            "margin-right": "10px"
          }
        }, "File Name:"), UI$1.createElement(TextInput, {
          placeholder: "Main1.cpp",
          ref: "fileNameInput",
          style: {
            "padding-left": "5px"
          }
        })];
      }
      getActionName() {
        return "Add";
      }
      action() {
        Ajax.postJSON("/workspace/create_workspace_file/", {
          fileName: this.fileNameInput.getValue(),
          workspaceId: this.options.workspaceId
        }).then(() => this.hide());
      }
    }
    let CreateFileButton = ActionModalButton(CreateFileModal);
    class WorkspaceFileNameManager extends Panel {
      getTitle() {
        return "Files";
      }
      getFiles() {
        return this.options.workspace.getFiles().filter(file => {
          return !file.getName().startsWith('.');
        });
      }
      render() {
        let children = [UI$1.createElement(CreateFileButton, {
          icon: "plus",
          ref: "addFileButton",
          style: {
            "margin": "5px"
          },
          level: Level.SUCCESS,
          size: Size.EXTRA_SMALL,
          modalOptions: {
            title: "Add file to workspace " + this.options.workspace.name,
            workspaceId: this.options.workspace.id
          }
        })];
        for (let file of this.getFiles()) {
          children.push(UI$1.createElement(FileNameEditor, {
            file: file,
            ref: "file" + file.id
          }));
        }
        return children;
      }
      onMount() {
        let refresh = () => {
          this.redraw();
          this.options.fileSelect.options.selected = this.options.fileSelect.get();
          this.options.fileSelect.options.options = this.getFiles();
          this.options.fileSelect.redraw();
        };
        WorkspaceFileStore.addListener("changedFile", refresh);
        this.options.workspace.addListener("newFile", refresh);
        this.options.workspace.addListener("removedFile", refresh);
      }
    }
    class WorkspaceCustomNamedFilesPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspace = workspaceIDE.workspace;
        let fileManager = workspaceIDE.getPlugin("FileManager");

        // The language select now becomes a file select
        let fileSelect = this.workspaceIDE.programmingLanguageSelect;

        // Remove the old change listener
        fileSelect.removeNodeListener("change", fileManager.changeFileCallback);

        // Set the new options
        fileSelect.options.options = this.workspace.getFiles().filter(file => {
          return file.getName()[0] !== '.';
        });
        fileSelect.options.selected = fileManager.getDefaultFile();
        fileSelect.redraw();

        // Add a new change listener
        fileSelect.addChangeListener(() => {
          let file = fileSelect.get();
          fileManager.setIDEOpenFile(file, ProgrammingLanguage.getLanguageForFileName(file.getName()), false);
        });

        // Append a tab for file name managing to the tab area
        let tabArea = workspaceIDE.tabArea;
        tabArea.appendChild(UI$1.createElement(WorkspaceFileNameManager, {
          workspace: this.workspace,
          fileSelect: fileSelect
        }));
      }
    }
    WorkspaceCustomNamedFilesPlugin.priorityIndex = 1000;

    const PluginTypes = {
      BASE: [WorkspaceSettingsPlugin, WorkspaceSingleFileManagerPlugin, WorkspaceCustomRunPlugin, WorkspaceKeymapPlugin, WorkspaceCompilerParserPlugin]
    };
    PluginTypes.CHECKER = [...PluginTypes.BASE, WorkspaceCustomNamedFilesPlugin];
    PluginTypes.GLOBAL = [...PluginTypes.BASE, WorkspaceSharePlugin];
    PluginTypes.CONTEST = [...PluginTypes.BASE, WorkspaceContestSubmitPlugin];
    PluginTypes.CONTEST_PUBLIC_SOURCES = [...PluginTypes.CONTEST, WorkspaceSharePlugin];
    PluginTypes.CONTEST_ENFORCED_TEMPLATE = [...PluginTypes.CONTEST, WorkspaceEnforcedTemplatePlugin];
    PluginTypes.CONTEST_PUBLIC_SOURCES_ENFORCED_TEMPLATE = [...PluginTypes.CONTEST, WorkspaceSharePlugin, WorkspaceEnforcedTemplatePlugin];
    class WorkspaceIDE extends Pluginable(WorkspacePanel) {
      constructor(options) {
        super(options);
        this.startTime = performance.now();
        this.options.aceTheme = this.options.aceTheme || "ace/theme/dawn";
      }
      registerPlugins() {
        this.options.plugins = (this.options.plugins || []).sort((a, b) => {
          return a.priorityIndex - b.priorityIndex;
        });
        for (let PluginConstructor of this.options.plugins) {
          this.registerPlugin(PluginConstructor);
        }
        this.addSettingsListeners();
        this.dispatch("initDone");
      }
      whenLoaded(callback) {
        if (this._loaded) {
          callback();
        } else {
          this.addListenerOnce("loaded", callback);
        }
      }
      onMount() {
        super.onMount();
        this.workspace = this.options.workspace;
        this.sessionId = Math.random().toString().substr(2);
        this.workspace.sessionId = this.sessionId;
        console.log("Init without plugin registrations: ", performance.now() - this.startTime);
        this.codeEditor.whenLoaded(() => {
          this.registerPlugins();
          this._loaded = true;
          this.dispatch("loaded");
        });
      }
      addSettingsListeners() {
        this.getPlugin("SettingsManager");
        // TODO: Complete this!
      }
    }

    class NavCounterBadge extends Badge {
      getDefaultOptions() {
        return {
          style: {
            right: "-5px",
            top: "30px",
            position: "absolute",
            zIndex: "1"
          },
          counter: 0
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        if (this.options.counter === 0) {
          attr.addClass("hidden");
        } else {
          attr.removeClass("hidden");
        }
      }
      render() {
        return this.options.counter;
      }
      setValue(value) {
        this.updateOptions({
          counter: value
        });
        NavManager.Global.checkForWrap();
      }
      getValue() {
        return this.options.counter;
      }
      increment() {
        this.setValue(this.getValue() + 1);
      }
      reset() {
        this.setValue(0);
      }
      attachListenerForAction(obj, eventName, action, condition) {
        this.attachListener(obj, eventName, (...args) => {
          if (!condition || !(typeof condition === "function") || condition(...args)) {
            action(...args);
          }
        });
      }
      attachListenerForIncrement(obj, eventName, condition) {
        this.attachListenerForAction(obj, eventName, () => this.increment(), condition);
      }
      attachListenerForReset(obj, eventName, condition) {
        this.attachListenerForAction(obj, eventName, () => this.reset(), condition);
      }
    }

    class UsersSolved extends UI$1.Element {
      render() {
        const {
          summaries
        } = this.options;
        return [UI$1.createElement("h3", null, UI$1.T("Users that solved this task: "), " ", summaries.length, " (", UI$1.createElement("span", {
          ref: "details",
          style: {
            "color": "blue",
            "cursor": "pointer"
          }
        }, "details"), ")"), UI$1.createElement("div", {
          ref: "userHandlesArea",
          style: {
            maxWidth: "500px",
            maxHeight: "300px",
            "overflow-y": "scroll"
          }
        })];
      }
      onMount() {
        this.details.addClickListener(() => {
          const {
            summaries
          } = this.options;
          if (this.users) {
            this.userHandlesArea.addClass("hidden");
            this.users = false;
          } else {
            this.users = true;
            if (this.userHandlesArea.hasClass("hidden")) {
              this.userHandlesArea.removeClass("hidden");
            } else {
              for (let summary of summaries) {
                this.userHandlesArea.appendChild(UI$1.createElement("div", {
                  style: {
                    margin: "3px",
                    padding: "4px",
                    display: "inline-block",
                    border: "2px solid #e6e6e6",
                    "borderRadius": "4px"
                  }
                }, UI$1.createElement(UserHandle$1, {
                  id: summary.userId
                })));
              }
            }
          }
        });
      }
    }
    class BestSubmissionsTable extends Table {
      getEntryKey(entry, index) {
        return index;
      }
      getEntries() {
        return this.summaries;
      }
    }
    class BestTimesTable extends BestSubmissionsTable {
      constructor(obj) {
        super(obj);
        this.summaries = this.options.summaries;
        this.summaries.sort((a, b) => {
          return a.bestTime - b.bestTime;
        });
        this.summaries = this.summaries.slice(0, Math.min(10, this.summaries.length));
      }
      getDefaultColumns() {
        let style = {
          textAlign: "center"
        };
        return [{
          value: entry => UI$1.createElement(UserHandle$1, {
            id: entry.userId
          }),
          headerName: "User",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => Formatter.cpuTime(entry.bestTime),
          headerName: "CPU Time",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => {
            return UI$1.createElement(SubmissionSummaryMarkup, {
              id: entry.bestTimeEvalJobId
            });
          },
          headerName: "Submission",
          headerStyle: style
        }];
      }
    }
    class BestMemoryTable extends BestSubmissionsTable {
      constructor(obj) {
        super(obj);
        this.summaries = this.options.summaries;
        this.summaries.sort((a, b) => {
          return a.bestMemory - b.bestMemory;
        });
        this.summaries = this.summaries.slice(0, Math.min(10, this.summaries.length));
      }
      getDefaultColumns() {
        let style = {
          textAlign: "center"
        };
        return [{
          value: entry => UI$1.createElement(UserHandle$1, {
            id: entry.userId
          }),
          headerName: "User",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => Formatter.memory(entry.bestMemory),
          headerName: "Memory usage",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => {
            return UI$1.createElement(SubmissionSummaryMarkup, {
              id: entry.bestMemoryEvalJobId
            });
          },
          headerName: "Submission",
          headerStyle: style
        }];
      }
    }
    class LoadingTable extends Table {
      getEntryKey(entry, index) {
        return index;
      }
      getEntries() {
        return [0];
      }
      getDefaultColumns() {
        let style = {
          textAlign: "center"
        };
        return [{
          value: entry => "Loading...",
          headerName: "User",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => "",
          headerName: "CPU Time",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => "",
          headerName: "Submission",
          headerStyle: style
        }];
      }
    }
    class EvalTaskStatisticsWidget extends UI$1.Element {
      render() {
        let summaries = this.getSummaries();
        if (summaries) {
          return [UI$1.createElement(UsersSolved, {
            summaries: summaries
          }), UI$1.createElement("h3", null, " ", UI$1.T("Solutions with lowest CPU Time:"), " "), UI$1.createElement(BestTimesTable, {
            summaries: summaries,
            style: {
              "border": "1px solid #BBB",
              "borderRadius": "5px"
            }
          }), UI$1.createElement("h3", null, " ", UI$1.T("Solutions with lowest memory usage:"), " "), UI$1.createElement(BestMemoryTable, {
            summaries: summaries,
            style: {
              "border": "1px solid #BBB",
              "borderRadius": "5px"
            }
          })];
        }
        EvalTaskUserSummaryStore.fetchEvalTask(this.options.evalTask.id, () => {
          this.redraw();
        });
        return [UI$1.createElement("h3", null, "Loading..."), UI$1.createElement("h3", null, " ", UI$1.T("Solutions with lowest CPU Time:"), " "), UI$1.createElement(LoadingTable, null), UI$1.createElement("h3", null, " ", UI$1.T("Solutions with lowest memory usage:"), " "), UI$1.createElement(LoadingTable, null)];
      }
      getSummaries() {
        const {
          evalTask
        } = this.options;
        if (EvalTaskUserSummaryStore.fetchedEvalTasks.has(evalTask.id)) {
          let summariesOfEvalTask = EvalTaskUserSummaryStore.getByEvalTaskId(evalTask.id);
          let result = [];
          for (let summary of summariesOfEvalTask) {
            if (summary.solved) {
              result.push(summary);
            }
          }
          return result;
        }
        return null;
      }
    }

    const EvalTaskBadge = (tooltip, children, icon, color = "#eeeeaa") => class Badge extends UI$1.Primitive("span") {
      getDefaultOptions() {
        return {
          HTMLtitle: tooltip,
          style: {
            cursor: "help",
            backgroundColor: color,
            padding: "6px",
            borderRadius: "4px",
            fontSize: "1.3em",
            marginBottom: "5px",
            marginLeft: "6px"
          }
        };
      }
      render() {
        return [UI$1.createElement(FAIcon, {
          icon: icon
        }), children];
      }
    };
    const InteractiveBadge = EvalTaskBadge("This task is interactive", "Interactive", "exchange");
    const EnforcedTemplateBadge = EvalTaskBadge("This task uses enforced templates", "Template", "code");
    EvalTaskBadge("This task is output-only", "Output", "file-text-o");
    EvalTaskBadge("This is an approximation task", "Aprox", "");

    class ServerInputTest extends UI$1.Element {
      getDefaultOptions() {
        return {
          type: "increment",
          height: 150
        };
      }
      setOptions(options) {
        options.input = options.input && options.input.replace(new RegExp("\\\\n", "g"), "\n");
        super.setOptions(options);
      }
      extraNodeAttributes(attr) {
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("display", "flex");
        attr.setStyle("flex-direction", "column");
      }
      render() {
        return [UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          ref: "runInputButton",
          level: Level.PRIMARY,
          onClick: () => this.recalculate(),
          icon: "cogs",
          style: {
            marginBottom: "10px"
          }
        }, " ", UI$1.T("Compute"))), UI$1.createElement("div", {
          ref: "container",
          style: {
            flex: "1"
          }
        }, UI$1.createElement("div", {
          style: {
            float: "left",
            width: "48%",
            height: "100%"
          }
        }, UI$1.createElement(CodeEditor, {
          ref: "inputEditor",
          value: this.options.input,
          style: {
            height: "100%"
          }
        })), UI$1.createElement("div", {
          style: {
            float: "right",
            width: "48%",
            height: "100%",
            marginRight: "2%"
          }
        }, UI$1.createElement(StaticCodeHighlighter, {
          ref: "outputView",
          style: {
            height: "100%"
          }
        })))];
      }
      recalculate() {
        const request = {
          type: this.options.type,
          input: this.inputEditor.getValue()
        };
        this.runInputButton.setLevel(Level.WARNING);
        Ajax.postJSON("/eval/input_server_test/", request, {
          onComplete: () => setTimeout(() => this.runInputButton.setLevel(Level.PRIMARY), 2000)
        }).then(data => {
          this.outputView.setValue(String(data.output));
          this.runInputButton.setLevel(Level.SUCCESS);
        });
      }
    }

    // TODO This should not be a lambda probably, and the Markdown parser should also allow functions
    const EvalTaskExamplesTable = evalTask => class EvalTaskExamplesTable extends Table {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          tableLayout: "fixed",
          pageBreakInside: "avoid" // For printing
        });
      }
      getCellStyle() {
        return {
          pageBreakBefore: "avoid" // TODO For printing
        };
      }
      getDefaultEntries(options) {
        return evalTask.exampleTests;
      }
      getDefaultColumns(options, entries) {
        let haveComments = false;
        for (const entry of entries) {
          haveComments = haveComments || entry.comment;
        }
        let columns;
        if (evalTask.getType() == 0) {
          // Non-interactive problems
          columns = [{
            value: entry => UI$1.createElement("pre", null, entry.input),
            headerName: UI$1.T("Input"),
            cellStyle: this.getCellStyle()
          }, {
            value: entry => UI$1.createElement("pre", null, entry.output),
            headerName: UI$1.T("Output"),
            cellStyle: this.getCellStyle()
          }];
        } else {
          // interactive problems
          columns = [{
            value: entry => {
              return UI$1.createElement(InteractiveTaskLog, {
                extra: entry.extra
              });
            },
            headerName: UI$1.T("Interaction"),
            cellStyle: this.getCellStyle()
          }];
        }
        if (haveComments || this.options.loadTestButton) {
          columns.push({
            value: entry => {
              let result = [];
              if (entry.comment) {
                result.push(UI$1.createElement(MarkupRenderer, {
                  classMap: evalTask.articleClassMap,
                  value: entry.comment
                }));
              }
              if (this.options.loadTestButton) {
                result.push(UI$1.createElement(Button$1, {
                  label: UI$1.T(this.options.loadTestText || "Load test"),
                  onClick: () => {
                    evalTask.dispatch("loadTest", entry.input);
                  },
                  level: Level.INFO,
                  style: {
                    display: "block",
                    margin: "5px"
                  }
                }));
              }
              return result;
            },
            headerName: UI$1.T("Explanation"),
            cellStyle: this.getCellStyle()
          });
        }
        return columns;
      }
    };

    var _dec$D, _dec2$c, _class$S, _descriptor$n, _descriptor2$l, _dec3$5, _class2$r, _descriptor3$j;
    let ContestAnnouncement = (_dec$D = field("Contest"), _dec2$c = field("ContestTask"), (_class$S = class ContestAnnouncement extends StoreObject {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "contest", _descriptor$n, this);
        _initializerDefineProperty(this, "task", _descriptor2$l, this);
      }
      getContest() {
        return this.contest;
      }
      getDate() {
        return new StemDate(this.date);
      }
      getContestTask() {
        let contestTask = ContestTaskStore.get(this.taskId);
        if (!contestTask) {
          const contest = this.getContest();
          return contest?.getContestTaskById(this.taskId);
        }
        return contestTask;
      }
      getTarget() {
        if (this.taskId) {
          return "Task " + this.getContestTask().longName;
        }
        return "General";
      }
      isTaskBroadcast() {
        return !!this.taskBroadcast;
      }
      getMessage() {
        if (this.isTaskBroadcast()) {
          return 'Task "' + this.getContestTask().longName + '" is now available!';
        }
        return this.message;
      }
    }, (_descriptor$n = _applyDecoratedDescriptor(_class$S.prototype, "contest", [_dec$D], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor2$l = _applyDecoratedDescriptor(_class$S.prototype, "task", [_dec2$c], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    })), _class$S));
    const ContestAnnouncementStore = new GenericObjectStore("ContestAnnouncement", ContestAnnouncement, {
      dependencies: ["contest"]
    });
    let ContestQuestion = (_dec3$5 = field("Contest"), (_class2$r = class ContestQuestion extends StoreObject {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "contest", _descriptor3$j, this);
      }
      applyEvent(event) {
        super.applyEvent(event);
        if (event.type !== "typingStateChange" && event.type !== "createReactionCollection") {
          this.getContest().dispatch("updateQuestion", this);
        }
      }
      getContest() {
        return this.contest;
      }
      isAskedByCurrentUser() {
        return USER.id === this.userAskedId;
      }
      getContestTask() {
        return ContestTaskStore.get(this.contestTaskId);
      }
      isAnswered() {
        return this.replyTime;
      }
      shouldAppear() {
        return USER.id === this.userAskedId || this.isPublic;
      }
      getReactionCollection(fakeIfMissing = false) {
        let reactionCollection = UserReactionCollectionStore.get(this.reactionCollectionId);
        if (fakeIfMissing && !reactionCollection) {
          return {
            upvotesCount: 0,
            downvotesCount: 0,
            getCurrentUserReactionType() {}
          };
        }
        return reactionCollection;
      }
      getNumLikes() {
        return this.getReactionCollection(true).upvotesCount;
      }
      getNumDislikes() {
        return this.getReactionCollection(true).downvotesCount;
      }
      getVotesBalance() {
        return this.getNumLikes() - this.getNumDislikes();
      }
      getUserVote() {
        return this.getReactionCollection(true).getCurrentUserReactionType();
      }
      react(reaction, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/contest/question_reaction/", {
          contestQuestionId: this.id,
          reaction: reaction
        }).then(onSuccess, onError);
      }
      like(onSuccess, onError) {
        this.react("like", onSuccess, onError);
      }
      dislike(onSuccess, onError) {
        this.react("dislike", onSuccess, onError);
      }
      resetReaction(onSuccess, onError) {
        this.react("resetReaction", onSuccess, onError);
      }
    }, (_descriptor3$j = _applyDecoratedDescriptor(_class2$r.prototype, "contest", [_dec3$5], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    })), _class2$r));
    const ContestQuestionStore = new GenericObjectStore("ContestQuestion", ContestQuestion, {
      dependencies: ["contest"]
    });

    var _class$R, _descriptor$m, _descriptor2$k, _descriptor3$i, _descriptor4$g, _descriptor5$e, _descriptor6$b, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$5;
    let ContestQuestionListStyle = (_class$R = class ContestQuestionListStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "contestQuestionList", _descriptor$m, this);
        _initializerDefineProperty(this, "cardPanelContainer", _descriptor2$k, this);
        this.cardPanelBodyStyle = {
          padding: this.themeProps.CONTEST_QUESTION_CARD_PANEL_BODY_PADDING + "px",
          lineHeight: this.themeProps.CONTEST_QUESTION_CARD_PANEL_LINE_HEIGHT + "px"
        };
        _initializerDefineProperty(this, "extraElementStyle", _descriptor3$i, this);
        _initializerDefineProperty(this, "questionsContainer", _descriptor4$g, this);
        _initializerDefineProperty(this, "questionsColumnContainer", _descriptor5$e, this);
        _initializerDefineProperty(this, "filterContainer", _descriptor6$b, this);
        _initializerDefineProperty(this, "filterSwitcherContainer", _descriptor7$7, this);
        this.filterOptionBase = {
          height: "40px",
          paddingLeft: "5px",
          border: "1px solid black",
          justifyContent: "center",
          display: "flex",
          flexDirection: "column",
          fontSize: "1.2em",
          cursor: "pointer"
        };
        _initializerDefineProperty(this, "filterOption", _descriptor8$7, this);
        _initializerDefineProperty(this, "filterOptionFocused", _descriptor9$6, this);
        _initializerDefineProperty(this, "filterSwitcher", _descriptor10$5, this);
      }
    }, (_descriptor$m = _applyDecoratedDescriptor(_class$R.prototype, "contestQuestionList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          margin: "0 auto",
          justifyContent: "center"
        };
      }
    }), _descriptor2$k = _applyDecoratedDescriptor(_class$R.prototype, "cardPanelContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          maxWidth: "100%",
          padding: this.themeProps.CONTEST_QUESTION_CARD_PANEL_PADDING,
          width: this.themeProps.CONTEST_QUESTION_CARD_PANEL_WIDTH
        };
      }
    }), _descriptor3$i = _applyDecoratedDescriptor(_class$R.prototype, "extraElementStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flex: "1",
          padding: this.themeProps.CONTEST_QUESTION_CARD_PANEL_PADDING,
          minWidth: this.themeProps.CONTEST_QUESTION_CARD_PANEL_MIN_WIDTH
        };
      }
    }), _descriptor4$g = _applyDecoratedDescriptor(_class$R.prototype, "questionsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          margin: "0 auto",
          display: "flex",
          justifyContent: "center",
          overflow: "hidden"
        };
      }
    }), _descriptor5$e = _applyDecoratedDescriptor(_class$R.prototype, "questionsColumnContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          overflow: "auto"
        };
      }
    }), _descriptor6$b = _applyDecoratedDescriptor(_class$R.prototype, "filterContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflowY: "auto",
          width: "25%",
          height: "100%",
          float: "left"
        };
      }
    }), _descriptor7$7 = _applyDecoratedDescriptor(_class$R.prototype, "filterSwitcherContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "75%",
          height: "100%",
          float: "right"
        };
      }
    }), _descriptor8$7 = _applyDecoratedDescriptor(_class$R.prototype, "filterOption", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({
          backgroundColor: this.themeProps.COLOR_BACKGROUND,
          ":hover": {
            backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
          }
        }, this.filterOptionBase);
      }
    }), _descriptor9$6 = _applyDecoratedDescriptor(_class$R.prototype, "filterOptionFocused", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({
          ":hover": {
            backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
          },
          backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
        }, this.filterOptionBase);
      }
    }), _descriptor10$5 = _applyDecoratedDescriptor(_class$R.prototype, "filterSwitcher", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          overflow: "auto"
        };
      }
    })), _class$R);

    var _dec$C, _class$Q, _dec2$b, _class2$q, _dec3$4, _class3$b;
    const FilterOptions = {
      ALL: "All",
      GENERAL: "General"
    };
    function getQuestionsForFilter(filter, contest) {
      const questions = contest.getQuestions();
      if (filter === FilterOptions.ALL) {
        return questions;
      }
      if (filter === FilterOptions.GENERAL) {
        return questions.filter(question => !question.contestTaskId);
      }
      const contestTask = contest.getContestTasks().find(contestTask => contestTask.longName === filter);
      return questions.filter(question => question.contestTaskId === contestTask.id);
    }
    let ContestQuestionList = (_dec$C = registerStyle(ContestQuestionListStyle), _dec$C(_class$Q = class ContestQuestionList extends UI$1.Element {
      getDefaultOptions() {
        return Object.assign({
          displayListTitle: true
        }, super.getDefaultOptions());
      }
      getContest() {
        return this.options.contest;
      }
      getQuestions() {
        return this.getContest().getQuestions();
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.contestQuestionList);
      }
      renderQuestion(question) {
        if (!question.shouldAppear()) {
          return null;
        }
        let askedTime = StemDate.format(question.timeAsked, "HH:mm:ss");
        let answeredTime;
        let answeredStatus;
        if (question.replyTime) {
          answeredTime = StemDate.format(question.replyTime, "HH:mm:ss");
          answeredStatus = UI$1.createElement("i", null, ` (Answered at ${answeredTime})`);
        }
        let questionType;
        if (question.isPublic) {
          questionType = "Public Answer";
        }
        let level = Level.PRIMARY;
        let answerElement;
        if (question.isAnswered()) {
          level = Level.SUCCESS;
          answerElement = UI$1.createElement("div", null, UI$1.createElement("strong", null, "Answer: "), UI$1.createElement(MarkupRenderer, {
            value: question.reply
          }));
        }
        if (question.isInvalid) {
          level = Level.DANGER;
          answerElement = UI$1.createElement("div", null, UI$1.createElement("strong", null, "Invalid question"));
        }
        let target = question.contestTaskId ? ContestTaskStore.get(question.contestTaskId).longName : FilterOptions.GENERAL;
        let votingWidget = question.isPublic && question.isAnswered() && UI$1.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          message: question
        });
        let title = UI$1.createElement("div", null, UI$1.createElement("div", null, askedTime, answeredStatus, ": ", UI$1.createElement("strong", null, target)), UI$1.createElement("div", null, UI$1.createElement("strong", null, questionType)));
        return UI$1.createElement("div", {
          className: this.styleSheet.cardPanelContainer,
          key: question.id
        }, UI$1.createElement(CardPanel, {
          title: title,
          level: level,
          bodyStyle: this.styleSheet.cardPanelBodyStyle,
          id: "question" + question.id
        }, UI$1.createElement("p", null, UI$1.createElement(UserHandle$1, {
          userId: question.userAskedId
        }), ": " + question.question), answerElement, votingWidget || null));
      }
      render() {
        // Sort questions by latest activity
        const userQuestions = this.getQuestions().filter(question => question.isAskedByCurrentUser()).sort((x, y) => {
          return Math.max(y.timeAsked, y.replyTime || 0) - Math.max(x.timeAsked, x.replyTime || 0);
        });
        const publicQuestions = this.getQuestions().filter(question => !question.isAskedByCurrentUser()).sort((x, y) => {
          return Math.max(y.timeAsked, y.replyTime || 0) - Math.max(x.timeAsked, x.replyTime || 0);
        });
        const recentQuestions = publicQuestions.slice(0, 2);
        const sortedPublicQuestionsByBalance = publicQuestions.length > 2 ? publicQuestions.slice(recentQuestions.length, publicQuestions.length).sort((x, y) => {
          return y.getVotesBalance() - x.getVotesBalance();
        }) : [];
        const yourQuestionsTitle = this.options.displayListTitle && userQuestions.length ? UI$1.createElement("h4", {
          style: {
            textAlign: "center",
            borderBottom: "2px solid black"
          }
        }, "Own questions") : null;
        const publicQuestionsTitle = this.options.displayListTitle && publicQuestions.length ? UI$1.createElement("h4", {
          style: {
            textAlign: "center",
            borderBottom: "2px solid black"
          }
        }, "Public questions") : null;
        return [yourQuestionsTitle, userQuestions.map(this.renderQuestion, this), publicQuestionsTitle, recentQuestions.concat(sortedPublicQuestionsByBalance).map(this.renderQuestion, this)];
      }
      attachQuestionListeners() {
        const questionCallback = question => {
          if (question.contestId === this.getContest().id) {
            this.redraw();
          }
        };
        this.attachCreateListener(ContestQuestionStore, questionCallback);
        this.attachListener(this.getContest(), "updateQuestion", questionCallback);
      }
      onMount() {
        this.attachQuestionListeners();
      }
    }) || _class$Q);
    class ContestTaskQuestionList extends ContestQuestionList {
      getQuestions() {
        return this.getContest().getQuestions().filter(question => {
          return question.contestTaskId === this.options.contestTaskId;
        });
      }
    }
    class AdminContestQuestionCard extends CardPanel {
      // getDefaultOptions() {
      //     return Object.assign({}, super.getDefaultOptions(), {
      //         bodyStyle: {
      //             padding: "3px",
      //         }
      //     });
      // }

      // extraNodeAttributes(attr) {
      //     super.extraNodeAttributes(attr);
      //     attr.addClass(this.styleSheet.cardPanelContainer);
      // }

      getLevel() {
        if (this.options.question) {
          if (this.options.question.isInvalid) {
            return Level.DANGER;
          }
          if (this.options.question.isAnswered()) {
            return Level.SUCCESS;
          }
        }
        return Level.PRIMARY;
      }
      getTitle() {
        const question = this.options.question;
        const askedTime = StemDate.format(question.timeAsked, "HH:mm:ss");
        let answeredStatus, answeredTime;
        if (question.replyTime) {
          answeredTime = StemDate.format(question.replyTime, "HH:mm:ss");
          answeredStatus = UI$1.createElement("i", null, "(Answered at ", answeredTime, " by ", UI$1.createElement(UserHandle$1, {
            id: question.replyUserId
          }), ")");
        }
        let target = question.contestTaskId ? ContestTaskStore.get(question.contestTaskId).longName : FilterOptions.GENERAL;
        return UI$1.createElement("div", null, askedTime, answeredStatus, ": ", UI$1.createElement("strong", null, target));
      }
      logReply(redraw = false) {
        const xhrPromise = Ajax.postJSON("/contest/question_typing_state_change/", {
          questionId: this.options.question.id,
          contestId: this.options.question.contestId,
          reply: this.answerField.getValue(),
          sessionId: this.sessionId
        });
        if (redraw) {
          xhrPromise.then(() => this.redraw());
        }
      }
      render() {
        const question = this.options.question;
        let someoneTypingArea,
          isReadonly = false,
          backgroundColor = Theme.props.COLOR_BACKGROUND;
        if (question.replyUserId && question.replyUserId !== USER.id && !question.isAnswered() && !question.isInvalid) {
          isReadonly = true;
          backgroundColor = Theme.props.COLOR_BACKGROUND_ALTERNATIVE;
          someoneTypingArea = UI$1.createElement(Badge, {
            level: Level.WARNING,
            key: "someoneTypingArea",
            style: {
              marginBottom: "10px"
            }
          }, UI$1.createElement("em", null, UI$1.createElement(UserHandle$1, {
            userId: question.replyUserId
          }), " is typing a response!"), UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            size: Size.EXTRA_SMALL,
            onClick: () => this.logReply(true),
            style: {
              marginLeft: "3px"
            }
          }, "Take over"));
        }
        const answerElement = UI$1.createElement("div", null, UI$1.createElement(FormField, {
          inline: false,
          style: {
            margin: "initial",
            padding: "0"
          }
        }, UI$1.createElement("strong", {
          style: {
            display: "block"
          }
        }, "Answer: "), someoneTypingArea, UI$1.createElement(TextArea, {
          ref: "answerField",
          rows: "5",
          readOnly: isReadonly,
          value: question.reply || "",
          style: {
            height: "100px",
            maxWidth: "100%",
            backgroundColor: backgroundColor
          }
        })), UI$1.createElement(ButtonGroup, {
          size: Size.SMALL
        }, UI$1.createElement(Button$1, {
          ref: "answerQuestionButton",
          level: Level.PRIMARY,
          disabled: isReadonly
        }, question.isAnswered() ? "Change answer" : "Answer"), UI$1.createElement(Button$1, {
          ref: "invalidQuestionButton",
          level: Level.DANGER,
          disabled: isReadonly
        }, "Invalid question")), UI$1.createElement("div", {
          style: {
            paddingTop: "10px"
          }
        }, UI$1.createElement("strong", null, "Public answer", UI$1.createElement(RawCheckboxInput, {
          ref: "publicAnswerCheckbox",
          initialValue: question.isPublic
        }))));
        return [UI$1.createElement(UserHandle$1, {
          userId: question.userAskedId
        }), UI$1.createElement("strong", null, ": "), question.question, answerElement];
      }
      onMount() {
        super.onMount();
        this.sessionId = Math.random().toString().substr(2);
        this.attachEventListener(this.options.question, "typingStateChange", event => {
          if (event.sessionId !== this.sessionId) {
            this.redraw();
          }
        });
        const logReplyThrottler = new CallThrottler({
          throttle: 500
        });
        const logReplyThrottled = logReplyThrottler.wrap(() => this.logReply());
        this.answerField.addNodeListener("input", logReplyThrottled);
        this.answerQuestionButton.addClickListener(() => {
          if (!confirm("Are you sure you want to answer this question?")) {
            return;
          }
          this.answerQuestion();
        });
        this.invalidQuestionButton.addClickListener(() => {
          if (!confirm("Are you sure you want to invalidate this question? This cannot be undone!")) {
            return;
          }
          this.answerQuestion(true);
        });
      }
      answerQuestion(invalidQuestion) {
        let answer = this.answerField.getValue();
        let isPublicAnswer = this.publicAnswerCheckbox.getValue();
        let request = {
          contestId: this.options.contest.id,
          questionId: this.options.question.id
        };
        if (invalidQuestion) {
          request.isInvalid = true;
        } else {
          if (!answer) return;
          if (isPublicAnswer) {
            request.isPublic = true;
          }
          request.reply = answer;
        }
        Ajax.postJSON("/contest/answer_question/", request);
      }
    }
    class AdminContestQuestionList extends ContestQuestionList {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          displayListTitle: false
        });
      }
      renderQuestion(question) {
        return UI$1.createElement("div", {
          className: this.styleSheet.cardPanelContainer,
          key: question.id
        }, UI$1.createElement(AdminContestQuestionCard, {
          question: question,
          contest: this.getContest(),
          bodyStyle: {
            padding: "15px"
          }
        }));
      }
      getQuestions() {
        return getQuestionsForFilter(this.options.filter || FilterOptions.ALL, this.getContest());
      }
    }
    class AnsweredContestQuestionList extends AdminContestQuestionList {
      getQuestions() {
        let questions = super.getQuestions();
        questions = questions.filter(a => a.isAnswered() || a.isInvalid).sort((a, b) => {
          return b.replyTime - a.replyTime;
        });
        if (questions.length > 20) {
          questions = questions.slice(0, 20);
        }
        return questions;
      }
    }
    class UnansweredContestQuestionList extends AdminContestQuestionList {
      getQuestions() {
        let questions = super.getQuestions();
        return questions.filter(a => !(a.isAnswered() || a.isInvalid)).sort((a, b) => a.id - b.id);
      }
    }
    let FilterOption = (_dec2$b = registerStyle(ContestQuestionListStyle), _dec2$b(_class2$q = class FilterOption extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.filterOption);
      }
      focus() {
        this.removeClass(this.styleSheet.filterOption);
        this.addClass(this.styleSheet.filterOptionFocused);
      }
      unfocus() {
        this.removeClass(this.styleSheet.filterOptionFocused);
        this.addClass(this.styleSheet.filterOption);
      }
      getNumQuestions() {
        return getQuestionsForFilter(this.options.filter, this.options.contest).filter(a => !(a.isAnswered() || a.isInvalid)).length;
      }
      render() {
        const numQuestions = this.getNumQuestions();
        let badge = null;
        if (numQuestions) {
          badge = UI$1.createElement("span", {
            style: {
              paddingRight: "5px"
            }
          }, UI$1.createElement(Badge, {
            level: Level.DANGER
          }, numQuestions));
        }
        return [UI$1.createElement("div", null, [badge, this.options.filter])];
      }
      onMount() {
        this.attachCreateListener(ContestQuestionStore, contestQuestion => {
          if (this.options.contest.id === contestQuestion.contestId) {
            this.redraw();
          }
        });
        this.attachListener(this.options.contest, "updateQuestion", () => this.redraw());
      }
    }) || _class2$q);
    let AdminContestQuestionPanel = (_dec3$4 = registerStyle(ContestQuestionListStyle), _dec3$4(_class3$b = class AdminContestQuestionPanel extends UI$1.Element {
      getContestTasks() {
        return this.options.contest.getContestTasks();
      }
      getFilterOptions() {
        let options = [FilterOptions.ALL, FilterOptions.GENERAL];
        for (let contestTask of this.getContestTasks()) {
          options.push(contestTask.longName);
        }
        return options;
      }
      renderQuestionListForFilter(filter) {
        return UI$1.createElement("div", {
          className: this.styleSheet.questionsContainer,
          ref: "switcherChild" + filter
        }, UI$1.createElement("div", {
          className: this.styleSheet.questionsColumnContainer
        }, UI$1.createElement(UnansweredContestQuestionList, {
          filter: filter,
          ref: "unansweredQuestionList",
          contest: this.options.contest
        })), UI$1.createElement("div", {
          className: this.styleSheet.questionsColumnContainer
        }, UI$1.createElement(AnsweredContestQuestionList, {
          filter: filter,
          ref: "answeredQuestionList",
          contest: this.options.contest
        })));
      }
      changeFilter(filterOption) {
        for (const filter of this.getFilterOptions()) {
          this["filter" + filter].unfocus();
        }
        this.filterSwitcher.setActive(this["switcherChild" + filterOption]);
        this["filter" + filterOption].focus();
      }
      render() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.filterContainer
        }, this.getFilterOptions().map(filterOption => UI$1.createElement(FilterOption, {
          onClick: () => this.changeFilter(filterOption),
          filter: filterOption,
          contest: this.options.contest,
          ref: "filter" + filterOption
        }))), UI$1.createElement("div", {
          className: this.styleSheet.filterSwitcherContainer
        }, UI$1.createElement(Switcher, {
          className: this.styleSheet.filterSwitcher,
          ref: "filterSwitcher"
        }, this.getFilterOptions().map(filterOption => this.renderQuestionListForFilter(filterOption)))), UI$1.createElement("div", {
          style: {
            clear: "both"
          }
        })];
      }
      onMount() {
        this.changeFilter(FilterOptions.ALL);
      }
    }) || _class3$b);
    class AskQuestionModal extends ActionModal {
      getTitle() {
        return "Ask question";
      }
      getActionName() {
        return "Ask question";
      }
      getBody() {
        let taskOptions = this.options.contest.getContestTasks();
        taskOptions.push({
          general: true,
          toString: () => FilterOptions.GENERAL
        });
        return [UI$1.createElement(FormField, {
          label: "Task name"
        }, UI$1.createElement(Select, {
          ref: "contestTaskSelect",
          className: "form-control",
          options: taskOptions
        })), UI$1.createElement(TextArea, {
          rows: "2",
          ref: "questionTextField",
          placeholder: "Type question...",
          style: {
            resize: "vertical",
            width: "100%"
          }
        })];
      }
      action() {
        let question = this.questionTextField.getValue();
        let contestTask = this.contestTaskSelect.get();
        let request = {
          contestId: this.options.contest.id,
          question: question
        };
        if (!contestTask.general) {
          request.contestTaskId = contestTask.id;
        }
        Ajax.postJSON("/contest/ask_question/", request);
        this.hide();
      }
    }
    class AskTaskQuestionModal extends AskQuestionModal {
      getBody() {
        return [UI$1.createElement(TextArea, {
          rows: "2",
          ref: "questionTextField",
          placeholder: "Type question...",
          style: {
            resize: "vertical",
            width: "100%"
          }
        })];
      }
      action() {
        let question = this.questionTextField.getValue();
        let {
          contest,
          contestTask
        } = this.options;
        let request = {
          contestId: contest.id,
          question: question
        };
        request.contestTaskId = contestTask.id;
        Ajax.postJSON("/contest/ask_question/", request);
        this.hide();
      }
    }
    const AskTaskQuestionButton = ActionModalButton(AskTaskQuestionModal);

    class ContestLocalStorageManagerClass {
      constructor() {
        this.localStorageMap = new Map();
      }
      getLocalStorageMap(contestId, type) {
        const identifier = "contest-" + contestId + "user-" + USER.id + type;
        if (!this.localStorageMap.has(identifier)) {
          this.localStorageMap.set(identifier, new LocalStorageMap(identifier));
        }
        return this.localStorageMap.get(identifier);
      }

      /* Key is task id.
         Value is badge count.
       */
      getQuestionsLocalStorageMap(contestId) {
        return this.getLocalStorageMap(contestId, "questions");
      }

      /* Key is "counter".
         Value is badge count.
       */
      getAnnouncementsLocalStorageMap(contestId) {
        return this.getLocalStorageMap(contestId, "announcements");
      }

      /* Key is data key.
         Value is data.
       */
      getNotificationsLocalStorageMap(contestId) {
        return this.getLocalStorageMap(contestId, "notifications");
      }
    }
    const ContestLocalStorageManager = new ContestLocalStorageManagerClass();

    // TODO This should not be a lambda probably, and the Markdown parser should also allow functions
    const EvalTaskTestGroupingTable = evalTask => class EvalTaskTestGroupingTable extends Table {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          tableLayout: "fixed",
          pageBreakInside: "avoid" // For printing
        });
      }
      getCellStyle() {
        return {
          pageBreakBefore: "avoid" // TODO For printing, fix implementing this
        };
      }
      getDefaultEntries(options) {
        return evalTask.testGrouping;
      }
      getDefaultColumns(options, entries) {
        const INDEX_STYLE = {
          width: 30
        };
        const POINTS_STYLE = {
          width: 60
        };
        return [["#", (testGroup, index) => index + 1, {
          cellStyle: INDEX_STYLE,
          headerStyle: INDEX_STYLE
        }], ["Points", testGroup => testGroup.pointsWorth, {
          cellStyle: POINTS_STYLE,
          headerStyle: POINTS_STYLE
        }], ["Restrictions", testGroup => UI$1.createElement(MarkupRenderer, {
          classMap: evalTask.articleClassMap,
          value: testGroup.comment
        })]];
      }
    };

    var _class$P, _descriptor$l, _dec$B, _class2$p;
    class EvalTaskLimits extends UI$1.Element {
      render() {
        const evalTask = this.options.evalTask;
        return [UI$1.T("Time limit:"), " ", UI$1.createElement("em", null, Formatter.cpuTime(evalTask.getTimeLimit(this.options.programmingLanguageId) / 1000)), UI$1.createElement("br", null), UI$1.T("Memory limit:"), " ", UI$1.createElement("em", null, Formatter.memory(evalTask.getMemoryLimit(this.options.programmingLanguageId) * 1024)), UI$1.createElement("br", null), UI$1.createElement("br", null)];
      }
      setProgrammingLanguageId(programmingLanguageId) {
        this.updateOptions({
          programmingLanguageId
        });
      }
    }
    class ContestTaskSummaryPanel extends Panel {
      getContestTask() {
        return this.options.contestTask;
      }
      getEvalTaskBadges() {
        let badges = [];
        let evalTask = this.getContestTask().getEvalTask();
        if (evalTask) {
          if (evalTask.hasEnforcedTemplates()) {
            badges.push(UI$1.createElement(EnforcedTemplateBadge, null));
          }
          if (evalTask.isInteractive()) {
            badges.push(UI$1.createElement(InteractiveBadge, null));
          }
        }
        return badges;
      }
      render() {
        const contestTask = this.getContestTask();
        const evalTask = contestTask.getEvalTask();
        const contest = contestTask.getContest();
        const article = contestTask.getStatementArticle().getTranslation();
        if (article.markup.startsWith("pdf:")) {
          const pdfURL = article.markup.substring(4);
          return [UI$1.createElement("div", {
            className: "text-center"
          }, UI$1.createElement(EvalTaskLimits, {
            ref: "taskLimits",
            evalTask: evalTask,
            programmingLanguageId: this.options.programmingLanguageId
          }), UI$1.createElement("object", {
            data: pdfURL,
            type: "application/pdf",
            width: "100%",
            height: "640px"
          }))];
        }
        const articleClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["TaskExamples", EvalTaskExamplesTable(evalTask)], ["TaskTestGrouping", EvalTaskTestGroupingTable(evalTask)], ["RawHTML", RawHTML], ["ServerInputTest", ServerInputTest]]);
        evalTask.articleClassMap = articleClassMap;
        return [contest.getLogoURL() && UI$1.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI$1.createElement("img", {
          style: {
            maxWidth: "360px",
            marginBottom: "-10px"
          },
          src: contest.getLogoURL()
        })), UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement("h1", null, UI$1.T(evalTask.longName)), UI$1.createElement(EvalTaskLimits, {
          ref: "taskLimits",
          evalTask: evalTask,
          programmingLanguageId: this.options.programmingLanguageId
        }), UI$1.createElement("div", null, this.getEvalTaskBadges())), UI$1.createElement(ArticleRenderer, {
          ref: "statementArticle",
          article: article,
          showEditButton: true,
          liveLanguage: true,
          editButtonUrl: "/task/" + evalTask.urlName + "/edit/",
          classMap: articleClassMap
        })];
      }
      onMount() {
        this.attachListener(Language, "localeChange", () => this.redraw());
      }
    }
    class EvalTaskSolutionPanel extends Panel {
      getTitle() {
        return UI$1.T("Editorial");
      }
      render() {
        return UI$1.createElement(ArticleRenderer, {
          article: this.options.evalTask.getSolutionArticle(),
          liveLanguage: true
        });
      }
    }
    class EvalTaskStatisticsPanel extends Panel {
      getTitle() {
        return UI$1.T("Statistics");
      }
      onMount() {
        this.addListener("setActive", () => {
          if (this.options.children.length === 0) {
            let child = UI$1.createElement(EvalTaskStatisticsWidget, {
              evalTask: this.options.evalTask
            });
            this.appendChild(child);
          }
        });
      }
    }
    class QuestionsPanel extends Panel {
      render() {
        let {
          contest,
          contestTask
        } = this.options;
        return [UI$1.createElement(AskTaskQuestionButton, {
          level: Level.PRIMARY,
          label: UI$1.T("Ask question"),
          modalOptions: {
            contest,
            contestTask
          },
          style: {
            margin: "10px"
          }
        }), UI$1.createElement(ContestTaskQuestionList, {
          contest: contest,
          contestTaskId: contestTask.id
        })];
      }
    }
    class ContestTaskCounterBadge extends NavCounterBadge {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          style: {
            right: 0,
            top: 0,
            marginLeft: 5,
            position: "initial"
          }
        });
      }
    }
    let ContestTaskPanelStyle = (_class$P = class ContestTaskPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "taskPanel", _descriptor$l, this);
      }
    }, (_descriptor$l = _applyDecoratedDescriptor(_class$P.prototype, "taskPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "5px 24px",
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        };
      }
    })), _class$P);
    let ContestTaskPanel = (_dec$B = registerStyle(ContestTaskPanelStyle), _dec$B(_class2$p = class ContestTaskPanel extends FullScreenable(Panel) {
      getDefaultOptions() {
        return {
          ...super.getDefaultOptions(),
          updateURL: true
        };
      }
      getContestTask() {
        return ContestTaskStore.get(this.options.contestTaskId);
      }
      getEvalTask() {
        return this.getContestTask().getEvalTask();
      }
      getContest() {
        return this.getContestTask().getContest();
      }
      getWorkspace() {
        return this.getEvalTask().getWorkspace();
      }
      showWorkspace() {
        this.divider.collapseChild(0);
        this.divider.expandChild(1);
      }
      showStatement() {
        this.divider.collapseChild(1);
        this.divider.expandChild(0);
      }
      showBoth() {
        if (this.idePanel.getWidth() === 0) {
          this.idePanel.setWidth("50%");
          this.taskPanel.setWidth("50%");
        }
        this.divider.expandChild(0);
        this.divider.expandChild(1);
      }
      setURL(urlParts) {
        this.showUrlTab(urlParts[0] || "");
      }
      addQuestionBadgeListeners() {
        const localStorageMap = ContestLocalStorageManager.getQuestionsLocalStorageMap(this.getContestTask().id);

        /* When badge is created, it takes its counter from the local storage. After that:
           - when a question is created: increase badge counter if the active tab isn't "Questions"
           - when active tab is set to "Questions": reset badge count and update local storage value
           - when local storage value changes: if the new value is 0 it means that the "Questions" tab has been clicked
                on another tab, so reset the badge counter.
         */

        this.badge.setValue(localStorageMap.get(this.getContestTask().id) || 0);
        this.attachListener(this.tabArea.activeTabDispatcher, () => {
          if (this.tabArea.getActive() === this.questionsPanel) {
            this.badge.reset();
            localStorageMap.set(this.getContestTask().id, 0);
          }
        });
        localStorageMap.addChangeListener(event => {
          if (!event.newValue) {
            this.badge.reset();
          }
        });
        const incrementBadgeCount = question => {
          if (question.contestId === this.getContest().id && question.contestTaskId === this.getContestTask().id) {
            this.badge.increment();
          }
        };
        this.attachListener(ContestQuestionStore, "create", question => {
          if (!question.isAskedByCurrentUser()) {
            incrementBadgeCount(question);
          }
        });
        this.attachListener(this.getContest(), "updateQuestion", incrementBadgeCount);
      }
      onMount() {
        this.attachChangeListener(this.getEvalTask(), () => this.redraw());
        const modifyIde = () => {
          const updateTaskLimits = programmingLanguage => {
            this.taskSummaryPanel.taskLimits.setProgrammingLanguageId(programmingLanguage.id);
          };
          this.ide.addListener("changeLanguage", updateTaskLimits);
          updateTaskLimits(this.ide.programmingLanguageSelect.get());

          // Automatically focus the code editor when entering the page (feature request)
          this.ide.codeEditor.focus();
          this.ide.codeEditor.gotoEnd();
        };
        this.addListener("workspaceLoaded", () => modifyIde());
        if (this.ide) {
          modifyIde();
        }

        // TODO: make this a method in this class!
        let dispatchResize = () => {
          if (this.ide) {
            this.ide.sectionDivider.dispatch("resize");
          }
        };
        window.addEventListener("resize", () => {
          dispatchResize();
        });
        this.idePanel.addListener("resize", () => {
          dispatchResize();
        });
        let contest = this.getContest();
        if (contest.systemGenerated) {
          this.attachEventListener(contest, "contestEnd", () => {
            this.tabArea.redraw();
          });
        }

        // TODO: Why is this here?
        contest.addEventListener("broadcastTask", event => {
          GlobalState$1.importState(event.extra.state);
        });
        window.taskView = false;

        // Questions Badge
        if (this.questionsPanel) {
          this.addQuestionBadgeListeners();
        }
        this.addListener("enterFullScreen", () => this.ide.dispatch("enterFullScreen"));
        this.addListener("exitFullScreen", () => this.ide.dispatch("exitFullScreen"));
        this.attachListener(this.idePanel, "resize", () => {
          if (this.ide) {
            this.ide.dispatch("resize");
          }
        });
        this.attachListener(this.taskPanel, "resize", () => {
          this.tabArea.titleArea.dispatch("resize");
        });
      }
      getCommentsPanel() {
        const discussionId = this.getEvalTask().discussionId;
        if (discussionId && (!this.getContest().isRunning() || this.getContest().isInfinite())) {
          return UI$1.createElement(Panel, {
            ref: "discussionPanel",
            title: UI$1.T("Task Discussion"),
            tabHref: this.getSubURL("discussion")
          }, UI$1.createElement(AsyncCommentThread, {
            chatId: discussionId
          }));
        }
      }
      getSolutionPanel() {
        const solutionArticle = this.getEvalTask().getSolutionArticle();
        if (solutionArticle && (!this.getContest().isRunning() || this.getContest().isInfinite())) {
          return UI$1.createElement(EvalTaskSolutionPanel, {
            ref: "solutionPanel",
            tabHref: this.getSubURL("solution"),
            evalTask: this.getEvalTask()
          });
        }
      }
      getStatisticsPanel() {
        if (this.getContestTask().canShowStatistics()) {
          return UI$1.createElement(EvalTaskStatisticsPanel, {
            ref: "statisticsPanel",
            tabHref: this.getSubURL("statistics"),
            evalTask: this.getEvalTask()
          });
        }
      }
      getSubmissionPanel() {
        return UI$1.createElement(SubmissionSummaryContestFilter, {
          ref: "submissionsPanel",
          title: UI$1.T("Submissions"),
          tabHref: this.getSubURL("submissions"),
          contestId: this.getContest().id,
          contestTaskId: this.getContestTask().id
        });
      }
      getQuestionsPanelTitleWithBadge() {
        if (!this.badge) {
          this.badge = UI$1.createElement(ContestTaskCounterBadge, {
            level: Level.DANGER
          });
        }
        return UI$1.createElement("div", null, UI$1.createElement("span", null, UI$1.T("Questions")), this.badge);
      }
      getQuestionsPanel() {
        const contest = this.getContest();
        if (!contest.canReceiveQuestions()) {
          return;
        }
        return UI$1.createElement(QuestionsPanel, {
          ref: "questionsPanel",
          title: this.getQuestionsPanelTitleWithBadge(),
          tabHref: this.getSubURL("questions"),
          contest: this.getContest(),
          contestTask: this.getContestTask()
        });
      }
      requestEvalTaskWorkspace() {
        Ajax.postJSON("/eval/fetch_eval_task_user_summary/", {
          evalTaskId: this.getEvalTask().id
        }).then(() => {
          if (this.getWorkspace()) {
            this.idePanel.setChildren([this.getWorkspaceIDE()]);
            this.dispatch("workspaceLoaded");
          }
        });
      }
      getWorkspaceIDE() {
        if (USER.isAuthenticated) {
          const workspace = this.getWorkspace();
          if (workspace) {
            let plugins = PluginTypes.CONTEST;
            if (this.getContest().canShowPublicSources() && this.getEvalTask().hasEnforcedTemplates()) {
              plugins = PluginTypes.CONTEST_PUBLIC_SOURCES_ENFORCED_TEMPLATE;
            } else if (this.getContest().canShowPublicSources()) {
              plugins = PluginTypes.CONTEST_PUBLIC_SOURCES;
            } else if (this.getEvalTask().hasEnforcedTemplates()) {
              plugins = PluginTypes.CONTEST_ENFORCED_TEMPLATE;
            }
            this.ide = UI$1.createElement(WorkspaceIDE, {
              plugins: plugins,
              workspace: workspace,
              fullContainer: false,
              contestTaskId: this.options.contestTaskId
            });
            this.ide.toggleFullScreen = () => this.toggleFullScreen();
            return this.ide;
          } else {
            const timeShouldRequest = this.getContestTask().getTimeAvailable().add({
              seconds: 10 + 10 * Math.random()
            });
            let requestDelay = +timeShouldRequest - ServerTime.now();
            if (this.getContest() && this.getContest().isVirtual()) {
              requestDelay = 0;
            }
            setTimeout(() => this.requestEvalTaskWorkspace(), Math.min(Math.max(requestDelay, 0), 20 * 1000));
            return [StateDependentElement.renderLoading(), UI$1.createElement("div", {
              style: {
                marginTop: "20px",
                textAlign: "center",
                fontSize: "1.3em"
              }
            }, "Loading the workspace...")];
          }
        } else {
          return UI$1.createElement("div", null, UI$1.createElement("h3", {
            className: "text-center"
          }, UI$1.T("Authenticate to use the workspace")), UI$1.createElement(Login, {
            ref: this.refLink("loginPanel")
          }));
        }
      }

      /* TODO: WARNING! THIS CLASS FAILS ON REDRAW */
      redraw() {
        if (!this.taskPanel) {
          super.redraw();
        } else {
          this.taskPanel.redraw();
        }
      }
      getSubURL(section) {
        if (this.options.updateURL) {
          let prefix;
          if (this.options.customURLPrefix) {
            prefix = this.options.customURLPrefix;
          } else {
            prefix = this.getContestTask().getFullURL();
          }
          return prefix + section + "/";
        }
      }
      render() {
        let programmingLanguageId = ProgrammingLanguage.getDefaultLanguage().id;
        const isMobile = Device.isMobileDevice();
        const ideWidth = isMobile ? "0%" : "50%";
        const taskWidth = isMobile ? "100%" : "50%";
        return [UI$1.createElement(TitledSectionDivider, {
          ref: "divider",
          orientation: Orientation$1.HORIZONTAL,
          style: {
            overflow: "hidden",
            height: "100%",
            width: "100%"
          }
        }, UI$1.createElement(Panel, {
          size: taskWidth,
          style: {
            overflow: "hidden"
          },
          title: "task",
          ref: "taskPanel"
        }, UI$1.createElement(FlatTabArea, {
          style: {
            height: "100%"
          },
          ref: "tabArea",
          lazyRender: true,
          panelClass: this.styleSheet.taskPanel
        }, UI$1.createElement(ContestTaskSummaryPanel, {
          ref: "taskSummaryPanel",
          title: UI$1.T("Statement"),
          active: "true",
          tabHref: this.getSubURL("statement"),
          contestTask: this.getContestTask(),
          programmingLanguageId: programmingLanguageId,
          style: {
            width: "100%",
            height: "100%"
          }
        }), this.getSolutionPanel(), this.getCommentsPanel(), this.getStatisticsPanel(), this.getSubmissionPanel(), this.getQuestionsPanel())), UI$1.createElement(Panel, {
          collapsed: Device.isMobileDevice(),
          size: ideWidth,
          ref: "idePanel",
          title: "workspace / submit"
        }, this.getWorkspaceIDE()))];
      }
      showUrlTab(location) {
        for (const panel of this.tabArea.options.children) {
          if (panel.options.tabHref === this.getSubURL(location)) {
            panel.dispatch("show");
            return;
          }
        }
        this.taskSummaryPanel.dispatch("show");
      }
    }) || _class2$p);
    class ContestTaskModal extends Modal {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          height: "80%",
          width: "80%"
        });
      }
      showTask() {
        this.modalWindow.setChildren(this.render());
      }
      getContestTaskPanelStyle() {
        return {
          minHeight: "700px",
          borderRadius: "10px"
        };
      }
      render() {
        let contestTask = ContestTaskStore.get(this.options.contestTaskId);
        if (contestTask) {
          return [UI$1.createElement(ContestTaskPanel, {
            style: this.getContestTaskPanelStyle(),
            contestTaskId: this.options.contestTaskId,
            updateURL: false
          })];
        }
        // This is a post because it creates a workspace if one doesn't exist
        Ajax.postJSON("/contest/get_contest_task/", {
          contestTaskId: this.options.contestTaskId,
          requestContestTask: true
        }).then(() => this.showTask());
        return [StateDependentElement.renderLoading()];
      }
    }
    class ContestTaskButton extends Button$1 {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          style: {
            margin: "5px"
          },
          level: Level.PRIMARY,
          size: Size.LARGE
        });
      }
      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI$1.T("Solve this task");
        }
        super.setOptions(options);
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (this.contestTaskModal) {
            this.contestTaskModal.show();
          } else {
            this.contestTaskModal = ContestTaskModal.show({
              contestTaskId: this.options.contestTaskId,
              destroyOnHide: false
            });
          }
        });
      }
    }

    class DelayedContestTaskPanel extends StateDependentElement(ContestTaskPanel) {
      get pageTitle() {
        return this.getContestTask() && this.getContestTask().longName;
      }
      beforeRedrawNotLoaded() {
        if (this.getContestTask() && this.getContestTask().hasStateLoaded()) {
          // The contest task already has its state loaded, either from the WebSocket or from previous requests.
          this.setLoaded();
          return;
        }
        Ajax.postJSON("/contest/get_contest_task/", {
          contestTaskId: this.options.contestTaskId
        }).then(data => {
          this.importState(data);
          this.setLoaded();
        });
      }
      onDelayedMount() {
        super.onDelayedMount();
        if (this.urlParts) {
          this.setURL(this.urlParts);
        }
      }
      setURL(urlParts) {
        if (this.taskPanel) {
          super.setURL(urlParts);
        } else {
          this.urlParts = urlParts;
        }
      }
    }

    class ContestScoreTracker extends UI$1.Primitive("span") {
      getContest() {
        return this.options.contest;
      }
      getContestUser() {
        return this.getContest().getUser(USER.id);
      }
      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }
        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();
        if (contest.isVirtual()) {
          contestUsers.push(user);
        }
        let rank = 1;
        for (let contestUser of contestUsers) {
          if (compareTotalScoreAndPenalty(user, contestUser) > 0) {
            rank += 1;
          }
        }
        return "Rank " + rank + " / " + contestUsers.length;
      }
      getScoreText() {
        if (this.getContestUser().hasOwnProperty("totalScore")) {
          return "Score: " + Formatter.truncate(this.getContestUser().totalScore, 2) + "";
        }
      }
      track() {
        if (this.getContestUser()) {
          const rankText = this.getRankText();
          const scoreText = this.getScoreText();
          let text;
          if (rankText && scoreText) {
            text = rankText + " (" + scoreText + ")";
          } else {
            text = rankText || scoreText || "";
          }
          this.setChildren([text]);
        }
      }
      onMount() {
        this.track();
        const contest = this.options.contest;
        if (this.options.contest.isVirtual()) {
          this.attachListener(contest.getBaseContest(), "rankingsChange", () => this.track());
        }
        this.attachListener(contest, "rankingsChange", () => this.track());
      }
    }
    class ArchiveScoreTracker extends ContestScoreTracker {
      getContest() {
        return this.options.archive;
      }
      getRankText() {
        let archiveUsers = this.getContest().getUsers();
        let rank = 1;
        for (let archiveUser of archiveUsers) {
          if (compareTotalScoreAndPenalty(this.getContestUser(), archiveUser) > 0) {
            rank += 1;
          }
        }
        return "Rank " + rank + " / " + archiveUsers.length;
      }
      onMount() {
        this.track();
        this.attachListener(this.getContest(), "rankingsChange", () => this.track());
      }
    }

    class NavChatBadge extends NavCounterBadge {
      onMount() {
        super.onMount();
        const contestPanel = this.options.contestPanel;
        const contest = this.options.contest;
        this.attachListener(contestPanel, "activeElementChanged", () => {
          if (contestPanel.getActive() === contestPanel.chat) {
            this.reset();
          }
        });
        if (contest.getChat()) {
          this.attachListener(contest.getChat().getMessageThread(), "newMessage", () => {
            if (contestPanel.getActive() !== contestPanel.chat) {
              this.increment();
            }
          });
        }
      }
    }
    class NavAnnouncementsBadge extends NavCounterBadge {
      onMount() {
        super.onMount();
        const contestPanel = this.options.contestPanel;
        const localStorageMap = this.options.localStorageMap;

        /* When badge is created, it takes its counter from the local storage. After that:
           - when an announcement is created: increase badge counter if the active tab isn't "Announcements"
           - when active tab is set to "Announcements": reset badge count and update local storage value
           - when local storage value changes: if the new value is 0 it means that the "Announcements" tab has been
                clicked on another tab, so reset the badge counter.
         */

        this.attachListener(localStorageMap, "change", event => {
          if (!event.newValue) {
            this.reset();
          }
        });
        this.attachListenerForIncrement(ContestAnnouncementStore, "create", announcement => announcement.contestId === this.options.contest.id);
        this.attachListener(contestPanel, "activeElementChanged", () => {
          if (contestPanel.getActive() === contestPanel.announcements) {
            this.reset();
            localStorageMap.set("counter", 0);
          }
        });
      }
    }
    class ContestNavigationHandler extends Dispatchable {
      constructor(contest, contestPanel) {
        super();
        this.contest = contest;
        this.contestPanel = contestPanel;
      }
      getURLPrefix(str) {
        let url = "/contest/" + this.contest.name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      getTasksDropdownElements() {
        return this.contest.getContestTasks().map(contestTask => UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("task/" + contestTask.name),
          value: contestTask.longName,
          key: Math.random()
        }));
      }
      getLeftChildren() {
        const contest = this.contest;
        let leftChildren = [];
        // Summary button
        leftChildren.push(UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI$1.T("Summary")
        }));
        // Tasks dropdown
        if (contest.hasStarted()) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getURLPrefix("tasks"),
            key: "tasks",
            value: UI$1.T("Tasks")
          }, this.getTasksDropdownElements()));
        }
        // Scoreboard button
        if (contest.canShowScoreboard()) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getURLPrefix("scoreboard"),
            key: "scoreboard",
            value: UI$1.T("Scoreboard")
          }));
        }
        // Submissions button
        if (contest.hasStarted() && USER.isAuthenticated) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getURLPrefix("submissions"),
            key: "submissions",
            value: UI$1.T("Own Submissions")
          }));
        }
        // Chat button
        if (contest.chatId) {
          leftChildren.push(this.createChatButton());
        }
        // Questions & Announcements Buttons
        if (!contest.systemGenerated && contest.hasStarted()) {
          leftChildren.push(this.createAnnouncementsButton());
        }
        // Analysis button
        if (contest.hasFinished() && contest.isAnalysisPublic) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getURLPrefix("analysis"),
            key: "analysis",
            value: UI$1.T("Analysis")
          }));
        }
        return leftChildren;
      }
      getRightChildren() {
        const contest = this.contest;
        let rightChildren = [];
        if (contest.hasStarted() && USER.isAuthenticated) {
          rightChildren.push(this.createRankInfo());
        }
        rightChildren.push(this.createTimeCounter());
        return rightChildren;
      }
      apply() {
        if (!this.contestPanel.isInDocument()) {
          return;
        }
        NavManager.Global.skipWrap();
        NavManager.Global.getLeftConditioned().setChildren(this.getLeftChildren());
        NavManager.Global.getRightConditioned().setChildren(this.getRightChildren());
        NavManager.Global.unskipWrap();
        NavManager.Global.checkForWrap();
      }
      createChatButton() {
        const badge = UI$1.createElement(NavChatBadge, {
          contestPanel: this.contestPanel,
          contest: this.contest
        });
        const chatButton = UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("chat"),
          key: "chat",
          style: {
            position: "relative"
          },
          value: [UI$1.T("Chat"), badge]
        });
        return chatButton;
      }
      createAnnouncementsButton() {
        const localStorageMap = ContestLocalStorageManager.getAnnouncementsLocalStorageMap(this.contest.id);
        const badge = UI$1.createElement(NavAnnouncementsBadge, {
          contestPanel: this.contestPanel,
          contest: this.contest,
          counter: localStorageMap.get("counter") || 0,
          level: Level.DANGER,
          localStorageMap: localStorageMap
        });
        const announcementsButton = UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("announcements"),
          key: "announcements",
          style: {
            position: "relative"
          },
          value: [UI$1.T("Announcements"), badge]
        });
        return announcementsButton;
      }
      createTimeCounter() {
        const timer = UI$1.createElement(ContestTimeCounter, {
          contest: this.contest
        });
        this.attachChangeListener(timer, () => NavManager.Global.checkForWrap());
        return UI$1.createElement(NavElement, {
          value: [timer],
          key: "timer"
        });
      }
      createRankInfo() {
        const tracker = UI$1.createElement(ContestScoreTracker, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachChangeListener(tracker, () => NavManager.Global.checkForWrap());
        return UI$1.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }
      reset() {
        NavManager.Global.getLeftConditioned().setChildren([]);
        NavManager.Global.getRightConditioned().setChildren([]);
        NavManager.Global.checkForWrap();
      }
    }
    class ArchiveNavigationHandler extends ContestNavigationHandler {
      getLeftChildren() {
        let leftChildren = [UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("tasks"),
          value: UI$1.T("Tasks")
        }), UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("scoreboard"),
          value: UI$1.T("Scoreboard")
        }), UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("submissions"),
          value: UI$1.T("Submissions")
        })];
        if (this.contest.discussionId) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getURLPrefix("chat"),
            value: UI$1.T("Chat")
          }));
        }
        return leftChildren;
      }
      getRightChildren() {
        const tracker = UI$1.createElement(ArchiveScoreTracker, {
          archive: this.contest
        });
        this.contestPanel.attachChangeListener(tracker, () => setTimeout(() => NavManager.Global.checkForWrap()));
        return [UI$1.createElement(NavElement, {
          value: tracker,
          key: Math.random()
        })];
      }
    }
    const TopLevelNavigationHandler = NavigationHandler => class TopLevelNavigationHandler extends NavigationHandler {
      getURLPrefix(str) {
        let url = "/" + this.contest.name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
    };
    const TopLevelContestNavigationHandler = TopLevelNavigationHandler(ContestNavigationHandler);
    const TopLevelArchiveNavigationHandler = TopLevelNavigationHandler(ArchiveNavigationHandler);

    class ContestRegisterer extends StoreObject {
      getContest() {
        return ContestStore.get(this.contestId);
      }
      isOwned() {
        return USER.id === this.ownerId;
      }
      getCode() {
        let contestName = this.getContest().name;
        return contestName.substr(contestName.length - 12);
      }
    }
    class ContestRegistererStoreClass extends GenericObjectStore {
      getForContest(contestId) {
        for (let registerer of this.all()) {
          if (registerer.contestId === contestId) {
            return registerer;
          }
        }
        return null;
      }
    }
    const ContestRegistererStore = new ContestRegistererStoreClass("contestregisterer", ContestRegisterer);

    const DEFAULT_FILE_NAME = "data.csv";

    // TODO: this should be a CSV writer, right?
    class CSVBuilder {
      constructor(columns) {
        this.setColumns(columns);
      }
      setColumns(columns) {
        this.columns = ColumnHandler.mapColumns(columns);
      }
      static escapeEntry(str) {
        str = String(str);
        if (str.includes(",")) {
          // TODO: this doesn't support \n or \r in the string
          str = '"' + str.replace('"', '""') + '"';
        }
        return str;
      }
      getHeaderLine() {
        let str = "";
        for (let index = 0; index < this.columns.length; index++) {
          const column = this.columns[index];
          if (index) {
            str += ",";
          }
          str += this.constructor.escapeEntry(column.name);
        }
        return str;
      }
      getEntryLine(entry) {
        let str = "";
        for (let index = 0; index < this.columns.length; index++) {
          const column = this.columns[index];
          if (index) {
            str += ",";
          }
          str += this.constructor.escapeEntry(column.value(entry));
        }
        return str;
      }
      getText(entries) {
        let text = this.getHeaderLine();
        for (const entry of entries) {
          text += "\n" + this.getEntryLine(entry);
        }
        return text;
      }
      saveFile(entries, fileName = DEFAULT_FILE_NAME) {
        const text = this.getText(entries);
        return FileSaver.saveAs(text, fileName);
      }
      static saveFile(columns, entries, fileName = DEFAULT_FILE_NAME) {
        let builder = new this(columns);
        return builder.saveFile(entries, fileName);
      }
    }

    const USERS_FILTER = {
      ALL_PARTICIPANTS: 0,
      ONLY_OFFICIAL: 1,
      ONLY_UNOFFICIAL: 2
    };
    class ContestEntriesManager extends EntriesManager {
      constructor(contest, virtualContest, comparator) {
        super([], {
          comparator
        });
        this.addContestListeners(contest);
        this.addContestListeners(virtualContest);
        this.contest = contest;
        this.virtualContest = virtualContest;
        this.cacheEntries();
      }
      addContestListeners(contest) {
        if (!contest) {
          return;
        }
        this.attachChangeListener(contest, () => {
          this.updateEntries();
        });
        this.attachListener(contest, "rankingsChange", () => {
          this.updateEntries();
        });
      }
      getRawEntries() {
        if (!this.contest) {
          return [];
        }
        let contestUsers = this.contest.getUsers();
        if (this.virtualContest) {
          contestUsers = [...contestUsers, ...this.virtualContest.getUsers()];
        }
        return contestUsers;
      }
    }
    class ContestUsersTableWithoutRangeInterface extends SortableTable {
      setOptions(options) {
        super.setOptions(options);

        // First by rating, second by name
        const {
          columns
        } = this.options;
        this.columnSortingOrder = [columns[2], columns[1]];
      }
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ContestEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }
        return this.entriesManager;
      }
      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }
      onMount() {
        super.onMount();

        // TODO: remove this when only using RangeTableInterface (move it to RangeTable)
        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
        this.attachChangeListener(this.getEntriesManager(), () => {
          if (!document.body.contains(this.node)) {
            this.parent.dispatch("shouldRedrawChild", {
              child: this
            });
          } else {
            this.redraw();
          }
        });
      }
      getRowClass() {
        return ScoreboardEntryRow;
      }
      getEntries() {
        return this.getEntriesManager().getEntries();
      }
      getDefaultColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        return [{
          value: (contestUser, index) => index + 1,
          headerName: "#",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: numberStyle
        }, {
          value: contestUser => {
            let handle = UI$1.createElement(UserHandle$1, {
              userId: contestUser.userId,
              showCountry: true
            });
            if (!contestUser.getContest().isVirtual()) {
              return handle;
            } else {
              //TODO: refactor this to update every minute
              return UI$1.createElement("span", null, handle, " virtual ", contestUser.getContestStartTime() < ServerTime.now().unix() && ServerTime.now().unix() < contestUser.getContestEndTime() ? new Duration((ServerTime.now().unix() - contestUser.getContestStartTime()) * 1000).format("HH:mm") : "");
            }
          },
          rawValue: contestUser => {
            let publicUser = PublicUserStore.get(contestUser.userId);
            if (!publicUser) {
              return "publicUser-" + contestUser.userId;
            }
            return publicUser.getDisplayHandle();
          },
          headerName: "User",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: "80%"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contestUser => {
            //TODO: send publicUser when someone registers
            let user = PublicUserStore.get(contestUser.userId);
            if (!user) {
              return "-";
            }
            return user.rating || "-";
          },
          rawValue: contestUser => {
            let user = PublicUserStore.get(contestUser.userId);
            if (!user) {
              return 0;
            }
            return user.rating || 0;
          },
          headerName: "Rating",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }];
      }
    }
    class ContestUsersTable extends RangeTableInterface(ContestUsersTableWithoutRangeInterface) {
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ContestEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }
        return this.entriesManager;
      }
      getEntries() {
        return this.getEntriesManager().getEntries();
      }
    }
    class ScoreboardEntryRow extends TableRow {
      extraNodeAttributes(attr) {
        if (this.options.entry.userId === USER.id) {
          attr.setAttribute("id", "currentUserRow");
          attr.setStyle("backgroundColor", enhance(Theme.Global.properties.COLOR_BACKGROUND, 0.15));
        }
      }
    }
    class ScoreboardEntriesManager extends ContestEntriesManager {
      cacheEntries() {
        const entries = this.getRawEntries();
        Contest.calculateMetaRanks(entries);
        Contest.calculateRanks(entries);
        this.cachedEntries = this.sortEntries(this.filterEntries(entries));
        this.dispatchChange();
      }
    }
    class ScoreboardTableWithoutRangeInterface extends SortableTable {
      setOptions(options) {
        super.setOptions(options);

        // First by score, second by name
        const {
          columns
        } = this.options;
        this.columnSortingOrder = [columns[2], columns[1]];
      }
      getRowClass() {
        return ScoreboardEntryRow;
      }
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ScoreboardEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }
        return this.entriesManager;
      }
      getEntries() {
        return this.getEntriesManager().getEntries();
      }
      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }
      showSubmissions(contestUser, contestTask) {
        let sourcesNotPublic;
        if (!this.options.originalContest.canShowPublicSources()) {
          sourcesNotPublic = UI$1.createElement("h3", null, "Sources are NOT public! You can only see this as an admin!");
        }
        let filters = {
          contestId: contestUser.contestId,
          userId: contestUser.userId,
          contestTaskId: contestUser.getContest().getMatchingContestTask(contestTask).id
        };
        Modal.show({
          fillScreen: true,
          children: [sourcesNotPublic, UI$1.createElement(SubmissionSummaryPanel, {
            filters: filters,
            style: {
              paddingRight: "5%"
            }
          })]
        });
      }
      renderContestUserAndContestTaskCell(contestUser, contestTask) {
        if (!contestUser.scores) {
          return "-";
        }
        let userTaskSummary = contestUser.scores[contestTask.id];
        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }
        if (!userTaskSummary) {
          return "-";
        }
        const userScore = userTaskSummary.score || 0;
        let score, penalty;
        if (contestTask.hasPartialScore()) {
          score = UI$1.createElement("span", null, Formatter.truncate(userScore * contestTask.pointsWorth, 2));
        } else if (userScore === 1) {
          score = UI$1.createElement("span", {
            className: "fa fa-check fa-lg",
            style: {
              color: "green"
            }
          });
        } else {
          score = UI$1.createElement("span", {
            className: "fa fa-times fa-lg",
            style: {
              color: "red"
            }
          });
        }
        if (contestTask.hasPenalty()) {
          let numSubmissions = null;
          if (userScore === 1) {
            if (userTaskSummary.scoreSubmissionNumber > 1) {
              numSubmissions = UI$1.createElement("span", {
                style: {
                  fontSize: "0.8em"
                }
              }, "(", userTaskSummary.scoreSubmissionNumber - 1, ")");
            }
          } else if (userTaskSummary.numSubmissions > 0) {
            numSubmissions = UI$1.createElement("span", {
              style: {
                fontSize: "0.8em"
              }
            }, "(", userTaskSummary.numSubmissions, ")");
          }
          score = [score, numSubmissions];
          let contestStartTime = new StemDate(contestUser.getContestStartTime());
          let solutionTime = new StemDate(userTaskSummary.scoreTime);
          let solutionTimeRelative = solutionTime.diffDuration(contestStartTime);
          if (contestTask.hasPartialScore() || userScore === 1) {
            penalty = UI$1.createElement("div", {
              style: {
                fontSize: "0.8em",
                color: "grey"
              }
            }, solutionTimeRelative.format("HH:mm"));
          }
        }
        const containerOptions = {
          style: {}
        };
        if (USER.isSuperUser || this.options.originalContest.canShowPublicSources()) {
          containerOptions.onClick = () => this.showSubmissions(contestUser, contestTask);
          Object.assign(containerOptions.style, {
            cursor: "pointer",
            pointerEvents: "auto"
          });
        }
        return UI$1.createElement("div", containerOptions, [score, penalty]);
      }
      getContestUserAndContestTaskCellRawValue(contestUser, contestTask) {
        if (!contestUser.scores) {
          return -1;
        }
        let userTaskSummary = contestUser.scores[contestTask.id];
        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }
        if (!userTaskSummary) {
          return -1;
        }
        if (contestTask.hasPartialScore()) {
          return userTaskSummary.score;
        }
        if (userTaskSummary.score) {
          return 1;
        }
        return 0;
      }
      renderContestTaskHeader(contestTask, index) {
        let taskName;
        if (this.options.contest.scoreboardType === Contest.scoreboardType.TASK_NAME) {
          taskName = UI$1.createElement("div", null, UI$1.T(contestTask.longName));
        } else {
          taskName = UI$1.createElement(PopupSpan, {
            popupContent: UI$1.T(contestTask.longName)
          }, String.fromCharCode("A".charCodeAt(0) + index));
        }
        let taskScore = null;
        if (contestTask.hasScore()) {
          taskScore = UI$1.createElement("div", {
            style: {
              fontSize: "0.9em"
            }
          }, Formatter.truncate(contestTask.pointsWorth, 2));
        }
        return [taskName, taskScore];
      }
      shouldShowTaskColumns() {
        return this.options.contest.scoreboardType !== Contest.scoreboardType.TOTAL_SCORE_ONLY;
      }
      getDefaultColumns() {
        const {
          contest
        } = this.options;
        const columnWidths = {
          rank: 1,
          user: 29,
          score: 10,
          tasks: 60
        };
        const numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        const centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        const scoreColumns = this.options.scoreColumns;
        scoreColumns[0].headerStyle = scoreColumns[0].cellStyle = {
          ...centerStyle,
          width: columnWidths.score + "%"
        };
        const columns = [{
          headerName: UI$1.T("Rank"),
          rawValue: contestUser => contestUser.rank,
          value: contestUser => {
            let displayRank = contestUser.rank;
            const {
              globalRank
            } = contestUser;
            if (globalRank && globalRank != contestUser.rank) {
              displayRank = displayRank + " (" + globalRank + ")";
            }
            return displayRank;
          },
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: columnWidths.rank + "%",
            maxWidth: "50px"
          },
          cellStyle: {
            ...numberStyle,
            width: columnWidths.rank + "%",
            maxWidth: "50px"
          }
        }, {
          headerName: UI$1.T("User"),
          value: contestUser => {
            let handle = UI$1.createElement(UserHandle$1, {
              userId: contestUser.userId,
              showCountry: true
            });
            if (!contestUser.getContest().isVirtual() || ContestRegistererStore.getForContest(contestUser.getContest().getBaseContest().id)) {
              return handle;
            } else {
              //TODO: refactor this to update every minute
              return UI$1.createElement("span", null, handle, " ", UI$1.T("virtual"), " ", contestUser.getContestStartTime() < ServerTime.now().unix() && ServerTime.now().unix() < contestUser.getContestEndTime() ? new Duration((ServerTime.now().unix() - contestUser.getContestStartTime()) * 1000).format("HH:mm") : "");
            }
          },
          rawValue: contestUser => {
            let publicUser = PublicUserStore.get(contestUser.userId);
            if (!publicUser) {
              return "publicUser-" + contestUser.userId;
            }
            return publicUser.getDisplayHandle();
          },
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: columnWidths.user + "%"
          },
          cellStyle: {
            verticalAlign: "middle",
            width: columnWidths.user + "%"
          }
        }, ...scoreColumns];
        if (this.shouldShowTaskColumns()) {
          const contestTasks = contest.getContestTasks();
          for (let i = 0; i < contestTasks.length; i += 1) {
            const contestTask = contestTasks[i];
            columns.push({
              headerName: () => this.renderContestTaskHeader(contestTask, i),
              value: contestUser => this.renderContestUserAndContestTaskCell(contestUser, contestTask),
              rawValue: contestUser => this.getContestUserAndContestTaskCellRawValue(contestUser, contestTask),
              sortDescending: true,
              headerStyle: {
                ...centerStyle,
                width: columnWidths.tasks / contestTasks.length + "%"
              },
              cellStyle: {
                ...centerStyle,
                width: columnWidths.tasks / contestTasks.length + "%"
              }
            });
          }
        }
        return columns;
      }
      onMount() {
        super.onMount();
        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
        this.attachChangeListener(this.getEntriesManager(), () => {
          this.redraw();
        });
      }
    }
    class ScoreboardTable extends RangeTableInterface(ScoreboardTableWithoutRangeInterface) {
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ScoreboardEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }
        return this.entriesManager;
      }
      getEntries() {
        return this.getEntriesManager().getEntries();
      }
    }
    class PrivateArchiveUsersTable extends SortableTable {
      onMount() {
        super.onMount();

        // TODO: should be addListener("createOrUpdate")
        ContestUserStore.addCreateListener(data => {
          this.parent.dispatch("shouldRedrawChild", {
            child: this
          });
        });
        ContestUserStore.addChangeListener(data => {
          this.parent.dispatch("shouldRedrawChild", {
            child: this
          });
        });
      }
      getEntries() {
        if (!this.options.privateArchive) {
          return [];
        }
        return this.options.privateArchive.getUsers();
      }
      getDefaultColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        let columns = [{
          value: (privateArchiveUser, index) => index + 1,
          headerName: "#",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: numberStyle
        }, {
          value: privateArchiveUser => {
            return UI$1.createElement(UserHandle$1, {
              userId: privateArchiveUser.userId,
              showCountry: true
            });
          },
          rawValue: privateArchiveUser => {
            return privateArchiveUser.userId;
          },
          headerName: "User",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }];
        for (let contestTask of this.options.privateArchive.getContestTasks()) {
          columns.push({
            value: privateArchiveUser => {
              let contestUser = privateArchiveUser.getContestUser(contestTask);
              if (!contestUser) {
                return "-";
              }
              if (!contestUser.scores) {
                return "-";
              }
              let userTaskSummary = contestUser.scores[contestTask.id];
              if (!userTaskSummary) {
                return "-";
              }
              let showSubmissions = () => {
                let filters = {
                  contestId: contestTask.getEvalTask().defaultContest.id,
                  userId: contestUser.userId,
                  contestTaskId: contestTask.id
                };
                Modal.show({
                  fillScreen: true,
                  children: [UI$1.createElement(SubmissionSummaryPanel, {
                    filters: filters,
                    style: {
                      paddingRight: "5%"
                    }
                  })]
                });
              };
              let score;
              if (contestUser.solvedTask(contestTask)) {
                score = UI$1.createElement("span", {
                  className: "fa fa-check fa-lg",
                  style: {
                    color: "green"
                  },
                  onClick: showSubmissions
                });
              } else {
                score = Formatter.truncate(userTaskSummary.score, 2);
              }
              return UI$1.createElement("span", {
                onClick: showSubmissions
              }, score);
            },
            rawValue: privateArchiveUser => {
              let contestUser = privateArchiveUser.getContestUser(contestTask);
              if (!contestUser) {
                return -1;
              }
              if (!contestUser.scores) {
                return -1;
              }
              let userTaskSummary = contestUser.scores[contestTask.id];
              if (!userTaskSummary) {
                return -1;
              }
              return userTaskSummary.score || 0;
            },
            headerName: () => UI$1.createElement("div", null, contestTask.longName),
            sortDescending: true,
            headerStyle: centerStyle,
            cellStyle: centerStyle
          });
        }
        return columns;
      }
    }
    class ContestUsersFilter extends UI$1.Primitive("span") {
      extraNodeAttributes(attr) {
        attr.setStyle("whiteSpace", "nowrap");
      }
      render() {
        return [UI$1.createElement(Select, {
          ref: "filterUsers",
          options: ["All participants", "Only official", "Only unofficial"],
          style: {
            height: "2.2em"
          }
        }), UI$1.createElement(Select, {
          ref: "filterCountry",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: this.options.contest.getCountries()
        }), UI$1.createElement(TextInput, {
          ref: "findUserInput",
          style: {
            height: "2.03em",
            marginLeft: "10px",
            verticalAlign: "middle"
          },
          placeholder: "Find user..."
        })];
      }
      getFilter() {
        return contestUser => {
          const usersFilter = this.filterUsers.getIndex();
          const countryIdFilter = this.filterCountry.get().id;
          const findUser = this.findUserInput.getValue() || "";
          const isOfficial = contestUser.isOfficial();
          if (isOfficial && usersFilter === USERS_FILTER.ONLY_UNOFFICIAL || !isOfficial && usersFilter === USERS_FILTER.ONLY_OFFICIAL) {
            return false;
          }
          const keywords = findUser.trim().toLowerCase();
          const publicUser = PublicUserStore.get(contestUser.userId);
          // TODO: Public user should have been in state.
          if (!publicUser) {
            return false;
          }
          if (keywords !== "") {
            if ((publicUser.name || "").toLowerCase().indexOf(keywords) == -1 && (publicUser.username || "").toLowerCase().indexOf(keywords) == -1) {
              return false;
            }
          }
          if (countryIdFilter) {
            return publicUser.countryId === countryIdFilter;
          }
          return true;
        };
      }
      updateFilter() {
        this.dispatch("filterChange");
      }
      onMount() {
        this.filterUsers.addChangeListener(() => {
          this.updateFilter();
        });
        this.filterCountry.addChangeListener(() => {
          this.updateFilter();
        });
        this.findUserInput.addNodeListener("keyup", () => {
          this.updateFilter();
        });
        this.updateFilter();
        const updateThrottler = new CallThrottler({
          throttle: 300
        });
        const updateCountryFilterThrottled = updateThrottler.wrap(() => this.filterCountry.updateOptions({
          options: this.options.contest.getCountries()
        }));
        this.attachListener(this.options.contest, "contestUserUpdate", updateCountryFilterThrottled);
      }
    }
    class Scoreboard extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Utils.fullHeight);
        attr.setStyle({
          display: "flex",
          flexDirection: "column"
        });
      }
      getContestUsersFilter() {
        return UI$1.createElement(ContestUsersFilter, {
          ref: "contestUsersFilter",
          contest: this.options.contest
        });
      }
      getContestUsersTableClass() {
        return ContestUsersTable;
      }
      getScoreboardTableClass() {
        return ScoreboardTable;
      }
      shouldIncludeRelatedContests() {
        return this.includeRelatedContestsInput?.getValue() && this.options.contest.getRelatedContests().length > 0;
      }
      getScoreColumns() {
        const {
          contest
        } = this.options;
        const relatedContests = contest.getRelatedContests();
        const linkedContests = [contest, ...relatedContests];
        const reverseCmp = (a, b) => b - a;
        const totalScoreColumn = [{
          toUI() {
            return UI$1.createElement("span", null, UI$1.createElement("span", {
              style: {
                fontSize: "1.2em"
              }
            }, UI$1.T("Score")), !!contest.hasPenalty() && UI$1.createElement("span", {
              style: {
                fontSize: "0.8em"
              }
            }, " (", UI$1.T("Penalty"), ")"));
          },
          toString() {
            return "Score";
          }
        }, contestUser => ({
          toUI() {
            return UI$1.createElement("span", null, UI$1.createElement("strong", {
              style: {
                fontSize: "1.2em"
              }
            }, contestUser.numSubmissions ? Formatter.truncate(contestUser.totalScore, 2) : "-"), contest.hasPenalty() && contestUser.penalty > 0 && UI$1.createElement("span", {
              style: {
                fontSize: "0.8em"
              }
            }, "(", Math.round(contestUser.penalty), ")"));
          },
          toString() {
            return contestUser.totalScore;
          }
        }), {
          rawValue: entry => entry,
          cmp: compareContestUsers
        }];
        if (!this.shouldIncludeRelatedContests()) {
          return [totalScoreColumn];
        }
        const contestSharedPrefixLength = () => {
          const contestNames = linkedContests.map(c => c.longName);
          for (let sharedPrefixLength = 0; sharedPrefixLength + 1 < contestNames[0].length; sharedPrefixLength++) {
            const curChar = contestNames[0].charAt(sharedPrefixLength);
            for (let index = 1; index < contestNames.length; index++) {
              if (contestNames[index].charAt(sharedPrefixLength) !== curChar) {
                return 0; // or sharedPrefixLength;
              }
            }
            if (curChar === ":" || curChar === "-") {
              return sharedPrefixLength + 1;
            }
          }
          return 0;
        };
        const sharedPrefixLength = contestSharedPrefixLength();
        return [[UI$1.T("Total Score"), contestUser => ({
          toUI() {
            return UI$1.createElement("strong", {
              style: {
                fontSize: "1.2em"
              }
            }, Formatter.truncate(contestUser.recalculateMetaScore(), 2));
          },
          toString() {
            return contestUser.recalculateMetaScore();
          }
        }), {
          cmp: reverseCmp
        }], [UI$1.T("Total Rank"), contestUser => contestUser.metaRank], ...linkedContests.map(linkedContest => {
          const title = linkedContest.longName.substring(sharedPrefixLength).trim();
          const score = contestUser => {
            const linkedContestUser = linkedContest.getUser(contestUser.userId);
            return linkedContestUser?.numSubmissions ? Formatter.truncate(linkedContestUser.totalScore, 2) : "-";
          };
          return [title, score];
        })];
      }
      async downloadScores() {
        const {
          contest
        } = this.options;
        const contestUsers = Array.from(contest.contestUsers.values());
        if (this.shouldIncludeRelatedContests()) {
          Contest.calculateMetaRanks(contestUsers);
        } else {
          Contest.calculateRanks(contestUsers);
        }
        const csvColumns = [["Username", u => u.getPublicUser().username], ["Name", u => u.getPublicUser().name], ...this.getScoreColumns(), ["Penalty", u => u.penalty], ["Country", u => u.getPublicUser().getCountry() || ""]];
        for (const contestTask of contest.getContestTasks()) {
          const getStats = contestUser => contestUser.scores[contestTask.id];
          const getScore = contestUser => (getStats(contestUser)?.score || 0) * 100.0;
          const getPenalty = contestUser => (getStats(contestUser)?.scoreTime || contest.startTime) - contest.startTime;
          const name = contestTask.toString();
          csvColumns.push([name, getScore]);
          csvColumns.push([name + " Penalty", getPenalty]);
        }
        csvColumns.push(["Judge decision", contestUser => {
          if (contestUser.isDisqualified()) {
            return "Disqualified";
          }
          return "-";
        }]);
        CSVBuilder.saveFile(csvColumns, contestUsers, contest.name + "-Scores.csv");
      }
      getScoreboardActionableArea() {
        const {
          contest
        } = this.options;
        return [contest.getUser(USER.id) && UI$1.createElement(Button$1, {
          ref: "showMeButton",
          label: UI$1.T("Show Me"),
          onClick: () => this.showMe(),
          style: {
            marginRight: "10px",
            height: "2.2em"
          },
          level: Level.INFO,
          size: Size.SMALL
        }), this.getContestUsersFilter(),
        // TODO: add this functionality for all contest owners
        USER.isSuperUser && [UI$1.createElement(Button$1, {
          onClick: () => this.downloadScores(),
          label: "Download scores",
          style: {
            marginLeft: "10px",
            height: "2.2em",
            paddingTop: 0,
            paddingBottom: 0
          },
          level: Level.PRIMARY,
          size: Size.SMALL
        }), contest.parentId && UI$1.createElement("label", null, UI$1.createElement(RawCheckboxInput, {
          ref: "includeRelatedContestsInput",
          value: this.includeRelatedContests,
          onChange: value => {
            this.includeRelatedContests = value; // Ugh, fucking hell
            this.redraw();
          }
        }), "Include related contests")]];
      }
      render() {
        const {
          contest,
          virtualContest,
          originalContest
        } = this.options;
        const ScoreboardTableClass = originalContest.hasStarted() ? this.getScoreboardTableClass() : this.getContestUsersTableClass();
        return [UI$1.createElement("div", {
          style: {
            padding: "20px 0"
          }
        }, this.getScoreboardActionableArea()), UI$1.createElement(ScoreboardTableClass, {
          ref: "scoreboardTable",
          contest: contest,
          virtualContest: virtualContest,
          originalContest: originalContest,
          scoreColumns: this.getScoreColumns(),
          style: {
            flex: "1"
          }
        })];
      }
      showMe() {
        const currentUserRow = document.getElementById("currentUserRow");
        if (currentUserRow) {
          document.body.scrollTop = Math.max(currentUserRow.offsetTop - window.innerHeight / 2, 0);
        } else {
          this.scoreboardTable.dispatch("showCurrentUser");
        }
      }
      onMount() {
        super.onMount();
        this.scoreboardTable.applyFilter(this.contestUsersFilter.getFilter());
        this.contestUsersFilter.addListener("filterChange", () => {
          this.scoreboardTable.applyFilter(this.contestUsersFilter.getFilter());
        });
        this.addListener("setActive", active => {
          setTimeout(() => {
            this.scoreboardTable.redraw();
          });
          if (active) {
            if (typeof this.scoreboardTable.applyScrollState == "function") {
              this.scoreboardTable.applyScrollState();
            }
          } else {
            if (typeof this.scoreboardTable.saveScrollState == "function") {
              this.scoreboardTable.saveScrollState();
            }
          }
        });
      }
    }

    var _dec$A, _class$O;
    class MetaContestEntriesManager extends EntriesManager {
      constructor(metaContest) {
        super([], {
          comparator: (userA, userB) => userB.totalScore - userA.totalScore
        });
        this.metaContest = metaContest;
        const updateEntriesThrottler = new CallThrottler({
          throttle: 250
        });
        this.updateEntriesThrottled = updateEntriesThrottler.wrap(() => this.updateEntries());
        this.cacheEntries();
      }
      getRawEntries() {
        if (!this.metaContest) {
          return [];
        }
        return this.metaContest.getUsers();
      }
    }
    let MetaContestUsersTable = (_dec$A = autoredraw(ArchiveUserStore), _dec$A(_class$O = class MetaContestUsersTable extends RangeTableInterface(Table) {
      getRowClass() {
        return ScoreboardEntryRow;
      }
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new MetaContestEntriesManager(this.options.metaContest);
        }
        return this.entriesManager;
      }
      getEntries() {
        return this.getEntriesManager().getEntries();
      }
      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }
      getDefaultColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        return [{
          headerName: UI.T("Rank"),
          value: (metaContestUser, rowIndex) => rowIndex + 1,
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: "0%"
          },
          cellStyle: {
            ...numberStyle,
            width: "0%"
          }
        }, {
          headerName: UI.T("User"),
          value: metaContestUser => UI.createElement(UserHandle$1, {
            userId: metaContestUser.userId,
            user: metaContestUser,
            showCountry: true
          }),
          rawValue: metaContestUser => {
            let publicUser = PublicUserStore.get(metaContestUser.userId);
            if (!publicUser) {
              return "publicUser-" + metaContestUser.userId;
            }
            return publicUser.getDisplayHandle();
          },
          headerStyle: {
            verticalAlign: "middle",
            width: "80%"
          },
          cellStyle: {
            verticalAlign: "middle",
            width: "80%"
          }
        }, {
          headerName: UI.T("Score"),
          value: metaContestUser => {
            //TODO: send publicUser when someone registers
            return Formatter.truncate(metaContestUser.totalScore, 2);
          },
          rawValue: metaContestUser => metaContestUser.totalScore,
          headerStyle: {
            ...centerStyle,
            width: "20%"
          },
          cellStyle: {
            ...centerStyle,
            width: "20%"
          }
        }];
      }
      redraw(event) {
        if (event) {
          this.getEntriesManager().updateEntriesThrottled();
        } else {
          super.redraw();
        }
      }
    }) || _class$O);

    var _dec$z, _class$N;

    // TODO: merge this class with ContestUsersFilter
    class CountryUsersFilter extends UI$1.Primitive("span") {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("whiteSpace", "nowrap");
        attr.setStyle("padding", "10px 0");
      }
      render() {
        return [UI$1.createElement(Select, {
          ref: "filterCountry",
          onChange: () => this.updateFilter(),
          style: {
            height: "2em",
            marginLeft: "10px"
          },
          options: this.options.countries
        })];
      }
      getFilter() {
        this.options.countryIdFilter = this.filterCountry.get().id;
        return user => {
          if (this.options.countryIdFilter) {
            return user.countryId === this.options.countryIdFilter;
          }
          return true;
        };
      }
      updateFilter() {
        this.dispatch("filterChange");
      }
    }
    let ArchiveScoreboardWrapper = (_dec$z = autoredraw(ArchiveUserStore), _dec$z(_class$N = class ArchiveScoreboardWrapper extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          flexDirection: "column",
          height: "100%"
        });
      }
      render() {
        return [UI$1.createElement(CountryUsersFilter, {
          ref: "archiveUsersFilter",
          countries: this.options.archive.getCountries()
        }), UI$1.createElement(MetaContestUsersTable, {
          ref: "scoreboard",
          metaContest: this.options.archive,
          style: {
            flex: "1",
            overflow: "hidden"
          }
        })];
      }
      onMount() {
        this.archiveUsersFilter.addListener("filterChange", () => {
          this.scoreboard.applyFilter(this.archiveUsersFilter.getFilter());
        });
        this.addListener("setActive", active => {
          this.scoreboard.redraw();
          if (active) {
            if (typeof this.scoreboard.applyScrollState == "function") {
              this.scoreboard.applyScrollState();
            }
          } else {
            if (typeof this.scoreboard.saveScrollState == "function") {
              this.scoreboard.saveScrollState();
            }
          }
        });
      }
    }) || _class$N);
    class ArchiveSubmissionsWrapper extends UI$1.Element {
      onMount() {
        this.addListener("setActive", active => {
          if (active) {
            if (this.options.children.length === 0) {
              this.appendChild(UI$1.createElement(SubmissionSummaryContestFilter, {
                contestId: this.options.archive.baseContestId,
                allContests: true
              }));
            }
          }
        });
      }
    }
    class ArchivePanel extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new ArchiveNavigationHandler(this.getArchive(), this);
      }
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fullHeight: true
        });
      }
      getArchive() {
        return ArchiveStore.get(this.options.archiveId);
      }
      getTasks() {
        return UI$1.createElement(ContestTaskListWithFilters, {
          contest: this.getArchive(),
          isArchive: true
        });
      }
      getScoreboard() {
        return UI$1.createElement(ArchiveScoreboardWrapper, {
          archive: this.getArchive(),
          className: GlobalStyle.Container.MEDIUM
        });
      }
      getSubmissions() {
        return UI$1.createElement(ArchiveSubmissionsWrapper, {
          archive: this.getArchive(),
          className: GlobalStyle.Container.MEDIUM
        });
      }
      getChat() {
        const chatId = this.getArchive().discussionId;
        return chatId && UI$1.createElement(ContestChat, {
          chatId: chatId,
          ref: this.refLink("chat")
        });
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getTasks(), [new Route("tasks", () => this.getTasks()), new Route("task", () => this.getTasks(), [new TerminalRoute("%s", options => {
          const contestTask = ContestTaskStore.getByContestIdAndUrlName(this.getArchive().baseContestId, options.args[0]);
          return contestTask && UI$1.createElement(DelayedContestTaskPanel, {
            contestTaskId: contestTask.id
          });
        })]), new Route("scoreboard", () => this.getScoreboard()), new Route("submissions", () => this.getSubmissions()), new Route("chat", () => this.getChat())]);
        return this.routes;
      }
      onMount() {
        Ajax.getJSON("/contest/archive_scoreboard_state/", {
          archiveId: this.getArchive().id
        }).then(() => this.getArchive().recalculateUsers());
        if (this.isInDocument()) {
          this.navHandler.apply();
        }
        if (this.getArchive().discussionId) {
          GroupChatStore.fetch(this.getArchive().discussionId, () => this.chat && this.chat.redraw(), error => this.chat && this.chat.updateOptions({
            error
          }));
        }
        GlobalState$1.registerStream("contest-" + this.getArchive().baseContestId + "-scores");
      }
    }

    // import {UI, RangeTableInterface, SortableTable} from "UI";
    class RankingTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        const {
          columns
        } = this.options;
        this.columnSortingOrder = [columns[0], columns[1]];
      }
      getEntries() {
        return this.sortEntries(PublicUserStore.all().filter(user => user.rating));
      }
      getDefaultColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        const paddingStyle = {
          paddingTop: 8,
          paddingBottom: 8,
          paddingLeft: 4,
          paddingRight: 3
        };
        const rankStyle = {
          width: "0%"
        };
        const userStyle = {
          width: "80%",
          whiteSpace: "nowrap"
        };
        const scoreStyle = {
          width: "20%"
        };
        return [{
          value: user => user.globalRatingRank,
          headerName: UI$1.T("Rank"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, rankStyle, paddingStyle),
          cellStyle: Object.assign(numberStyle, rankStyle, paddingStyle)
        }, {
          value: user => UI$1.createElement(UserHandle$1, {
            userId: user.id,
            showCountry: true
          }),
          headerName: UI$1.T("User"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle, paddingStyle),
          cellStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle, paddingStyle)
        }, {
          value: user => user.rating || "-",
          headerName: UI$1.T("Rating"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, scoreStyle, paddingStyle),
          cellStyle: Object.assign({
            verticalAllign: "middle"
          }, scoreStyle, paddingStyle)
        }];
      }
    }
    class RankingsEntriesManager extends EntriesManager {
      constructor(comparator) {
        super([], {
          comparator
        });
        this.cacheEntries();
      }
      getRawEntries() {
        return PublicUserStore.all().filter(user => user.rating);
      }
    }
    class RankingRangeTable extends RangeTableInterface(RankingTable) {
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new RankingsEntriesManager(this.getComparator());
        }
        return this.entriesManager;
      }
      getEntries() {
        return this.getEntriesManager().getEntries();
      }
      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }
      onMount() {
        super.onMount();
        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
      }
    }
    class MinRanking extends RankingTable {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("margin-bottom", "0");
      }
      getEntries() {
        if (this.shortList) {
          return this.sortEntries(this.shortList);
        }
        let allUsers = PublicUserStore.all().filter(user => !user.isAdmin);
        allUsers.sort((a, b) => {
          return (b.rating || 0) - (a.rating || 0);
        });
        this.shortList = allUsers.slice(0, 10);
        return this.sortEntries(this.shortList);
      }
    }
    class ReputationRanking extends RankingRangeTable {
      getDefaultColumns(options) {
        const columns = super.getDefaultColumns(options);
        Object.assign(columns[0], {
          value: user => this.options.reputationDict[user.id].rank
        });
        Object.assign(columns[2], {
          value: user => parseInt(this.options.reputationDict[user.id].reputation),
          headerName: "Reputation"
        });
        return columns;
      }
    }
    class GlobalRatings extends SortableTable {
      getDefaultOptions() {
        return {
          style: {
            margin: "0 auto",
            maxWidth: "1000px",
            width: "90%",
            display: "flex",
            flexDirection: "column",
            height: "100%"
          }
        };
      }
      render() {
        let ranking;
        if (this.options.type === "reputation") {
          ranking = UI$1.createElement(ReputationRanking, {
            ref: "ranking",
            reputationDict: this.options.reputationDict,
            style: {
              flex: "1",
              overflow: "hidden"
            }
          });
        } else {
          ranking = UI$1.createElement(RankingRangeTable, {
            ref: "ranking",
            style: {
              flex: "1",
              overflow: "hidden"
            }
          });
        }
        return [UI$1.createElement("h3", {
          className: "text-center"
        }, UI$1.T("Leaderboard")), UI$1.createElement(CountryUsersFilter, {
          ref: "usersFilter",
          countries: PublicUserStore.getCountries()
        }), ranking];
      }
      onMount() {
        this.usersFilter.addListener("filterChange", () => {
          this.ranking.applyFilter(this.usersFilter.getFilter());
        });
      }
    }

    class LeaderboardPanel extends CardPanel {
      getTitle() {
        return UI$1.T("Leaderboard");
      }
      render() {
        return [UI$1.createElement(MinRanking, {
          style: {
            fontSize: "0.9em",
            padding: "0 !important",
            borderTop: "0",
            borderBottom: "1px solid #ddd"
          }
        }), UI$1.createElement("div", {
          style: {
            textAlign: "center",
            height: "32px",
            lineHeight: "32px",
            padding: "0 !important"
          }
        }, UI$1.createElement(Link, {
          href: "/ratings/",
          value: UI$1.T("See full leaderboard")
        }))];
      }
    }

    class SendFeedbackPanel extends CardPanel {
      constructor(...args) {
        super(...args);
        this.haveSentFeedback = false;
      }
      getTitle() {
        return UI$1.T("Feedback");
      }
      render() {
        const buttonOptions = !this.haveSentFeedback ? {
          label: UI$1.T("Send feedback"),
          level: Level.PRIMARY,
          icon: "book",
          onClick: () => this.sendFeedback()
        } : {
          label: UI$1.T("Thanks for your feedback!"),
          level: Level.SUCCESS,
          disabled: true,
          icon: "check-square"
        };
        return [UI$1.createElement("div", {
          style: {
            textAlign: "center",
            fontSize: "1.1em",
            height: "30px",
            lineHeight: "30px"
          }
        }, UI$1.T("Tell us what you think!")), UI$1.createElement("div", {
          ref: "writingSection",
          className: "text-center"
        }, !this.haveSentFeedback && UI$1.createElement(TextArea, {
          ref: "textInput",
          style: {
            overflow: "auto",
            resize: "none",
            width: "100%",
            maxWidth: "90%",
            height: "30px",
            borderRadius: "0px"
          }
        }), UI$1.createElement(Button$1, _extends({
          style: {
            margin: 2,
            backgroundColor: "#fff",
            border: "0",
            color: "#337ab7",
            padding: "0",
            marginTop: 2
          }
        }, buttonOptions)))];
      }
      async sendFeedback() {
        if (!USER.isAuthenticated) {
          LoginModal.show();
          return;
        }
        let message = (this.textInput.getValue() || "").trim();
        if (message.length === 0 || this.options.sentFeedback) {
          // TODO have an alert message here
          return;
        }
        const request = {
          message: message,
          clientMessage: "{}"
        };
        await Ajax.postJSON("/send_feedback/", request);
        this.haveSentFeedback = true;
        this.redraw();
      }
    }

    class TransferOwnershipModal extends ActionModal {
      getActionName() {
        return "Transfer ownership";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getArticle() {
        return this.options.article;
      }
      getBody() {
        return [UI$1.createElement(UI$1.TextElement, {
          ref: "text",
          value: "Set owner for " + this.getArticle().name + ":"
        }), UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "ownerFormField",
          label: "Author ID"
        }, UI$1.createElement(TextInput, {
          ref: "ownerFormInput",
          value: this.getArticle().userCreatedId
        })))];
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "transferOwnershipButton",
          level: this.getActionLevel(),
          onClick: () => this.action(),
          statusOptions: [this.getActionName(), {
            icon: "spinner fa-spin",
            label: " transfering ownership ..."
          }, this.getActionName(), "Failed"]
        }))];
      }
      action() {
        let newOwner = this.ownerFormInput.getValue();
        let request = {
          newOwner: newOwner
        };
        this.messageArea.showMessage("Saving...", "black", null);
        this.transferOwnershipButton.postJSON("/article/" + this.getArticle().id + "/set_owner/", request).then(() => this.hide(), error => this.messageArea.showMessage("Error in changing owner " + error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    let DeleteArticleModal$1 = class DeleteArticleModal extends ActionModal {
      getActionName() {
        return "Delete article";
      }
      getBody() {
        return UI$1.createElement(UI$1.TextElement, {
          ref: "text",
          value: "Delete " + this.getArticle().name + "?"
        });
      }
      getArticle() {
        return this.options.article;
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "deleteArticleButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteArticle();
          },
          statusOptions: ["Delete article", {
            icon: "spinner fa-spin",
            label: " deleting article ..."
          }, "Delete article", "Failed"]
        }))];
      }
      deleteArticle() {
        this.deleteArticleButton.postJSON("/article/" + this.getArticle().id + "/delete/", {}).then(() => {
          let table = this.options.parent.table;
          table.options.articles.splice(table.getArticleIndex(this.getArticle().id), 1);
          table.redraw();
          this.hide();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    };
    class CreateArticleModal extends ActionModal {
      getActionName() {
        return "Create article";
      }
      getBody() {
        return UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "articleNameFormField",
          label: "Article name"
        }, UI$1.createElement(TextInput, {
          ref: "articleNameInput",
          value: ""
        })), UI$1.createElement(FormField, {
          ref: "dependencyFormField",
          label: "Dependencies"
        }, UI$1.createElement(TextInput, {
          ref: "dependencyInput",
          value: ""
        })), UI$1.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI$1.createElement(Select, {
          ref: "languageSelect",
          options: Language.all()
        })), UI$1.createElement(FormField, {
          ref: "publicFormField",
          label: "Public"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "publicCheckbox"
        })));
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "createArticleButton",
          level: Level.PRIMARY,
          onClick: () => {
            this.createArticle();
          },
          statusOptions: ["Create article", {
            icon: "spinner fa-spin",
            label: " creating article ..."
          }, "Create article", "Failed"]
        }))];
      }
      createArticle(options) {
        let name = this.articleNameInput.getValue();
        let dependency = this.dependencyInput.getValue();
        let languageId = this.languageSelect.get().id;
        let isPublic = this.publicCheckbox.getValue();
        let request = {
          name: name,
          dependency: dependency,
          languageId: languageId,
          isPublic: isPublic
        };
        if (options) {
          Object.assign(request, options);
        }
        this.createArticleButton.postJSON("/create_article/", request).then(data => {
          this.options.parent.table.addArticle(ArticleStore.get(data.article.id));
          this.hide();
        }, error => {
          this.messageArea.showMessage(error.message, "red");
        });
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    class AddTranslationModal extends CreateArticleModal {
      getActioName() {
        return "Add translation";
      }
      getBody() {
        const baseArticle = this.options.baseArticle;
        return UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "articleNameFormField",
          label: "Article name"
        }, UI$1.createElement(TextInput, {
          ref: "articleNameInput",
          value: "Translation for " + baseArticle.name
        })), UI$1.createElement(FormField, {
          ref: "dependencyFormField",
          label: "Dependencies"
        }, UI$1.createElement(TextInput, {
          ref: "dependencyInput",
          value: baseArticle.dependency
        })), UI$1.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI$1.createElement(Select, {
          ref: "languageSelect",
          options: Language.all()
        })), UI$1.createElement(FormField, {
          ref: "publicFormField",
          label: "Public"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "publicCheckbox",
          initialValue: baseArticle.isPublic
        })));
      }
      getFooter() {
        const baseArticle = this.options.baseArticle;
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "createArticleButton",
          level: Level.PRIMARY,
          onClick: () => this.createArticle({
            baseArticleId: baseArticle.id,
            markup: baseArticle.markup
          }),
          statusOptions: ["Add translation", {
            icon: "spinner fa-spin",
            label: " creating translation article ..."
          }, "Success", "Failed"]
        }))];
      }
    }
    class ArticleOwnerSpan extends UI$1.Primitive("span") {
      getArticle() {
        return this.options.article;
      }
      render() {
        return UI$1.createElement(UserHandle$1, {
          id: this.getArticle().userCreatedId
        });
      }
      onMount() {
        this.attachChangeListener(this.getArticle(), () => this.redraw());
      }
    }
    class ArticlePublicSpan extends FAIcon {
      getDefaultOptions() {
        return {
          size: "lg"
        };
      }
      getArticle() {
        return this.options.article;
      }
      isPublic() {
        return this.options.article.isPublic;
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("color", this.isPublic() ? "green" : "red");
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.icon = this.isPublic() ? "check" : "times";
      }
      onMount() {
        this.attachChangeListener(this.getArticle(), () => this.updateOptions({
          icon: this.isPublic() ? "check" : "times"
        }));
      }
    }
    class ArticleTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }
      resetColumnSortingOrder() {
        const {
          columns
        } = this.options;
        this.columnSortingOrder = [columns[4], columns[5], columns[0], columns[3], columns[2], columns[1]];
      }
      getArticleIndex(articleId) {
        for (let i = 0; i < this.options.articles.length; i += 1) {
          if (this.options.articles[i].id === articleId) return i;
        }
        return -1;
      }
      addArticle(article) {
        this.options.articles.push(article);
        this.redraw();
      }
      getDefaultColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let headerStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let columns = [{
          value: article => UI$1.createElement(Link, {
            href: "/article/" + article.id + "/edit/",
            value: article.name
          }),
          rawValue: article => article.name,
          headerName: "Article",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => UI$1.createElement(ArticleOwnerSpan, {
            article: article
          }),
          rawValue: article => PublicUserStore.get(article.userCreatedId).username,
          headerName: "Author",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => UI$1.createElement(ArticlePublicSpan, {
            article: article
          }),
          rawValue: article => article.isPublic ? "Yes" : "No",
          headerName: "Public",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => Language.get(article.languageId).name,
          rawValue: article => Language.get(article.languageId).name,
          headerName: "Language",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => StemDate.unix(article.dateCreated).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: article => article.dateCreated,
          sortDescending: true,
          headerName: "Date created",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => StemDate.unix(article.dateModified).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: article => article.dateModified,
          sortDescending: true,
          headerName: "Date modified",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }];
        if (!this.options.parent.options.readOnly) {
          if (USER.isSuperUser) {
            columns.push({
              value: article => UI$1.createElement(Button$1, {
                level: Level.PRIMARY,
                label: "Set owner",
                onClick: () => TransferOwnershipModal.show({
                  article
                })
              }),
              headerName: "Set owner",
              headerStyle: headerStyle,
              cellStyle: cellStyle
            });
          }
          columns.push({
            value: article => UI$1.createElement(Button$1, {
              level: Level.DANGER,
              label: "Delete",
              onClick: () => {
                DeleteArticleModal$1.show({
                  article,
                  parent: this.options.parent
                });
              }
            }),
            headerName: "Delete",
            headerStyle: headerStyle,
            cellStyle: cellStyle
          });
        }
        return columns;
      }
      getEntries() {
        return this.sortEntries(this.options.articles);
      }
    }
    class ArticleManager extends Panel {
      getDefaultOptions() {
        return {
          title: "Article manager",
          articles: []
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      setOptions(options) {
        options = Object.assign(this.getDefaultOptions(), options);
        super.setOptions(options);
      }
      render() {
        let addButton = null;
        if (!this.options.readOnly) {
          addButton = UI$1.createElement("div", {
            className: "pull-right"
          }, UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            label: "Create article",
            onClick: () => CreateArticleModal.show({
              parent: this
            }),
            style: {
              marginTop: "5px",
              marginBottom: "5px"
            }
          }));
        }
        this.options.articles = ArticleStore.all();
        return [UI$1.createElement("div", {
          className: "pull-left"
        }, UI$1.createElement("h4", null, UI$1.createElement("strong", null, this.options.title))), addButton, UI$1.createElement(ArticleTable, {
          ref: "table",
          articles: this.options.articles,
          parent: this
        })];
      }
    }
    class ArticleTranslationManager extends Panel {
      getDefaultOptions() {
        return {
          title: "Translation manager"
        };
      }
      setOptions(options) {
        options = Object.assign(this.getDefaultOptions(), options);
        super.setOptions(options);
      }
      render() {
        this.table = UI$1.createElement(ArticleTable, {
          articles: [],
          parent: this
        });
        let addButton = null;
        if (!this.options.readOnly) {
          addButton = UI$1.createElement("div", {
            className: "pull-right"
          }, UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            label: "Add translation",
            onClick: () => AddTranslationModal.show({
              parent: this,
              baseArticle: this.options.baseArticle
            }),
            style: {
              marginTop: "5px",
              marginBottom: "5px"
            }
          }));
        }
        return [UI$1.createElement("div", {
          className: "pull-left"
        }, UI$1.createElement("h4", null, UI$1.createElement("strong", null, this.options.title))), addButton, this.table];
      }
      onMount() {
        if (!this.options.baseArticle) {
          return;
        }
        Ajax.getJSON("/article/" + this.options.baseArticle.id + "/get_translations/", {}).then(() => {
          for (let article of ArticleStore.all()) {
            if (article.baseArticleId === this.options.baseArticle.id) {
              this.table.options.articles.push(article);
            }
          }
          this.table.redraw();
        });
      }
    }

    const deleteRedirectLink = "/";
    class ArticleMarkupEditor extends MarkupEditor {
      setOptions(options) {
        super.setOptions(options);
        this.options.value = this.options.article.markup;
      }
      getMarkupRenderer() {
        return UI$1.createElement(ArticleRenderer, {
          ref: this.refLink("markupRenderer"),
          article: this.options.article,
          style: {
            flex: "1",
            height: "100%",
            overflow: "auto"
          }
        });
      }
      updateValue(markup) {
        this.options.article.markup = markup;
        super.updateValue(markup);
      }
    }
    class DeleteArticleModal extends ActionModal {
      getActionName() {
        return "Delete Article";
      }
      getBody() {
        return UI$1.createElement("p", null, "Delete ", this.options.article.name, "?");
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "deleteArticleButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteArticle();
          },
          statusOptions: ["Delete article", {
            icon: "spinner fa-spin",
            label: " deleting article ..."
          }, "Delete article", "Failed"]
        }))];
      }
      deleteArticle() {
        this.deleteArticleButton.postJSON("/article/" + this.options.article.id + "/delete/", {}).then(() => {
          if (this.options.article.baseArticleId) window.location.replace("/article/" + this.options.article.baseArticleId + "/edit/");else window.location.replace(deleteRedirectLink);
        }, error => this.messageArea.showMessage(error.message, "red"));
      }
    }
    class ArticleEditor extends Panel {
      setOptions(options) {
        super.setOptions(options);
      }
      getArticle() {
        return ArticleStore.get(this.options.articleId);
      }
      initializeVersioning() {
        if (ArticleEditor.DiffWidgetClass) {
          this.versions = [];
          this.versionsLabels = [];
          for (let article of this.getArticle().getEdits()) {
            this.versions.push(article.content);
            this.versionsLabels.push("Version " + article.id);
          }
          this.versions.push(this.getArticle().markup);
          this.versionsLabels.push("Edit version");
          this.versions.reverse();
          this.versionsLabels.reverse();
          this.leftEditable = true;
          this.rightEditable = false;
        }
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          display: "flex",
          flexDirection: "column",
          height: "100%"
        });
      }
      render() {
        this.initializeVersioning();
        let translationsPanel = null;
        let baseArticleForm = null;
        if (this.getArticle().baseArticleId) {
          baseArticleForm = UI$1.createElement(FormField, {
            ref: "baseArticleFormField",
            label: "Base article"
          }, UI$1.createElement(Link, {
            href: "/article/" + this.getArticle().baseArticleId + "/edit/",
            value: "Go to base article"
          }));
        } else {
          translationsPanel = UI$1.createElement(Panel, {
            title: "Translations"
          }, UI$1.createElement(ArticleTranslationManager, {
            title: "Translations for " + this.getArticle().name,
            baseArticle: this.getArticle()
          }));
        }
        let ownershipPanel = null;
        if (USER.isSuperUser) {
          ownershipPanel = UI$1.createElement(Panel, {
            title: "Ownership"
          }, UI$1.createElement(Form, {
            style: {
              marginTop: "10px"
            }
          }, UI$1.createElement(FormField, {
            ref: "ownerFormField",
            label: "Author ID"
          }, UI$1.createElement(TextInput, {
            ref: "ownerFormInput",
            value: this.getArticle().userCreatedId
          }))), UI$1.createElement(AjaxButton, {
            ref: "setOwnerButton",
            level: Level.INFO,
            onClick: () => {
              let newOwner = this.ownerFormInput.getValue();
              this.setOwner(newOwner);
            },
            statusOptions: ["Transfer ownership", {
              icon: "spinner fa-spin",
              label: " transfering ownership ..."
            }, "Transfer ownership", "Failed"]
          }), UI$1.createElement(TemporaryMessageArea, {
            ref: "setOwnerMessageArea"
          }));
        }
        let revisionsPanel;
        if (ArticleEditor.DiffWidgetClass) {
          let DiffWidgetClass = ArticleEditor.DiffWidgetClass;
          revisionsPanel = UI$1.createElement(Panel, {
            title: "Revisions",
            style: {
              height: "100%",
              display: "flex",
              flexDirection: "column"
            }
          }, UI$1.createElement(Panel, null, UI$1.createElement(Select, {
            ref: "leftTextSelector",
            options: this.versionsLabels
          }), UI$1.createElement(Select, {
            style: {
              float: "right",
              marginRight: "25px"
            },
            ref: "rightTextSelector",
            options: this.versionsLabels
          })), UI$1.createElement(DiffWidgetClass, {
            ref: "diffWidget",
            leftEditable: this.leftEditable,
            rightEditable: this.rightEditable,
            leftTextValue: this.versions[2],
            arrows: this.arrows,
            rightTextValue: this.versions[1],
            style: {
              flex: "1",
              height: "calc(100% - 100px)",
              width: "calc(100% - 100px)"
            }
          }));
        }
        return [UI$1.createElement("h3", null, this.getArticle().name + " Id=" + this.options.articleId), UI$1.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true,
          style: {
            flex: "1",
            height: "100%",
            display: "flex",
            flexDirection: "column"
          }
        }, UI$1.createElement(Panel, {
          title: "Edit",
          active: true,
          style: {
            height: "100%",
            overflow: "hidden"
          }
        }, UI$1.createElement(AjaxButton, {
          style: {
            zIndex: 2,
            position: "relative"
          },
          ref: "saveMarkupButton",
          level: Level.INFO,
          onClick: () => {
            let content = this.markupEditor.getValue();
            this.saveMarkup(content);
          },
          statusOptions: ["Save", {
            icon: "spinner fa-spin",
            label: " saving ..."
          }, "Save", "Failed"]
        }), UI$1.createElement(TemporaryMessageArea, {
          ref: "saveMarkupMessageArea"
        }), UI$1.createElement(ArticleMarkupEditor, {
          style: {
            height: "100%",
            marginTop: "-31px",
            display: "flex",
            flexDirection: "column"
          },
          ref: "markupEditor",
          article: this.getArticle()
        })), revisionsPanel, UI$1.createElement(Panel, {
          title: "Summary"
        }, UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "articleNameFormField",
          label: "Article name"
        }, UI$1.createElement(TextInput, {
          ref: "articleNameFormInput",
          value: this.getArticle().name
        })), UI$1.createElement(FormField, {
          ref: "dependencyFormField",
          label: "Dependencies"
        }, UI$1.createElement(TextInput, {
          ref: "dependencyFormInput",
          value: this.getArticle().dependency
        })), baseArticleForm, UI$1.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI$1.createElement(Select, {
          ref: "languageSelect",
          options: Language.all(),
          selected: Language.get(this.getArticle().languageId)
        })), UI$1.createElement(FormField, {
          ref: "publicFormField",
          label: "Public"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "publicCheckbox",
          initialValue: this.getArticle().isPublic
        }))), UI$1.createElement(AjaxButton, {
          ref: "saveOptionsButton",
          level: Level.INFO,
          onClick: () => {
            let name = this.articleNameFormInput.getValue();
            let dependency = this.dependencyFormInput.getValue();
            let languageId = this.languageSelect.get().id;
            let isPublic = this.publicCheckbox.getValue();
            let options = {
              name: name,
              dependency: dependency,
              languageId: languageId,
              isPublic: isPublic
            };
            this.saveOptions(options);
          },
          statusOptions: ["Save", {
            icon: "spinner fa-spin",
            label: " saveing ..."
          }, "Save", "Failed"]
        }), UI$1.createElement(Button$1, {
          ref: "deleteArticleButton",
          level: Level.DANGER,
          label: "Delete article",
          style: {
            marginLeft: "3px"
          },
          onClick: () => this.deleteArticleModal.show()
        }), UI$1.createElement(TemporaryMessageArea, {
          ref: "saveOptionsMessageArea"
        })), translationsPanel, ownershipPanel)];
      }
      saveMarkup(content) {
        let request = {
          markup: content
        };
        this.saveMarkupMessageArea.showMessage("Saving...", "black", null);
        this.saveMarkupButton.postJSON("/article/" + this.options.articleId + "/edit/", request).then(() => {
          // Add a new version in the dropdown if the save is a success
          if (ArticleEditor.DiffWidgetClass) {
            this.addNewVersion(content);
          }
          this.saveMarkupMessageArea.showMessage("Saved article");
        }, error => this.saveMarkupMessageArea.showMessage("Error in saving the article: " + error.message, "red"));
      }
      saveOptions(options) {
        let request = {};
        Object.assign(request, options);
        this.saveOptionsMessageArea.showMessage("Saving...", "black", null);
        this.saveOptionsButton.postJSON("/article/" + this.options.articleId + "/edit/", request).then(() => window.location.replace("/article/" + this.options.articleId + "/edit/"), error => this.saveOptionsMessageArea.showMessage("Error in saving the article: " + error.message, "red"));
      }
      setOwner(newOwner) {
        this.setOwnerMessageArea.showMessage("Saving...", "black", null);
        this.setOwnerButton.postJSON("/article/" + this.options.articleId + "/set_owner/", {
          newOwner: newOwner
        }).then(() => this.setOwnerMessageArea.showMessage("Author successfully changed"), error => this.setOwnerMessageArea.showMessage("Error in changing owner " + error.message, "red"));
      }
      addNewVersion(content) {
        this.versionsLabels[0] = "Version " + this.versionsLabels.length;
        this.versions[0] = content;
        this.versions.unshift(this.markupEditor.getValue());
        this.versionsLabels.unshift("Edit version");
        let leftIndex = this.leftTextSelector.getIndex();
        let rightIndex = this.rightTextSelector.getIndex();
        this.leftTextSelector.redraw();
        this.rightTextSelector.redraw();
        this.setLeftIndex(leftIndex);
        this.setRightIndex(rightIndex);
      }
      setLeftIndex(index) {
        this.leftTextSelector.setIndex(index);
        this.diffWidget.setLeftText(this.versions[index]);
      }
      setRightIndex(index) {
        this.rightTextSelector.setIndex(index);
        this.diffWidget.setRightText(this.versions[index]);
      }
      onMount() {
        this.deleteArticleModal = UI$1.createElement(DeleteArticleModal, {
          article: this.getArticle()
        });
        if (ArticleEditor.DiffWidgetClass) {
          this.tabArea.titleArea.children[1].addClickListener(() => {
            this.versions[0] = this.markupEditor.getValue();
            this.setLeftIndex(this.leftTextSelector.getIndex());
            this.setRightIndex(this.rightTextSelector.getIndex());
            //this.diffWidget.diffGutterPanel.scroll();
          });
          let updateEditable = () => {
            this.leftEditable = this.leftTextSelector.getIndex() === 0;
            this.rightEditable = this.rightTextSelector.getIndex() === 0;
            this.diffWidget.setLeftEditable(this.leftEditable);
            this.diffWidget.setRightEditable(this.rightEditable);
          };
          this.leftTextSelector.addChangeListener(() => {
            this.diffWidget.setLeftText(this.versions[this.leftTextSelector.getIndex()]);
            updateEditable();
          });
          this.rightTextSelector.addChangeListener(() => {
            this.diffWidget.setRightText(this.versions[this.rightTextSelector.getIndex()]);
            updateEditable();
          });
          this.setLeftIndex(0);
          this.setRightIndex(1);

          //this.diffWidget.diffGutter.redraw();
        }
        window.onbeforeunload = () => {
          // Are you sure you want to close the page?
          return "";
        };
      }
    }

    class BlogEntryEditModal extends Modal {
      getModalWindowStyle() {
        return Object.assign({}, super.getModalWindowStyle(), {
          margin: "0 auto",
          maxHeight: "100%",
          overflow: "initial",
          display: "flex",
          flexDirection: "column",
          top: "1vh",
          height: "98vh"
        });
      }
      render() {
        let entry = BlogEntryStore.get(this.options.entryId);
        let article = entry.getArticle();
        let discussionButton = null;
        if (!entry.discussionId) {
          discussionButton = UI$1.createElement(Button$1, {
            level: Level.WARNING,
            label: "Create discussion",
            onClick: () => this.createDiscussion(),
            style: {
              marginLeft: "5px"
            }
          });
        }
        return [UI$1.createElement("h3", null, "Edit Entry"), UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          label: "Title"
        }, UI$1.createElement(TextInput, {
          ref: "titleInput",
          value: article.name
        })), UI$1.createElement(FormField, {
          label: "URL Name"
        }, UI$1.createElement(TextInput, {
          ref: "urlInput",
          value: entry.urlName
        })), UI$1.createElement(FormField, {
          label: "Visible"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "visibleCheckbox",
          initialValue: entry.visible
        })), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Change settings",
          onClick: () => this.changeSettings()
        }), discussionButton, UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        })), UI$1.createElement(ArticleEditor, {
          ref: "contentEditor",
          articleId: article.id,
          style: {
            flex: "1"
          }
        })];
      }
      changeSettings() {
        let title = this.titleInput.getValue();
        let urlName = this.urlInput.getValue();
        let request = {
          entryId: this.options.entryId,
          isVisible: this.visibleCheckbox.getValue()
        };
        if (title) {
          request.title = title;
        }
        if (urlName) {
          request.urlName = urlName;
        }
        Ajax.postJSON("/blog/change_entry_settings/", request).then(data => {
          if (data.urlName) {
            Router.changeURL(["blog", data.urlName]);
          }
          this.hide();
        });
      }
      createDiscussion() {
        let request = {
          entryId: this.options.entryId
        };
        Ajax.postJSON("/blog/create_entry_discussion/", request).then(() => this.hide());
      }
    }
    class NewBlogEntryModal extends Modal {
      render() {
        return [UI$1.createElement("h1", null, "New Entry"), UI$1.createElement(FormGroup, null, UI$1.createElement(FormField, {
          label: "Title"
        }, UI$1.createElement(TextInput, {
          ref: "titleInput"
        })), UI$1.createElement(FormField, {
          label: "URL Name"
        }, UI$1.createElement(TextInput, {
          ref: "urlInput"
        })), UI$1.createElement(FormField, {
          label: "Visible"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "visibleCheckbox"
        })), UI$1.createElement(Button$1, {
          label: "Add Entry",
          level: Level.PRIMARY,
          onClick: () => {
            this.addEntry();
          }
        }), UI$1.createElement(MarkupEditor, {
          ref: "postContentMarkup",
          style: {
            height: "450px"
          }
        }))];
      }
      onMount() {
        super.onMount();
        this.titleInput.addInputListener(() => {
          this.urlInput.setValue(slugify(this.titleInput.getValue()));
        });
      }
      addEntry() {
        let data = {};
        let title = this.titleInput.getValue();
        if (title) {
          data.title = title;
        }
        let urlName = this.urlInput.getValue();
        if (urlName) {
          data.urlName = urlName;
        }
        data.isVisible = this.visibleCheckbox.getValue();
        let content = this.postContentMarkup.getValue();
        if (content) {
          data.content = content;
        }
        Ajax.postJSON("/blog/add_entry/", data).then(data => {
          let blogEntry = BlogEntryStore.get(data.blogEntryId);
          Router.changeURL(["blog", blogEntry.urlName]);
          this.hide();
        });
      }
    }
    class BlogEntryPreview extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          position: "relative",
          maxHeight: "420px",
          marginTop: "45px",
          marginBottom: "45px"
        });
      }
      canOverwrite(obj) {
        return super.canOverwrite(obj) && this.options.entryId === obj.options.entryId;
      }
      getBlogEntry() {
        return BlogEntryStore.get(this.options.entryId);
      }
      getBlogArticle() {
        return this.getBlogEntry().getArticle();
      }
      getEntryURL() {
        return "/blog/" + this.getBlogEntry().urlName + "/";
      }
      render() {
        const {
          styleSheet
        } = this;
        const article = this.getBlogArticle();

        // TODO: not actually the published date
        let publishedDate = article.dateCreated;
        let publishedFormat = StemDate.unix(publishedDate).format("LL");
        let modifiedFormat;
        let articleInfoStyle = {
          color: "#777",
          fontSize: "1em",
          margin: "0",
          fontStyle: "italic"
        };
        if (article.dateModified > article.dateCreated) {
          modifiedFormat = UI$1.createElement("p", {
            style: articleInfoStyle
          }, UI$1.T("Last update on"), " ", StemDate.unix(article.dateModified).format("LL"), ".");
        }
        return [UI$1.createElement("div", {
          style: {
            height: "100%"
          }
        }, UI$1.createElement("div", {
          style: {
            boxShadow: "0px 0px 10px rgb(160, 162, 168)",
            "background-color": "#fff",
            "padding": "1% 4% 10px 4%",
            "margin": "0 auto",
            "width": "900px",
            "max-width": "100%",
            position: "relative"
          }
        }, UI$1.createElement("div", {
          style: styleSheet.writtenBy
        }, UI$1.T("Written by"), " ", UI$1.createElement(UserHandle$1, {
          userId: article.userCreatedId
        }), ", ", publishedFormat, ".", modifiedFormat), UI$1.createElement("div", {
          style: styleSheet.title
        }, UI$1.createElement(Link, {
          href: this.getEntryURL(),
          value: article.name,
          style: {
            "text-decoration": "none",
            "color": "inherit"
          }
        })), UI$1.createElement(BlogArticleRenderer, {
          article: article,
          style: styleSheet.blogArticleRenderer
        }), UI$1.createElement("div", {
          className: styleSheet.whiteOverlay
        }), UI$1.createElement(Link, {
          href: this.getEntryURL(),
          style: styleSheet.link,
          value: UI$1.T("Continue reading")
        })))];
      }
    }
    class BlogEntryView extends UI$1.Element {
      get pageTitle() {
        return this.getBlogArticle().name;
      }
      getBlogEntry() {
        return BlogEntryStore.get(this.options.entryId);
      }
      getBlogArticle() {
        return this.getBlogEntry().getArticle();
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.blogEntryView);
      }
      getComments() {
        let chatId = this.getBlogEntry().discussionId;
        if (!chatId) {
          return null;
        }
        return UI$1.createElement("div", {
          style: {
            marginBottom: "20px",
            marginTop: "20px"
          }
        }, UI$1.createElement(AsyncCommentThread, {
          chatId: chatId
        }));
      }
      render() {
        const article = this.getBlogArticle();
        const {
          styleSheet
        } = this;

        // TODO: not actually the published date
        let publishedDate = article.dateCreated;
        let publishedFormat = StemDate.unix(publishedDate).format("LL");
        let modifiedFormat;
        let articleInfoStyle = {
          margin: "3px",
          color: "#777",
          fontSize: "1em",
          fontStyle: "italic"
        };
        if (article.dateModified > article.dateCreated) {
          modifiedFormat = UI$1.createElement("p", {
            style: articleInfoStyle
          }, "Last update on ", StemDate.unix(article.dateModified).format("LL"), ".");
        }
        let blogEntryEditButton;
        // TODO: should use proper rights
        if (USER.isSuperUser) {
          blogEntryEditButton = UI$1.createElement(Button$1, {
            label: "Edit",
            onClick: () => {
              BlogEntryEditModal.show({
                entryId: this.getBlogEntry().id,
                fillScreen: true
              });
            }
          });
        }
        return [UI$1.createElement("div", {
          style: {
            "background-color": "#fff",
            "padding": "2% 5%",
            "box-shadow": "rgb(160, 160, 160) 0px 3px 15px"
          }
        }, blogEntryEditButton, UI$1.createElement("div", {
          style: styleSheet.writtenBy
        }, "Written by ", UI$1.createElement(UserHandle$1, {
          userId: article.userCreatedId
        }), " on ", publishedFormat, ".", modifiedFormat), UI$1.createElement("div", {
          style: styleSheet.title
        }, article.name), UI$1.createElement(BlogArticleRenderer, {
          style: styleSheet.article,
          article: article
        }), UI$1.createElement("div", {
          style: {
            "margin-top": "30px",
            "margin-bottom": "10px"
          }
        }, UI$1.createElement(Link, {
          href: "/blog/",
          style: styleSheet.link,
          value: "Back to the Main Blog"
        })), this.getComments()), UI$1.createElement("div", {
          className: styleSheet.bottomSection
        })];
      }
    }
    class BlogEntryList extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("paddingTop", "10px");
      }
      showNewBlogPostModal() {
        let modal = UI$1.createElement(NewBlogEntryModal, {
          fillScreen: true
        });
        modal.show();
      }
      render() {
        const {
          styleSheet
        } = this;
        let entries = [];
        let blogEntries = BlogEntryStore.all().sort((a, b) => {
          return b.getArticle().dateCreated - a.getArticle().dateCreated;
        });
        for (let entry of blogEntries) {
          entries.push(UI$1.createElement(BlogEntryPreview, {
            key: entry.id,
            entryId: entry.id
          }));
        }
        return [USER.isSuperUser ? UI$1.createElement(Button$1, {
          label: "New Entry",
          onClick: () => this.showNewBlogPostModal()
        }) : null, UI$1.createElement("div", {
          ref: "entriesList"
        }, entries), UI$1.createElement(Button$1, {
          label: this.options.finishedLoading ? UI$1.T("End of blog") : UI$1.T("Load More"),
          ref: "loadMoreButton",
          style: {
            margin: "0px auto",
            display: "block"
          },
          className: styleSheet.loadMoreButton,
          disabled: this.options.finishedLoading
        }), UI$1.createElement("div", {
          style: {
            height: "45px",
            width: "100%"
          }
        })];
      }
      onMount() {
        super.onMount();
        this.loadMoreButton.addClickListener(() => {
          if (!this.options.finishedLoading) {
            Ajax.getJSON("/blog/", {
              lastDate: Math.min.apply(null, BlogEntryStore.all().map(x => x.getArticle().dateCreated))
            }).then(data => {
              this.options.finishedLoading = data.finishedLoading;
              if (this.options.finishedLoading) {
                this.loadMoreButton.options.label = UI$1.T("No more posts");
                this.loadMoreButton.redraw();
                this.loadMoreButton.disable();
              }
              this.redraw();
            });
          }
        });
        this.attachCreateListener(BlogEntryStore, () => {
          this.redraw();
        });
      }
    }
    Theme.register(BlogEntryView, BlogStyle);
    Theme.register(BlogEntryPreview, BlogStyle);
    Theme.register(BlogEntryList, BlogStyle);
    class DelayedBlogEntryList extends StateDependentElement(BlogEntryList) {}
    class DelayedBlogEntryView extends StateDependentElement(BlogEntryView) {
      getBlogEntry() {
        return BlogEntryStore.getEntryForURL(this.options.entryURL);
      }
      get pageTitle() {
        if (this.getBlogEntry()) {
          return super.pageTitle;
        } else {
          return null;
        }
      }
      set pageTitle(value) {}
      onDelayedMount() {
        super.onDelayedMount();
        Router.updateURL();
      }
      getAjaxUrl() {
        return "/blog/get_blog_post/";
      }
      getAjaxRequest() {
        return {
          entryUrlName: this.options.entryURL
        };
      }
    }
    class BlogRoute extends Route {
      getSubroutes() {
        return [new Route("%s", options => {
          let entryURL = options.args[options.args.length - 1];
          let blogEntry = BlogEntryStore.getEntryForURL(entryURL);
          if (blogEntry) {
            return UI$1.createElement(BlogEntryView, {
              entryId: blogEntry.id
            });
          } else {
            return UI$1.createElement(DelayedBlogEntryView, {
              entryURL: entryURL
            });
          }
        })];
      }
      constructor(expr = "blog", options = {}) {
        options.title = options.title || "Blog";
        super(expr, DelayedBlogEntryList, [], options);
        this.subroutes = this.getSubroutes();
      }
    }

    class InlineBlogPreview extends UI$1.Element {
      render() {
        let entries = [];
        let blogEntries = BlogEntryStore.all().sort((a, b) => {
          return b.getArticle().dateCreated - a.getArticle().dateCreated;
        });
        for (let entry of blogEntries) {
          entries.push(UI$1.createElement(BlogEntryPreview, {
            key: entry.id,
            entryId: entry.id,
            urlPrefix: "/blog/",
            style: {
              marginBottom: "-20px !important"
            }
          }));
        }
        return entries;
      }
    }

    class UpcomingContestsPanel extends CardPanel {
      getTitle() {
        return UI$1.T("Upcoming Contests");
      }
      render() {
        const contests = ContestStore.all().filter(contest => !contest.systemGenerated && !contest.hasFinished() && !contest.isInfinite());
        let list = [];
        if (contests.length) {
          let startedContests = contests.filter(contest => contest.hasStarted());
          let futureContests = contests.filter(contest => !contest.hasStarted());
          startedContests = startedContests.sort((contest1, contest2) => {
            return -contest2.getEndTime() + contest1.getEndTime();
          });
          futureContests = futureContests.sort((contest1, contest2) => {
            return -contest2.getStartTime() + contest1.getStartTime();
          });
          list = startedContests.concat(futureContests).map(contest => UI$1.createElement("div", {
            style: {
              border: "2px  #ddd",
              borderRadius: "8px",
              textAlign: "center",
              margin: "1px"
            }
          }, UI$1.createElement("div", {
            style: {
              fontSize: "1.3em"
            }
          }, UI$1.createElement(Link, {
            href: "/contest/" + contest.name,
            value: contest.longName
          })), UI$1.createElement("div", {
            style: {
              fontSize: "1em",
              paddingTop: "8px"
            }
          }, contest.getFormattedStartTime()), UI$1.createElement("div", {
            style: {
              fontSize: "1em",
              paddingTop: "8px",
              fontWeight: "bold",
              fontStyle: "italic"
            }
          }, UI$1.createElement(ContestTimeCounter, {
            contest: contest
          }))));
        } else {
          list.push(UI$1.createElement("div", {
            style: {
              textAlign: "center"
            }
          }, UI$1.T("No upcoming contests.")));
        }
        return UI$1.createElement("div", {
          style: {
            padding: "8px"
          }
        }, list, UI$1.createElement("div", {
          style: {
            textAlign: "center",
            paddingTop: "8px"
          }
        }, UI$1.createElement(Link, {
          href: "/contests/",
          value: UI$1.T("See full contests list")
        })));
      }
    }

    class FrontPagePanel extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          margin: "0 auto",
          width: "90%",
          maxWidth: "1000px"
        });
      }
      renderInlineBlog() {
        const blogEntries = BlogEntryStore.all().sort((a, b) => {
          return b.getArticle().dateCreated - a.getArticle().dateCreated;
        });
        if (isSepi()) {
          return blogEntries.map(blogEntry => UI$1.createElement(BlogArticleRenderer, {
            article: blogEntry.getArticle()
          }));
        }
        return [UI$1.createElement("div", {
          ref: "leftPanelChild",
          style: {
            height: "50px",
            lineHeight: "50px",
            fontSize: "1.8em",
            marginBottom: "-30px",
            paddingLeft: "16px"
          }
        }, UI$1.T("Latest Blog Entries")), UI$1.createElement(InlineBlogPreview, {
          ref: "miniBlog"
        })];
      }
      render() {
        const panelStyle = width => ({
          width: width + "%",
          display: "inline-block",
          verticalAlign: "top",
          textAlign: "none",
          whiteSpace: "initial",
          padding: "0px 10px",
          marginBottom: "-70px"
        });
        const styleElements = UI$1.createElement(StyleElement, null, UI$1.createElement(StyleInstance, {
          selector: "#frontPage h1",
          attributes: {
            "font-size": "1.65em",
            "margin-top": "9px",
            "margin-bottom": "5px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: "#frontPage h2",
          attributes: {
            "font-size": "1.15em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: "#frontPage h3",
          attributes: {
            "font-size": "0.88em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: "#frontPage h4",
          attributes: {
            "font-size": "0.71em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: "#frontPage h5",
          attributes: {
            "font-size": "0.60em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".panel-body",
          attributes: {
            "padding": "5px"
          }
        }));
        if (!Device.isMobileDevice()) {
          return [UI$1.createElement("div", {
            ref: "leftPanel",
            style: panelStyle(76)
          }, this.renderInlineBlog()), UI$1.createElement("div", {
            ref: "rightPanel",
            style: Object.assign({}, panelStyle(23), {
              marginTop: "63.5px"
            })
          }, UI$1.createElement("div", {
            style: {
              marginBottom: "40px"
            }
          }, UI$1.createElement(UpcomingContestsPanel, {
            style: {
              "margin-bottom": "40px",
              marginTop: "30px"
            }
          }), !isSepi() && UI$1.createElement(HourlyContestsPanel, null)), !isSepi() && [UI$1.createElement(LeaderboardPanel, {
            ref: "leaderboard",
            style: {
              marginBottom: "40px"
            },
            bodyStyle: {
              padding: 0
            }
          }), UI$1.createElement(SendFeedbackPanel, {
            ref: "suggestionPanel",
            style: {
              marginBottom: "40px"
            }
          })]), styleElements];
        } else {
          return [UI$1.createElement("div", {
            ref: "leftPanel",
            style: panelStyle(76)
          }, UI$1.createElement("div", {
            style: {
              marginBottom: "40px"
            }
          }, UI$1.createElement(UpcomingContestsPanel, {
            style: {
              "margin-bottom": "40px",
              marginTop: "30px"
            }
          }))), UI$1.createElement("div", {
            ref: "rightPanel",
            style: Object.assign({}, panelStyle(23), {
              marginTop: "63.5px"
            })
          }, this.renderInlineBlog()), !isSepi() && UI$1.createElement("div", {
            style: Object.assign({}, panelStyle(100), {
              marginTop: "63.5px"
            })
          }, UI$1.createElement(LeaderboardPanel, {
            ref: "leaderboard",
            bodyStyle: {
              padding: 0
            }
          }), UI$1.createElement(HourlyContestsPanel, {
            style: {
              marginTop: "40px"
            }
          }), UI$1.createElement(SendFeedbackPanel, {
            ref: "suggestionPanel",
            style: {
              marginTop: "40px",
              marginBottom: "40px"
            }
          })), styleElements];
        }
      }
      recalculateDimensions() {
        let parentSize = this.getWidth();
        if (parentSize <= 900) {
          this.setStyle("white-space", "initial");
          this.rightPanel.setWidth("100%");
          this.leftPanel.setWidth("100%");
          return;
        }
        this.leftPanel.setWidth("76%");
        this.rightPanel.setWidth("23%");
        this.setStyle("white-space", "nowrap");
      }
      onMount() {
        setTimeout(() => {
          this.recalculateDimensions();
        }, 0);
        window.addEventListener("resize", () => {
          this.recalculateDimensions();
        });
        this.addListener("show", () => {
          this.recalculateDimensions();
        });
      }
    }

    class ProblemSetting extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("width", "60%");
        attr.setStyle("margin-left", "20%");
      }
      render() {
        return [UI$1.createElement("h1", {
          style: "margin-bottom: 20px;"
        }, "Problem setting"), UI$1.createElement("p", null, "We are looking for hard problems. Each Div. 1 + Div. 2 round consists of ", UI$1.createElement("strong", null, "7"), " tasks of varying difficulty. The first few are addressed to the casual competitors, while the last three are supposed to be more challenging. These last three problems (let's label them ", UI$1.createElement("strong", null, "1, 2, 3"), ", with ", UI$1.createElement("strong", null, "1"), " being the hardest) are what we are looking for."), UI$1.createElement("p", null, "You can check out previous Rounds", UI$1.createElement(Link, {
          value: "#4",
          href: "/contest/beta-round-4/"
        }), ",", UI$1.createElement(Link, {
          value: "#9",
          href: "/contest/round-9/"
        }), " and", UI$1.createElement(Link, {
          value: "#18",
          href: "/contest/round-18/"
        }), "to get an idea about the kind of tasks we consider suitable for future contests."), UI$1.createElement("p", null, "As the bottleneck of setting a contest usually consists of finding a suitable ", UI$1.createElement("strong", null, "1"), "(the hardest problem), we will accept the following proposals:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, UI$1.createElement("strong", null, "1"), ": 200$"), UI$1.createElement("li", null, UI$1.createElement("strong", null, "1 + 2"), ": 200$ + 125$ = 325$"), UI$1.createElement("li", null, UI$1.createElement("strong", null, "1 + 2 + 3"), ": 200$ + 125$ + 75$ = 400$")), UI$1.createElement("p", null, "The first step of becoming a problem setter consists in sending us an email at", UI$1.createElement("a", {
          href: "mailto:contact@csacademy.com"
        }, "contact@csacademy.com"), " consisting of:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, " Short problem statement. Leave out any unnecessary story details, as we will write the final draft. Our policy is to create minimalistic statements. "), UI$1.createElement("li", null, " Solution description (.txt, .pdf, .doc, .docx, etc.) ")), UI$1.createElement("p", null, "If we accept your proposal you will be required to further provide:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, " Official solution in C++ and/or Java. "), UI$1.createElement("li", null, " Tests. "), UI$1.createElement("li", null, " Checker (if it's the case). "), UI$1.createElement("li", null, " (Optional): Brute force, wrong greedy, or any other solution that shouldn't pass the test cases. ")), UI$1.createElement("p", null, "For any other questions contact us at ", UI$1.createElement("a", {
          href: "mailto:contact@csacademy.com"
        }, "contact@csacademy.com"), ".")];
      }
    }

    class Donate extends ScriptDelayedElement(UI$1.Element) {
      renderLoaded() {
        return UI$1.createElement("div", {
          style: {
            paddingTop: 48
          },
          ref: "blinkDonatePageContainer"
        }, UI$1.createElement("div", {
          ref: "blinkDonatePage"
        }));
      }
      renderNotLoaded() {
        return [StateDependentElement.renderLoading(), this.renderLoaded()];
      }
      setLoaded() {
        blink.createPanel(this.blinkDonatePage.node, blinkSDK.PANEL_TYPE.donationPage, {}, {
          onMount: () => super.setLoaded()
        });
      }
    }

    var _class$M, _descriptor$k, _class2$o, _descriptor2$j, _descriptor3$h, _descriptor4$f, _descriptor5$d;
    let LessonSectionPanelStyle = (_class$M = class LessonSectionPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "lessonSectionPanel", _descriptor$k, this);
      }
    }, (_descriptor$k = _applyDecoratedDescriptor(_class$M.prototype, "lessonSectionPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "800px",
          maxWidth: "80%",
          margin: "0 auto",
          marginBottom: "30px"
        };
      }
    })), _class$M);
    let LessonPanelStyle = (_class2$o = class LessonPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "articleRenderer", _descriptor2$j, this);
        _initializerDefineProperty(this, "className", _descriptor3$h, this);
        _initializerDefineProperty(this, "comments", _descriptor4$f, this);
        _initializerDefineProperty(this, "commentsContainer", _descriptor5$d, this);
      }
    }, (_descriptor2$j = _applyDecoratedDescriptor(_class2$o.prototype, "articleRenderer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "17px",
          textAlign: "justify",
          " h1": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h2": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h3": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h4": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h5": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h6": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          }
        };
      }
    }), _descriptor3$h = _applyDecoratedDescriptor(_class2$o.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#fff",
          boxShadow: "rgb(160, 160, 160) 0px 3px 15px",
          width: "900px",
          padding: "2% 5%",
          maxWidth: "100%",
          margin: "0 auto"
        };
      }
    }), _descriptor4$f = _applyDecoratedDescriptor(_class2$o.prototype, "comments", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxWidth: "100%"
        };
      }
    }), _descriptor5$d = _applyDecoratedDescriptor(_class2$o.prototype, "commentsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "20px",
          paddingBottom: "20px",
          paddingTop: "10px"
        };
      }
    })), _class2$o);

    var _dec$y, _class$L;
    let LessonSectionPanel = (_dec$y = registerStyle(LessonSectionPanelStyle), _dec$y(_class$L = class LessonSectionPanel extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.lessonSectionPanel);
      }
      getLessons() {
        return this.options.lessonSection.getLessons();
      }
      getLessonURL(urlName) {
        return "/lesson/" + urlName;
      }
      render() {
        let {
          title
        } = this.options;
        let lessons = this.getLessons();
        if (!USER.isSuperUser) {
          lessons = lessons.filter(lesson => lesson.visible);
        }

        // If there are no available lessons, don't show just the label to the regular users.
        if (lessons.length === 0 && !USER.isSuperUser) {
          return null;
        }
        return UI$1.createElement(CardPanel, {
          title: title,
          headingCentered: false,
          size: Size.LARGE
        }, UI$1.createElement(RowList, {
          rows: lessons,
          alternateColors: false,
          size: Size.LARGE,
          rowParser: (lesson, index) => {
            return UI$1.createElement(Link, {
              href: this.getLessonURL(lesson.urlName),
              value: lesson.name
            });
          }
        }));
      }
    }) || _class$L);
    class LessonList extends UI$1.Element {
      render() {
        let allLessonSections = LessonSectionStore.all();
        return allLessonSections.map(lessonSection => UI$1.createElement(LessonSectionPanel, {
          title: lessonSection.name,
          lessonSection: lessonSection
        }));
      }
    }

    var _dec$x, _class$K, _LessonPanel;
    class LessonEditModal extends Modal {
      getModalWindowStyle() {
        return Object.assign({}, super.getModalWindowStyle(), {
          margin: "0 auto",
          maxHeight: "100%",
          overflow: "initial",
          display: "flex",
          flexDirection: "column",
          top: "1vh",
          height: "98vh"
        });
      }
      render() {
        let lesson = this.options.lesson;
        let article = lesson.getArticle();
        let discussionButton = null;
        if (!lesson.discussionId) {
          discussionButton = UI$1.createElement(Button$1, {
            level: Level.WARNING,
            label: "Create discussion",
            onClick: () => this.createDiscussion(),
            style: {
              marginLeft: "5px"
            }
          });
        }
        return [UI$1.createElement("h1", null, "Edit Lesson"), UI$1.createElement("div", null, UI$1.createElement(FormField, {
          label: "Title"
        }, UI$1.createElement(TextInput, {
          ref: "titleInput",
          value: article.name
        })), UI$1.createElement(FormField, {
          label: "URL Name"
        }, UI$1.createElement(TextInput, {
          ref: "urlInput",
          value: lesson.urlName
        })), UI$1.createElement(FormField, {
          label: "Visible"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "visibleCheckbox",
          value: lesson.visible
        })), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Change settings",
          onClick: () => this.changeSettings()
        }), discussionButton, UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        })), UI$1.createElement(ArticleEditor, {
          ref: "contentEditor",
          articleId: article.id,
          style: {
            flex: "1"
          }
        })];
      }
      changeSettings() {
        let title = this.titleInput.getValue();
        let urlName = this.urlInput.getValue();
        let lesson = this.options.lesson;
        let request = {
          isVisible: this.visibleCheckbox.getValue()
        };
        if (title) {
          request.title = title;
        }
        if (urlName) {
          request.urlName = urlName;
        }
        Ajax.postJSON("/lesson/" + lesson.urlName + "/edit/", request);
      }
      createDiscussion() {
        let request = {};
        Ajax.postJSON("/lesson/" + this.options.lesson.urlName + "/create_discussion/", request).then(data => this.hide());
      }
    }
    let LessonPanel = (_dec$x = registerStyle(LessonPanelStyle), _dec$x(_class$K = (_LessonPanel = class LessonPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }
      render() {
        let lesson = LessonStore.all().find(lesson => lesson.urlName === Router.parseURL()[1]);
        let article = lesson.getArticle();
        let articleComments;
        if (lesson.discussionId) {
          articleComments = UI$1.createElement(AsyncCommentThread, {
            chatId: lesson.discussionId,
            className: this.styleSheet.comments
          });
        }
        let lessonEditButton;
        if (USER.isSuperUser) {
          lessonEditButton = UI$1.createElement(Button$1, {
            label: "Edit",
            onClick: () => {
              LessonEditModal.show({
                lesson: lesson,
                fillScreen: true
              });
            }
          });
        }
        return [lessonEditButton, UI$1.createElement(ArticleRenderer, {
          article: article,
          classMap: LessonPanel.LessonClassMap,
          liveLanguage: true,
          className: this.styleSheet.articleRenderer
        }), UI$1.createElement("div", {
          className: this.styleSheet.commentsContainer
        }, articleComments)];
      }
      onMount() {
        let previousBackgroundColor = document.body.style["backgroundColor"];
        document.body.style["backgroundColor"] = "#f3f4f6";
        this.addListener("urlEnter", () => {
          previousBackgroundColor = document.body.style["backgroundColor"];
          document.body.style["backgroundColor"] = "#f3f4f6";
        });
        this.addListener("urlExit", () => {
          document.body.style["backgroundColor"] = previousBackgroundColor;
        });
      }
    }, _LessonPanel.LessonClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["ContestTaskButton", ContestTaskButton]]), _LessonPanel)) || _class$K);

    class EditThreadReplyButton extends Button$1 {
      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI$1.T("Preview");
        }
        options.level = options.level || Level.PRIMARY;
        super.setOptions(options);
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }
          EditThreadReplyModal.show({
            messageInstance: this.options.messageInstance,
            classMap: ChatMarkupRenderer.classMap
          });
        });
      }
    }
    class EditThreadReplyModal extends MarkupEditorModal {
      onMount() {
        super.onMount();
        this.markupEditor.setValue(this.options.messageInstance.getContent());
        // this.markupEditor.codeEditor.getAce().focus();
        this.doneButton.addClickListener(() => {
          this.options.messageInstance.edit(this.markupEditor.getValue());
        });
      }
    }

    class DeleteThreadReplyModal extends ActionModal {
      getTitle() {
        return UI$1.T("Delete message");
      }
      getActionName() {
        return UI$1.T("Delete");
      }
      getBody() {
        return UI$1.createElement("p", null, UI$1.T("Are you sure you want to delete the message?"));
      }
      action() {
        this.options.messageInstance.deleteMessage();
        this.hide();
      }
    }
    let DeleteThreadReplyButton = ActionModalButton(DeleteThreadReplyModal);

    var _class$J, _descriptor$j, _descriptor2$i, _descriptor3$g, _descriptor4$e, _descriptor5$c, _class2$n, _descriptor6$a, _descriptor7$6, _descriptor8$6, _descriptor9$5, _descriptor10$4, _descriptor11$4, _descriptor12$3, _descriptor13$3, _descriptor14$3, _descriptor15$2, _descriptor16$2, _descriptor17$2, _descriptor18$1, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _class3$a, _descriptor25, _class4$5, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _class5$2, _descriptor33, _class6$1, _descriptor34, _descriptor35, _descriptor36, _descriptor37, _descriptor38, _descriptor39, _descriptor40, _descriptor41, _descriptor42, _descriptor43, _descriptor44, _descriptor45, _descriptor46, _descriptor47, _class7$1, _descriptor48, _descriptor49, _descriptor50, _descriptor51, _descriptor52;
    const colors = {
      // BLUE: "#20232d",
      BLUE: "#202e3e",
      HOVER_BLUE: "#364251",
      // BLACK: "#181a22",
      BLACK: "#1c2937",
      // HOVER_BLACK: "#323539",
      HOVER_BLACK: "#364251",
      WHITE: "#eee"
    };
    (_class$J = class ForumThreadReplyStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "mainClass", _descriptor$j, this);
        _initializerDefineProperty(this, "repliesUserAndDate", _descriptor2$i, this);
        _initializerDefineProperty(this, "repliesUser", _descriptor3$g, this);
        _initializerDefineProperty(this, "repliesDate", _descriptor4$e, this);
        _initializerDefineProperty(this, "repliesContent", _descriptor5$c, this);
      }
    }, (_descriptor$j = _applyDecoratedDescriptor(_class$J.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          margin: "0 auto",
          maxWidth: "1200px"
        };
      }
    }), _descriptor2$i = _applyDecoratedDescriptor(_class$J.prototype, "repliesUserAndDate", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          lineHeight: "40px",
          fontSize: "15px",
          marginTop: "8px",
          marginBottom: "8px"
        };
      }
    }), _descriptor3$g = _applyDecoratedDescriptor(_class$J.prototype, "repliesUser", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          color: "#444",
          fontSize: "14px"
        };
      }
    }), _descriptor4$e = _applyDecoratedDescriptor(_class$J.prototype, "repliesDate", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right"
        };
      }
    }), _descriptor5$c = _applyDecoratedDescriptor(_class$J.prototype, "repliesContent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "15px",
          fontSize: "16px"
        };
      }
    })), _class$J);
    let ForumThreadPanelStyle = (_class2$n = class ForumThreadPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.fontSize = "0.9em";
        this.numRepliesFontSize = "1.03em";
        this.messageFontSize = "1.2em";
        this.buttonFontSize = "1em";
        _initializerDefineProperty(this, "mainClass", _descriptor6$a, this);
        _initializerDefineProperty(this, "title", _descriptor7$6, this);
        _initializerDefineProperty(this, "backButton", _descriptor8$6, this);
        _initializerDefineProperty(this, "replyButtonDiv", _descriptor9$5, this);
        _initializerDefineProperty(this, "replyButton", _descriptor10$4, this);
        _initializerDefineProperty(this, "fullPost", _descriptor11$4, this);
        _initializerDefineProperty(this, "dislikeButton", _descriptor12$3, this);
        _initializerDefineProperty(this, "likeButton", _descriptor13$3, this);
        _initializerDefineProperty(this, "author", _descriptor14$3, this);
        _initializerDefineProperty(this, "header", _descriptor15$2, this);
        _initializerDefineProperty(this, "message", _descriptor16$2, this);
        _initializerDefineProperty(this, "buttons", _descriptor17$2, this);
        _initializerDefineProperty(this, "bottomPanel", _descriptor18$1, this);
        _initializerDefineProperty(this, "voting", _descriptor19, this);
        _initializerDefineProperty(this, "numReplies", _descriptor20, this);
        _initializerDefineProperty(this, "replies", _descriptor21, this);
        _initializerDefineProperty(this, "editDeleteButtons", _descriptor22, this);
        _initializerDefineProperty(this, "editButton", _descriptor23, this);
        _initializerDefineProperty(this, "deleteButton", _descriptor24, this);
      }
    }, (_descriptor6$a = _applyDecoratedDescriptor(_class2$n.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0 auto",
          marginBottom: "20px",
          width: "100%"
        };
      }
    }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$n.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          margin: "0 auto",
          fontSize: "2em",
          color: "#333",
          minHeight: "50px",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$n.prototype, "backButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#444",
          fontSize: this.fontsize,
          textDecoration: "none",
          transition: ".15s",
          opacity: "1",
          ":hover": {
            opacity: "1",
            color: "#337ab7",
            transition: ".15s"
          }
        };
      }
    }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$n.prototype, "replyButtonDiv", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          height: "50px",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          margin: "0 auto"
        };
      }
    }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$n.prototype, "replyButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0"
        };
      }
    }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$n.prototype, "fullPost", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          margin: "0 auto",
          fontSize: this.fontSize,
          border: "1px solid #ddd",
          borderTop: "0"
        };
      }
    }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$n.prototype, "dislikeButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          marginRight: "16px"
        };
      }
    }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$n.prototype, "likeButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          marginRight: "8px"
        };
      }
    }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$n.prototype, "author", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#262626",
          fontSize: this.fontSize,
          height: "50px",
          display: "flex",
          alignItems: "center",
          paddingLeft: "0",
          // justifyContent: "center",
          textTransform: "uppercase"
          // fontWeight: "bold",
        };
      }
    }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$n.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$n.prototype, "message", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "5px 12px",
          fontSize: this.messageFontSize,
          color: colors.BLUE,
          " p": {
            marginBottom: "0",
            padding: "5px 0"
          }
        };
      }
    }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$n.prototype, "buttons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50px",
          width: "100%",
          paddingTop: "12px"
        };
      }
    }), _descriptor18$1 = _applyDecoratedDescriptor(_class2$n.prototype, "bottomPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50px",
          width: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between"
        };
      }
    }), _descriptor19 = _applyDecoratedDescriptor(_class2$n.prototype, "voting", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingRight: "12px"
        };
      }
    }), _descriptor20 = _applyDecoratedDescriptor(_class2$n.prototype, "numReplies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50px",
          fontSize: this.numRepliesFontSize,
          paddingLeft: "12px",
          color: "#767676",
          display: "flex",
          alignItems: "center",
          fontWeight: "bold",
          textTransform: "uppercase"
        };
      }
    }), _descriptor21 = _applyDecoratedDescriptor(_class2$n.prototype, "replies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          color: "#444"
        };
      }
    }), _descriptor22 = _applyDecoratedDescriptor(_class2$n.prototype, "editDeleteButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: "50px",
          padding: "0 7px",
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-start"
        };
      }
    }), _descriptor23 = _applyDecoratedDescriptor(_class2$n.prototype, "editButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "35px",
          width: "35px",
          margin: "0 4px",
          border: "0",
          borderRadius: "0",
          color: "#fff",
          backgroundColor: "#333",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: this.buttonFontSize,
          transition: ".2s",
          ":hover": {
            backgroundColor: "#454545",
            transition: ".2s"
          }
        };
      }
    }), _descriptor24 = _applyDecoratedDescriptor(_class2$n.prototype, "deleteButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "35px",
          width: "35px",
          margin: "0 4px",
          border: "0",
          borderRadius: "0",
          color: "#fff",
          backgroundColor: "#333",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: this.buttonFontSize,
          transition: ".2s",
          ":hover": {
            backgroundColor: "#454545",
            transition: ".2s"
          }
        };
      }
    })), _class2$n);
    let ForumButtonStyle = (_class3$a = class ForumButtonStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "button", _descriptor25, this);
      }
    }, (_descriptor25 = _applyDecoratedDescriptor(_class3$a.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "16px",
          color: "#fff",
          height: "30px",
          marginTop: "10px",
          width: "auto",
          borderRadius: "0px",
          backgroundColor: colors.BLUE,
          border: "0",
          padding: "5px 10px",
          marginBottom: "0",
          borderColor: colors.BLUE,
          fontSize: "13px",
          transition: ".2s",
          outline: "none",
          ":hover": {
            backgroundColor: colors.HOVER_BLUE,
            borderColor: colors.HOVER_BLUE,
            transition: ".2s"
          },
          ":active": {
            backgroundColor: colors.HOVER_BLUE,
            borderColor: colors.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: colors.HOVER_BLUE,
            borderColor: colors.HOVER_BLUE,
            transition: ".2s"
          }
        };
      }
    })), _class3$a);
    let ForumThreadHeaderStyle = (_class4$5 = class ForumThreadHeaderStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        this.fontSize = "0.85em";
        this.widthLimit = 800;
        this.tagsHeight = 50;
        // borderTopColor = "rgb(232, 189, 35)";
        this.borderTopColor = "#333";
        this.baseStyleObject = {
          height: this.tagsHeight + "px",
          // display: "inline-block",
          // float: "left",
          color: "#262626",
          // letterSpacing: "-0.3px",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          textTransform: "uppercase",
          fontWeight: "bold"
        };
        _initializerDefineProperty(this, "mainClass", _descriptor26, this);
        _initializerDefineProperty(this, "tagsTitle", _descriptor27, this);
        _initializerDefineProperty(this, "tagsAuthor", _descriptor28, this);
        _initializerDefineProperty(this, "tagsReplies", _descriptor29, this);
        _initializerDefineProperty(this, "tagsViews", _descriptor30, this);
        _initializerDefineProperty(this, "tagsVotes", _descriptor31, this);
        _initializerDefineProperty(this, "tagsActivity", _descriptor32, this);
      }
    }, (_descriptor26 = _applyDecoratedDescriptor(_class4$5.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "1200px",
          marginLeft: "auto",
          marginRight: "auto",
          // borderBottom: "2px solid #333",// + this.borderTopColor,
          color: "#aaa",
          display: "flex",
          boxSizing: "content-box",
          backgroundColor: "#eaeaea",
          height: this.tagsHeight,
          borderTop: "3px solid " + this.borderTopColor
        };
      }
    }), _descriptor27 = _applyDecoratedDescriptor(_class4$5.prototype, "tagsTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // marginLeft: "1%",
          // width: "40%",
          paddingLeft: "12px",
          flex: () => {
            if (window.innerWidth < this.widthLimit) {
              return "1.5";
            }
            return "3";
          },
          justifyContent: "initial",
          fontSize: this.fontSize
        }];
      }
    }), _descriptor28 = _applyDecoratedDescriptor(_class4$5.prototype, "tagsAuthor", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "14%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".7",
          textAlign: "center",
          fontSize: this.fontSize
        }];
      }
    }), _descriptor29 = _applyDecoratedDescriptor(_class4$5.prototype, "tagsReplies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize
        }];
      }
    }), _descriptor30 = _applyDecoratedDescriptor(_class4$5.prototype, "tagsViews", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize,
          display: () => {
            console.log(window.innerWidth);
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }
            return "inherit";
          }
        }];
      }
    }), _descriptor31 = _applyDecoratedDescriptor(_class4$5.prototype, "tagsVotes", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize,
          display: () => {
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }
            return "inherit";
          }
        }];
      }
    }), _descriptor32 = _applyDecoratedDescriptor(_class4$5.prototype, "tagsActivity", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "20%",
          paddingLeft: "4px",
          paddingRight: "12px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize
        }];
      }
    })), _class4$5);
    let ForumThreadPreviewStyle = (_class5$2 = class ForumThreadPreviewStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        // functionality
        this.maxHeight = 50;
        this.lines = 2;
        this.lineHeight = this.maxHeight / this.lines;
        // design
        this.fontSize = ".88em";
        this.color = "#aaa";
        _initializerDefineProperty(this, "forumThreadPreview", _descriptor33, this);
      }
    }, (_descriptor33 = _applyDecoratedDescriptor(_class5$2.prototype, "forumThreadPreview", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxHeight: this.maxHeight + "px",
          lineHeight: this.lineHeight + "px",
          overflow: "hidden",
          fontSize: this.fontSize,
          color: this.color,
          " *": {
            marginBottom: "0"
          }
        };
      }
    })), _class5$2);
    let ForumThreadBubbleStyle = (_class6$1 = class ForumThreadBubbleStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        this.fontSize = "1em";
        this.titlePaddingBottom = "10px";
        this.widthLimit = 800;
        this.baseStyleObject = {
          display: "inline-block",
          verticalAlign: "top",
          fontSize: this.fontSize
        };
        _initializerDefineProperty(this, "backgroundColorOddInstances", _descriptor34, this);
        _initializerDefineProperty(this, "backgroundColorPinnedInstances", _descriptor35, this);
        _initializerDefineProperty(this, "backgroundColorEvenInstances", _descriptor36, this);
        _initializerDefineProperty(this, "mainClass", _descriptor37, this);
        _initializerDefineProperty(this, "threadTitleAndPreview", _descriptor38, this);
        _initializerDefineProperty(this, "threadTitle", _descriptor39, this);
        _initializerDefineProperty(this, "pinnedIcon", _descriptor40, this);
        _initializerDefineProperty(this, "threadTitleSpan", _descriptor41, this);
        _initializerDefineProperty(this, "threadAuthor", _descriptor42, this);
        _initializerDefineProperty(this, "threadReplies", _descriptor43, this);
        _initializerDefineProperty(this, "threadRepliesSpan", _descriptor44, this);
        _initializerDefineProperty(this, "threadViews", _descriptor45, this);
        _initializerDefineProperty(this, "threadVotes", _descriptor46, this);
        _initializerDefineProperty(this, "threadActivity", _descriptor47, this);
      }
    }, (_descriptor34 = _applyDecoratedDescriptor(_class6$1.prototype, "backgroundColorOddInstances", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#f4f6f7",
          ":hover": {
            backgroundColor: "#eff1f2"
          }
        };
      }
    }), _descriptor35 = _applyDecoratedDescriptor(_class6$1.prototype, "backgroundColorPinnedInstances", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#f4f6f7",
          ":hover": {
            backgroundColor: "#eff1f2"
          }
        };
      }
    }), _descriptor36 = _applyDecoratedDescriptor(_class6$1.prototype, "backgroundColorEvenInstances", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#fff",
          ":hover": {
            backgroundColor: "#fafafa"
          }
        };
      }
    }), _descriptor37 = _applyDecoratedDescriptor(_class6$1.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "1200px",
          marginLeft: "auto",
          marginRight: "auto",
          color: "#555",
          border: "1px solid #ddd",
          borderTop: "0",
          display: "flex"
        };
      }
    }), _descriptor38 = _applyDecoratedDescriptor(_class6$1.prototype, "threadTitleAndPreview", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flexDirection: "column",
          flex: () => {
            if (window.innerWidth < this.widthLimit) {
              return "1.5";
            }
            return "3";
          },
          paddingTop: "25px",
          paddingBottom: "25px",
          paddingLeft: "12px"
        };
      }
    }), _descriptor39 = _applyDecoratedDescriptor(_class6$1.prototype, "threadTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "40%",
          // maxWidth: "50%",
          // flex: "1.5",
          flexDirection: "column",
          textAlign: "justify",
          // paddingRight: "8px",
          verticalAlign: "middle",
          wordWrap: "break-word",
          color: "#252628",
          paddingBottom: this.titlePaddingBottom
        }];
      }
    }), _descriptor40 = _applyDecoratedDescriptor(_class6$1.prototype, "pinnedIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          display: "inline-block",
          float: "left",
          height: "60px",
          paddingTop: "25px",
          paddingRight: "12px"
        };
      }
    }), _descriptor41 = _applyDecoratedDescriptor(_class6$1.prototype, "threadTitleSpan", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          verticalAlign: "middle",
          lineHeight: "20px",
          // maxWidth: "95%",
          transition: "0.2s",
          fontSize: "1.2em",
          ":hover": {
            color: "#337ab7",
            transition: "0.2s"
          }
        };
      }
    }), _descriptor42 = _applyDecoratedDescriptor(_class6$1.prototype, "threadAuthor", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "14%",
          // maxWidth: "14%",
          flex: ".7",
          // paddingLeft: "8px",
          textAlign: "center",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px"
        }];
      }
    }), _descriptor43 = _applyDecoratedDescriptor(_class6$1.prototype, "threadReplies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          flex: ".5",
          textAlign: "center",
          fontWeight: "bold",
          color: "#767676",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px"
        }];
      }
    }), _descriptor44 = _applyDecoratedDescriptor(_class6$1.prototype, "threadRepliesSpan", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "0.2s",
          ":hover": {
            color: "#337ab7",
            transition: "0.2s"
          }
        };
      }
    }), _descriptor45 = _applyDecoratedDescriptor(_class6$1.prototype, "threadViews", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          flex: ".5",
          textAlign: "center",
          color: "#767676",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px",
          display: () => {
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }
            return "inherit";
          }
        }];
      }
    }), _descriptor46 = _applyDecoratedDescriptor(_class6$1.prototype, "threadVotes", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          flex: ".5",
          textAlign: "center",
          color: "#767676",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px",
          display: () => {
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }
            return "inherit";
          }
        }];
      }
    }), _descriptor47 = _applyDecoratedDescriptor(_class6$1.prototype, "threadActivity", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "20%",
          flex: ".5",
          textAlign: "center",
          color: "#767676",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "12px",
          fontSize: ".85em"
        }];
      }
    })), _class6$1);
    let ForumPanelStyle = (_class7$1 = class ForumPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.textColor = "#333";
        this.headerItemHeight = 50;
        _initializerDefineProperty(this, "mainClass", _descriptor48, this);
        _initializerDefineProperty(this, "title", _descriptor49, this);
        _initializerDefineProperty(this, "buttonParent", _descriptor50, this);
        _initializerDefineProperty(this, "button", _descriptor51, this);
        _initializerDefineProperty(this, "header", _descriptor52, this);
      }
    }, (_descriptor48 = _applyDecoratedDescriptor(_class7$1.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor49 = _applyDecoratedDescriptor(_class7$1.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          // textAlign: "center",
          fontSize: "2em",
          color: this.textColor,
          height: this.headerItemHeight + "px",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor50 = _applyDecoratedDescriptor(_class7$1.prototype, "buttonParent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          margin: "0 auto",
          height: this.headerItemHeight + "px",
          display: "flex",
          justifyContent: "flex-end",
          alignItems: "center"
        };
      }
    }), _descriptor51 = _applyDecoratedDescriptor(_class7$1.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0"
        };
      }
    }), _descriptor52 = _applyDecoratedDescriptor(_class7$1.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 2 * this.headerItemHeight + "px",
          width: "100%"
        };
      }
    })), _class7$1);

    var _dec$w, _class$I;
    let CreateThreadReplyButton = (_dec$w = registerStyle(ForumButtonStyle), _dec$w(_class$I = class CreateThreadReplyButton extends Button$1 {
      getDefaultOptions() {
        return {
          level: Level.PRIMARY,
          size: Size.LARGE,
          label: UI$1.T("Preview")
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.button);
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }
          if (!this.markupEditorModal) {
            this.markupEditorModal = UI$1.createElement(CreateThreadReplyModal, {
              forumThreadId: this.options.forumThreadId,
              classMap: ChatMarkupRenderer.classMap
            });
          }
          this.markupEditorModal.show();
        });
      }
    }) || _class$I);
    class CreateThreadReplyModal extends MarkupEditorModal {
      onMount() {
        super.onMount();
        this.doneButton.addClickListener(() => {
          this.createThreadReply();
        });
      }
      createThreadReply() {
        // TODO: should be a dispatch: it should jump and highlight your post
        Ajax.postJSON("/forum/forum_thread_post/", {
          forumThreadId: this.options.forumThreadId,
          message: this.markupEditor.getValue()
        });
      }
    }

    var _dec$v, _class$H, _dec2$a, _class2$m;
    let forumThreadPanelStyle = ForumThreadPanelStyle.getInstance();
    ForumButtonStyle.getInstance(); // To ensure css importance order

    class CreateForumThreadModal extends MarkupEditorModal {
      render() {
        let inputStyle = {
          "margin-bottom": "4px",
          "border": "0",
          //"border-radius": "4px",
          //"border": "2px solid #dcdcdc",
          "outline": "none",
          "color": "#333",
          "font-size": "14px",
          "padding-left": "8px",
          "width": "100%",
          "text-align": "center",
          "font-weight": "bold"
        };
        return [UI$1.createElement(Input, {
          label: UI$1.T("Title"),
          ref: "titleInput",
          style: inputStyle,
          placeholder: "Click here to edit the title (max. 160 characters)."
        }), ...super.render()];
      }
      onMount() {
        this.doneButton.addClickListener(() => {
          this.createForumThread();
        });
      }
      routeToThread(forumThreadId) {
        // TODO: add the temp forum title
        Router.changeURL(["forum", forumThreadId, "title"]);
      }
      createForumThread() {
        let request = {
          forumId: this.options.forumId,
          title: this.titleInput.getValue(),
          message: this.markupEditor.getValue()
        };
        Ajax.postJSON("/forum/create_forum_thread/", request).then(data => {
          this.routeToThread(data.forumThreadId);
          this.titleInput.setValue("");
          this.markupEditor.setValue("");
          this.markupEditor.redraw();
          this.hide();
        });
      }
    }
    let CreateForumThreadButton = (_dec$v = registerStyle(ForumButtonStyle), _dec$v(_class$H = class CreateForumThreadButton extends Button$1 {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.button);
      }
      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI$1.T("Preview");
        }
        options.level = options.level || Level.PRIMARY;
        options.size = options.size || Size.LARGE;
        super.setOptions(options);
      }
      getModalClass() {
        return CreateForumThreadModal;
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }
          this.getModalClass().show({
            forumId: this.options.forumId,
            classMap: ChatMarkupRenderer.classMap
          });
        });
      }
    }) || _class$H);
    class DeleteForumThreadModal extends ActionModal {
      getTitle() {
        return UI$1.T("Delete forum thread");
      }
      getActionName() {
        return UI$1.T("Delete");
      }
      getBody() {
        return UI$1.createElement("p", null, UI$1.T("Are you sure you want to delete thread"), " \"" + this.options.forumThread.title + "\"?");
      }
      action() {
        this.options.forumThread.deleteThread();
        this.hide();
      }
    }
    let DeleteForumThreadButton = ActionModalButton(DeleteForumThreadModal);
    class ForumThreadReply extends UI$1.Element {
      extraNodeAttributes(attr) {
        // attr.addClass(forumThreadReplyStyle.mainClass);
      }
      getMessageInstance() {
        return this.options.messageInstance;
      }
      render() {
        let messageInstance = this.getMessageInstance();
        let deleteMessage;
        let editMessage;
        let editAndDeleteButtons = UI$1.createElement("span", null);
        if (USER.isSuperUser || USER.id === messageInstance.userId) {
          deleteMessage = UI$1.createElement(DeleteThreadReplyButton, {
            icon: "trash",
            level: Level.DANGER,
            className: forumThreadPanelStyle.deleteButton,
            modalOptions: {
              messageInstance: messageInstance
            }
          });
          editMessage = UI$1.createElement(EditThreadReplyButton, {
            icon: "pencil",
            level: Level.INFO,
            messageInstance: messageInstance,
            forumThreadPanel: this,
            className: forumThreadPanelStyle.editButton
          });
          editAndDeleteButtons = UI$1.createElement("div", {
            className: forumThreadPanelStyle.editDeleteButtons,
            style: {
              width: "auto"
            }
          }, editMessage, deleteMessage);
        }
        return [UI$1.createElement("div", {
          className: forumThreadPanelStyle.fullPost
        }, UI$1.createElement("div", {
          className: forumThreadPanelStyle.author,
          style: {
            fontSize: "1em",
            paddingLeft: "12px",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center"
          }
        }, UI$1.createElement(UserHandle$1, {
          id: messageInstance.userId,
          style: {
            textTransform: "initial",
            fontSize: "1.1em"
          }
        }), UI$1.createElement(TimePassedSpan, {
          timeStamp: messageInstance.getDate(),
          style: {
            color: "#262626 !important",
            paddingRight: "12px"
          }
        })), UI$1.createElement(ChatMarkupRenderer, {
          ref: this.refLink("postContent" + messageInstance.id),
          value: messageInstance.getContent(),
          className: forumThreadPanelStyle.message
        }), UI$1.createElement("div", {
          className: forumThreadPanelStyle.bottomPanel
        }, editAndDeleteButtons, UI$1.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          balanceColor: "#313534",
          notVoteColor: "#313534",
          message: messageInstance,
          className: forumThreadPanelStyle.voting
        })))];
      }
      onMount() {
        this.attachEventListener(this.getMessageInstance(), "messageDelete", () => {
          this.hide();
        });
        this.attachEventListener(this.getMessageInstance(), "messageEdit", () => {
          this.redraw();
        });
      }
    }
    let ForumThreadPanel = (_dec2$a = registerStyle(ForumThreadPanelStyle), _dec2$a(_class2$m = class ForumThreadPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.mainClass);
      }
      returnToMainForum() {
        Router.changeURL(this.getMainForumURL());
      }
      getMainForumURL() {
        return "/forum/";
      }
      getForumThreadState(callback = NOOP_FUNCTION) {
        let request = {
          forumThreadId: this.options.forumThread.id
        };
        Ajax.postJSON("/forum/forum_thread_state/", request).then(callback, error => {
          this.returnToMainForum();
          ErrorHandlers.showErrorAlert(error);
        });
      }
      getForumThread() {
        return this.options.forumThread;
      }
      getTitle() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.title
        }, UI$1.createElement(Link, {
          href: this.getMainForumURL(),
          className: this.styleSheet.backButton,
          value: UI$1.createElement("span", {
            className: "fa fa-arrow-left",
            style: {
              paddingRight: "10px",
              fontSize: ".8em",
              color: "#333"
            }
          })
        }), this.getForumThread().getTitle())];
      }
      getAuthor() {
        return UI$1.createElement("div", {
          className: this.styleSheet.author
        }, UI$1.T("written by"), "\xA0", UI$1.createElement(UserHandle$1, {
          id: this.getForumThread().authorId,
          style: {
            textTransform: "initial"
          }
        }), "\xA0", UI$1.createElement(TimePassedSpan, {
          timeStamp: this.getForumThread().getTimeAdded(),
          style: {
            color: "#262626 !important"
          }
        }));
      }
      getMessage() {
        return UI$1.createElement("div", {
          className: this.styleSheet.message
        }, UI$1.createElement(ChatMarkupRenderer, {
          ref: this.refLink("content"),
          value: this.getForumThread().getContentMessage().getContent(),
          style: {
            height: "auto"
          }
        }));
      }
      getNumReplies(postsLength) {
        return [UI$1.createElement("div", {
          className: this.styleSheet.numReplies
        }, UI$1.createElement("span", {
          style: {
            "font-weight": "bold"
          }
        }, postsLength), "\xA0", "replies in this thread" + (postsLength == 0 ? ", be the first one to comment" : ""))];
      }
      getVoting() {
        return UI$1.createElement("div", {
          className: this.styleSheet.voting
        }, UI$1.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          balanceColor: "#313534",
          notVoteColor: "#313534",
          message: this.getForumThread().getContentMessage(),
          style: {
            "margin-left": "0"
          }
        }));
      }
      render() {
        if (!this.options.forumThread.isLoaded()) {
          this.getForumThreadState(() => {
            this.redraw();
            this.initializeListeners();
          });
          return UI$1.createElement(ConcentricCirclesLoadingScreen, null);
        }
        let replies = [];
        let spaceBetween;
        let forumThread = this.options.forumThread;

        // sort the forum replies by the activity date
        let forumThreadMessages = Array.from(forumThread.getMessageThread().getMessages());
        forumThreadMessages.sort((a, b) => {
          return a.getDate() - b.getDate();
        });
        for (let messageInstance of forumThreadMessages) {
          if (messageInstance !== forumThread.getContentMessage()) {
            replies.push(UI$1.createElement(ForumThreadReply, {
              className: this.styleSheet.replies,
              messageInstance: messageInstance
            }));
          }
        }
        if (replies.length) {
          spaceBetween = UI$1.createElement("div", {
            style: {
              height: "60px",
              borderBottom: "1px solid #ddd",
              width: "90%",
              maxWidth: "1200px",
              margin: "0 auto"
            }
          });
        }
        let deleteButton;
        let editButton;
        let editAndDeleteButtons;
        if (USER.isSuperUser || USER.id === this.getForumThread().authorId) {
          deleteButton = UI$1.createElement(DeleteForumThreadButton, {
            icon: "trash",
            level: Level.DANGER,
            className: this.styleSheet.deleteButton,
            modalOptions: {
              forumThread: this.getForumThread()
            }
          });
          editButton = UI$1.createElement(EditThreadReplyButton, {
            icon: "pencil",
            level: Level.INFO,
            className: this.styleSheet.editButton,
            messageInstance: this.getForumThread().getContentMessage()
          });
          editAndDeleteButtons = UI$1.createElement("div", {
            className: this.styleSheet.editDeleteButtons
          }, editButton, deleteButton);
        }
        return [UI$1.createElement("div", {
          style: {
            marginBottom: "60px"
          }
        }, UI$1.createElement("div", {
          className: this.styleSheet.header
        }, this.getTitle(), UI$1.createElement("div", {
          className: this.styleSheet.replyButtonDiv
        }, this.getAuthor(), UI$1.createElement(CreateThreadReplyButton, {
          label: UI$1.T("REPLY"),
          className: this.styleSheet.replyButton,
          forumThreadId: forumThread.id,
          forumThread: this.getForumThread(),
          classMap: ChatMarkupRenderer.classMap
        }))), UI$1.createElement("div", {
          style: {
            width: "90%",
            maxWidth: "1200px",
            margin: "0 auto",
            height: "3px",
            backgroundColor: "#333",
            marginTop: "10px"
          }
        }), UI$1.createElement("div", {
          className: this.styleSheet.fullPost
        }, this.getMessage(), UI$1.createElement("div", {
          className: this.styleSheet.bottomPanel
        }, this.getNumReplies(replies.length), this.getVoting()), editAndDeleteButtons), spaceBetween, replies)];
      }
      deleteThread() {
        this.getForumThread().deleteThread();
      }
      initializeListeners() {
        // These listeners need to be attached after the ForumThread is loaded in the js state
        this.getForumThread().getMessageThread().addListener("newMessage", () => {
          this.redraw();
        });
        this.getForumThread().getMessageThread().addListener("deleteMessage", () => {
          this.redraw();
        });
        this.getForumThread().getContentMessage().addEventListener("messageEdit", () => {
          this.content.setValue(this.getForumThread().getContentMessage().getContent());
          this.content.redraw();
        });
      }
      onMount() {
        // This applies only for a newly created forum thread, since the listeners from
        // render do not get attached when the thread is already in the state.

        if (this.options.forumThread.isLoaded()) {
          this.initializeListeners();
        }
        this.getForumThread().addDeleteListener(() => {
          this.returnToMainForum();
        });
      }
    }) || _class2$m);

    var _dec$u, _class$G, _dec2$9, _class2$l, _dec3$3, _class3$9, _dec4$2, _class4$4;
    let ForumThreadHeader = (_dec$u = registerStyle(ForumThreadHeaderStyle), _dec$u(_class$G = class ForumThreadHeader extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.mainClass);
      }
      getTitle() {
        return UI$1.createElement("div", {
          className: this.styleSheet.tagsTitle
        }, UI$1.T("Title"));
      }
      getAuthor() {
        return UI$1.createElement("div", {
          className: this.styleSheet.tagsAuthor
        }, UI$1.T("Author"));
      }
      getReplies() {
        return UI$1.createElement("div", {
          className: this.styleSheet.tagsReplies
        }, UI$1.T("Replies"));
      }
      getViews() {
        return UI$1.createElement("div", {
          className: this.styleSheet.tagsViews
        }, UI$1.T("Views"));
      }
      getVotes() {
        return UI$1.createElement("div", {
          className: this.styleSheet.tagsVotes
        }, UI$1.T("Score"));
      }
      getActivity() {
        return UI$1.createElement("div", {
          className: this.styleSheet.tagsActivity
        }, UI$1.T("Active"));
      }
      render() {
        return [this.getTitle(), this.getAuthor(), this.getReplies(), this.getViews(), this.getVotes(), this.getActivity()];
      }
    }) || _class$G);
    let ForumThreadPreview = (_dec2$9 = registerStyle(ForumThreadPreviewStyle), _dec2$9(_class2$l = class ForumThreadPreview extends ChatMarkupRenderer {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.forumThreadPreview);
      }
    }) || _class2$l);
    let ForumThreadBubble = (_dec3$3 = registerStyle(ForumThreadBubbleStyle), autoredraw(_class3$9 = _dec3$3(_class3$9 = class ForumThreadBubble extends UI$1.Element {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass(this.styleSheet.mainClass);
        // couldn't figure out how to solve this easier and better
        // if (this.options.isPinned) {
        //     attr.addClass(String(forumThreadBubbleStyle.backgroundColorPinnedInstances));
        // } else if (this.options.color == 0) {
        //     attr.addClass(String(forumThreadBubbleStyle.backgroundColorOddInstances));
        // } else {
        //     attr.addClass(String(forumThreadBubbleStyle.backgroundColorEvenInstances));
        // }
        return attr;
      }
      getHref() {
        return "/forum/" + this.getForumThread().id + "/" + slugify(this.getForumThread().getTitle());
      }
      getForumThread() {
        return this.options.forumThread;
      }
      getThreadTitle() {
        let pinned = "";
        if (this.getForumThread().isPinned()) {
          pinned = UI$1.createElement("span", {
            className: "fa fa-thumb-tack " + this.styleSheet.pinnedIcon,
            "aria-hidden": "true",
            style: {
              paddingTop: "0",
              lineHeight: "20px",
              height: "20px"
            }
          });
        }
        let forumThread = this.getForumThread();
        return [UI$1.createElement("div", {
          className: this.styleSheet.threadTitleAndPreview
        }, UI$1.createElement("div", {
          className: this.styleSheet.threadTitle,
          style: {
            paddingBottom: () => {
              if (forumThread.getContentMessage().content) {
                return this.styleSheet.titlePaddingBottom;
              }
              return "0";
            }
          }
        }, pinned, UI$1.createElement(Link, {
          style: {
            "text-decoration": "none",
            "color": "inherit",
            "font-size": "14px",
            "text-align": "justify"
          },
          href: this.getHref(),
          value: UI$1.createElement("span", {
            className: this.styleSheet.threadTitleSpan
          }, this.getForumThread().getTitle())
        })), UI$1.createElement(ForumThreadPreview, {
          value: this.getForumThread().getContentMessage().content
        }))];
      }
      getThreadAuthor() {
        return [UI$1.createElement("span", {
          className: this.styleSheet.threadAuthor
        }, UI$1.createElement(UserHandle$1, {
          id: this.getForumThread().authorId,
          style: {
            "line-height": "normal",
            wordBreak: "break-word"
          }
        }))];
      }
      getThreadReplies() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.threadReplies
        }, UI$1.createElement(Link, {
          style: {
            "text-decoration": "none",
            "color": "inherit"
          },
          href: this.getHref(),
          value: UI$1.createElement("span", {
            className: this.styleSheet.threadRepliesSpan
          }, this.getForumThread().getNumReplies())
        }))];
      }
      getThreadViews() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.threadViews
        }, this.getForumThread().numViews)];
      }
      getThreadVotes() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.threadVotes
        }, this.getForumThread().getVotesBalance())];
      }
      getThreadActivity() {
        let threadActivity = this.getForumThread().getLastActive();
        /* TODO @mihaic, this should support custom color option (but I didn't want to change stem files on my own). check UIPrimitives.jsx line 400 */
        return [UI$1.createElement("div", {
          className: this.styleSheet.threadActivity
        }, UI$1.createElement(TimePassedSpan, {
          timeStamp: threadActivity
        }))];
      }
      render() {
        return [this.getThreadTitle(), this.getThreadAuthor(), this.getThreadReplies(), this.getThreadViews(), this.getThreadVotes(), this.getThreadActivity()];
      }
    }) || _class3$9) || _class3$9);
    class ForumThreadList extends UI$1.Element {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle({
          width: "90%",
          margin: "0 auto",
          marginTop: "10px",
          marginBottom: "60px"
          // boxShadow: "0px 0px 10px #ddd", // TODO: Do we want this?
        });
        return attr;
      }
      getBubbleClass() {
        return ForumThreadBubble;
      }
      render() {
        let forumThreads = Array.from(this.options.forum.getForumThreads());
        forumThreads.sort((a, b) => {
          if (a.isPinned() && b.isPinned()) {
            return b.getPinIndex() - a.getPinIndex();
          }
          if (a.isPinned()) {
            return -1;
          }
          if (b.isPinned()) {
            return 1;
          }
          return b.lastActive - a.lastActive;
        });
        let result = [];
        let color = 1;
        result.push(UI$1.createElement(ForumThreadHeader, null));
        let Bubble = this.getBubbleClass();
        for (let forumThread of forumThreads) {
          result.push(UI$1.createElement(Bubble, {
            forumThread: forumThread,
            color: color,
            isPinned: forumThread.isPinned()
          }));
          if (!forumThread.isPinned()) {
            color = !color;
          }
        }
        return result;
      }
      onMount() {
        super.onMount();
        this.options.forum.addListener("newForumThread", () => {
          this.redraw();
        });
      }
    }
    let ForumPanel = (_dec4$2 = registerStyle(ForumPanelStyle), _dec4$2(_class4$4 = class ForumPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.mainClass);
      }
      getTitle() {
        return UI$1.createElement("div", {
          className: this.styleSheet.title
        }, this.options.forum.name);
      }
      getButton() {
        return UI$1.createElement("div", {
          className: this.styleSheet.buttonParent
        }, UI$1.createElement(CreateForumThreadButton, {
          label: "NEW POST",
          className: this.styleSheet.button,
          forumId: this.options.forum.id
        }));
      }
      getForumThreadList() {
        return UI$1.createElement(ForumThreadList, {
          forum: this.options.forum
        });
      }
      render() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.header
        }, this.getTitle(), this.getButton()), this.getForumThreadList()];
      }
      onMount() {
        this.attachListener(ForumThreadStore, "create", () => this.redraw());
        this.attachListener(ForumThreadStore, "delete", () => this.redraw());
      }
    }) || _class4$4);
    class DelayedForumPanel extends StateDependentElement(ForumPanel) {
      importState(data) {
        super.importState(data);
        this.options.forum = ForumStore.get(this.options.forumId);
      }
    }
    class DelayedForumThreadPanel extends StateDependentElement(ForumThreadPanel) {
      // TODO: must be able to specify if URL is POST or GET in StateDependentElement
      beforeRedrawNotLoaded() {
        Ajax.postJSON("/forum/forum_thread_state/", {
          forumThreadId: this.options.forumThreadId
        }).then(data => {
          this.importState(data);
          this.setLoaded();
        }, () => {});
      }
      importState(data) {
        super.importState(data);
        this.options.forumThread = ForumThreadStore.get(this.options.forumThreadId);
      }
    }
    class ForumRoute extends Route {
      getSubroutes() {
        return [new Route(["%s", "%s"], options => {
          const forumThreadId = options.args[options.args.length - 2];
          const forumThread = ForumThreadStore.get(forumThreadId);
          if (forumThread) {
            return UI$1.createElement(ForumThreadPanel, {
              forumThread: forumThread
            });
          } else {
            return UI$1.createElement(DelayedForumThreadPanel, {
              forumThreadId: forumThreadId
            });
          }
        })];
      }
      constructor(expr = "forum", options = {}) {
        super(expr, DelayedForumPanel, [], options);
        this.subroutes = this.getSubroutes();
      }
    }

    var _dec$t, _class$F;
    class TaskType {
      constructor(id, name) {
        this.id = id;
        this.toString = () => name;
      }
    }
    const taskTypes = [new TaskType(0, "Batch"), new TaskType(1, "Interactive")];
    function translateArticle(article, language, ownerId, modal) {
      let request = {
        name: "Translation for " + article.name + " in " + language.name,
        baseArticleId: article.id,
        dependency: article.dependency,
        languageId: language.id,
        isPublic: article.isPublic,
        markup: article.markup,
        userCreatedId: ownerId
      };
      Ajax.postJSON("/create_article/", request).then(data => modal.hide(), error => modal.messageArea.showMessage(error.message, "red"));
    }
    class TranslateModal extends ActionModal {
      getActionName() {
        return "Add translation";
      }
      getBody() {
        return [UI$1.createElement(UI$1.TextElement, {
          ref: "text",
          value: "Translate statement and solution"
        }), UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI$1.createElement(Select, {
          ref: "languageSelect",
          options: Language.all()
        })), UI$1.createElement(FormField, {
          ref: "ownerFormField",
          label: "Assign to user"
        }, UI$1.createElement(TextInput, {
          ref: "ownerFormInput",
          value: USER.id
        })))];
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Add translation",
          onClick: () => this.addTranslation()
        }))];
      }
      setTask(evalTask) {
        this.evalTask = evalTask;
        this.text.setValue("Translate statement and solution for " + this.evalTask.longName + ":");
      }
      addTranslation() {
        let language = this.languageSelect.get();
        let ownerId = this.ownerFormInput.getValue();
        let statementId = this.evalTask.statementArticleId;
        let solutionId = this.evalTask.solutionArticleId;
        translateArticle(ArticleStore.get(statementId), language, ownerId, this);
        if (solutionId) translateArticle(ArticleStore.get(solutionId), language, ownerId, this);
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    class CreateEvalTaskModal extends ActionModal {
      getActionName() {
        return "Create task";
      }
      getBody() {
        return UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "urlNameFormField",
          label: "URL name"
        }, UI$1.createElement(TextInput, {
          ref: "urlNameInput",
          value: ""
        })), UI$1.createElement(FormField, {
          ref: "longNameFormField",
          label: "Long name"
        }, UI$1.createElement(TextInput, {
          ref: "longNameInput",
          value: ""
        })), UI$1.createElement(FormField, {
          ref: "typeFormField",
          label: "Type"
        }, UI$1.createElement(Select, {
          ref: "typeSelect",
          options: taskTypes
        })), UI$1.createElement(FormField, {
          ref: "timeLimitFormField",
          label: "Time limit (ms)"
        }, UI$1.createElement(TextInput, {
          ref: "timeLimitInput",
          value: "1000"
        })), UI$1.createElement(FormField, {
          ref: "memoryLimitFormField",
          label: "Memory limit (MB)"
        }, UI$1.createElement(TextInput, {
          ref: "memoryLimitInput",
          value: "256"
        })));
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Create task",
          onClick: () => this.createTask()
        })];
      }
      createTask() {
        let urlName = this.urlNameInput.getValue();
        let longName = this.longNameInput.getValue();
        let type = this.typeSelect.get().id;
        let timeLimit = this.timeLimitInput.getValue();
        let memoryLimit = this.memoryLimitInput.getValue() * 1024;
        let request = {
          urlName: urlName,
          longName: longName,
          type: type,
          timeLimit: timeLimit,
          memoryLimit: memoryLimit
        };
        Ajax.postJSON("/eval/create_eval_task/", request).then(() => window.location.pathname = "/task/" + urlName + "/edit/", error => this.messageArea.showMessage(error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    let EvalTaskTable = (_dec$t = autoredraw(EvalTaskStore), _dec$t(_class$F = class EvalTaskTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        this.columnSortingOrder = [this.options.columns[0]];
      }
      getDefaultColumns() {
        const cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        const headerStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        return [{
          value: evalTask => evalTask.id,
          headerName: "ID",
          headerStyle: headerStyle,
          cellStyle: cellStyle,
          sortDescending: true
        }, {
          value: evalTask => UI$1.createElement(Link, {
            href: "/task/" + evalTask.urlName + "/edit/",
            value: evalTask.longName
          }),
          rawValue: evalTask => evalTask.urlName,
          headerName: "Task",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => taskTypes[evalTask.type].toString(),
          headerName: "Type",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => Formatter.cpuTime(evalTask.timeLimit / 1000),
          rawValue: evalTask => evalTask.timeLimit,
          headerName: "Time limit",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => Formatter.memory(evalTask.memoryLimit * 1024),
          rawValue: evalTask => evalTask.memoryLimit,
          headerName: "Memory limit",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => UI$1.createElement(Button$1, {
            level: Level.PRIMARY,
            label: "Translate",
            onClick: () => {
              this.parent.translateModal.show();
              this.parent.translateModal.setTask(evalTask);
            }
          }),
          headerName: "Translate",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }];
      }
      getEntries() {
        let evalTasks = EvalTaskStore.all().filter(evalTask => {
          return evalTask.canBeEditedByUser();
        });
        return this.sortEntries(evalTasks);
      }
    }) || _class$F);
    class EvalTaskManager extends Panel {
      getDefaultOptions() {
        return {
          title: "Task manager"
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      render() {
        return [UI$1.createElement("div", {
          className: "pull-left"
        }, UI$1.createElement("h4", null, UI$1.createElement("strong", null, this.options.title))), UI$1.createElement("div", {
          className: "pull-right"
        }, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Create eval task",
          onClick: () => this.createEvalTaskModal.show(),
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          }
        })), UI$1.createElement(EvalTaskTable, {
          ref: "table"
        })];
      }
      onMount() {
        super.onMount();
        this.getEvalTasks();
        this.translateModal = UI$1.createElement(TranslateModal, {
          parent: this
        });
        this.createEvalTaskModal = UI$1.createElement(CreateEvalTaskModal, {
          parent: this
        });
      }
      getEvalTasks() {
        Ajax.getJSON("/eval/get_available_tasks/", {}).then(() => this.table.redraw());
      }
    }

    class TaskChecker extends StoreObject {
      getWorkspaces() {
        return this.workspaceIds.map(id => WorkspaceStore.get(id));
      }
      toString() {
        return this.name;
      }
    }
    class TaskCheckerStoreClass extends GenericObjectStore {
      constructor() {
        super("TaskChecker", TaskChecker);
      }
      allIncludingDefault() {
        let all = this.all();
        all.splice(0, 0, {
          name: "------",
          id: 0,
          workspaceIds: [],
          toString: () => {
            return "------";
          }
        });
        return all;
      }
    }
    const TaskCheckerStore = new TaskCheckerStoreClass();

    class FlashableButton extends Button$1 {
      flash(level, timeout = 2000) {
        let originalLevel = this.getLevel();
        this.setLevel(level);
        setTimeout(() => {
          this.setLevel(originalLevel);
        }, timeout);
      }
    }
    class OriginalContestEditor extends UI$1.Element {
      setOptions(options) {
        super.setOptions(options);
        ///Creating the contest list and adding a dummy contest, for no contest
        let c = new Contest();
        c.id = 0;
        c.longName = "-----";
        this.contests = [c, ...ContestStore.all()];
        this.selected = ContestStore.get(this.options.evalTask.originalContestId) || c;
      }
      render() {
        return [UI$1.createElement("h3", null, "Original Contest"), UI$1.createElement("div", null, UI$1.createElement(Select, {
          ref: "originalContestSelect",
          options: this.contests,
          selected: this.selected
        }), UI$1.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          size: Size.SMALL,
          style: {
            marginLeft: "10px"
          },
          icon: "floppy-o"
        }))];
      }
      saveOriginalContest(id) {
        let request = {
          originalContestChanged: true,
          originalContestId: id
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }
      onMount() {
        this.saveButton.addClickListener(() => {
          let newContest = this.contests[this.originalContestSelect.getIndex()];
          if (this.originalContestSelect.getIndex() === 0) {
            this.saveOriginalContest(null);
          } else {
            this.saveOriginalContest(newContest.id);
          }
        });
      }
    }

    // TODO refactor store usage
    let tagOptions = TagStore.all().sort(function (a, b) {
      if (a.toString() < b.toString()) {
        return -1;
      }
      if (a.toString() > b.toString()) {
        return 1;
      }
      return 0;
    });
    class TagEditor extends UI$1.Element {
      addTag() {
        this.value.push(tagOptions[0].id);
        this.redraw();
      }
      removeTag(index) {
        this.value.splice(index, 1);
        this.redraw();
      }
      setOptions(options) {
        super.setOptions(options);
        this.value = this.options.evalTask.tagIds || [];
      }
      renderTagOptions() {
        return this.value.map((tagId, index) => UI$1.createElement("div", {
          style: {
            marginTop: 10
          }
        }, UI$1.createElement(Select, {
          style: {
            height: 30
          },
          options: tagOptions,
          initialValue: TagStore.get(tagId),
          onChange: tag => {
            console.log(tag);
            this.value[index] = tag.id;
          }
        }), UI$1.createElement(Button$1, {
          onClick: () => this.removeTag(index),
          style: {
            marginLeft: 6
          },
          level: Level.DANGER,
          icon: "minus",
          size: Size.SMALL
        })));
      }
      render() {
        return [UI$1.createElement("h3", {
          style: {
            marginRight: 10,
            marginBottom: 3
          }
        }, "Tags"), this.renderTagOptions(), UI$1.createElement(ButtonGroup, {
          style: {
            marginTop: 10
          }
        }, UI$1.createElement(Button$1, {
          onClick: () => this.addTag(),
          level: Level.SUCCESS,
          icon: "plus",
          size: Size.SMALL
        }), UI$1.createElement(FlashableButton, {
          ref: "saveButton",
          onClick: () => this.saveTags(),
          level: Level.PRIMARY,
          icon: "floppy-o",
          size: Size.SMALL
        }))];
      }
      async saveTags() {
        const request = {
          tagsChanged: true,
          tagIds: this.value
        };
        await Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request);
        this.saveButton.flash(Level.SUCCESS);
      }
    }
    let CheckerEditor$1 = class CheckerEditor extends UI$1.Element {
      render() {
        return [UI$1.createElement("h3", null, "Task checker"),
        // TODO @branch have a button to create a new checker
        UI$1.createElement("div", null, UI$1.createElement(Select, {
          ref: "checkerSelect",
          options: TaskCheckerStore.allIncludingDefault(),
          selected: TaskCheckerStore.get(this.options.evalTask.checkerId)
        }), UI$1.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          size: Size.SMALL,
          style: {
            marginLeft: "10px"
          },
          icon: "floppy-o"
        })), UI$1.createElement("div", null, UI$1.createElement(FlashableButton, {
          ref: "cachebustButton",
          level: Level.PRIMARY,
          style: {
            marginTop: "10px"
          }
        }, "Clear eval cache"))];
      }
      saveChecker() {
        let request = {
          checkerChanged: true,
          checkerId: this.checkerSelect.get().id
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }
      cachebust() {
        Ajax.postJSON("/eval/checker/cache_bust/", {
          evalTaskId: this.options.evalTask.id
        }).then(() => this.cachebustButton.flash(Level.SUCCESS));
      }
      onMount() {
        this.saveButton.addClickListener(() => {
          this.saveChecker();
        });
        this.cachebustButton.addClickListener(() => {
          this.cachebust();
        });
      }
    };
    class DifficultyEditor extends UI$1.Element {
      render() {
        return [UI$1.createElement("h3", null, "Difficulty"), UI$1.createElement("div", null, UI$1.createElement(Select, {
          ref: "difficultySelect",
          options: Difficulty.all(),
          selected: Difficulty.get(EvalTaskStatisticsStore.getByEvalTaskId(this.options.evalTask.id).evalTaskDifficulty)
        }), UI$1.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          size: Size.SMALL,
          style: {
            marginLeft: "10px"
          },
          icon: "floppy-o"
        }))];
      }
      saveDifficulty() {
        let request = {
          evalTaskId: this.options.evalTask.id,
          difficulty: this.difficultySelect.get().id
        };
        Ajax.postJSON("/eval/change_task_difficulty/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }
      onMount() {
        this.saveButton.addClickListener(() => {
          this.saveDifficulty();
        });
      }
    }
    class BroadcastButton extends UI$1.Element {
      render() {
        return [UI$1.createElement("h3", null, "Task Update"), UI$1.createElement(AjaxButton, {
          ref: "broadcastButton",
          level: Level.PRIMARY,
          onClick: () => {
            this.broadcast();
          },
          statusOptions: ["Update task for users", {
            icon: "spinner fa-spin",
            label: " broadcasting ..."
          }, "Success", "Failed"]
        })];
      }
      broadcast() {
        this.broadcastButton.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          broadcast: true
        });
      }
    }
    class TaskNameEditor extends UI$1.Element {
      render() {
        return [UI$1.createElement("h3", null, "Task name"), UI$1.createElement(Form, {
          style: {
            maxWidth: "300px",
            margin: 0
          }
        }, UI$1.createElement(FormField, {
          ref: "urlNameFormField",
          label: "URL Name",
          style: {
            margin: 0
          }
        }, UI$1.createElement(TextInput, {
          ref: "urlNameFormInput",
          style: {
            paddingLeft: "4px"
          },
          value: this.options.evalTask.urlName
        })), UI$1.createElement(FormField, {
          ref: "longNameFormField",
          label: "Long Name",
          style: {
            margin: 0
          }
        }, UI$1.createElement(TextInput, {
          ref: "longNameFormInput",
          style: {
            paddingLeft: "4px"
          },
          value: this.options.evalTask.longName
        })), UI$1.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          icon: "save"
        }))];
      }
      onMount() {
        this.saveButton.addClickListener(() => {
          let request = {
            nameChanged: true,
            urlName: this.urlNameFormInput.getValue(),
            longName: this.longNameFormInput.getValue()
          };
          Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => location.reload());
        });
      }
    }
    class GeneralPanel extends Panel {
      getTitle() {
        return "General";
      }
      render() {
        return [UI$1.createElement(TaskNameEditor, {
          evalTask: this.options.evalTask
        }), UI$1.createElement(CheckerEditor$1, {
          evalTask: this.options.evalTask
        }), UI$1.createElement(BroadcastButton, {
          evalTask: this.options.evalTask,
          style: {
            marginTop: "20px"
          }
        }), UI$1.createElement(OriginalContestEditor, {
          evalTask: this.options.evalTask
        }), UI$1.createElement(TagEditor, {
          evalTask: this.options.evalTask,
          style: {
            marginTop: "10px"
          }
        }), UI$1.createElement(DifficultyEditor, {
          evalTask: this.options.evalTask
        })];
      }
    }

    class StatementPanel extends Panel {
      getTitle() {
        return "Statement";
      }
      render() {
        return UI$1.createElement(ArticleEditor, {
          articleId: this.options.evalTask.statementArticleId
        });
      }
    }

    var _class$E, _descriptor$i, _dec$s, _class2$k, _class3$8;
    function parseTestRanges(testRanges, allTestIds, groupIndex, parsedGroups, ignoreDuplicateGroup = false) {
      testRanges = testRanges.toLowerCase().replaceAll(" ", "");
      const groupIds = new Set();
      const explicitTestIds = new Set();
      const forceParseInt = str => {
        const value = parseInt(str, 10);
        if (isNaN(value) || String(value) !== str) {
          throw `Failed to parse as integer "${str}"`;
        }
        return value;
      };
      if (testRanges === "*") {
        return {
          testIds: allTestIds,
          explicitTestIds,
          groupIds,
          includeAll: true
        };
      }
      const parts = testRanges.split(/[;,]+/).filter(value => value.length > 0);
      for (const part of parts) {
        if (part.startsWith("g")) {
          const includedGroupIndex = forceParseInt(part.substring(1));
          if (includedGroupIndex <= 0 || includedGroupIndex >= groupIndex) {
            throw `Must only include previous groups (${part})`;
          }
          groupIds.add(includedGroupIndex);
          continue;
        }
        if (!part.includes("-")) {
          const testId = forceParseInt(part);
          if (!allTestIds.has(testId)) {
            throw `Invalid test id (${part})`;
          }
          explicitTestIds.add(testId);
          continue;
        }
        const values = part.split("-");
        if (values.length !== 2) {
          throw `Range must have exactly two parts (${part})`;
        }
        const [firstIndex, lastIndex] = values.map(forceParseInt);
        for (let testId = firstIndex; testId <= lastIndex; testId++) {
          if (!allTestIds.has(testId)) {
            throw `Invalid test id "${testId}" from range "${part}"`;
          }
          explicitTestIds.add(testId);
        }
      }
      const testIds = new Set(Array.from(explicitTestIds));
      for (const includedGroupIndex of groupIds) {
        const includeTestIds = parsedGroups[includedGroupIndex - 1]?.testIds;
        if (testIds) {
          // Maybe prev parse failed, skip in that case
          for (const testId of includeTestIds) {
            testIds.add(testId);
          }
        }
      }
      if (!ignoreDuplicateGroup) {
        for (const previousGroup of parsedGroups) {
          if (areSetsEqual(previousGroup.testIds, testIds)) {
            throw `Covers same tests as ${previousGroup.index}`;
          }
        }
      }
      return {
        testIds,
        explicitTestIds,
        groupIds
      };
    }
    let TestGroupingEditorStyle = (_class$E = class TestGroupingEditorStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$i, this);
      }
    }, (_descriptor$i = _applyDecoratedDescriptor(_class$E.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxWidth: 400,
          margin: "auto",
          paddingBottom: 40
        };
      }
    })), _class$E);
    let TestGroupingEditor = (_dec$s = registerStyle(TestGroupingEditorStyle), autoredraw(_class2$k = _dec$s(_class2$k = class TestGroupingEditor extends BaseInputElement {
      getDefaultOptions(options) {
        const {
          evalTask
        } = options;
        return {
          ...super.getDefaultOptions(options),
          initialValue: evalTask.testGrouping
        };
      }
      addTestGroup() {
        const newValue = Array.from(toArray(this.value));
        newValue.push({
          testRanges: "*",
          pointsWorth: 0,
          comment: ""
        });
        this.setValue(newValue);
      }
      deleteTestGroup(index) {
        const newValue = Array.from(this.value);
        newValue.splice(index, 1);
        this.setValue(newValue);
      }

      // Returns errors and warnings
      validate() {
        const {
          evalTask
        } = this.options;
        const testGroups = toArray(this.value);
        let totalPoints = 0;
        const warnings = [],
          errors = [];
        const allTests = [...evalTask.exampleTests, ...evalTask.systemTests];
        const allTestIds = new Set(allTests.map(test => test.index));
        if (testGroups.length === 0) {
          return {
            warnings,
            errors
          };
        }
        const previouslyParsedGroups = [];
        const allTestIdsInGroups = new Set();
        testGroups.forEach((testGroup, index) => {
          index = index + 1;
          totalPoints += testGroup.pointsWorth;
          try {
            const result = parseTestRanges(testGroup.testRanges, allTestIds, index, previouslyParsedGroups);
            result.index = index;
            previouslyParsedGroups.push(result);
            testGroup.testIndexes = Array.from(result.testIds);
            testGroup.testIndexes.sort((a, b) => a - b);
            for (const testId of testGroup.testIndexes) {
              allTestIdsInGroups.add(testId);
            }
          } catch (error) {
            errors.push(`Group ${index}: ${error}`);
          }
        });
        const systemTestsNotInGroups = unwrapArray(evalTask.systemTests.map(test => !allTestIdsInGroups.has(test.index) && test.index));
        warnings.unshift(...unwrapArray([totalPoints != 100 && `Total points: ${totalPoints}${totalPoints < 100 ? ", (" + (100 - totalPoints) + " undistributed)" : ""}`, systemTestsNotInGroups.length > 0 && `Non-example test(s) not included in grouping: ${systemTestsNotInGroups}`]));
        return {
          errors,
          warnings
        };
      }
      async save() {
        const value = toArray(this.value);
        const request = {
          testGrouping: JSON.stringify(value.length > 0 ? value : null)
        };
        await Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request);
      }
      render() {
        const testGroups = toArray(this.value);
        const columns = [["#", (testGroups, index) => index + 1], ["Tests", testGroup => UI$1.createElement(Input, {
          initialValue: testGroup.testRanges,
          onChange: value => {
            testGroup.testRanges = value;
            this.redraw();
          }
        })], ["Points Worth", testGroup => UI$1.createElement(NumberInput, {
          min: 1,
          initialValue: testGroup.pointsWorth,
          onChange: value => {
            testGroup.pointsWorth = value;
            this.redraw();
          }
        })], ["Comment", testGroup => UI$1.createElement(Input, {
          initialValue: testGroup.comment,
          onChange: value => {
            testGroup.comment = value;
          }
        })], ["", (testGroup, index) => UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          label: "Delete",
          onClick: () => this.deleteTestGroup(index)
        }))]];
        const {
          errors,
          warnings
        } = this.validate();
        return [testGroups.length > 0 ? UI$1.createElement(Table, {
          entries: testGroups,
          columns: columns
        }) : UI$1.createElement("div", null, "Test grouping is disabled"), errors.map(error => UI$1.createElement("p", {
          style: {
            color: "red"
          }
        }, "X ", error)), warnings.map(warning => UI$1.createElement("p", {
          style: {
            color: "darkorange"
          }
        }, "\u26A0 ", warning)), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          label: "Add test group",
          onClick: () => this.addTestGroup()
        }), UI$1.createElement(Button$1, {
          label: "Save",
          disabled: errors.length > 0,
          onClick: () => this.save()
        }))];
      }
    }) || _class2$k) || _class2$k);
    let TestGroupingPanel = autoredraw(_class3$8 = class TestGroupingPanel extends CollapsiblePanel {
      getTitle() {
        const {
          evalTask
        } = this.options;
        const testGrouping = toArray(evalTask.testGrouping);
        const status = testGrouping.length > 0 ? `${testGrouping.length} groups` : "disabled";
        return `Test Grouping (${status})`;
      }
      render() {
        return UI$1.createElement(TestGroupingEditor, {
          evalTask: this.options.evalTask
        });
      }
    }) || _class3$8;

    function SuccessMessage(message) {
      return UI$1.createElement("p", {
        style: {
          color: Theme.props.COLOR_SUCCESS
        }
      }, "\u2705 ", message);
    }
    function WarningMessage(message) {
      return UI$1.createElement("p", {
        style: {
          color: Theme.props.COLOR_WARNING
        }
      }, "\u26A0\uFE0F ", message);
    }
    function ErrorMessage(message) {
      return UI$1.createElement("p", {
        style: {
          color: Theme.props.COLOR_DANGER
        }
      }, "\u274C ", message);
    }
    const IssueSummary = {
      _warnings: [],
      _errors: [],
      warn(message) {
        this._warnings.push(message);
      },
      error(message) {
        this._errors.push(message);
      },
      clear() {
        this._warnings = [];
        this._errors = [];
      },
      allOk() {
        return this._warnings.length === 0 && this._errors.length === 0;
      },
      render() {
        if (this.allOk()) {
          return SuccessMessage("OK");
        }
        return [...this._errors.map(message => ErrorMessage(message)), ...this._warnings.map(message => WarningMessage(message))];
      }
    };

    function formatBytes(bytes) {
      const UNIT_SYMBOL = ["B", "KB", "MB", "GB", "TB", "PB"];
      if (bytes == null) {
        return "-";
      }
      if (bytes === 0) {
        return "0 " + UNIT_SYMBOL[0];
      }
      bytes = parseInt(bytes, 10);
      const unitIndex = Math.min(parseInt(Math.floor(Math.log(bytes) / Math.log(1024))), UNIT_SYMBOL.length - 1);
      if (unitIndex === 0) {
        return bytes + " " + UNIT_SYMBOL[unitIndex];
      }
      const amountInUnits = bytes / Math.pow(1024, unitIndex);
      const decimalDigits = amountInUnits < 10 ? 2 : 1;
      return amountInUnits.toFixed(decimalDigits) + " " + UNIT_SYMBOL[unitIndex];
    }
    function formatError(error) {
      if (error.error) {
        return formatError(error.error);
      }
      if (error.message) {
        return formatError(error.message);
      }
      return String(error);
    }

    var _class$D, _descriptor$h, _descriptor2$h, _descriptor3$f, _dec$r, _class2$j;
    let ToggleInputStyle = (_class$D = class ToggleInputStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$h, this);
        _initializerDefineProperty(this, "pill", _descriptor2$h, this);
        _initializerDefineProperty(this, "toggleOn", _descriptor3$f, this);
      }
    }, (_descriptor$h = _applyDecoratedDescriptor(_class$D.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          display: "flex",
          // TODO @Andrei shouldn't this be inline-flex?
          alignItems: "center",
          position: "relative",
          borderRadius: 20,
          width: 35,
          height: 15,
          background: this.themeProps.TOGGLE_BACKGROUND
        };
      }
    }), _descriptor2$h = _applyDecoratedDescriptor(_class$D.prototype, "pill", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "absolute",
          left: "0%",
          transitionProperty: "background, left",
          transition: this.themeProps.DEFAULT_TRANSITION,
          borderRadius: "100%",
          width: this.themeProps.TOGGLE_PILL_SIZE,
          height: this.themeProps.TOGGLE_PILL_SIZE,
          background: this.themeProps.TOGGLE_DISABLED_BACKGROUND,
          boxShadow: this.themeProps.TOGGLE_SHADOW
        };
      }
    }), _descriptor3$f = _applyDecoratedDescriptor(_class$D.prototype, "toggleOn", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          left: "calc(100% - " + this.themeProps.TOGGLE_PILL_SIZE + "px)",
          background: this.themeProps.TOGGLE_COLOR
        };
      }
    })), _class$D);
    let ToggleInput = (_dec$r = registerStyle(ToggleInputStyle), _dec$r(_class2$j = class ToggleInput extends BaseInputElement {
      render() {
        const {
          styleSheet
        } = this;
        return UI$1.createElement("div", {
          className: styleSheet.pill + (this.getValue() && styleSheet.toggleOn)
        });
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          const newValue = !this.getValue();
          this.setValue(newValue);
        });
      }
    }) || _class2$j);

    class TestUploadStatus extends UI$1.Primitive("span") {
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "inline-flex",
          alignItems: "baseline"
        });
      }
      render() {
        const {
          error,
          message,
          progress,
          response
        } = this.options;
        if (error) {
          return `Error: ${error}`;
        }
        if (response) {
          // This means we're done
          const {
            numTestFilesUpdated,
            numTestFilesDeleted
          } = response;
          const deleteInfo = numTestFilesDeleted ? ` and ${numTestFilesDeleted} deleted` : "";
          return `Done, ${numTestFilesUpdated} test files updated${deleteInfo}.`;
        }
        if (progress == null) {
          return message;
        }
        if (progress < 1.0) {
          return ["Uploading", UI$1.createElement(ProgressBar, {
            style: {
              width: 250,
              display: "inline-block",
              marginLeft: 8,
              height: 8
            },
            level: Level.SUCCESS,
            value: progress
          })];
        }
        return "Processing...";
      }
    }
    class TestUploadPanel extends CollapsiblePanel {
      constructor(...args) {
        super(...args);
        this.uploadStatus = {};
        this.maxUploadSize = 100 << 20;
        this.maxFiles = 100;
      }
      getTitle() {
        return "Upload tests";
      }
      updateSelectedFileDescription() {
        const filesToUpload = this.testInputField?.getFiles() || [];
        this.updateUploadStatus({
          error: null,
          progress: null,
          response: null
        });
        if (filesToUpload.length === 0) {
          return;
        }
        let totalFileSize = 0;
        for (const file of filesToUpload) {
          totalFileSize += file.size;
        }
        if (totalFileSize > this.maxUploadSize) {
          this.updateUploadStatus({
            error: `Total upload size too large: ${formatBytes(totalFileSize)} > ${formatBytes(this.maxUploadSize)}`
          });
          return;
        }
        if (filesToUpload.length > this.maxFiles) {
          this.updateUploadStatus({
            error: `Too many files selected, max ${this.maxFiles}`
          });
        }
        return this.updateUploadStatus({
          message: `${formatBytes(totalFileSize)} ready to upload`
        });
      }
      render() {
        return [UI$1.createElement(FileInput, {
          ref: "testInputField",
          multipleFiles: true,
          fileTypes: ".in,.ok,.zip",
          onChange: () => this.updateSelectedFileDescription()
        }), UI$1.createElement(Button$1, {
          label: "Upload tests",
          onClick: () => this.uploadTests(),
          level: Level.PRIMARY,
          style: {
            margin: "5px"
          }
        }), UI$1.createElement(TestUploadStatus, this.uploadStatus),
        // TODO: click on the label
        UI$1.createElement("div", {
          style: {
            margin: 12,
            marginLeft: 24,
            fontWeight: "bold"
          }
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "removeUnmodifiedInput",
          initialValue: false
        }), " Remove unmodified tests"), UI$1.createElement("div", null, UI$1.createElement("ul", null, UI$1.createElement("li", null, "Upload either a .zip file or individual test files. Zip files can contain a folder, files are loaded ", UI$1.createElement(Definition, {
          value: "recursively",
          term: "recursion"
        }), "."), UI$1.createElement("li", null, "For any modified test case, both the input and output need to be provided."), UI$1.createElement("li", null, "When \"Remove unmodified tests\" is selected, all tests not found in the upload will be removed."), UI$1.createElement("li", null, UI$1.createElement("strong", null, "dos2unix"), " will be run on the files, to normalize line ending."), UI$1.createElement("li", null, "At most 200 test cases can be created for a task"), UI$1.createElement("li", null, "Total unpacked test size should be at most 200MB, but please think of the children and try to keep it under 5-10MB for evaluation performance reasons.")))];
      }
      updateUploadStatus(newStatus) {
        Object.assign(this.uploadStatus, newStatus);
        this.redraw();
      }
      async uploadTests() {
        const {
          evalTask
        } = this.options;
        const formData = new FormData();
        const filesToUpload = this.testInputField.getFiles();
        if (filesToUpload.length === 0) {
          this.updateUploadStatus({
            error: "No files selected for upload."
          });
          return;
        }
        for (const file of filesToUpload) {
          if (file.size > 1e8) {
            this.updateUploadStatus({
              error: "File " + file.name + " too large."
            });
            continue;
          }
          formData.append(file.name, file);
        }
        if (this.removeUnmodifiedInput?.getValue()) {
          formData.set("removeUnmodified", "true");
        }
        this.uploadStatus = {};
        this.updateUploadStatus({
          progress: 0
        });
        const onUploadProgress = event => this.updateUploadStatus({
          progress: event.loaded / event.total
        });
        Ajax.postJSON(evalTask.getEditUrl(), formData, {
          onUploadProgress
        }).then(response => {
          this.updateUploadStatus({
            response
          });
        }, error => {
          this.updateUploadStatus({
            error: formatError(error)
          });
        });
      }
    }

    var _class$C;
    class TestCaseRow extends CollapsibleTableRow {
      onMount() {
        super.onMount();
        this.isExampleCheckbox.addClickListener(() => {
          this.markChanged();
        });
        this.previewButton.addClickListener(() => {
          // TODO: should be something different here, only mark as changed if content changes
          this.markChanged();
        });
        this.saveButton.addClickListener(() => {
          this.saveTest();
        });
        this.deleteButton.addClickListener(() => {
          const {
            entry
          } = this.options;
          const shouldDelete = window.confirm(`Do you want to delete test ${entry.index}?`);
          if (!shouldDelete) {
            return;
          }
          this.deleteTest();
        });
        this.downloadButton.addClickListener(() => {
          this.downloadTest();
        });
      }
      downloadTest() {
        const test = this.options.entry;
        const request = {
          testId: test.id,
          downloadTest: true
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => {
          let delay = 0;
          if (data.input) {
            let file1 = new Blob([data.input], {
              type: 'text/plain;charset=utf-8'
            });
            FileSaver.saveAs(file1, 'input.txt');
            delay += 1000;
          }
          if (data.output) {
            setTimeout(() => {
              let file2 = new Blob([data.output], {
                type: 'text/plain;charset=utf-8'
              });
              FileSaver.saveAs(file2, 'output.txt');
            }, delay);
            delay += 1000;
          }
          if (data.extra) {
            setTimeout(() => {
              let file3 = new Blob([data.extra], {
                type: 'text/plain;charset=utf-8'
              });
              FileSaver.saveAs(file3, 'extra.txt');
            }, delay);
          }
        });
      }
      renderFilePanel(title, content, panelStyle) {
        return UI.createElement(Panel, {
          style: panelStyle
        }, UI.createElement("div", {
          style: {
            height: "20px",
            paddingLeft: "10px",
            boxSizing: "border-box",
            backgroundColor: "white"
          }
        }, title), UI.createElement(StaticCodeHighlighter, {
          style: {
            width: "100%",
            height: "150px"
          },
          value: content
        }));
      }
      renderCollapsible() {
        const {
          entry
        } = this.options;
        const panelStyle = {
          height: "170px",
          width: "33.33%",
          display: "inline-block"
        };
        const panels = [this.renderFilePanel(" Input", entry.input, panelStyle), this.renderFilePanel(" Judge output", entry.output, panelStyle), this.renderFilePanel(" Extra", JSON.stringify(entry.extra), panelStyle)];
        return UI.createElement(Panel, {
          className: "section" + entry.testNumber,
          key: entry.testNumber,
          orientation: Orientation$1.HORIZONTAL,
          style: {
            height: panelStyle.height,
            width: "100%",
            padding: "5px"
          }
        }, UI.createElement(SectionDivider, {
          style: {
            height: "100%"
          },
          orientation: Orientation$1.HORIZONTAL
        }, panels));
      }
      markChanged() {
        this.setStyle("background-color", "lightblue");
      }
      markUnchanged() {
        this.setStyle("background-color", "white");
      }
      saveTest() {
        let test = this.options.entry;
        let isExample = this.isExampleCheckbox.node.checked;
        let comment = this.previewButton.options.getValue() || "";
        const request = {
          testId: test.id,
          isExample: isExample,
          comment: comment
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => this.markUnchanged());
      }
      deleteTest() {
        let test = this.options.entry;
        const request = {
          testId: test.id,
          deleteTest: true
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => this.parent.redraw());
      }
    }
    class TestCaseTable extends CollapsibleTable {
      getRowClass() {
        return TestCaseRow;
      }
      getRowOptions(entry, rowIndex) {
        const {
          evalTask
        } = this.options;
        return {
          ...super.getRowOptions(entry, rowIndex),
          evalTask
        };
      }
      getDefaultColumns() {
        const numberStyle = {
          textAlign: "right"
        };
        const STANDARD_COL = {
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        };
        return [["Index", entry => entry.index, STANDARD_COL], ["Name", entry => {
          if (entry.name && String(entry.name) !== String(entry.index)) {
            return entry.name;
          }
          return "-";
        }, STANDARD_COL], ["Input size", entry => entry.inputSize, STANDARD_COL], ["Output size", entry => entry.outputSize, STANDARD_COL], ["Extra size", entry => entry.extraSize, STANDARD_COL], ["Is example", entry => UI.createElement(RawCheckboxInput, {
          noStupid: true,
          value: entry.isExample,
          ref: "isExampleCheckbox"
        }), STANDARD_COL],
        // WOW, the ref is applied to the table row!
        ["Comment", entry => {
          //TODO: duplicated from ChatWidget.renderMessageBox, refactor to common class (MessageBox)
          const chatInputStyle = {
            display: "inline-block",
            overflow: "auto",
            resize: "none",
            height: "46px",
            "vertical-align": "top"
          };
          const entryMessageInputRef = "messageInput" + entry.id;

          // TODO: this is broken

          return UI.createElement("div", null, UI.createElement(TextArea, {
            ref: this.refLink(entryMessageInputRef),
            style: chatInputStyle,
            value: entry.comment || ""
          }), UI.createElement(PreviewMarkupButton, {
            ref: "previewButton",
            getValue: () => this[entryMessageInputRef].getValue(),
            setValue: value => {
              this[entryMessageInputRef].setValue(value);
              this[entryMessageInputRef].node.focus();
            }
          }));
        }], ["Last modified", entry => entry.lastModified, STANDARD_COL], ["Actions", entry => UI.createElement(ButtonGroup, {
          level: Level.INFO,
          size: Size.SMALL
        }, UI.createElement(Button$1, {
          ref: "saveButton",
          label: "Save"
        }), UI.createElement(Button$1, {
          ref: "downloadButton",
          label: "Download"
        }), UI.createElement(Button$1, {
          ref: "deleteButton",
          label: "Delete",
          level: Level.DANGER
        }))]];
      }
      getEntryKey(entry, index) {
        return index;
      }
      getEntries() {
        const {
          evalTask
        } = this.options;
        return [].concat(evalTask.exampleTests, evalTask.systemTests);
      }
    }
    let TestCaseTablePanel = autoredraw(_class$C = class TestCaseTablePanel extends CollapsiblePanel {
      getTitle() {
        const {
          evalTask
        } = this.options;
        const allTests = [].concat(evalTask.exampleTests, evalTask.systemTests);
        let maxInput = 0,
          totalInput = 0,
          maxOutput = 0,
          totalOutput = 0;
        for (const test of allTests) {
          totalInput += test.inputSize;
          totalOutput += test.outputSize;
          if (test.inputSize > maxInput) {
            maxInput = test.inputSize;
          }
          if (test.outputSize > maxOutput) {
            maxOutput = test.outputSize;
          }
        }
        return `${allTests.length} tests (${evalTask.exampleTests.length} ex.) | Input: ${formatBytes(maxInput)} max, ${formatBytes(totalInput)} total | Output: ${formatBytes(maxOutput)} max, ${formatBytes(totalOutput)} total | Cumulated ${formatBytes(totalInput + totalOutput)}`;
      }
      render() {
        return UI.createElement(TestCaseTable, {
          evalTask: this.options.evalTask
        });
      }
    }) || _class$C;

    function hasEvalTaskInArchive(evalTask) {
      const archiveContestIds = new Set(ArchiveStore.all().map(archive => archive.baseContestId));
      for (const contestTask of ContestTaskStore.filterBy({
        evalTaskId: evalTask.id
      })) {
        if (archiveContestIds.has(contestTask.contestId)) {
          return true;
        }
      }
      return false;
    }
    class EditTestsPanel extends Panel {
      getTitle() {
        return "Tests";
      }
      render() {
        const {
          evalTask
        } = this.options;
        return [UI.createElement("div", {
          style: {
            marginTop: 12
          }
        }, UI.createElement("a", {
          className: ButtonStyle.getInstance().container,
          style: {
            margin: "5px"
          },
          href: `/task/${evalTask.urlName}-tests.zip`,
          target: "_blank"
        }, "Download tests"), hasEvalTaskInArchive(evalTask) && UI.createElement("div", {
          style: {
            color: "darkorange",
            padding: 8
          }
        }, "\u26A0 Tests are publicly downloadable due to inclusion in archive.")), UI.createElement(TestUploadPanel, {
          evalTask: evalTask
        }), UI.createElement(TestCaseTablePanel, {
          evalTask: evalTask,
          style: {
            marginTop: 8,
            marginBottom: 8
          }
        }), UI.createElement(TestGroupingPanel, {
          evalTask: evalTask
        })];
      }
    }

    class AbstractUsernameAutocomplete extends Dispatchable {
      static requestNewUsers(prefix, callback) {
        Ajax.getJSON(PublicUserStore.fetchURL, {
          usernamePrefix: prefix
        }).then(data => {
          let userIds = (data.state.publicuser || []).map(user => user.id);
          this.usernamePrefixCache.set(prefix, userIds);
          callback(userIds);
        }, () => {});
      }
      static loadUsersForPrefix(prefix, callback) {
        if (!prefix.length) {
          callback([]);
          return;
        }
        if (!this.usernamePrefixCache) {
          this.usernamePrefixCache = new Map();
        }
        if (this.usernamePrefixCache.has(prefix)) {
          callback(this.usernamePrefixCache.get(prefix));
          return;
        }
        for (let i = 1; i < prefix.length; i += 1) {
          let partialPrefix = prefix.substring(0, i);
          if (this.usernamePrefixCache.has(partialPrefix) && this.usernamePrefixCache.get(partialPrefix).length === 0) {
            callback([]);
            return;
          }
        }
        this.requestNewUsers(prefix, callback);
      }
    }
    class AutocompleteWindow extends VolatileFloatingWindow {
      extraNodeAttributes(attr) {
        attr.setStyle("z-index", "9999");
      }
      getDefaultOptions() {
        return {
          direction: Direction.UP,
          userDivHeight: 25,
          maxHeight: 300,
          highlightColor: "rgb(230, 230, 230)"
        };
      }
      setOptions(options) {
        options = Object.assign(this.getDefaultOptions(), options);
        let height = Math.min(options.maxHeight, options.userIds.length * options.userDivHeight);
        options.offsets = getOffset(options.parentNode);
        options.style = Object.assign({
          marginBottom: "5px",
          border: "1px solid black",
          position: "absolute",
          backgroundColor: "white",
          maxHeight: options.maxHeight + "px",
          overflow: "auto",
          boxShadow: "0 6px 12px rgba(0,0,0,.175)",
          top: options.offsets.top - height + "px",
          left: options.offsets.left + "px"
        }, options.style || {});
        if (options.direction === Direction.DOWN) {
          options.style.top = parseInt(options.style.top) + height + parseInt(getComputedStyle(options.parentNode, "height")) + "px";
        }
        super.setOptions(options);
      }
      render() {
        this.userDivs = [];
        for (let userId of this.options.userIds) {
          this.userDivs.push(UI$1.createElement("div", {
            userId: userId,
            style: {
              "padding": "0 5px",
              "border": "1px solid grey",
              "height": this.options.userDivHeight + "px",
              "line-height": this.options.userDivHeight + "px",
              "cursor": "pointer"
            }
          }, UI$1.createElement(UserHandle$1, {
            userId: userId,
            disableClick: true
          })));
        }
        return this.userDivs;
      }
      moveIndex(delta) {
        let index = this.currentIndex;
        index += delta;
        if (index === this.userDivs.length) {
          index -= this.userDivs.length;
        }
        if (index < 0) {
          index += this.userDivs.length;
        }
        this.setCurrentIndex(index);
      }
      getCurrentUserId() {
        return this.userDivs[this.currentIndex].options.userId;
      }
      setCurrentIndex(index) {
        if (this.hasOwnProperty("currentIndex")) {
          this.userDivs[this.currentIndex].setStyle("background-color", "white");
        }
        this.currentIndex = index;
        this.userDivs[this.currentIndex].setStyle("background-color", this.options.highlightColor);
        this.scrollTo(index);
      }
      onMount() {
        this.setCurrentIndex(0);
        for (let i = 0; i < this.userDivs.length; i += 1) {
          this.userDivs[i].addNodeListener("mouseover", () => {
            this.setCurrentIndex(i);
          });
          this.userDivs[i].addClickListener(() => {
            if (this.options.onChooseUser) {
              this.options.onChooseUser(this.getCurrentUserId());
            }
          });
        }
      }
      scrollTo(index) {
        if (this.node && this.options.userDivHeight * this.userDivs.length > this.options.maxHeight) {
          this.node.scrollTop = Math.max(this.node.scrollTop, this.options.userDivHeight * (index + 1) - this.options.maxHeight);
          this.node.scrollTop = Math.min(this.node.scrollTop, this.options.userDivHeight * index);
        }
      }

      // These two methods are here in order to avoid code duplication. The "obj" argument is
      // the class whose method these functions should theoretically be (AtMentionPlugin or UserChoiceField)

      // Called whenever the class has a list of users that should be displayed in an AutocompleteWindow,
      // above the "inputField" DOM Node
      static handleAutocomplete(obj, userIds, inputField) {
        if (obj.autocompleteWindow && obj.autocompleteWindow.node) {
          obj.autocompleteWindow.destroyNode();
        }
        if (userIds.length === 0) {
          obj.duringAutocomplete = false;
          return;
        }
        obj.duringAutocomplete = true;
        obj.autocompleteWindow = AutocompleteWindow.create(document.body, {
          parentNode: inputField,
          userIds: userIds,
          onChooseUser: userId => {
            obj.duringAutocomplete = false;
            obj.autocompleteUser(userId);
          }
        });
      }

      // Called whenever there is a keydown event on the inputField that has a window attached, treats the cases
      // of Enter, Escape and Up/Down arrows, modifying the attached window as needed.
      static handleKeydownEvent(obj, event) {
        if (event.key === "Enter" || event.keyCode === 13) {
          // Enter key
          if (obj.duringAutocomplete) {
            obj.duringAutocomplete = false;
            obj.autocompleteUser(obj.autocompleteWindow.getCurrentUserId());
            event.preventDefault();
          }
        }
        if (event.keyCode === 27) {
          // Escape key
          obj.duringAutocomplete = false;
          obj.dispatch("autocomplete", []);
        }
        if (event.keyCode === 38 || event.keyCode === 40) {
          // Up and down arrows
          if (obj.autocompleteWindow) {
            obj.autocompleteWindow.moveIndex(event.keyCode - 39);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      }
    }
    class UserInputField extends UI$1.Element {
      render() {
        return [UI$1.createElement(TextInput, {
          ref: "usernameInput"
        }), UI$1.createElement(Button$1, {
          ref: "submitButton",
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL,
          icon: "check",
          style: {
            marginLeft: "5px"
          }
        }), UI$1.createElement(TemporaryMessageArea, {
          ref: "errorArea"
        })];
      }
      getUserId() {
        let username = this.usernameInput.getValue();
        for (let user of PublicUserStore.all()) {
          if (user.name === username || user.username === username) {
            return user.id;
          }
        }
        return parseInt(username);
      }
      autocompleteUser(userId) {
        this.usernameInput.setValue(PublicUserStore.get(userId).username);
        this.dispatch("autocomplete", []);
      }
      clear() {
        this.usernameInput.setValue("");
        this.duringAutocomplete = false;
        this.dispatch("autocomplete", []);
      }
      handleChange() {
        let prefix = this.usernameInput.getValue();
        AbstractUsernameAutocomplete.loadUsersForPrefix(prefix, userIds => {
          this.dispatch("autocomplete", userIds);
        });
      }
      onMount() {
        this.usernameInput.addNodeListener("keydown", event => {
          AutocompleteWindow.handleKeydownEvent(this, event);
        });
        this.usernameInput.addNodeListener("input", () => {
          this.handleChange();
        });
        this.addListener("autocomplete", userIds => {
          AutocompleteWindow.handleAutocomplete(this, userIds, this.usernameInput);
        });
        this.submitButton.addClickListener(() => {
          if (this.getUserId()) {
            this.dispatch("user", this.getUserId());
          } else {
            this.errorArea.showMessage("Invalid username. Please try again.");
          }
        });
      }
    }

    var _dec$q, _class$B;
    let TestersTable = (_dec$q = autoredraw(ContestUserStore), _dec$q(_class$B = class TestersTable extends Table {
      getEntries() {
        return ContestUserStore.all().filter(user => user.contestId === this.options.evalTask.defaultContestId);
      }
      removeTester(user) {
        if (!confirm("Are you sure you want to remove the tester having userId " + user.userId + " ?")) {
          return;
        }
        Ajax.postJSON("/contest/external_deregister/", {
          contestId: this.options.evalTask.defaultContestId,
          userId: user.userId
        }).then(ContestUserStore.applyDeleteEvent({
          type: "delete",
          objectId: user.id
        }));
      }
      getDefaultColumns() {
        let numberCellStyle = {
          textAlign: "right"
        };
        return [{
          value: user => UI$1.createElement("span", {
            className: "fa fa-times fa-lg",
            style: {
              color: "red",
              cursor: "pointer"
            },
            onClick: () => this.removeTester(user)
          })
        }, {
          value: (user, index) => index,
          headerName: "#",
          cellStyle: numberCellStyle,
          headerStyle: numberCellStyle
        }, {
          value: user => UI$1.createElement(UserHandle$1, {
            id: user.userId
          }),
          headerName: "User"
        }, {
          value: user => user.totalScore || 0,
          headerName: "Score",
          cellStyle: numberCellStyle,
          headerStyle: numberCellStyle
        }, {
          value: user => user.numSubmissions || 0,
          headerName: "Num submissions",
          cellStyle: numberCellStyle,
          headerStyle: numberCellStyle
        }];
      }
    }) || _class$B);
    class TestersPanel extends Panel {
      getTitle() {
        return "Testers";
      }
      render() {
        const {
          evalTask
        } = this.options;
        const contestLink = "/contest/" + evalTask.defaultContest.name + "/";
        return [UI$1.createElement("h4", null, "Besides the admins, the following people can test this task:"), UI$1.createElement("h5", null, "Link: ", UI$1.createElement(Link, {
          href: location.origin + contestLink,
          value: location.origin + contestLink
        })), UI$1.createElement(TestersTable, {
          evalTask: this.options.evalTask,
          ref: "testersTable"
        }), UI$1.createElement("h4", {
          style: {
            marginTop: "20px"
          }
        }, "Give access to a new user:"), UI$1.createElement(UserInputField, {
          ref: "userInputField"
        })];
      }
      onMount() {
        this.attachListener(this.userInputField, "user", async userId => {
          this.userInputField.clear();
          await Ajax.postJSON("/contest/external_register/", {
            contestId: this.options.evalTask.defaultContestId,
            userId: userId
          });
          this.testersTable.redraw();
        });
      }
    }

    class EditorialPanel extends Panel {
      getTitle() {
        return "Editorial";
      }
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          height: "100%",
          flexDirection: "column"
        });
      }
      render() {
        let evalTask = this.options.evalTask;
        if (evalTask.getHiddenSolutionArticle()) {
          let button;
          if (!evalTask.solutionArticleId) {
            button = UI$1.createElement(Button$1, {
              label: "Publish solution article",
              level: Level.WARNING,
              onClick: () => {
                this.publishSolutionArticle();
              }
            });
          } else {
            button = UI$1.createElement(Button$1, {
              label: "Unpublish solution article",
              level: Level.WARNING,
              onClick: () => {
                this.unpublishSolutionArticle();
              }
            });
          }
          return [UI$1.createElement(ButtonGroup, null, button, UI$1.createElement(Button$1, {
            style: {
              marginLeft: "20px"
            },
            label: "Delete hidden solution article",
            onClick: () => {
              this.deleteHiddenSolutionArticle();
            },
            level: Level.DANGER
          })), UI$1.createElement(ArticleEditor, {
            ref: "solutionEditor",
            articleId: evalTask.hiddenSolutionArticleId,
            style: {
              flex: "1"
            }
          })];
        } else {
          return [UI$1.createElement("h2", null, "The task doesn't have a solution article, click bellow to create one"), UI$1.createElement(Button$1, {
            label: "Create hidden solution article",
            onClick: () => {
              this.createHiddenSolutionArticle();
            }
          })];
        }
      }
      unpublishSolutionArticle() {
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          unpublishSolutionArticle: true
        }).then(() => {
          delete this.options.evalTask.solutionArticleId;
          this.redraw();
        });
      }
      publishSolutionArticle() {
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          publishSolutionArticle: true
        }).then(() => this.redraw());
      }
      createHiddenSolutionArticle() {
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          createHiddenSolutionArticle: true
        }).then(data => {
          this.options.evalTask.hiddenSolutionArticleId = parseInt(data.hiddenSolutionArticleId);
          this.redraw();
        });
      }
      deleteHiddenSolutionArticle() {
        alert("Can't handle this now");
      }
    }

    class TemplateCellEditor extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          boxShadow: "0px 0px 4px #555",
          padding: "10px 2px",
          marginBottom: "5px",
          marginTop: "5px",
          marginLeft: "3px",
          borderRadius: "4px"
        });
      }
      render() {
        let types = [{
          toString: () => "collapsed"
        }, {
          toString: () => "collapsible"
        }, {
          toString: () => "uncollapsible"
        }, {
          toString: () => "editable"
        }];
        let selected = (this.options.initialValue || {
          type: "editable"
        }).type;
        for (let type of types) {
          if (type.toString() === selected) {
            selected = type;
            break;
          }
        }
        return [UI$1.createElement(Select, {
          ref: "typeSelect",
          options: types,
          style: {
            "margin-bottom": "10px",
            "padding": "5px",
            "background-color": "white"
          },
          selected: selected
        }), UI$1.createElement(Button$1, {
          ref: "removeButton",
          level: Level.DANGER,
          icon: "minus",
          style: {
            "display": "inline-block",
            "margin-left": "20px"
          }
        }), UI$1.createElement(CodeEditor, {
          ref: "codeEditor",
          maxLines: 10,
          value: (this.options.initialValue || {
            lines: []
          }).lines.join("\n"),
          fontSize: "15",
          aceMode: this.options.aceMode
        })];
      }
      onMount() {
        super.onMount();
        this.removeButton.addClickListener(() => {
          this.parent.dispatch("removeTemplateElement", this);
          this.options.editor.dispatch("change");
        });
        this.typeSelect.addChangeListener(() => {
          this.options.editor.dispatch("change");
        });
        this.codeEditor.addAceChangeListener(() => {
          setTimeout(() => {
            this.options.editor.dispatch("change");
          });
        });
      }
      getValue() {
        return {
          type: this.typeSelect.get().toString(),
          lines: this.codeEditor.getValue().replace(/\r/, "").split("\n")
        };
      }
    }
    class AddTemplateCellButton extends Button$1 {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          level: Level.SUCCESS,
          icon: "plus"
        });
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          let editor = this.parent;
          let index = editor.addButtons.indexOf(this);
          let language = this.options.editor.options.language;
          let templateEditor = UI$1.createElement(TemplateCellEditor, {
            initialValue: "",
            aceMode: language.aceMode,
            editor: this.options.editor
          });
          let addButton = UI$1.createElement(AddTemplateCellButton, {
            editor: this.options.editor
          });
          templateEditor.mount(editor, this.node);
          addButton.mount(editor, templateEditor.node);
          editor.options.children.splice(2 * index, 0, addButton, templateEditor);
          editor.addButtons.splice(index, 0, addButton);
          editor.templateEditors.splice(index, 0, templateEditor);
        });
      }
    }
    class LanguageTemplateEditor extends UI$1.Element {
      setOptions(options) {
        super.setOptions(options);
        this.templates = this.options.evalTask.enforcedTemplates[this.options.language.id] || [];
      }
      render() {
        this.options.children = [];
        this.templateEditors = [];
        this.addButtons = [];
        let addButton;
        for (let i = 0; i < this.templates.length; i += 1) {
          let templateEditor = UI$1.createElement(TemplateCellEditor, {
            initialValue: this.templates[i],
            aceMode: this.options.language.aceMode,
            editor: this.options.editor
          });
          addButton = UI$1.createElement(AddTemplateCellButton, {
            editor: this.options.editor
          });
          this.addButtons.push(addButton);
          this.templateEditors.push(templateEditor);
          this.options.children.push(addButton);
          this.options.children.push(templateEditor);
        }
        addButton = UI$1.createElement(AddTemplateCellButton, {
          editor: this.options.editor
        });
        this.addButtons.push(addButton);
        this.options.children.push(addButton);
        return this.options.children;
      }
      onMount() {
        super.onMount();
        this.addListener("removeTemplateElement", template => {
          let index = this.templateEditors.indexOf(template);
          let button = this.addButtons[index];
          let templateEditor = this.templateEditors[index];
          this.addButtons.splice(index, 1);
          this.templateEditors.splice(index, 1);
          this.eraseChild(button);
          this.eraseChild(templateEditor);
        });
      }
      getParsedArray() {
        let template = [];
        for (let templateEditor of this.templateEditors) {
          template.push(templateEditor.getValue());
        }
        return template;
      }
    }
    class LanguageTab extends UI$1.Element {
      render() {
        return [UI$1.createElement(LanguageTemplateEditor, {
          style: {
            "width": "50%",
            "padding-right": "10px",
            "float": "left",
            height: "100%",
            overflow: "auto"
          },
          ref: "languageTemplateEditor",
          editor: this,
          evalTask: this.options.evalTask,
          language: this.options.language
        }), UI$1.createElement("div", {
          style: {
            "display": "inline-block",
            "width": "50%",
            "float": "right",
            height: "100%",
            overflow: "hidden"
          }
        }, UI$1.createElement(StaticCodeHighlighter, {
          ref: "codeRenderer",
          fontSize: "15",
          aceMode: this.options.language.aceMode,
          style: {
            height: "100%"
          }
        })), UI$1.createElement("div", {
          style: {
            "clear": "both"
          }
        })];
      }
      getParsedArray() {
        return this.languageTemplateEditor.getParsedArray();
      }
      checkTemplate(evalTask, language) {
        let template = evalTask.enforcedTemplates[language.id] || [];
        if (template.length === 0) {
          return "Empty template!";
        }
        for (let i = 0; i < template.length; i += 1) {
          if (i > 0 && template[i].type === "editable" && template[i - 1].type === "editable") {
            return "There should not be two editable areas in a row!";
          }
          if (template[i].lines.length === 1 && template[i].type !== "editable") {
            return "There should be at least one \\n character in every uneditable area.";
          }
        }
        if (template[0].type === "editable") {
          return "The first block should not be editable";
        }
        if (template[template.length - 1].type === "editable") {
          return "The last block should not be editable";
        }
        return null;
      }
      updateCodeRenderer(evalTask) {
        let session = this.codeRenderer.ace.getSession();
        this.folds = this.folds || [];
        this.foldLines = this.foldLines || [];
        this.markers = this.markers || [];
        if (session.folds) {
          for (let fold of session.folds) {
            session.removeFold(fold);
          }
        }
        for (let marker of this.markers) {
          this.codeRenderer.removeMarker(marker);
        }
        this.folds = [];
        this.markers = [];
        let error = this.checkTemplate(evalTask, this.options.language);
        if (error) {
          this.codeRenderer.setValue(error);
        } else {
          let code = evalTask.getTemplate(this.options.language);
          this.codeRenderer.setValue(code);
          let template = evalTask.enforcedTemplates[this.options.language.id] || [];
          this.ranges = updateAceRanges(template, code, this.markers, this.folds, session);
        }
      }
      updateFoldingMethod() {
        let session = this.codeRenderer.ace.getSession();
        session.on("changeFold", edit => {
          if (!edit.data || this.codeRenderer.getValue() === "") {
            return;
          }
          if (edit.action === "remove") {
            for (let i = 0; i < this.folds.length; i += 1) {
              if (edit.data === this.folds[i]) {
                this.folds[i] = {
                  isFolded: false
                };
                decorateUncollapsed(session, this.ranges[i].start.row);
              }
            }
          }
        });
        this.codeRenderer.ace.on("gutterclick", event => {
          let row = event.getDocumentPosition().row;
          for (let i = 0; i < this.ranges.length; i += 1) {
            if (this.ranges[i].start.row === row) {
              if (this.folds[i] && this.folds[i].isFolded) {
                session.removeFold(this.folds[i]);
                this.folds[i] = {
                  isFolded: false
                };
                decorateUncollapsed(session, this.ranges[i]);
              } else if (this.folds[i] && !this.folds[i].isFolded) {
                const Range = CodeEditor.AceRange;
                this.folds[i] = session.addFold("...", new Range(this.ranges[i].start.row, this.ranges[i].start.column, this.ranges[i].end.row - 1, 10000));
                this.folds[i].isFolded = true;
                decorateCollapsed(session, this.ranges[i]);
              }
            }
          }
        });
      }
      onMount() {
        if (!window.ace) {
          CodeEditor.requireAce(() => {
            this.onMount();
          });
          return;
        }
        let evalTask = this.options.evalTask;
        evalTask.enforcedTemplates = evalTask.enforcedTemplates || {};
        evalTask.enforcedTemplates[this.options.language.id] = this.languageTemplateEditor.getParsedArray();
        this.updateCodeRenderer(evalTask);
        this.updateFoldingMethod();
        this.addListener("change", () => {
          let evalTask = this.options.evalTask;
          evalTask.enforcedTemplates = evalTask.enforcedTemplates || {};
          evalTask.enforcedTemplates[this.options.language.id] = this.languageTemplateEditor.getParsedArray();
          this.updateCodeRenderer(evalTask);
        });
      }
    }
    class TemplatesPanel extends Panel {
      getTitle() {
        return "Templates";
      }
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          flexDirection: "column"
        });
      }
      render() {
        if (this.options.evalTask.hasEnforcedTemplates()) {
          this.languageTabs = [];
          for (let language of ProgrammingLanguage.all()) {
            this.languageTabs.push(UI$1.createElement(LanguageTab, {
              style: {
                "width": "100%",
                height: "100%"
              },
              language: language,
              evalTask: this.options.evalTask
            }));
          }
          return [UI$1.createElement(ButtonGroup, null, UI$1.createElement(Select, {
            ref: "languageSelect",
            options: ProgrammingLanguage.all(),
            style: {
              "margin": "20px",
              "padding": "5px",
              "background-color": "white"
            }
          }), UI$1.createElement(Button$1, {
            ref: "saveButton",
            style: {
              display: "inline-block"
            },
            level: Level.PRIMARY
          }, "Save")), UI$1.createElement(Switcher, {
            ref: "languageSwitcher",
            style: {
              flex: "1",
              height: "100%",
              display: "flex"
            }
          }, this.languageTabs)];
        }
        return [UI$1.createElement("h2", null, "The task doesn't have any enforced templates, click bellow to create them"), UI$1.createElement(Button$1, {
          ref: this.refLink("createButton"),
          label: "Turn task to enforced-template task"
        })];
      }
      save() {
        let json = {};
        for (let languageTab of this.languageTabs) {
          let value = languageTab.getParsedArray();
          if (value.length) {
            json[languageTab.options.language.id] = value;
          }
        }
        this.options.evalTask.enforcedTemplates = json;
        let request = {
          enforcedTemplatesChanged: true,
          enforcedTemplates: JSON.stringify(json)
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => {
          this.saveButton.setLevel(Level.SUCCESS);
          setTimeout(() => {
            this.saveButton.setLevel(Level.PRIMARY);
          }, 1500);
        });
      }
      getChildTab(languageId) {
        for (let languageTab of this.languageTabs) {
          if (languageTab.options.language.id === languageId) {
            return languageTab;
          }
        }
        return null;
      }
      onMount() {
        super.onMount();
        if (this.createButton) {
          this.createButton.addClickListener(() => {
            this.options.evalTask.enforcedTemplates = {};
            this.redraw();
            this.saveButton.addClickListener(() => {
              this.save();
            });
            this.languageSelect.addChangeListener(() => {
              this.languageSwitcher.setActive(this.getChildTab(this.languageSelect.get().id));
            });
          });
        }
        if (this.saveButton) {
          this.saveButton.addClickListener(() => {
            this.save();
          });
          this.languageSelect.addChangeListener(() => {
            this.languageSwitcher.setActive(this.getChildTab(this.languageSelect.get().id));
          });
        }
      }
    }

    function parseTime(time) {
      if (time === "") {
        return 0;
      }
      if (time[time.length - 1] === "s" || time[time.length - 1] === "S") {
        return parseFloat(time.substr(0, time.length - 1)) * 1000;
      }
      return parseFloat(time) || 0;
    }
    function parseMemory(memory) {
      if (memory === "") {
        return 0;
      }
      if (memory.length >= 2 && memory.substring(memory.length - 2, memory.length).toUpperCase() === "MB") {
        return 1024 * parseFloat(memory.substring(0, memory.length - 2));
      }
      return parseFloat(memory) || 0;
    }
    class ComputedTimeSpan extends UI$1.Element {
      getNodeType() {
        return "span";
      }
      getComputedTime() {
        let evalTask = this.options.evalTask;
        let language = this.options.language;
        let limits = evalTask.programmingLanguageLimits || {};
        let defaultTime;
        let limitsPanel = this.options.table.options.ref.parent;
        if (limitsPanel.timeLimitInput) {
          defaultTime = parseTime(limitsPanel.timeLimitInput.getValue()) || 0;
        } else {
          defaultTime = evalTask.timeLimit;
        }
        let timeRatio;
        let timeRatioInput = this.options.table["timeRatio" + language.id];
        if (timeRatioInput && timeRatioInput.wasChanged) {
          timeRatio = parseFloat(timeRatioInput.getValue());
        } else if (limits[language.id] && limits[language.id].timeRatio) {
          timeRatio = limits[language.id].timeRatio;
        } else if (language.timeRatio) {
          timeRatio = language.timeRatio;
        } else {
          timeRatio = 1;
        }
        let extraTime;
        let extraTimeInput = this.options.table["extraTime" + language.id];
        if (extraTimeInput && extraTimeInput.wasChanged) {
          extraTime = parseTime(extraTimeInput.getValue());
        } else if (limits[language.id] && limits[language.id].extraTime) {
          extraTime = limits[language.id].extraTime;
        } else if (language.extraTime) {
          extraTime = language.extraTime;
        } else {
          extraTime = 0;
        }
        return defaultTime * timeRatio + extraTime + "ms";
      }
      render() {
        return this.getComputedTime();
      }
    }
    class ComputedMemorySpan extends UI$1.Element {
      getNodeType() {
        return "span";
      }
      getComputedMemory() {
        let language = this.options.language;
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};
        let defaultMemory;
        let limitsPanel = this.options.table.options.ref.parent;
        if (limitsPanel.memoryLimitInput) {
          defaultMemory = parseMemory(limitsPanel.memoryLimitInput.getValue()) || 0;
        } else {
          defaultMemory = evalTask.memoryLimit;
        }
        let extraMemory;
        let extraMemoryInput = this.options.table["extraMemory" + language.id];
        if (extraMemoryInput && extraMemoryInput.wasChanged) {
          extraMemory = parseMemory(extraMemoryInput.getValue());
        } else if (limits[language.id] && limits[language.id].extraMemory) {
          extraMemory = limits[language.id].extraMemory;
        } else if (language.extraMemory) {
          extraMemory = language.extraMemory;
        } else {
          extraMemory = 0;
        }
        return defaultMemory + extraMemory + "kb";
      }
      render() {
        return this.getComputedMemory();
      }
    }
    class LimitsPerLanguageRow extends TableRow {
      onMount() {
        let table = this.options.parent;
        let checkbox = table["save" + this.options.entry.id];
        if (checkbox.node.checked) {
          this.setStyle("background-color", "#87ACCC");
        }
        checkbox.addChangeListener(() => {
          if (checkbox.node.checked) {
            this.setStyle("background-color", "#87ACCC");
          } else {
            this.setStyle("background-color", "");
          }
        });
      }
    }
    class LimitsPerLanguageTable extends Table {
      getRowClass() {
        return LimitsPerLanguageRow;
      }
      getEntryKey(entry, index) {
        return index;
      }
      getEntries() {
        return ProgrammingLanguage.all();
      }
      getExtraMemory(id) {
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};
        if (limits[id] && limits[id]["extraMemory"]) {
          return [limits[id]["extraMemory"], true];
        }
        return [0, false];
      }
      getExtraTime(id) {
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};
        if (limits[id] && limits[id]["extraTime"]) {
          return [limits[id]["extraTime"], true];
        }
        return [0, false];
      }
      getTimeRatio(id) {
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};
        if (limits[id] && limits[id]["timeRatio"]) {
          return [limits[id]["timeRatio"], true];
        }
        return [1, false];
      }
      getDefaultColumns() {
        // TODO @cleanup simplify like other tables
        const numberStyle = {
          textAlign: "center"
        };
        return [{
          value: entry => {
            let checked = false;
            if (this.getExtraMemory(entry.id)[1] || this.getExtraTime(entry.id)[1] || this.getTimeRatio(entry.id)[1]) {
              checked = true;
            }
            return UI$1.createElement(RawCheckboxInput, {
              ref: this.refLink("save" + entry.id),
              checked: checked
            });
          },
          headerName: "Save to DB",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.name,
          headerName: "Language",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            let ratio, wasChanged;
            [ratio, wasChanged] = this.getTimeRatio(entry.id);
            let bgColor = "";
            if (wasChanged) {
              bgColor = "rgba(255,190,0,0.8)";
            }
            let timeRatioField = UI$1.createElement(TextInput, {
              ref: this.refLink("timeRatio" + entry.id),
              value: ratio,
              style: {
                "background-color": bgColor
              }
            });
            timeRatioField.wasChanged = wasChanged;
            return timeRatioField;
          },
          headerName: "Time limit ratio",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            let extraTime, wasChanged;
            [extraTime, wasChanged] = this.getExtraTime(entry.id);
            let bgColor = "";
            if (wasChanged) {
              bgColor = "rgba(255,190,0,0.8)";
            }
            let extraTimeField = UI$1.createElement(TextInput, {
              ref: this.refLink("extraTime" + entry.id),
              value: extraTime,
              style: {
                "background-color": bgColor
              }
            });
            extraTimeField.wasChanged = wasChanged;
            return extraTimeField;
          },
          headerName: "Extra time",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => UI$1.createElement(ComputedTimeSpan, {
            ref: this.refLink("computedTime" + entry.id),
            table: this,
            language: entry,
            evalTask: this.options.evalTask
          }),
          headerName: "Computed Time",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            let extraMemory, wasChanged;
            [extraMemory, wasChanged] = this.getExtraMemory(entry.id);
            let bgColor = "";
            if (wasChanged) {
              bgColor = "rgba(255,190,0,0.8)";
            }
            let extraMemoryField = UI$1.createElement(TextInput, {
              ref: this.refLink("extraMemory" + entry.id),
              value: extraMemory,
              style: {
                "background-color": bgColor
              }
            });
            extraMemoryField.wasChanged = wasChanged;
            return extraMemoryField;
          },
          headerName: "Extra memory",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => UI$1.createElement(ComputedMemorySpan, {
            ref: this.refLink("computedMemory" + entry.id),
            table: this,
            language: entry,
            evalTask: this.options.evalTask
          }),
          headerName: "Computed Memory",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }];
      }
    }
    class LimitsPanel extends Panel {
      getTitle() {
        return "Limits";
      }
      render() {
        let evalTask = this.options.evalTask;
        return [UI$1.createElement("div", {
          style: {
            padding: "20px"
          }
        }, UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          ref: "timeLimit",
          label: "Default Time Limit"
        }, UI$1.createElement(TextInput, {
          ref: "timeLimitInput",
          value: evalTask.timeLimit
        })), UI$1.createElement(FormField, {
          ref: "memoryLimit",
          label: "Default Memory Limit"
        }, UI$1.createElement(TextInput, {
          ref: "memoryLimitInput",
          value: evalTask.memoryLimit
        })))), UI$1.createElement(LimitsPerLanguageTable, {
          ref: "limitsTable",
          evalTask: evalTask
        }), UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement(Button$1, {
          ref: "saveLimitsButton",
          level: Level.PRIMARY,
          label: "Save changes",
          onClick: () => {
            this.saveChanges();
          }
        }), UI$1.createElement(TemporaryMessageArea, {
          ref: "saveStatus"
        }))];
      }
      saveChanges() {
        let timeLimit = parseTime(this.timeLimitInput.getValue());
        let memoryLimit = parseMemory(this.memoryLimitInput.getValue());
        if (timeLimit >= 30000 || memoryLimit >= 1024 * 8192) {
          this.saveStatus.showMessage("Failed, invalid default limits!", "red");
          return;
        }
        let limits = {};
        let languages = ProgrammingLanguage.all();
        for (let language of languages) {
          if (!this.limitsTable["save" + language.id].node.checked) {
            continue;
          }
          let timeRatioField = this.limitsTable["timeRatio" + language.id];
          let timeRatio = parseTime(timeRatioField.getValue());
          let extraTimeField = this.limitsTable["extraTime" + language.id];
          let extraTime = parseTime(extraTimeField.getValue());
          let extraMemoryField = this.limitsTable["extraMemory" + language.id];
          let extraMemory = parseMemory(extraMemoryField.getValue());
          if (timeLimit * timeRatio + extraTime >= 30000 || memoryLimit + extraMemory >= 1024 * 8192) {
            this.saveStatus.showMessage("Failed, invalid limits for " + language.name, "red");
            return;
          }
          limits[language.id] = {};
          if (extraTimeField.wasChanged) {
            limits[language.id].extraTime = extraTime;
          }
          if (extraMemoryField.wasChanged) {
            limits[language.id].extraMemory = extraMemory;
          }
          if (timeRatioField.wasChanged) {
            limits[language.id].timeRatio = timeRatio;
          }
          if (Object.keys(limits[language.id]).length === 0) {
            delete limits[language.id];
          }
        }
        let request = {
          limitsChanged: true,
          timeLimit: timeLimit,
          memoryLimit: memoryLimit,
          programmingLanguageLimits: JSON.stringify(limits)
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => this.saveStatus.showMessage("Limits changed"), error => this.saveStatus.showMessage(error.message, "red"));
      }
      onMount() {
        let table = this.limitsTable;
        for (let language of ProgrammingLanguage.all()) {
          table["timeRatio" + language.id].addNodeListener("input", () => {
            table["timeRatio" + language.id].wasChanged = true;
            table["timeRatio" + language.id].setStyle("background-color", "rgba(255,190,0,0.8");
            table["computedTime" + language.id].redraw();
          });
          table["extraTime" + language.id].addNodeListener("input", () => {
            table["extraTime" + language.id].wasChanged = true;
            table["extraTime" + language.id].setStyle("background-color", "rgba(255,190,0,0.8");
            table["computedTime" + language.id].redraw();
          });
          table["extraMemory" + language.id].addNodeListener("input", () => {
            table["extraMemory" + language.id].wasChanged = true;
            table["extraMemory" + language.id].setStyle("background-color", "rgba(255,190,0,0.8");
            table["computedMemory" + language.id].redraw();
          });
        }
        this.timeLimitInput.addNodeListener("input", () => {
          for (let language of ProgrammingLanguage.all()) {
            table["computedTime" + language.id].redraw();
          }
        });
        this.memoryLimitInput.addNodeListener("input", () => {
          for (let language of ProgrammingLanguage.all()) {
            table["computedMemory" + language.id].redraw();
          }
        });
      }
    }

    class ReevalModal extends ActionModal {
      getActionName() {
        return "Re-eval";
      }
      getCloseName() {
        return "Cancel";
      }
      getTitle() {
        return "Are you sure you want to re-evaluate ALL jobs?";
      }
      getMessage() {
        return "Aprox. number of jobs: " + EvalJobStore.jobCount;
      }
      getBody() {
        return [this.getMessage(), UI.createElement("div", null, "Programming Language: ", UI.createElement(Select, {
          options: ["-----", ...ProgrammingLanguage.all()],
          ref: "languageSelect"
        }))];
      }
      action() {
        const request = {
          evalTaskId: this.options.evalTask.id,
          job: "all"
        };
        const programmingLanguage = this.languageSelect.get();
        if (programmingLanguage.id) {
          request.programmingLanguageId = programmingLanguage.id;
        }
        Ajax.postJSON("/eval/reeval/", request).then(data => this.hide(), error => this.messageArea.showMessage(error.message, "red", 4000));
      }
    }
    const ReevalButton = ActionModalButton(ReevalModal);
    class ReevalDoneModal extends Modal {
      render() {
        return "All " + this.options.jobCount + " submissions have been enqueued successfully.";
      }
    }

    class EditSubmissionCommentModal extends ActionModal {
      getDefaultOptions() {
        return {
          ...super.getDefaultOptions(),
          closeButton: true,
          actionName: "Edit metadata"
        };
      }
      getBody() {
        const {
          evalJob
        } = this.options;
        return [UI.createElement("h2", null, "Comment"), UI.createElement(MarkupEditor, {
          ref: this.refLink("markupEditor"),
          showButtons: false,
          value: evalJob.comment,
          style: {
            height: 200
          }
        }), UI.createElement("div", null, "Expected result: ", UI.createElement(TextInput, {
          ref: "expectedResultInput",
          placeholder: "For ex. 100 or * or g1,g2",
          initialValue: evalJob.expectedResult
        }))];
      }
      async action() {
        const request = {
          evalJobId: this.options.evalJob.id,
          comment: this.markupEditor.getValue(),
          expectedResult: this.expectedResultInput.getValue()
        };
        try {
          const response = await Ajax.postJSON("/eval/edit_eval_job_comment/", request);
          this.hide();
        } catch (error) {
          this.messageArea.showMessage("Failed to save: " + error, "red", 8000);
        }
      }
    }

    var _class$A;
    function expectedResultMatches(evalJob) {
      const {
        expectedResult
      } = evalJob;
      if (expectedResult?.trim() === "*") {
        return evalJob.score === 1.0;
      }
      if (isNumericString(expectedResult, true)) {
        const expectedScore = parseFloat(expectedResult) / 100;
        return Math.abs(expectedScore - evalJob.score) < 1e-3;
      }

      // This must be a group notation
      const evalTask = evalJob.getEvalTask();
      const allTests = [...evalTask.exampleTests, ...evalTask.systemTests];
      const allTestIds = new Set(allTests.map(test => test.index));
      const testGroups = toArray(evalTask.testGrouping);
      let expectedDescription;
      try {
        // Build test groups just like in the group editor validation
        const previouslyParsedGroups = [];
        testGroups.forEach((testGroup, index) => {
          index = index + 1;
          const result = parseTestRanges(testGroup.testRanges, allTestIds, index, previouslyParsedGroups);
          result.index = index;
          previouslyParsedGroups.push(result);
        });
        expectedDescription = parseTestRanges(expectedResult, allTestIds, testGroups.length + 1, previouslyParsedGroups, true);
        if (expectedDescription.explicitTestIds.size) {
          throw "Can't define explicit tests";
        }
        if (expectedDescription.groupIds.size === 0) {
          throw "No groups identified";
        }
      } catch (error) {
        console.warn("Invalid expectedResult", expectedResult, error);
        return null;
      }
      for (let index = 1; index <= testGroups.length; index++) {
        const testGroup = testGroups[index - 1];
        const tests = evalJob.getAllTests(testGroup);
        if (!tests?.length) {
          return null;
        }
        const pointsReceived = testGroup.pointsWorth * Math.min(...tests.map(test => test.checkerScore || 0));
        if (pointsReceived > 0 && pointsReceived < testGroup.pointsWorth) {
          console.warn("Can't do expected with partial points per group");
          return false;
        }
        const groupPassed = pointsReceived > 0;
        if (groupPassed !== expectedDescription.groupIds.has(index)) {
          return false;
        }
      }
      return true;
    }
    let SubmissionSummaryWithReeval = autoredraw(_class$A = class SubmissionSummaryWithReeval extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("display", "flex");
      }
      renderPreparationMetadata() {
        const {
          evalJob
        } = this.options;
        const {
          comment,
          expectedResult
        } = evalJob;
        const expectedResultVerdict = expectedResult && expectedResultMatches(evalJob);
        if (!comment && !expectedResult) {
          return null;
        }
        return UI$1.createElement("div", {
          style: {
            display: "inline-block",
            margin: "8px 0 -16px 0"
          }
        }, comment && UI$1.createElement(MarkupRenderer, {
          value: comment
        }), expectedResult && UI$1.createElement("div", null, "Expected Result: ", expectedResult, " ", expectedResultVerdict != null ? expectedResultVerdict ? "" : "" : "[Invalid value]"));
      }
      render() {
        const {
          evalJob
        } = this.options;
        return [UI$1.createElement("div", {
          style: {
            margin: "8px",
            marginTop: "5px"
          }
        }, UI$1.createElement(Button$1, {
          onClick: () => {
            if (evalJob.getStatus() === EvalJob.Status.DONE) {
              Ajax.postJSON("/eval/reeval/", {
                evalTaskId: evalJob.evalTaskId,
                job: evalJob.id
              });
            }
          },
          style: {
            height: "100%"
          },
          icon: "rotate-left"
        })), UI$1.createElement("div", {
          style: {
            display: "inline-block"
          }
        }, this.renderPreparationMetadata(), UI$1.createElement("div", {
          style: {
            display: "flex"
          }
        }, UI$1.createElement(SubmissionSummary, {
          key: evalJob.id,
          evalJob: evalJob,
          hideTaskName: true
        }), UI$1.createElement(Button$1, {
          icon: "edit",
          onClick: () => EditSubmissionCommentModal.show({
            evalJob
          }),
          style: {
            margin: "auto auto auto 6px",
            height: "fit-content"
          },
          size: Size.SMALL
        })))];
      }
    }) || _class$A;
    class SubmissionSummaryPanelWithReeval extends SubmissionSummaryPanel {
      getSubmissionSummary(evalJob) {
        return UI$1.createElement(SubmissionSummaryWithReeval, {
          evalJob: evalJob,
          key: evalJob.id
        });
      }
      fetchEvalJobs(requestCount) {
        super.fetchEvalJobs(true);
      }
    }
    class SubmissionsPanel extends Panel {
      getTitle() {
        return "Submissions";
      }
      render() {
        return [UI$1.createElement("div", null, UI$1.createElement(ReevalButton, {
          modalOptions: {
            evalTask: this.options.evalTask
          },
          style: {
            margin: "15px",
            marginLeft: "8px"
          },
          level: Level.WARNING
        }, "Re-eval all submissions"), UI$1.createElement("div", {
          style: {
            display: "inline-flex",
            alignItems: "center"
          }
        }, UI$1.createElement(ToggleInput, {
          ref: "onlyWithCommentsInput",
          initialValue: false,
          onChange: value => {
            this.submissionPanel.editFilters({
              onlyWithComments: value
            });
          },
          style: {
            margin: 6
          }
        }), " Show only labeled submissions")), UI$1.createElement(SubmissionSummaryPanelWithReeval, {
          ref: "submissionPanel",
          filters: {
            evalTaskId: this.options.evalTask.id,
            onlyWithComments: this.onlyWithCommentsInput?.getValue()
          }
        })];
      }
      onMount() {
        GlobalState$1.registerStream("evaljobs");
        this.attachListener(EvalJobStore, "reevalDone", event => {
          if (event.data.evalTaskId === this.options.evalTask.id) {
            ReevalDoneModal.show({
              jobCount: event.data.jobCount
            });
          }
        });
      }
    }

    class PreviewPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center",
          paddingTop: "10px"
        });
      }
      getTitle() {
        return "Preview";
      }
      render() {
        return UI$1.createElement(ContestTaskPanel, {
          style: {
            textAlign: "initial"
          },
          enableSubrouter: false,
          contestTaskId: this.options.evalTask.defaultContestTaskId
        });
      }
      onMount() {
        super.onMount();
        this.addListener("show", () => {
          this.redraw();
        });
      }
    }

    var _class$z;
    const haveLoadedMarkedJobs = new Map();
    async function EnsureMarkedJobsLoaded(evalTask) {
      haveLoadedMarkedJobs.set(evalTask, false);
      const request = {
        numJobs: 200,
        evalTaskId: evalTask.id,
        requestCount: false,
        onlyWithComments: true
      };
      try {
        await Ajax.getJSON("/eval/get_eval_jobs/", request);
        haveLoadedMarkedJobs.set(evalTask, true);
      } catch (error) {
        haveLoadedMarkedJobs.set(evalTask, error);
      }
      evalTask.dispatchChange();
    }
    function ExpectedResultsAreOk(evalTask) {
      if (!haveLoadedMarkedJobs.has(evalTask)) {
        EnsureMarkedJobsLoaded(evalTask).then();
      }
      const loadResult = haveLoadedMarkedJobs.get(evalTask);
      if (!loadResult) {
        IssueSummary.warn("Still loading jobs");
        return "Loading...";
      }
      if (loadResult !== true) {
        IssueSummary.error("Failed to load sources");
        return "???";
      }
      const evalJobs = EvalJobStore.filterBy({
        evalTaskId: evalTask.id
      }).filter(evalJob => evalJob.expectedResult);
      if (evalJobs.length === 0) {
        IssueSummary.warn("There are no sources with an expected result");
      }
      const invalidJobs = new Set();
      for (const evalJob of evalJobs) {
        if (!expectedResultMatches(evalJob)) {
          invalidJobs.add(evalJob);
        }
      }
      if (invalidJobs.size > 0) {
        IssueSummary.error(`There are ${invalidJobs.size} source(s) where the expected result differs from the score`);
      }

      // TODO warn if only a single author has full score

      return `${evalJobs.length} sources checked`;
    }
    function TotalTestSize(evalTask) {
      const allTests = [].concat(evalTask.exampleTests, evalTask.systemTests);
      let totalInput = 0,
        totalOutput = 0;
      for (const test of allTests) {
        totalInput += test.inputSize;
        totalOutput += test.outputSize;
      }
      const totalSize = totalInput + totalOutput;
      if (totalSize >= 10 << 20) {
        IssueSummary.warn("Huge test size, do you really need it?");
      }
      if (totalSize === 0) {
        IssueSummary.error("There doesn't seem to be any test data");
      }
      return formatBytes(totalInput + totalOutput);
    }
    function MaximumEvaluationDuration(evalTask) {
      const allTests = [].concat(evalTask.exampleTests, evalTask.systemTests);
      const numTests = allTests.length;
      let minMemory = null,
        minTime = null;
      let maxMemory = 0,
        maxTime = 0;
      for (const programmingLanguage of ProgrammingLanguage.all()) {
        const langId = programmingLanguage.id;
        const memLimit = evalTask.getMemoryLimit(langId);
        const timeLimit = evalTask.getTimeLimit(langId);
        if (minMemory == null || memLimit < minMemory) {
          minMemory = memLimit;
        }
        if (minTime == null || timeLimit < minTime) {
          minTime = timeLimit;
        }
        if (memLimit > maxMemory) {
          maxMemory = memLimit;
        }
        if (timeLimit > maxTime) {
          maxTime = timeLimit;
        }
      }
      const minTestDuration = new Duration(minTime * numTests);
      const maxTestDuration = new Duration(maxTime * numTests);
      if (maxTestDuration.getSeconds() > 300) {
        IssueSummary.error("Evaluation can take a damn long time!");
      } else if (minTestDuration.getSeconds() > 60 || maxTestDuration.getSeconds() > 120) {
        IssueSummary.warn("Evaluation can take a long time");
      }
      return [UI.createElement("div", null, "Max eval duration: ", minTestDuration, " - ", maxTestDuration), UI.createElement("div", null, "Max memory: ", formatBytes(minMemory * 1024), " - ", formatBytes(maxMemory * 1024))];
    }
    let TaskChecklistPanel = autoredraw(_class$z = class TaskChecklistPanel extends Panel {
      getTitle() {
        return "Checklist";
      }
      render() {
        const {
          evalTask
        } = this.options;
        const columns = [["Check", entry => entry[0]], ["Value", entry => entry[1]], ["Recommendation", entry => entry[2]]];
        const checks = [["Expected scores match", ExpectedResultsAreOk],
        // ["Official implementation asserts something", "Warn: validate all the constraints"],
        ["Total test size", TotalTestSize], ["Maximum limits (over all languages)", MaximumEvaluationDuration]];
        const entries = checks.map(check => {
          const [title, checkFunc] = check;
          IssueSummary.clear();
          const value = checkFunc(evalTask);
          return [title, value, IssueSummary.render()];
        });
        return [UI.createElement(Table, {
          columns: columns,
          entries: entries
        })];
      }
    }) || _class$z;

    class TaskFileUploadPanel extends Panel {
      getTitle() {
        return "File Upload";
      }
      render() {
        this.options;
        return UI$1.createElement("div", null, "Configure file upload globally to allow per task.");
      }
    }

    var _class$y, _descriptor$g, _descriptor2$g, _dec$p, _class2$i;
    let EvalTaskEditorTabAreaStyle = (_class$y = class EvalTaskEditorTabAreaStyle extends MinimalistTabAreaStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "activeTab", _descriptor$g, this);
        _initializerDefineProperty(this, "tab", _descriptor2$g, this);
      }
    }, (_descriptor$g = _applyDecoratedDescriptor(_class$y.prototype, "activeTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "rgba(51,122,183,1)",
          borderTop: "1px solid rgba(51,122,183,1) !important",
          borderLeft: "1px solid rgba(51,122,183,1) !important",
          borderRight: "1px solid rgba(51,122,183,1) !important",
          borderTopLeftRadius: "7px",
          borderTopRightRadius: "7px",
          backgroundColor: "rgba(51, 122, 183, 0.15)"
        };
      }
    }), _descriptor2$g = _applyDecoratedDescriptor(_class$y.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.2em"
        };
      }
    })), _class$y);
    let EvalTaskEditorTabArea = (_dec$p = registerStyle(EvalTaskEditorTabAreaStyle), _dec$p(_class2$i = class EvalTaskEditorTabArea extends TabArea {
      getTitleArea(tabTitles) {
        for (let tabTitle of tabTitles) {
          tabTitle.options.style = {
            flex: 1,
            textAlign: "center"
          };
        }
        return UI$1.createElement("div", {
          ref: "titleArea",
          className: this.styleSheet.nav,
          style: {
            display: "flex",
            borderBottom: "1px solid rgba(51,122,183,1) !important"
          }
        }, tabTitles);
      }
    }) || _class2$i);
    class EvalTaskEditor extends UI$1.Element {
      getLocations() {
        return [["general", GeneralPanel], ["statement", StatementPanel], ["preview", PreviewPanel], ["tests", EditTestsPanel], ["editorial", EditorialPanel], ["limits", LimitsPanel], ["templates", TemplatesPanel], ["submissions", SubmissionsPanel], ["testers", TestersPanel], ["checklist", TaskChecklistPanel], ["file-upload", TaskFileUploadPanel]];
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "100%",
          display: "flex",
          flexDirection: "column"
        });
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      getEvalTask() {
        return EvalTaskStore.all().find(evalTask => evalTask.urlName === Router.parseURL()[1]);
      }
      getUrlPrefix(urlPart) {
        let url = "/task/" + this.getEvalTask().urlName + "/edit/";
        if (urlPart) {
          url += urlPart + "/";
        }
        return url;
      }
      render() {
        const evalTask = this.getEvalTask();
        const panels = this.getLocations().map(([location, PanelClass]) => UI$1.createElement(PanelClass, {
          evalTask: evalTask,
          ref: location + "Panel",
          tabHref: this.getUrlPrefix(location),
          style: {
            height: "100%"
          }
        }));
        return [UI$1.createElement("h2", null, "Task \"", evalTask.longName, "\" (id=", evalTask.id, ")"), UI$1.createElement(EvalTaskEditorTabArea, {
          style: {
            flex: "1"
          }
        }, panels)];
      }
      setURL(urlParts) {
        // check if it's not loaded
        if (!this.generalPanel) {
          this.initialUrlParts = urlParts;
          return;
        }
        const urlPart = urlParts[0] || "general";
        if (this[urlPart + "Panel"]) {
          this[urlPart + "Panel"].dispatch("show");
        } else {
          Router.changeURL(this.getUrlPrefix());
        }
      }
      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
        const evalTask = this.getEvalTask();
        GlobalState$1.registerStream("contest-" + evalTask.defaultContestId + "-scores");
        GlobalState$1.registerStream("contest-" + evalTask.defaultContestId + "-announcements");
        GlobalState$1.registerStream("contest-" + evalTask.defaultContestId + "-scoreevents");
      }
    }

    var _dec$o, _class$x;
    class WorkspaceNameSpan extends UI$1.Element {
      onMount() {
        this.button.addClickListener(() => {
          this.options.ref.parent.dispatch("changeWorkspace", this.options.workspace);
        });
        this.remove.addClickListener(() => {
          this.options.ref.parent.dispatch("removeWorkspace", this.options.workspace);
        });
      }
      highlight() {
        this.options.highlighted = true;
        this.button.setLevel(Level.SUCCESS);
      }
      unhighlight() {
        this.options.highlighted = false;
        this.button.setLevel(Level.INFO);
      }
      render() {
        const {
          workspace
        } = this.options;
        return [UI$1.createElement(Button$1, {
          ref: "remove",
          icon: "minus",
          style: {
            display: "inline-block",
            marginRight: 5
          },
          level: Level.DANGER
        }), UI$1.createElement(Button$1, {
          level: this.options.highlighted ? Level.SUCCESS : Level.INFO,
          size: Size.EXTRA_SMALL,
          ref: "button",
          style: {
            "font-size": "1.4em",
            "display": "inline-block"
          }
        }, "Workspace ", workspace.name || "Anonymous", " ID ", workspace.id, " UserID ", workspace.userId)];
      }
    }
    class InlineCheckerEditor extends CollapsiblePanel {
      getTitle() {
        return this.options.checker.name || "No name checker";
      }
      render() {
        const {
          checker
        } = this.options;
        const children = [];
        for (let workspace of this.options.checker.getWorkspaces()) {
          children.push(UI$1.createElement(WorkspaceNameSpan, {
            ref: "workspace-" + workspace.id,
            style: {
              "margin": "20px"
            },
            workspace: workspace
          }));
        }
        const deleteChecker = async () => {
          // TODO: this should prompt us for something
          await Ajax.postJSON("/eval/checker/delete", {
            "checkerId": this.options.checker.id
          });
        };
        return [UI$1.createElement("div", {
          style: {
            "width": "40%",
            "display": "inline-block"
          },
          ref: "workspaceListArea"
        }, children, UI$1.createElement("div", {
          style: {
            "margin-top": "10px"
          },
          ref: "addWorkspaceArea"
        }, UI$1.createElement(Button$1, {
          ref: "addWorkspaceButton",
          level: Level.PRIMARY,
          icon: "plus",
          style: {
            "margin-left": "20px"
          }
        }), UI$1.createElement(TextInput, {
          placeholder: "id",
          ref: "newWorkspaceId",
          style: {
            "padding-left": "5px",
            "margin-left": "5px"
          }
        })), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          onClick: deleteChecker,
          label: "Delete Checker",
          level: Level.DANGER
        })), UI$1.createElement("div", null, UI$1.createElement(Link, {
          href: `/eval/checker/${checker.id}`
        }, "Go to new checker editor"))), UI$1.createElement("div", {
          ref: "workspaceArea",
          style: {
            "width": "55%",
            "margin-left": "5%",
            "height": "400px",
            "display": "inline-block",
            "float": "right"
          }
        }, UI$1.createElement(Switcher, {
          ref: "workspaceSwitcher",
          style: {
            "height": "100%"
          }
        }, UI$1.createElement("div", {
          ref: "emptyWorkspaceChild"
        })))];
      }
      async linkWorkspace(id) {
        await Ajax.postJSON("/eval/checker/edit", {
          "operation": "addWorkspace",
          "checkerId": this.options.checker.id,
          "workspaceId": id
        });
        this.redraw();
      }
      async unlinkWorkspace(id) {
        await Ajax.postJSON("/eval/checker/edit", {
          "operation": "removeWorkspace",
          "checkerId": this.options.checker.id,
          "workspaceId": id
        });
        this.redraw();
        this.workspaceSwitcher.setActive(this.emptyWorkspaceChild);
      }
      onMount() {
        this.workspaceIDEMap = new Map();
        this.addWorkspaceButton.addClickListener(() => {
          let id = parseInt(this.newWorkspaceId.getValue());
          if (!isNaN(id) && id) {
            this.linkWorkspace(id);
          }
        });
        this.addListener("changeWorkspace", workspace => {
          if (!this.workspaceIDEMap.has(workspace)) {
            this.workspaceIDEMap.set(workspace, UI$1.createElement(WorkspaceIDE, {
              workspace: workspace,
              plugins: PluginTypes.CHECKER,
              key: Math.random()
            }));
            this.workspaceSwitcher.appendChild(this.workspaceIDEMap.get(workspace));
          }
          this.workspaceSwitcher.setActive(this.workspaceIDEMap.get(workspace));
          for (let workspace2 of this.options.checker.getWorkspaces()) {
            if (workspace2 === workspace) {
              this["workspace-" + workspace2.id].highlight();
            } else {
              this["workspace-" + workspace2.id].unhighlight();
            }
          }
        });
        this.addListener("removeWorkspace", workspace => {
          this.unlinkWorkspace(workspace.id);
        });
      }
    }
    class AddCheckerModal extends ActionModal {
      getActionName() {
        return "New Checker";
      }
      getBody() {
        return [UI$1.createElement("div", {
          style: {
            "display": "inline-block",
            "margin-right": "10px"
          }
        }, "Checker Name:"), UI$1.createElement(TextInput, {
          placeholder: "name",
          ref: "nameInputArea",
          style: {
            "padding-left": "5px"
          }
        })];
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: this.getCloseName(),
          onClick: () => this.hide(),
          style: {
            "margin-right": "10px"
          }
        }), ",", this.getActionButton())];
      }
      action() {
        Ajax.postJSON("/eval/checker/create", {
          "name": this.nameInputArea.getValue()
        }).then(() => {
          this.hide();
          Dispatcher.Global.dispatch("newChecker");
        });
      }
    }
    let AddCheckerButton = ActionModalButton(AddCheckerModal);
    class CachebustModal extends ActionModal {
      getActionName() {
        return "Bust Eval Cache";
      }
      getBody() {
        return "Are you sure? This action may take a long time";
      }
      action() {
        Ajax.postJSON("/eval/checker/cache_bust/", {});
      }
    }
    let CachebustButton = ActionModalButton(CachebustModal);
    let CheckerManager = (_dec$o = autoredraw(TaskCheckerStore), _dec$o(_class$x = class CheckerManager extends UI$1.Element {
      render() {
        const checkers = TaskCheckerStore.all();
        checkers.sort((a, b) => {
          return b.id - a.id;
        });
        return [UI$1.createElement(AddCheckerButton, {
          ref: this.refLink("addChecker"),
          level: Level.SUCCESS,
          style: {
            "margin-left": "30px"
          }
        }, "New Checker"), UI$1.createElement(CachebustButton, {
          ref: this.refLink("cachebustButton"),
          level: Level.DANGER,
          style: {
            "display": "inline-block",
            "margin-left": "20px"
          }
        }, "Bust Eval Cache"), checkers.map(checker => UI$1.createElement(InlineCheckerEditor, {
          checker: checker,
          ref: "checker" + checker.id,
          style: {
            "margin": "30px"
          }
        }))];
      }
    }) || _class$x);

    function computeDFSCoordsUndirected(graph, startNode = null) {
      let box = graph.getBox();
      let finalCoords = new Map();
      let visited = new Set();
      let subtreeWidth = new Map();
      let level = new Map();
      let sons = new Map();
      const marginUp = 30;
      const marginDown = 80;
      let buildDfsTree = (node, father = -1) => {
        // Calculate the level of current node
        if (father === -1) {
          level.set(node, 0);
        } else {
          level.set(node, level.get(father) + 1);
        }

        // Go through the incident edges to find node's sons
        sons.set(node, []);
        visited.add(node);
        let edges = node.getIncidentEdges();
        for (let i = 0; i < edges.length; i += 1) {
          let neighbour = edges[i].getTarget() === node ? edges[i].getSource() : edges[i].getTarget();

          // If it's a son, call recursively
          if (!visited.has(neighbour)) {
            sons.get(node).push(neighbour);
            buildDfsTree(neighbour, node);
          }
        }
      };
      let computeSubtreeWidth = node => {
        subtreeWidth.set(node, 0);

        // Width of a subtree is the sum of widths of the root's sons
        let currentSons = sons.get(node);
        for (let i = 0; i < currentSons.length; i += 1) {
          computeSubtreeWidth(currentSons[i]);
          subtreeWidth.set(node, subtreeWidth.get(node) + subtreeWidth.get(currentSons[i]));
        }

        // Leaf: width = 1
        if (subtreeWidth.get(node) === 0) {
          subtreeWidth.set(node, 1);
        }
      };
      let computeFinalX = (node, leftX, rightX) => {
        if (!finalCoords.has(node)) {
          finalCoords.set(node, {});
        }
        // Place node at the center of its given interval
        finalCoords.get(node).x = (leftX + rightX) / 2;

        // Assign to each son an interval proportional to its width
        let unitLen = (rightX - leftX) / subtreeWidth.get(node);
        let sonLeftX = leftX;
        let currentSons = sons.get(node);
        for (let i = 0; i < currentSons.length; i += 1) {
          computeFinalX(currentSons[i], sonLeftX, sonLeftX + unitLen * subtreeWidth.get(currentSons[i]));
          sonLeftX += unitLen * subtreeWidth.get(currentSons[i]);
        }
      };
      let computeFinalY = () => {
        // Calculate the depth of the lowest node of the tree
        let depth = 1;
        for (let i = 0; i < graph.nodes.length; i += 1) {
          depth = Math.max(depth, 1 + level.get(graph.nodes[i]));
        }

        // Calculate the space I can leave between two levels of nodes
        let levelDiff;
        if (depth > 1) {
          levelDiff = (box.height - marginUp - marginDown) / (depth - 1);
        } else {
          levelDiff = 0;
        }

        // Assign the y of every node proportional to its level
        for (let i = 0; i < graph.nodes.length; i += 1) {
          let node = graph.nodes[i];
          if (!finalCoords.has(node)) {
            finalCoords.set(node, {});
          }
          finalCoords.get(node).y = box.y + marginUp + levelDiff * level.get(node);
        }
      };

      // Simulate a DFS to build the tree
      if (startNode) {
        buildDfsTree(startNode);

        // Calculate the maximum number of vertices on any level
        // of a node's subtree
        computeSubtreeWidth(startNode);

        // Compute the final coordinates of the nodes
        computeFinalX(startNode, box.x, box.x + box.width);
      } else {
        let treeWidth = 0;
        let roots = [];
        for (let i = 0; i < graph.nodes.length; i += 1) {
          if (!visited.has(graph.nodes[i])) {
            buildDfsTree(graph.nodes[i]);
            computeSubtreeWidth(graph.nodes[i]);
            treeWidth += subtreeWidth.get(graph.nodes[i]);
            roots.push(graph.nodes[i]);
          }
        }
        let unitLen = box.width / treeWidth;
        let sonLeftX = box.x;
        for (let root of roots) {
          let sonRightX = sonLeftX + unitLen * subtreeWidth.get(root);
          computeFinalX(root, sonLeftX, sonRightX);
          sonLeftX = sonRightX;
        }
      }
      computeFinalY();
      return finalCoords;
    }
    function computeDFSCoordsDirected(graph, startNode = null, target = {}) {
      let box = graph.getBox();
      let finalCoords = new Map();
      let visited = new Set();
      let subtreeWidth = new Map();
      let level = new Map();
      let sons = new Map();
      target.nodeFathers = new Map();
      const marginUp = 30;
      const marginDown = 80;

      // Build the same tree as the DFS Player
      let buildDfsTree = (node, father = -1) => {
        if (father === -1) {
          level.set(node, 0);
        } else {
          level.set(node, level.get(father) + 1);
          target.nodeFathers.set(node, father);
        }
        sons.set(node, []);
        visited.add(node);
        let edges = node.getIncidentEdges();
        for (let i = 0; i < edges.length; i += 1) {
          if (edges[i].getTarget() === node) {
            continue;
          }
          let neighbour = edges[i].getTarget();
          if (!visited.has(neighbour)) {
            sons.get(node).push(neighbour);
            buildDfsTree(neighbour, node);
          }
        }
      };
      let computeSubtreeWidth = node => {
        subtreeWidth.set(node, 0);
        let currentSons = sons.get(node);
        for (let i = 0; i < currentSons.length; i += 1) {
          computeSubtreeWidth(currentSons[i]);
          subtreeWidth.set(node, subtreeWidth.get(node) + subtreeWidth.get(currentSons[i]));
        }
        if (subtreeWidth.get(node) === 0) {
          subtreeWidth.set(node, 1);
        }
      };
      let computeFinalX = (node, leftX, rightX) => {
        if (!finalCoords.has(node)) {
          finalCoords.set(node, {});
        }
        finalCoords.get(node).x = (leftX + rightX) / 2;
        let unitLen = (rightX - leftX) / subtreeWidth.get(node);
        let sonLeftX = leftX;
        let currentSons = sons.get(node);
        for (let i = 0; i < currentSons.length; i += 1) {
          computeFinalX(currentSons[i], sonLeftX, sonLeftX + unitLen * subtreeWidth.get(currentSons[i]));
          sonLeftX += unitLen * subtreeWidth.get(currentSons[i]);
        }
      };
      let computeFinalY = () => {
        let depth = 1;
        for (let i = 0; i < graph.nodes.length; i += 1) {
          depth = Math.max(depth, 1 + level.get(graph.nodes[i]));
        }
        let levelDiff;
        if (depth > 1) {
          levelDiff = (box.height - marginUp - marginDown) / (depth - 1);
        } else {
          levelDiff = 0;
        }
        for (let i = 0; i < graph.nodes.length; i += 1) {
          let node = graph.nodes[i];
          if (!finalCoords.has(node)) {
            finalCoords.set(node, {});
          }
          finalCoords.get(node).y = box.y + marginUp + levelDiff * level.get(node);
        }
      };
      target.roots = [];
      let treeWidth = 0;
      for (let i = 0; i < graph.nodes.length; i += 1) {
        if (!visited.has(graph.nodes[i])) {
          target.roots.push(graph.nodes[i]);
          buildDfsTree(graph.nodes[i]);
        }
      }
      for (let i = 0; i < target.roots.length; i += 1) {
        computeSubtreeWidth(target.roots[i]);
        treeWidth += subtreeWidth.get(target.roots[i]);
      }
      let unitLen = box.width / treeWidth;
      let sonLeftX = box.x;

      // Get the x coordinates of each root's subtree
      for (let i = 0; i < target.roots.length; i += 1) {
        let sonRightX = sonLeftX + unitLen * subtreeWidth.get(target.roots[i]);
        computeFinalX(target.roots[i], sonLeftX, sonRightX);
        sonLeftX = sonRightX;
      }

      // Compute each node's y coordinate
      computeFinalY();
      return finalCoords;
    }

    var _dec$n, _class$w;
    class GraphCodeEditor extends CodeEditor {
      onDelayedMount() {
        super.onDelayedMount();
        this.setAceRendererOption("showLineNumber", false);
      }
    }
    class GraphInputPanel extends Panel {
      setOptions(options) {
        super.setOptions(options);
        this.nodes = new Map();
        this.edges = new Map();
      }
      getNodeString(node) {
        return node.getLabel();
      }
      getEdgeString(edge) {
        return edge.getSource().getLabel() + " " + edge.getTarget().getLabel() + (edge.getLabel() ? " " + edge.getLabel() : "");
      }
      addNode(node) {
        if (this.nodes.has(node)) {
          return;
        }
        let line = 0;
        for (let value of this.nodes.values()) {
          for (let otherLine of value) {
            line = Math.max(otherLine + 1, line);
          }
        }
        this.nodes.set(node, [line]);
        if (line === 0) {
          this.graphDataEditor.append(this.getNodeString(node) + "\n");
        } else {
          this.graphDataEditor.insertAtLine(line, "\n" + this.getNodeString(node));
        }
        for (let edge of this.edges.keys()) {
          if (this.edges.get(edge) >= line) {
            this.edges.set(edge, this.edges.get(edge) + 1);
          }
        }
        for (let otherNode of this.nodes.keys()) {
          if (otherNode !== node) {
            let lines = this.nodes.get(otherNode);
            for (let i = 0; i < lines.length; i += 1) {
              if (lines[i] >= line) {
                lines[i] += 1;
              }
            }
          }
        }
        this.nodeCountEditor.setValue(this.graph.nodes.length.toString());
      }
      addEdge(edge) {
        let line = 0;
        for (let value of this.edges.values()) {
          line = Math.max(line, value + 1);
        }
        for (let value of this.nodes.values()) {
          for (let otherLine of value) {
            line = Math.max(otherLine + 1, line);
          }
        }
        this.edges.set(edge, line);
        this.graphDataEditor.append(this.getEdgeString(edge) + "\n");
      }
      deleteNode(node) {
        if (!this.nodes.has(node)) {
          return;
        }
        let lines = this.nodes.get(node);
        for (let line of lines) {
          for (let edge of this.edges.keys()) {
            if (this.edges.get(edge) >= line) {
              this.edges.set(edge, this.edges.get(edge) - 1);
            }
          }
          for (let otherNode of this.nodes.keys()) {
            if (otherNode !== node) {
              let otherNodeLines = this.nodes.get(otherNode);
              for (let i = 0; i < otherNodeLines.length; i += 1) {
                if (otherNodeLines[i] >= line) {
                  otherNodeLines[i] -= 1;
                }
              }
            }
          }
          this.graphDataEditor.removeLine(line);
        }
        this.nodes.delete(node);
        this.nodeCountEditor.setValue(this.graph.nodes.length.toString());
      }
      deleteEdge(edge) {
        if (!this.edges.has(edge)) {
          return;
        }
        let line = this.edges.get(edge);
        for (let otherEdge of this.edges.keys()) {
          if (this.edges.get(otherEdge) >= line) {
            this.edges.set(otherEdge, this.edges.get(otherEdge) - 1);
          }
        }
        for (let lines of this.nodes.values()) {
          for (let i = 0; i < lines.length; i += 1) {
            if (lines[i] >= line) {
              lines[i] -= 1;
            }
          }
        }
        this.graphDataEditor.removeLine(line);
        this.edges.delete(edge);
      }
      changeNodeLabel(node) {
        let lines = this.nodes.get(node) || [];
        for (let line of lines) {
          this.graphDataEditor.replaceLine(line, this.getNodeString(node) + "\n");
        }
        for (let edge of node.getIncidentEdges()) {
          let edgeLine = this.edges.get(edge);
          this.graphDataEditor.replaceLine(edgeLine, this.getEdgeString(edge) + "\n");
        }
      }
      changeEdgeLabel(edge) {
        let line = this.edges.get(edge);
        if (!line) {
          return;
        }
        this.graphDataEditor.replaceLine(line, this.getEdgeString(edge) + "\n");
      }
      setNewData(data) {
        this.nodes.clear();
        this.edges.clear();
        let lines = data.split("\n");
        let getGraphData = () => {
          let annotations = [];
          let userNodes = [];
          let userEdges = [];
          for (let index = 0; index < lines.length; index += 1) {
            let dataString = lines[index];
            let graphElements;
            let sourceLabel, targetLabel, costLabel;
            try {
              graphElements = consoleTokenizer(dataString);
            } catch (message) {
              if (typeof message === "string") {
                annotations.push({
                  row: index,
                  column: 1,
                  text: message,
                  type: "error"
                });
              }
            }
            if (graphElements == null) {
              continue;
            }
            sourceLabel = graphElements.length >= 1 ? graphElements[0] : null;
            targetLabel = graphElements.length >= 2 ? graphElements[1] : null;
            costLabel = graphElements.length >= 3 ? graphElements[2] : "";
            if (graphElements.length === 1) {
              if (userNodes.indexOf(sourceLabel) === -1) {
                userNodes.push(sourceLabel);
              }
            } else if (graphElements.length === 2 || graphElements.length === 3) {
              // Self loops are not allowed
              if (sourceLabel == targetLabel) {
                continue;
              }
              // Add source label in user nodes set
              if (userNodes.indexOf(sourceLabel) === -1) {
                userNodes.push(sourceLabel);
              }
              // Add target label in user nodes set
              if (userNodes.indexOf(targetLabel) === -1) {
                userNodes.push(targetLabel);
              }

              // Insert the edge in edge array
              userEdges.push({
                source: sourceLabel,
                target: targetLabel,
                cost: costLabel
              });
            } else if (graphElements.length > 3) {
              annotations.push({
                row: index,
                column: 1,
                text: "No more than 4 elements allowed",
                type: "error"
              });
            }
          }
          this.graphDataEditor.setAnnotations(annotations);
          return [userNodes, userEdges];
        };
        let deleteBadEdges = edges => {
          // Use a copy, as elements will be deleted from userEdges array to allow multiple edges support.
          let userEdgesCopy = [...edges];

          // Find the graph edges that should be deleted
          for (let i = 0; i < this.graph.edges.length; i += 1) {
            let edge = this.graph.edges[i];
            let sourceLabel = edge.getSource().getLabel();
            let targetLabel = edge.getTarget().getLabel();
            let costLabel = edge.getLabel();
            let edgeExists = false;

            // Check if the edge exists and insert it in the bad edges array if it doesn't
            for (let j = 0; j < userEdgesCopy.length; j += 1) {
              if (sourceLabel == userEdgesCopy[j].source && targetLabel == userEdgesCopy[j].target && costLabel === userEdgesCopy[j].cost) {
                edgeExists = true;
                userEdgesCopy.splice(j, 1);
                break;
              }
            }
            if (!edgeExists) {
              this.graph.removeEdge(edge);
              i -= 1;
            }
          }
        };
        let deleteBadNodes = nodes => {
          // Find the graph nodes that should be deleted
          for (let i = 0; i < this.graph.nodes.length; i += 1) {
            let node = this.graph.nodes[i];
            let nodeExists = false;

            // Check if the node exists
            for (let j = 0; j < nodes.length; j += 1) {
              if (node.getLabel() == nodes[j]) {
                nodeExists = true;
                break;
              }
            }
            if (!nodeExists) {
              this.graph.removeNode(node);
              i -= 1;
            }
          }
        };
        let createNewNodes = nodes => {
          for (let nodeString of nodes) {
            let nodeExists = false;
            // Check if the node exists
            for (let node of this.graph.nodes) {
              if (nodeString == node.getLabel()) {
                nodeExists = true;
                break;
              }
            }
            if (!nodeExists) {
              this.graph.addNode(UI$1.createElement(GraphNode, {
                data: {
                  label: nodeString
                }
              }));
            }
          }
        };
        let createNewEdges = edges => {
          let edgeArrayCopy = [...this.graph.edges];
          for (let edge of edges) {
            // Check if the edge exists
            let appears = false;
            for (let i = 0; i < edgeArrayCopy.length; i += 1) {
              if (edge.source == edgeArrayCopy[i].getSource().getLabel() && edge.target == edgeArrayCopy[i].getTarget().getLabel() && edge.cost == edgeArrayCopy[i].getLabel()) {
                edgeArrayCopy.splice(i, 1);
                appears = true;
                break;
              }
            }
            if (!appears) {
              let sourceIndex, targetIndex;
              // Find index of the source
              for (let i = 0; i < this.graph.nodes.length; i += 1) {
                if (this.graph.nodes[i].getLabel() == edge.source) {
                  sourceIndex = i;
                }
                if (this.graph.nodes[i].getLabel() == edge.target) {
                  targetIndex = i;
                }
              }
              // Create the new edge
              this.graph.addEdge(UI$1.createElement(GraphEdge, {
                data: {
                  source: sourceIndex,
                  target: targetIndex
                },
                label: edge.cost,
                directed: this.graph.isDirected()
              }));
            }
          }
        };

        // Set the view mode to force to allow smooth creation/deletion of elements
        this.graph.enterDrawMode();
        let graphData = getGraphData(),
          nodes,
          edges;
        if (!graphData) {
          nodes = edges = [];
        } else {
          nodes = graphData[0];
          edges = graphData[1];
        }
        deleteBadEdges(edges);
        deleteBadNodes(nodes);
        createNewNodes(nodes);
        createNewEdges(edges);
        this.graph.removeListeners();
        this.graph.enterForceMode();

        // Update the node count input
        this.nodeCountEditor.setValue(this.graph.nodes.length.toString());

        // Recalculate the nodes and edges lines
        for (let i = 0; i < lines.length; i += 1) {
          let tokens;
          try {
            tokens = consoleTokenizer(lines[i]);
          } catch (message) {
            continue;
          }
          if (tokens.length === 0) {
            continue;
          }
          if (tokens.length === 1) {
            for (let node of this.graph.nodes) {
              if (node.getLabel().toString() == tokens[0]) {
                if (!this.nodes.has(node)) {
                  this.nodes.set(node, []);
                }
                this.nodes.get(node).push(i);
              }
            }
          } else {
            for (let edge of this.graph.edges) {
              if (tokens[0] != edge.getSource().getLabel()) {
                continue;
              }
              if (tokens[1] != edge.getTarget().getLabel()) {
                continue;
              }
              if (tokens.length === 3 && tokens[2] != edge.getLabel()) {
                continue;
              }
              if (this.edges.has(edge)) {
                continue;
              }
              this.edges.set(edge, i);
              break;
            }
          }
        }
      }
      onMount() {
        this.nodeCountEditor.setReadOnly(true);
        this.nodeCountEditor.setAceOptions({
          autoScrollEditorIntoView: false,
          highlightActiveLine: false
        });
        this.addListener("changeInput", data => {
          this._selfChanged = true;
          switch (data.type) {
            case "newNode":
              this.addNode(data.node);
              break;
            case "newEdge":
              this.addEdge(data.edge);
              break;
            case "deleteNode":
              for (let edge of data.node.getIncidentEdges()) {
                this.deleteEdge(edge);
              }
              this.deleteNode(data.node);
              break;
            case "deleteEdge":
              this.deleteEdge(data.edge);
              break;
            case "changeNodeLabel":
              this.changeNodeLabel(data.node);
              break;
            case "changeEdgeLabel":
              this.changeEdgeLabel(data.edge);
              break;
          }
          this._selfChanged = false;
        });
        this._timeout = null;
        this.graphDataEditor.addAceSessionChangeListener(() => {
          /// If the change is created by editing the graph
          if (this._selfChanged) {
            return;
          }
          this.graph.pauseForce();
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          this._timeout = setTimeout(() => {
            this.setNewData(this.graphDataEditor.getValue());
            this._timeout = null;
          }, 500);
        });
      }
      render() {
        return [UI$1.createElement("label", null, " Node Count: "), UI$1.createElement(GraphCodeEditor, {
          ref: "nodeCountEditor",
          value: "",
          style: {
            width: "100%",
            height: "17px"
          }
        }), UI$1.createElement("label", null, " Graph Data: "), UI$1.createElement(GraphCodeEditor, {
          ref: "graphDataEditor",
          value: "",
          style: {
            width: "100%",
            height: "300px"
          }
        })];
      }
    }
    let GraphEditorLegend = (_dec$n = registerStyle(DropdownListStyle), _dec$n(_class$w = class GraphEditorLegend extends Panel {
      render() {
        return [UI$1.createElement("div", {
          ref: "Force"
        }, UI$1.createElement("h4", null, "Force mode"), UI$1.createElement("p", null, "In this mode, there is a gravitation pull that acts on the nodes and keeps them in the center of the drawing area. Also, the nodes exert a force on each other, making the whole graph look and act like real objects in space."), UI$1.createElement("p", null, "Ways you can interact with the graph:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, "Nodes support drag and drop."), UI$1.createElement("li", null, "At the end of the drop the node becomes fixed."), UI$1.createElement("li", null, "You can fix/unfix a node by simple click."))), UI$1.createElement("div", {
          ref: "Draw"
        }, UI$1.createElement("h4", null, "Draw mode"), UI$1.createElement("p", null, "This mode allows you to draw new nodes and/or edges."), UI$1.createElement("p", null, "Ways you can interact with the graph:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, "Clicking anywhere on the graph canvas creates a new node."), UI$1.createElement("li", null, "Clicking on a node starts the drawing process of a new edge."), UI$1.createElement("li", null, "To cancel the new edge, click anywhere on the canvas."), UI$1.createElement("li", null, "To finish drawing the edge, click on the desired neighbour."))), UI$1.createElement("div", {
          ref: "Edit"
        }, UI$1.createElement("h4", null, "Edit mode"), UI$1.createElement("p", null, "This mode allows you to edit nodes' labels and edges' costs."), UI$1.createElement("p", null, "Ways you can interact with the graph:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, "Click on a node label to change it. Now you can start typing in order to edit the label. Click anywhere or press Enter to finish editing."), UI$1.createElement("li", null, "Click on an edge to change it's cost. Now you can start typing in order to edit the cost. Click anywhere or press Enter to finish editing."))), UI$1.createElement("div", {
          ref: "Delete"
        }, UI$1.createElement("h4", null, "Delete mode"), UI$1.createElement("p", null, "This mode allows you to delete nodes and/or edges."), UI$1.createElement("p", null, "Ways you can interact with the graph:"), UI$1.createElement("ul", null, UI$1.createElement("li", null, "Click on a node to delete it"), UI$1.createElement("li", null, "Click on an edge to delete it."))), UI$1.createElement("div", {
          ref: "Config",
          style: {
            "padding-left": "20px"
          }
        }, UI$1.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI$1.createElement("div", {
          HTMLtitle: "Set the size of nodes",
          className: "fa fa-question-circle",
          style: {
            "margin-right": "3px"
          }
        }, " "), UI$1.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Node radius:"), UI$1.createElement(NumberInput, {
          ref: "nodeSize",
          min: "3",
          max: "25",
          value: "19",
          style: {
            display: "inline-block",
            width: "30%",
            "padding-left": "3px"
          }
        })), UI$1.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI$1.createElement("div", {
          HTMLtitle: "How much nodes connected by an edge attract each other",
          className: "fa fa-question-circle",
          style: {
            "margin-right": "3px"
          }
        }, " "), UI$1.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Edge ideal length:"), UI$1.createElement(NumberInput, {
          ref: "edgeIdealLength",
          min: "40",
          max: "200",
          value: "140",
          style: {
            display: "inline-block",
            width: "30%",
            "padding-left": "3px"
          }
        })), UI$1.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Node background:"), UI$1.createElement(Select, {
          ref: "nodeFillSelect",
          options: ["white", "red", "blue", "black", "purple", "orange", "green"]
        })), UI$1.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Node color:"), UI$1.createElement(Select, {
          ref: "nodeStrokeSelect",
          selected: "black",
          options: ["white", "red", "blue", "black", "purple", "orange", "green"]
        })), UI$1.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Edge color:"), UI$1.createElement(Select, {
          ref: "edgeColorSelect",
          selected: "black",
          options: ["white", "red", "blue", "black", "purple", "orange", "green"]
        })), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          ref: "runCommandButton",
          level: Level.INFO,
          style: {
            "border-radius": "0"
          }
        }, "Run Command"), UI$1.createElement("div", {
          ref: "commandsList",
          style: {
            width: "8.2em"
          },
          className: `${this.styleSheet.default} hidden`
        }, UI$1.createElement("div", {
          ref: "fixAllNodesButton"
        }, "Fix all nodes"), UI$1.createElement("div", {
          ref: "unfixAllNodesButton"
        }, "Unfix all nodes"), UI$1.createElement("div", {
          ref: "treeButton"
        }, "Arrange as tree"))))];
      }
      showMode() {
        this.Force.hide();
        this.Draw.hide();
        this.Edit.hide();
        this.Delete.hide();
        this.Config.hide();
        this[this.options.viewMode].show();
      }
      onMount() {
        this.showMode();
        this.addListener("changeLegend", value => {
          this.options.viewMode = value;
          this.showMode();
        });
        this.nodeSize.addNodeListener("change", () => {
          this.graph.dispatch("changeNodeRadius", parseInt(this.nodeSize.getValue()));
        });
        this.edgeIdealLength.addNodeListener("change", () => {
          this.graph.dispatch("changeEdgeIdealLength", parseInt(this.edgeIdealLength.getValue()));
        });
        this.nodeFillSelect.addNodeListener("change", () => {
          this.graph.dispatch("changeNodeFill", this.nodeFillSelect.get());
        });
        this.nodeStrokeSelect.addNodeListener("change", () => {
          this.graph.dispatch("changeNodeStroke", this.nodeStrokeSelect.get());
        });
        this.edgeColorSelect.addNodeListener("change", () => {
          this.graph.dispatch("changeEdgeColor", this.edgeColorSelect.get());
        });
        this.runCommandButton.addClickListener(() => {
          this.commandsList.toggleClass("hidden");
        });
        this.treeButton.addClickListener(() => {
          this.graph.dispatch("viewTree");
        });
        this.fixAllNodesButton.addClickListener(() => {
          for (let node of this.graph.nodes) {
            node.setFixed(true);
          }
        });
        this.unfixAllNodesButton.addClickListener(() => {
          for (let node of this.graph.nodes) {
            node.setFixed(false);
          }
          this.graph.runForces();
        });
      }
    }) || _class$w);
    class EditableGraph extends Graph {
      setOptions(options) {
        options.nodeRadius = GraphNode.prototype.getDefaultOptions().circleAttr.radius;
        super.setOptions(options);
      }
      removeListeners() {
        for (let node of this.nodes) {
          node.removeClickListener(node.click);
          if (this.mode === "Edit" || this.mode === "Draw") {
            node.addClickListener(node._fixNodeCallback);
          }
        }
        for (let edge of this.edges) {
          edge.removeClickListener(edge.click);
        }
        if (this.mode === "Draw") {
          this.parent.removeClickListener(this.parent.click);
        }
      }
      enterForceMode() {
        this.mode = "Force";
        this.unpauseForce();
      }
      enterDrawMode() {
        this.mode = "Draw";
        this.pauseForce();
        let nodeClickFunc = node => {
          for (let otherNode of this.nodes) {
            otherNode.removeClickListener(otherNode.click);
          }
          // start an edge draw
          let line = UI$1.createElement(SVG.Line, {
            x1: node.x,
            x2: node.x,
            y1: node.y,
            y2: node.y
          });
          line.mount(this.parent, this.node);
          let offsets = this.parent.node.getBoundingClientRect();
          let moveLine = event => {
            if (line.node) {
              line.setAttribute("x2", Device.getEventX(event) - offsets.left);
              line.setAttribute("y2", Device.getEventY(event) - offsets.top);
            }
          };
          window.addEventListener("mousemove", moveLine);
          let finishEdgeDraw = event => {
            for (let target of this.nodes) {
              if (target !== node && (event.target === target.circle.node || event.target === target.label.node)) {
                let edge = this.addEdge(UI$1.createElement(GraphEdge, {
                  data: {
                    source: this.nodes.indexOf(node),
                    target: this.nodes.indexOf(target)
                  },
                  directed: this.isDirected()
                }));
                this.dispatch("changeInput", {
                  type: "newEdge",
                  edge: edge
                });
                break;
              }
            }
            this.parent.removeClickListener(finishEdgeDraw);
            window.removeEventListener("mousemove", moveLine);
            line.destroyNode();
            for (let otherNode of this.nodes) {
              otherNode.addClickListener(otherNode.click);
            }
          };
          this.parent.addClickListener(finishEdgeDraw);
        };
        this.parent.click = event => {
          if (event.target !== this.parent.node) {
            return;
          }
          let offsets = this.parent.node.getBoundingClientRect();
          let node = this.addNode(UI$1.createElement(GraphNode, {
            data: {
              center: {
                x: Device.getEventX(event) - offsets.left,
                y: Device.getEventY(event) - offsets.top
              },
              label: this.getNextLabel()
            }
          }));
          node.removeClickListener(node._fixNodeCallback);
          node.click = () => {
            nodeClickFunc(node);
          };
          node.addClickListener(node.click);
          this.dispatch("changeInput", {
            type: "newNode",
            node: node
          });
        };
        this.parent.addClickListener(this.parent.click);
        for (let node of this.nodes) {
          node.removeClickListener(node._fixNodeCallback);
          node.click = () => {
            nodeClickFunc(node);
          };
          node.addClickListener(node.click);
        }
      }
      enterEditMode() {
        this.mode = "Edit";
        this.pauseForce();
        for (let node of this.nodes) {
          node.click = () => {
            let oldLabel = node.getLabel();
            node.setLabel("");
            this.dispatch("needTextArea", {
              coords: node.getCenter(),
              initialValue: oldLabel,
              target: node
            });
            node.addListener("doneEditing", value => {
              for (let otherNode of this.nodes) {
                if (otherNode !== node && otherNode.getLabel() == value) {
                  value = this.getNextLabel();
                  break;
                }
              }
              node.setLabel(value);
              this.dispatch("changeInput", {
                type: "changeNodeLabel",
                node: node
              });
            });
          };
          node.addClickListener(node.click);
          node.removeClickListener(node._fixNodeCallback);
        }
        for (let edge of this.edges) {
          edge.click = event => {
            event.stopPropagation();
            event.preventDefault();
            if (edge._clicked) {
              return;
            }
            edge._clicked = true;
            setTimeout(() => {
              edge._clicked = false;
            }, 20);
            let oldLabel = edge.getLabel() || "";
            edge.setLabel("");
            this.dispatch("needTextArea", {
              coords: {
                x: edge.costLabel.getX(),
                y: edge.costLabel.getY()
              },
              initialValue: oldLabel,
              target: edge
            });
            edge.addListener("doneEditing", value => {
              edge.setLabel(value);
              this.dispatch("changeInput", {
                type: "changeEdgeLabel",
                edge: edge
              });
            });
          };
          edge.addClickListener(edge.click);
        }
      }
      enterDeleteMode() {
        this.mode = "Delete";
        this.pauseForce();
        for (let node of this.nodes) {
          node.click = () => {
            this.dispatch("changeInput", {
              type: "deleteNode",
              node: node
            });
            this.removeNode(node);
          };
          node.addClickListener(node.click);
        }
        for (let edge of this.edges) {
          edge.click = () => {
            this.dispatch("changeInput", {
              type: "deleteEdge",
              edge: edge
            });
            this.removeEdge(edge);
          };
          edge.addClickListener(edge.click);
        }
      }
      dispatchInitialGraphData() {
        for (let node of this.nodes) {
          this.dispatch("changeInput", {
            type: "newNode",
            node: node
          });
        }
        for (let edge of this.edges) {
          this.dispatch("changeInput", {
            type: "newEdge",
            edge: edge
          });
        }
        this.unpauseForce();
      }
      onMount() {
        super.onMount();
        this.addListener("resize", () => {
          let oldHeight = this.getBox().height,
            oldWidth = this.getBox().width;
          this.setBox({
            x: 20,
            y: 20,
            height: this.parent.getHeight() - 40,
            width: this.parent.getWidth() - 40
          });
          this.options.gravityCenterXPercentage = 0.5;
          this.options.gravityCenterYPercentage = 0.5;
          this.options.gravityCenter = {
            x: this.parent.getWidth() / 2,
            y: this.parent.getHeight() / 2
          };
          for (let node of this.nodes) {
            node.setCenter({
              x: node.getCenter().x * this.getBox().width / oldWidth,
              y: node.getCenter().y * this.getBox().height / oldHeight
            });
          }
        });
        this.enterForceMode();
        this.addListener("changeViewMode", view => {
          if (this.mode === view) {
            return;
          }
          this.removeListeners();
          switch (view) {
            case "Force":
              this.enterForceMode();
              break;
            case "Draw":
              this.enterDrawMode();
              break;
            case "Edit":
              this.enterEditMode();
              break;
            case "Delete":
              this.enterDeleteMode();
          }
        });
        this.addListener("changeDirected", value => {
          if (value === "directed") {
            this.setDirected(true);
          } else {
            this.setDirected(false);
          }
        });
        this.addListener("changeIndexType", value => {
          this.options.indexType = value;
          this.populateNodeData();
          for (let i = 0; i < this.nodes.length; i += 1) {
            this.nodes[i].setLabel(this.options.nodes[i].label);
            this.dispatch("changeInput", {
              type: "changeNodeLabel",
              node: this.nodes[i]
            });
          }
        });
        this.addListener("changeNodeRadius", value => {
          value = Math.max(value, 3);
          value = Math.min(value, 30);
          this.setNodeRadius(value);
        });
        this.addListener("changeEdgeIdealLength", value => {
          value = Math.max(value, 40);
          this.setIdealEdgeDistance(value);
        });
        this.addListener("changeNodeFill", value => {
          this.options.nodeFill = value;
          for (let node of this.nodes) {
            node.setInnerColor(value);
          }
        });
        this.addListener("changeNodeStroke", value => {
          this.options.nodeStroke = value;
          for (let node of this.nodes) {
            node.setColor(value);
          }
        });
        this.addListener("changeEdgeColor", value => {
          this.options.edgeColor = value;
          for (let edge of this.edges) {
            edge.setColor(value);
          }
        });
        this.addListener("viewTree", () => {
          let coords = this.getDFSCoords();
          for (let node of this.nodes) {
            node.setFixed(true);
            node.setCenter(coords.get(node));
          }
        });
      }
      getDFSCoords() {
        if (this.isDirected()) {
          return computeDFSCoordsDirected(this);
        }
        return computeDFSCoordsUndirected(this);
      }
      setNodeRadius(value) {
        this.options.nodeRadius = value;
        for (let node of this.nodes) {
          node.setRadius(value);
        }
      }
      setIdealEdgeDistance(value) {
        this.options.idealEdgeDistance = value;
        this.runForces();
      }
      getNextLabel() {
        let v = [];
        for (let node of this.nodes) {
          v.push(parseInt(node.getLabel()));
        }
        let start = 1;
        if (this.getIndexType() === "0") {
          start = 0;
        }
        for (let i = start;; i += 1) {
          if (v.indexOf(i) === -1) {
            return i;
          }
        }
      }
    }
    class GraphEditor extends UI$1.Element {
      onMount() {
        setTimeout(() => {
          this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
          // dispatching the original graph data
          this.graph.dispatchInitialGraphData();
        }, 0);
        window.addEventListener("resize", () => {
          this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
        });
        this.inputPanel.graph = this.graph;
        this.editorLegend.graph = this.graph;

        // toggle buttons (Directed/Undirected, IndexType, View Mode)
        this.toggleDirected.addListener("setIndex", event => {
          this.graph.dispatch("changeDirected", event.value.toLocaleLowerCase());
        });
        this.toggleIndexType.addListener("setIndex", event => {
          if (event.value === "0-index") {
            event.value = "0";
          } else if (event.value === "1-index") {
            event.value = "1";
          } else if (event.value === "Custom Labels") {
            event.value = "custom";
          }
          this.graph.dispatch("changeIndexType", event.value);
        });
        this.toggleViewMode.addListener("setIndex", event => {
          this.editorLegend.dispatch("changeLegend", event.value);
          if (event.value === "Config") {
            event.value = "Force";
          }
          this.graph.dispatch("changeViewMode", event.value);
        });

        // in edit mode, the graph may request a text area
        // since the SVG cannot have a text input child
        // the text area must come from here
        this.graph.addListener("needTextArea", data => {
          if (this._editing) {
            this._editTarget.dispatch("doneEditing", this.textArea.getValue());
          }
          this._editing = true;
          this._editTarget = data.target;
          this.textArea.setStyle("display", "inline");
          this.textArea.setStyle("left", data.coords.x - 10 + "px");
          this.textArea.setStyle("top", data.coords.y - 10 + "px");
          this.textArea.setValue(data.initialValue);
          this.textArea.node.focus();
          this.textArea.node.select();
          let finishEvent = () => {
            data.target.dispatch("doneEditing", this.textArea.getValue());
            this.textArea.setStyle("display", "none");
            this.textArea.removeNodeListener("keypress", keypressEventWrapper);
            window.removeEventListener("click", finishEvent);
            this._editing = false;
          };
          let keypressEventWrapper = event => {
            if (event.keyCode === 13) {
              finishEvent();
            }
          };
          this.textArea.addNodeListener("keypress", keypressEventWrapper);
          window.addEventListener("click", finishEvent);
        });
        // This is so the window listeners do not trigger
        this.textArea.addClickListener(event => {
          event.stopPropagation();
        });

        // changes in graph in draw, edit or delete
        this.graph.addListener("changeInput", data => {
          this.inputPanel.dispatch("changeInput", data);
        });

        // Exporting starts here
        this.exportToPngButton.addClickListener(() => {
          this.exportToPng();
        });
        this.exportToMarkupButton.addClickListener(() => {
          let markup = this.graph.getMarkup();
          if (this.markupArea.options.isHidden) {
            this.markupArea.show();
            this.markupArea.options.isHidden = false;
          }
          this.markupArea.setValue(markup);
          this.markupArea.node.focus();
          this.markupArea.node.select();
          this.markupArea.node.scrollTop = 0;
        });
      }
      getDefaultOptions() {
        return {
          "nodes": [{
            "name": "0",
            "x": 120,
            "y": 150
          }, {
            "name": "1",
            "x": 350,
            "y": 300
          }, {
            "name": "2",
            "x": 50,
            "y": 50
          }, {
            "name": "3",
            "x": 350,
            "y": 50
          }, {
            "name": "4",
            "x": 50,
            "y": 300
          }, {
            "name": "5",
            "x": 270,
            "y": 150
          }],
          "edges": [{
            "source": 0,
            "target": 2
          }, {
            "source": 0,
            "target": 4
          }, {
            "source": 0,
            "target": 5
          }, {
            "source": 1,
            "target": 4
          }, {
            "source": 1,
            "target": 5
          }, {
            "source": 2,
            "target": 3
          }, {
            "source": 2,
            "target": 4
          }, {
            "source": 4,
            "target": 5
          }]
        };
      }
      resize(newHeight, newWidth) {
        newWidth = Math.max(newWidth, 300);
        newHeight = Math.max(newHeight, 300);
        newHeight = newWidth = Math.min(newHeight, newWidth);
        this.widgetBlock.setStyle("width", newWidth + 700 + "px");
        this.graphBlock.setStyle("width", newWidth + "px");
        this.graphBlock.setStyle("height", newHeight + "px");
        this.svgBlock.setStyle("width", newWidth + "px");
        this.svgBlock.setStyle("height", newHeight + "px");
        this.svg.setAttribute("width", newWidth + "px");
        this.svg.setAttribute("height", newHeight + "px");
        this.graph.dispatch("resize");
      }
      exportToPng() {
        // data will be the svg DOM node, serialized as a string
        let data = new XMLSerializer().serializeToString(this.svg.node);
        // this is to make the background color white instead of transparent
        data = data.replace("<svg", "<svg style='background-color: white;'");
        let DOMURL = window.URL || window.webkitURL || window;
        let svgBlob = new Blob([data], {
          type: 'image/svg+xml;charset=utf-8'
        });
        let url = DOMURL.createObjectURL(svgBlob);
        let image = document.createElement('img');
        image.onload = () => {
          let canvas = document.createElement("canvas");
          let context = canvas.getContext('2d');
          canvas.height = this.svg.getHeight();
          canvas.width = this.svg.getWidth();
          context.drawImage(image, 0, 0);
          DOMURL.revokeObjectURL(url);
          let imageURI = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
          let a = document.createElement("a");
          a.setAttribute("download", "graph.png");
          a.setAttribute("href", imageURI);
          a.setAttribute("target", "_blank");
          a.dispatchEvent(new MouseEvent("click", {
            view: window,
            bubbles: false,
            cancelable: true
          }));
        };
        image.src = url;
      }
      render() {
        return [UI$1.createElement("div", {
          ref: "widgetBlock",
          style: {
            margin: "0 auto"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-right": "30px",
            float: "left"
          }
        }, UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          ref: "toggleDirected",
          givenOptions: ["Undirected", "Directed"]
        })), UI$1.createElement(GraphInputPanel, {
          ref: "inputPanel",
          style: {
            "margin-top": "30px"
          }
        })), UI$1.createElement("div", {
          ref: "graphBlock",
          style: {
            width: "600px",
            display: "inline-block"
          }
        }, UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          ref: "toggleIndexType",
          givenOptions: ["0-index", "1-index", "Custom Labels"]
        })), UI$1.createElement("div", {
          ref: "svgBlock",
          style: {
            "width": "100%",
            height: "500px",
            "border": "1px solid black",
            "border-radius": "5px",
            "margin-top": "30px",
            "position": "relative"
          }
        }, UI$1.createElement(SVG.SVGRoot, {
          ref: "svg",
          width: "100%",
          height: "100%"
        }, UI$1.createElement(EditableGraph, {
          ref: "graph",
          nodes: this.options.nodes,
          edges: this.options.edges
        })), UI$1.createElement(TextInput, {
          ref: "textArea",
          style: {
            "position": "absolute",
            "display": "none",
            "height": "25px",
            "line-height": "25px",
            "width": "45px"
          }
        }))), UI$1.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-left": "30px",
            float: "right"
          }
        }, UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          ref: "toggleViewMode",
          givenOptions: ["Force", "Draw", "Edit", "Delete", "Config"]
        })), UI$1.createElement(GraphEditorLegend, {
          ref: "editorLegend",
          viewMode: this.toggleViewMode?.getValue() || "Force",
          style: {
            "border": "1px solid black",
            "border-radius": "5px",
            "margin-top": "30px",
            "padding": "10px",
            "min-height": "400px"
          }
        }), UI$1.createElement(ButtonGroup, {
          style: {
            marginTop: "5px"
          }
        }, UI$1.createElement(Button$1, {
          ref: "exportToPngButton",
          level: Level.INFO
        }, "Download as PNG"), UI$1.createElement(Button$1, {
          ref: "exportToMarkupButton",
          level: Level.INFO
        }, "Generate Markup")), UI$1.createElement(TextArea, {
          ref: "markupArea",
          isHidden: true,
          className: "hidden",
          style: {
            width: "100%",
            marginTop: "10px",
            minHeight: "100px"
          }
        })))];
      }
    }

    const C = {
      DIFF_EQUAL: 0,
      DIFF_DELETE: -1,
      DIFF_INSERT: 1,
      DIFF_CHANGE: 2,
      DIFF_COMPLEX: -2
    };
    const Options = {
      gutterBackground: "white",
      aceTheme: {
        aceName: "dawn"
      },
      yellowBlockColor: "#FFFECC",
      yellowCurveColor: "#FFFECC",
      yellowStrokeColor: "#F8F48B",
      blueBlockColor: "#C1EBFF",
      blueCurveColor: "#C1EBFF",
      blueStrokeColor: "#6CBADE",
      redBlockColor: "#FFC1C2",
      redCurveColor: "#FFC1C2",
      redStrokeColor: "#F08D8D",
      greenBlockColor: "#C7EFCC",
      greenCurveColor: "#C7EFCC",
      greenStrokeColor: "#6FC278",
      strokeWidth: "1px",
      arrowsColor: "black"
    };
    const ColorStyle = {
      "-1": "red-diff ",
      "1": "green-diff ",
      "2": "blue-diff ",
      "-2": "yellow-diff "
    };
    class DiffGutter extends SVG.SVGRoot {}
    class DiffWidget extends UI$1.Element {
      render() {
        return [UI$1.createElement(SectionDivider, {
          className: "diffing-tool",
          ref: "sectionDivider",
          orientation: Orientation$1.HORIZONTAL,
          style: {
            height: "100%"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "50%",
            height: "100%"
          }
        }, UI$1.createElement(CodeEditor, {
          ref: "leftCodeEditor",
          value: this.options.leftTextValue,
          readOnly: !this.options.leftEditable,
          style: {
            height: "100%"
          }
        })), UI$1.createElement(Panel, {
          fixed: true,
          ref: "diffGutterPanel",
          style: {
            display: "inline-block",
            height: "100%",
            width: "100px",
            overflow: "hidden"
          }
        }, UI$1.createElement(DiffGutter, {
          ref: "diffGutter",
          style: {
            backgroundColor: Options.gutterBackground,
            height: "100%",
            width: "100%"
          }
        })), UI$1.createElement("div", {
          style: {
            width: "50%",
            height: "100%"
          }
        }, UI$1.createElement(CodeEditor, {
          ref: "rightCodeEditor",
          value: this.options.rightTextValue,
          readOnly: !this.options.rightEditable,
          style: {
            height: "100%"
          }
        }))), UI$1.createElement(StyleElement, null, UI$1.createElement(StyleInstance, {
          selector: ".yellow-diff",
          ref: "yellowDiffStyle",
          attributes: {
            "background-color": Options.yellowBlockColor,
            "fill": Options.yellowCurveColor,
            stroke: Options.yellowStrokeColor,
            "border-color": Options.yellowStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".blue-diff",
          ref: "blueDiffStyle",
          attributes: {
            "background-color": Options.blueBlockColor,
            "fill": Options.blueCurveColor,
            stroke: Options.blueStrokeColor,
            "border-color": Options.blueStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".red-diff",
          ref: "redDiffStyle",
          attributes: {
            "background-color": Options.redBlockColor,
            "fill": Options.redCurveColor,
            stroke: Options.redStrokeColor,
            "border-color": Options.redStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".green-diff",
          ref: "greenDiffStyle",
          attributes: {
            "background-color": Options.greenBlockColor,
            "fill": Options.greenCurveColor,
            stroke: Options.greenStrokeColor,
            "border-color": Options.greenStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".acediff-diff.lines",
          attributes: {
            "position": "absolute",
            "z-index": "3"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".acediff-diff.targetOnly",
          attributes: {
            "height": "0px !important",
            "z-index": "4",
            "left": "4px !important",
            "border-top": "1px solid",
            "border-bottom": "1px solid",
            "position": "absolute"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".acediff-diff.targetOnly.top",
          attributes: {
            "top": "-2px",
            "border-top": "0px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".acediff-diff.targetOnly.bottom",
          attributes: {
            "border-bottom": "0px"
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".cursor-bar-yellow-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.yellowStrokeColor
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".cursor-bar-red-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.redStrokeColor
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".cursor-bar-green-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.greenStrokeColor
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".cursor-bar-blue-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.blueStrokeColor
          }
        }), UI$1.createElement(StyleInstance, {
          selector: ".diffing-tool .ace-dawn .ace_marker-layer .ace_active-line",
          attributes: {
            "background": "rgba(36, 87, 121, 0.15) !important",
            "z-index": "7",
            "margin-left": "4px",
            "opacity": "30%"
          }
        }))];
      }
      getDefaultOptions() {
        return {
          leftTextValue: "Welcome to our Diffing Tool!\n\nYou can edit both of these panels and the diff is updated live.\n\nThis block is identical in both sides.\nTherefore it is not highlighted.\n\nThis block has been deleted.\nDeleted blocks appear with color red.\n\nYellow is mostly used for partial identical content.\n\nThe blue color is used for many changes\ninside a block, so the entire block is\nconsidered changed.\n",
          rightTextValue: "Welcome to our Diffing Tool!\n\nYou can edit both of these panels and the diff is updated live.\n\nThis new block has been inserted.\nInserted blocks appear with color green.\n\nThis block is identical in both sides.\nTherefore it is not highlighted.\n\n\nYellow is used for partial identical text content.\n\nAzure denotes what is written in the left side \n(this block is to exemplify only)\n\nYou can click on the arrows in the central gutter to move changes from one part to the other.\n",
          leftEditable: true,
          rightEditable: true
        };
      }
      setLeftEditable(leftEditable) {
        this.updateOptions({
          leftEditable
        });
      }
      setRightEditable(rightEditable) {
        this.updateOptions({
          rightEditable
        });
      }
      setLeftText(leftTextValue) {
        this.updateOptions({
          leftTextValue
        });
      }
      setRightText(rightTextValue) {
        this.updateOptions({
          rightTextValue
        });
      }
      onMount() {
        this.leftCodeEditor.setAceTheme(Options.aceTheme);
        this.rightCodeEditor.setAceTheme(Options.aceTheme);
        this.rightCodeEditor.setShowGutter(false);
        this.leftCodeEditor.markers = [];
        this.rightCodeEditor.markers = [];
        this.diffGutterPanel.addNodeListener("mousewheel", event => {
          event.preventDefault();
          event.stopPropagation();
          this.leftCodeEditor.setScrollTop(this.leftCodeEditor.getScrollTop() + event.deltaY);
          this.rightCodeEditor.setScrollTop(this.rightCodeEditor.getScrollTop() + event.deltaY);
        });
        let initialDiffMade = false;
        this.leftCodeEditor.whenLoaded(() => {
          this.rightCodeEditor.whenLoaded(() => {
            setTimeout(() => {
              this.makeDiffs();
              initialDiffMade = true;
            });
          });
        });
        let changeBehaviour = () => {
          if (initialDiffMade) {
            this.makeDiffs();
          }
        };
        this.leftCodeEditor.addAceSessionEventListener("changeScrollTop", changeBehaviour);
        this.rightCodeEditor.addAceSessionEventListener("changeScrollTop", changeBehaviour);
        this.leftCodeEditor.addAceSessionChangeListener(changeBehaviour);
        this.rightCodeEditor.addAceSessionChangeListener(changeBehaviour);
        window.addEventListener("resize", changeBehaviour);
      }
      makeDiffs() {
        this.computeDiffs();
        this.createLogicalDiffs();
        this.deleteVisualDiffs();
        this.drawVisualDiffs();
      }
      computeDiffs() {
        let dmp = new diff_match_patch();
        let leftText = this.leftCodeEditor.getValue();
        let rightText = this.rightCodeEditor.getValue();
        let diff = dmp.diff_main(leftText, rightText);
        dmp.diff_cleanupSemantic(diff);
        this.diffs = diff;
      }
      createLogicalDiffs() {
        this.diffBlocks = [];
        this.diffCurves = [];
        let myDiffs = [];
        let lastType = 0;
        this.diffs.forEach(chunk => {
          if (chunk[1] === "") {
            return;
          }
          if (chunk[0] === C.DIFF_EQUAL) {
            myDiffs.push({
              type: C.DIFF_EQUAL,
              leftText: chunk[1],
              rightText: chunk[1]
            });
          } else if (chunk[0] === C.DIFF_INSERT) {
            if (lastType === C.DIFF_DELETE) {
              myDiffs.last().type = C.DIFF_CHANGE;
              myDiffs.last().rightText += chunk[1];
            } else {
              myDiffs.push({
                type: C.DIFF_INSERT,
                leftText: "",
                rightText: chunk[1]
              });
            }
          } else if (chunk[0] === C.DIFF_DELETE) {
            if (lastType === C.DIFF_INSERT) {
              myDiffs.last().type = C.DIFF_CHANGE;
              myDiffs.last().leftText += chunk[1];
            } else {
              myDiffs.push({
                type: C.DIFF_DELETE,
                leftText: chunk[1],
                rightText: ""
              });
            }
          }
          lastType = chunk[0];
        });
        let change = {
          leftStartRow: 0,
          leftEndRow: 0,
          rightStartRow: 0,
          rightEndRow: 0
        };
        let offset = {
          leftRow: 0,
          rightRow: 0,
          leftColumn: 0,
          rightColumn: 0
        };
        let changeBegun = false;
        let type = 0;
        let changeCount = 0;
        myDiffs.forEach(chunk => {
          let leftText = chunk.leftText;
          let rightText = chunk.rightText;
          let leftRowsCount = leftText.split("\n").length - 1;
          let rightRowsCount = rightText.split("\n").length - 1;
          let leftColumnCount = leftText.split("\n")[leftRowsCount].length;
          let rightColumnCount = rightText.split("\n")[rightRowsCount].length;
          let oldLeftStartRow = offset.leftRow;
          let oldRightStartRow = offset.rightRow;
          let currentLeftRow;
          let currentLeftColumn;
          let currentRightRow;
          let currentRightColumn;
          let bothBlocks = true;
          if (!leftRowsCount && !leftColumnCount && !rightRowsCount && !rightColumnCount) {
            return;
          }
          type = chunk.type;
          currentLeftRow = offset.leftRow + leftRowsCount + (leftColumnCount > 0);
          currentLeftColumn = (leftRowsCount > 0 ? leftColumnCount : offset.leftColumn + leftColumnCount) + (leftColumnCount !== 0);
          currentRightRow = offset.rightRow + rightRowsCount + (rightColumnCount > 0);
          currentRightColumn = (rightRowsCount > 0 ? rightColumnCount : offset.rightColumn + rightColumnCount) + (rightColumnCount !== 0);
          if (offset.leftColumn || offset.rightColumn) {
            bothBlocks = false;
          }
          if (type !== C.DIFF_EQUAL) {
            this.diffBlocks.push([type, offset.leftRow, offset.leftColumn, currentLeftRow, currentLeftColumn, offset.rightRow, offset.rightColumn, currentRightRow, currentRightColumn]);
          }
          offset.leftRow += leftRowsCount;
          offset.leftColumn = currentLeftColumn - (leftColumnCount !== 0);
          offset.rightRow += rightRowsCount;
          offset.rightColumn = currentRightColumn - (rightColumnCount !== 0);
          if (offset.leftColumn || offset.rightColumn) {
            bothBlocks = false;
          }
          if (bothBlocks && type !== C.DIFF_EQUAL) {
            this.diffCurves.push([type, oldLeftStartRow, offset.leftRow + (offset.leftColumn !== 0), oldRightStartRow, offset.rightRow + (offset.rightColumn !== 0)]);
          }
          if (changeBegun && ((offset.leftRow > change.leftEndRow || offset.rightRow > change.rightEndRow) && type === C.DIFF_EQUAL || bothBlocks)) {
            this.diffCurves.push([C.DIFF_COMPLEX, change.leftStartRow, change.leftEndRow, change.rightStartRow, change.rightEndRow]);
            this.diffBlocks.push([C.DIFF_COMPLEX, change.leftStartRow, 0, change.leftEndRow, 0, change.rightStartRow, 0, change.rightEndRow, 0]);
            changeCount = 0;
            changeBegun = false;
          } else if (!changeBegun && type !== C.DIFF_EQUAL && !bothBlocks) {
            changeBegun = true;
            changeCount = 1;
            change.leftStartRow = oldLeftStartRow;
            change.rightStartRow = oldRightStartRow;
            change.leftEndRow = offset.leftRow + (offset.leftColumn !== 0);
            change.rightEndRow = offset.rightRow + (offset.rightColumn !== 0);
          } else if (changeBegun) {
            changeCount += 1;
            change.leftEndRow = offset.leftRow + (offset.leftColumn !== 0);
            change.rightEndRow = offset.rightRow + (offset.rightColumn !== 0);
          }
        });
        if (changeBegun) {
          if (changeCount !== 1 || !type) {
            type = C.DIFF_COMPLEX;
          }
          this.diffCurves.push([type, change.leftStartRow, change.leftEndRow, change.rightStartRow, change.rightEndRow]);
          this.diffBlocks.push([C.DIFF_COMPLEX, change.leftStartRow, 0, change.leftEndRow, 0, change.rightStartRow, 0, change.rightEndRow, 0]);
        }
      }
      drawVisualDiffs() {
        this.drawCurves();
        this.drawBlocks();
      }
      deleteVisualDiffs() {
        this.deleteCurves();
        this.deleteBlocks();
      }
      drawCurves() {
        this.diffCurves.forEach(chunk => {
          this.drawDiffCurve(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4]);
        });
        for (let i = 0; i < this.diffCurves.length; i += 1) {
          this.diffGutter.children[i].setAttribute("class", ColorStyle[this.diffCurves[i][0]]);
        }
        this.diffCurves.forEach(chunk => {
          this.drawArrows(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4]);
        });
      }
      deleteCurves() {
        this.diffGutter.updateOptions({
          children: []
        });
      }
      drawBlocks() {
        // In order for the yellow blocks to be at the base, we need to reverse the order we draw the blocks.
        this.diffBlocks.reverse();
        this.diffBlocks.forEach(chunk => {
          this.drawDiffBlock(this.leftCodeEditor, chunk[0], chunk[1], chunk[2], chunk[3], chunk[4]);
          this.drawDiffBlock(this.rightCodeEditor, chunk[0], chunk[5], chunk[6], chunk[7], chunk[8]);
        });
      }
      deleteBlocks() {
        this.leftCodeEditor.markers.forEach(marker => {
          this.leftCodeEditor.removeMarker(marker);
        });
        this.rightCodeEditor.markers.forEach(marker => {
          this.rightCodeEditor.removeMarker(marker);
        });
      }
      drawArrows(type, leftStartRow, leftEndRow, rightStartRow, rightEndRow, leftArrow, rightArrow) {
        let leftScrollTop = this.leftCodeEditor.getScrollTop();
        let rightScrollTop = this.rightCodeEditor.getScrollTop();
        let leftRowHeight = this.leftCodeEditor.getRendererLineHeight();
        let rightRowHeight = this.rightCodeEditor.getRendererLineHeight();
        let p1_x = 3;
        let p1_y = (leftStartRow * leftRowHeight - leftScrollTop + leftEndRow * leftRowHeight - leftScrollTop + 2) / 2;
        let p2_x = this.diffGutter.getWidth() - 3;
        let p2_y = (rightStartRow * rightRowHeight - rightScrollTop + rightEndRow * rightRowHeight - rightScrollTop + 2) / 2;
        let h = 5;
        let w = 5;
        let dLeft = 'M ' + p1_x + ' ' + (p1_y - h) + ' l ' + w + ' ' + h + ' l ' + -w + ' ' + h + 'm 6 0 l ' + w + ' ' + -h + ' l ' + -w + ' ' + -h;
        let rLeft = 'M ' + p1_x + ' ' + (p1_y - h) + ' l ' + (2 * w + 6) + ' 0 l 0 ' + 2 * h + ' l ' + (-2 * w - 6) + ' 0 z';
        let dRight = 'M ' + p2_x + ' ' + (p2_y - h) + ' l ' + -w + ' ' + h + ' l ' + w + ' ' + h + 'm -6 0 l ' + -w + ' ' + -h + ' l ' + w + ' ' + -h;
        let rRight = 'M ' + p2_x + ' ' + (p2_y - h) + ' l ' + (-2 * w - 6) + ' 0 l 0 ' + 2 * h + ' l ' + (2 * w + 6) + ' 0 z';
        if (this.options.rightEditable) {
          if (typeof leftArrow !== "undefined") {
            leftArrow.options.children[0].setAttribute("d", rLeft);
            leftArrow.options.children[1].setAttribute("d", dLeft);
          }
          this.diffGutter.appendChild(UI$1.createElement(SVG.Group, {
            style: {
              backgroundColor: "red",
              cursor: "hand",
              pointerEvents: "all"
            }
          }, UI$1.createElement(SVG.Path, {
            d: rLeft,
            style: {
              stroke: "transparent",
              fill: "transparent"
            }
          }), UI$1.createElement(SVG.Path, {
            d: dLeft,
            style: {
              stroke: Options.arrowsColor,
              fill: "none",
              strokeWidth: "1.5px"
            }
          })));
          this.diffGutter.children.last().addClickListener(() => {
            let text = this.leftCodeEditor.getTextRange(leftStartRow, 0, leftEndRow, 0);
            this.rightCodeEditor.setTextRange(rightStartRow, 0, rightEndRow, 0, text);
          });
        }
        if (this.options.leftEditable) {
          if (typeof rightArrow !== "undefined") {
            rightArrow.options.children[0].setAttribute("d", rRight);
            rightArrow.options.children[1].setAttribute("d", dRight);
          }
          this.diffGutter.appendChild(UI$1.createElement(SVG.Group, {
            style: {
              backgroundColor: "red",
              cursor: "hand",
              pointerEvents: "all"
            }
          }, UI$1.createElement(SVG.Path, {
            d: rRight,
            style: {
              stroke: "transparent",
              fill: "transparent"
            }
          }), UI$1.createElement(SVG.Path, {
            d: dRight,
            style: {
              stroke: Options.arrowsColor,
              fill: "none",
              strokeWidth: "1.5px"
            }
          })));
          this.diffGutter.children.last().addClickListener(() => {
            let text = this.rightCodeEditor.getTextRange(rightStartRow, 0, rightEndRow, 0);
            this.leftCodeEditor.setTextRange(leftStartRow, 0, leftEndRow, 0, text);
          });
        }
      }
      drawDiffCurve(type, leftStartRow, leftEndRow, rightStartRow, rightEndRow, element) {
        let leftScrollTop = this.leftCodeEditor.getScrollTop();
        let rightScrollTop = this.rightCodeEditor.getScrollTop();
        let leftRowHeight = this.leftCodeEditor.getRendererLineHeight();
        let rightRowHeight = this.rightCodeEditor.getRendererLineHeight();
        let p1_x = -1;
        let p1_y = leftStartRow * leftRowHeight - leftScrollTop + 0.5;
        let p2_x = this.diffGutter.getWidth() + 1;
        let p2_y = rightStartRow * rightRowHeight - rightScrollTop + 0.5;
        let p3_x = -1;
        let p3_y = leftEndRow * leftRowHeight - leftScrollTop + 1.5;
        let p4_x = this.diffGutter.getWidth() + 1;
        let p4_y = rightEndRow * rightRowHeight - rightScrollTop + 1.5;
        let curve1 = this.computeCurve(p1_x, p1_y, p2_x, p2_y);
        let curve2 = this.computeCurve(p4_x, p4_y, p3_x, p3_y);
        let verticalLine1 = 'L' + p2_x + ',' + p2_y + ' ' + p4_x + ',' + p4_y;
        let verticalLine2 = 'L' + p3_x + ',' + p3_y + ' ' + p1_x + ',' + p1_y;
        let d = curve1 + ' ' + verticalLine1 + ' ' + curve2 + ' ' + verticalLine2;
        if (typeof element !== "undefined") {
          element.setAttr("d", d);
          return;
        }
        let el = UI$1.createElement(SVG.Path, {
          d: d
        });
        this.diffGutter.appendChild(el);
      }
      drawDiffBlock(editor, type, startRow, startColumn, endRow, endColumn) {
        if (endRow < startRow) {
          endRow = startRow;
        }
        let classNames = "acediff-diff " + ColorStyle[type];
        if (endColumn && endRow === startRow && endColumn === startColumn) {
          endRow = startRow + 1;
          endColumn = startColumn + 2;
          classNames += " cursor-bar-" + ColorStyle[type];
        }
        if (!startColumn && !endColumn) {
          editor.markers.push(editor.addMarker(startRow, 0, startRow - 1, 1, "acediff-diff " + ColorStyle[type] + "targetOnly top", "fullLine"));
          editor.markers.push(editor.addMarker(endRow, 0, endRow - 1, 1, "acediff-diff " + ColorStyle[type] + "targetOnly bottom", "fullLine"));
        }
        classNames += endRow > startRow ? "lines" : "targetOnly";
        let option = "";
        endRow -= 1;
        endColumn -= 1;
        if (type === -2 || endRow < startRow && endColumn === -1) {
          option += "fullLine";
        }
        if (endRow < startRow && endColumn === -1) {
          editor.markers.push(editor.addMarker(startRow, startColumn, endRow, endColumn, classNames, option));
        } else if (endColumn === -1) {
          editor.markers.push(editor.addMarker(startRow, startColumn, endRow + 1, endColumn + 1, classNames, option + " text"));
        } else {
          editor.markers.push(editor.addMarker(startRow, startColumn, endRow, endColumn, classNames, option));
        }
      }
      computeCurve(startX, startY, endX, endY) {
        let w = endX - startX;
        let halfWidth = startX + w / 2;
        return 'M ' + startX + ' ' + startY + ' C ' + halfWidth + ',' + startY + ' ' + halfWidth + ',' + endY + ' ' + endX + ',' + endY;
      }
    }
    class DelayedDiffWidget extends DelayedElement(DiffWidget) {
      async beforeRedrawNotLoaded() {
        await ensure("/static/ext/diff_match_patch.js");
        this.setLoaded();
      }
    }
    class DiffWidgetApp extends DelayedDiffWidget {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          paddingTop: "20px",
          marginLeft: "5%",
          width: "90%",
          height: "100%"
        });
      }
    }

    class ContestRegistererTable extends Table {
      getEntries() {
        return ContestRegistererStore.all();
      }
      getDefaultColumns() {
        return [{
          value: registerer => UI$1.createElement(Link, {
            value: registerer.getContest().getName(),
            href: "/contest/" + registerer.getContest().name
          }),
          headerName: "Name"
        }, {
          value: registerer => registerer.totalUsers,
          headerName: "Participants"
        }, {
          value: registerer => registerer.usersLastMonth,
          headerName: "Participants this month"
        }, {
          value: registerer => registerer.startDate ? StemDate.format(registerer.startDate, "DD/MM/YYYY HH:mm") : UI$1.createElement(Latex, {
            value: "-\\infty"
          }),
          headerName: "Start date"
        }, {
          value: registerer => registerer.endDate ? StemDate.format(registerer.endDate, "DD/MM/YYYY HH:mm") : UI$1.createElement(Latex, {
            value: "\\infty"
          }),
          headerName: "End date"
        }, {
          value: registerer => UI$1.createElement(Link, {
            value: "Edit contest",
            href: "/contest/" + registerer.getContest().name + "/edit/"
          })
        }, {
          value: registerer => UI$1.createElement(Link, {
            value: "Invite Link",
            href: "/contest/invite/" + registerer.getCode() + "/"
          })
        }];
      }
    }
    class NewContestModal extends ActionModal {
      getTitle() {
        return "Custom contest creation";
      }
      getBody() {
        return [UI$1.createElement("strong", null, "! Leave the Start Date and End Date empty for a contest you want open indefinitely"), UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          label: "Contest Name"
        }, UI$1.createElement(TextInput, {
          ref: "contestNameInput"
        })), UI$1.createElement(FormField, {
          label: "Start Date"
        }, UI$1.createElement(DateTimePicker, {
          ref: "startDatePicker"
        })), UI$1.createElement(FormField, {
          label: "End Date"
        }, UI$1.createElement(DateTimePicker, {
          ref: "endDatePicker"
        })), UI$1.createElement(FormField, {
          label: "Contest Duration (hours:minutes or minutes)"
        }, UI$1.createElement(TextInput, {
          ref: "durationInput",
          value: "01:00"
        })))];
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getActionName() {
        return "Create";
      }
      onMount() {
        super.onMount();
        let defaultDate = ServerTime.now().add({
          minutes: 1
        });
        let minutesToMilliseconds = 5 * 60 * 1000;
        let remainder = minutesToMilliseconds - defaultDate % minutesToMilliseconds;
        defaultDate.add(remainder, "milliseconds");
        this.startDatePicker.setDate(defaultDate);
        defaultDate.add({
          days: 1
        });
        this.endDatePicker.setDate(defaultDate);
      }
      action() {
        let contestLongName = this.contestNameInput.getValue();
        let startDate = this.startDatePicker.getDate();
        let endDate = this.endDatePicker.getDate();
        let duration = this.durationInput.getValue();
        if (duration) {
          duration = duration.split(":");
          if (duration.length > 1) {
            duration = 60 * 60 * 1000 * parseFloat(duration[0] || 0) + 60 * 1000 * parseFloat(duration[1] || 0);
          } else {
            duration = 60 * 1000 * parseFloat(duration[0] || 0);
          }
        }
        if (!duration || !contestLongName) {
          this.messageArea.showMessage("Invalid data given!", "red", 3000);
          return;
        }
        if (startDate) {
          startDate = startDate.getTime();
        }
        if (endDate) {
          endDate = endDate.getTime();
        }
        if (startDate && endDate && startDate >= endDate) {
          this.messageArea.showMessage("Invalid data given!", "red", 3000);
          return;
        }
        let request = {
          duration: duration,
          contestLongName: contestLongName
        };
        if (startDate) {
          request.startTime = startDate;
        }
        if (endDate) {
          request.endTime = endDate;
        }
        Ajax.postJSON("/contest/create_custom_contest/", request).then(() => {
          this.options.contestManager.table.redraw();
          this.hide();
        }, error => {
          this.messageArea.showMessage(error.message, "red", 3000);
        });
      }
    }
    let NewContestButton = ActionModalButton(NewContestModal);
    class ContestManager extends UI$1.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.EXTRA_SMALL);
      }
      render() {
        return [UI$1.createElement(NewContestButton, {
          level: Level.SUCCESS,
          style: {
            margin: "30px"
          },
          modalOptions: {
            contestManager: this
          }
        }, "New Contest"), UI$1.createElement(ContestRegistererTable, {
          ref: "table"
        })];
      }
    }

    class ContestInvitePage extends UI$1.Element {
      renderRegistrationMessage() {
        let contestRegisterer = ContestRegistererStore.get(this.options.contestRegistererId);
        let error = this.options.reason || "noregisterer";
        if (this.options.canRegister) {
          let name = contestRegisterer.getContest().longName;
          return [UI$1.createElement("div", {
            style: {
              marginTop: "20px"
            }
          }, "Contest name: " + name.substr(0, name.length - 15)), UI$1.createElement("div", {
            style: {
              marginTop: "20px"
            }
          }, "Duration: " + contestRegisterer.getContest().getFormattedDuration()), UI$1.createElement("div", {
            style: {
              marginTop: "20px"
            }
          }, "Click the button to go to the contest page. Take care, you can only participate once!" + " The contest will start when you click the button.")];
        }
        if (error === "toomany") {
          return ["The owner of this contest (", UI$1.createElement(UserHandle$1, {
            userId: contestRegisterer.ownerId
          }), ") has reached his limit of contest registrations this month. Please contact ", UI$1.createElement(UserHandle$1, {
            userId: contestRegisterer.ownerId
          }), " about this error."];
        }
        if (error === "participated") {
          return "You have already participated in this contest.";
        }
        if (!USER.isAuthenticated) {
          return "You need to log-in to continue.";
        }
        return "Invalid invitation link.";
      }
      render() {
        return [UI$1.createElement("div", {
          style: {
            marginTop: "50px"
          }
        }, UI$1.createElement("div", {
          style: {
            fontSize: "2em",
            padding: "0 15%"
          }
        }, this.renderRegistrationMessage()), UI$1.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI$1.createElement(TemporaryMessageArea, {
          ref: "errorArea"
        }), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          size: Size.LARGE,
          style: {
            margin: "20px auto",
            fontSize: "1.4em"
          },
          disabled: !this.options.canRegister,
          ref: "registerButton"
        }, "Participate")))];
      }
      onMount() {
        this.registerButton.addClickListener(() => {
          Ajax.postJSON("/contest/register_by_invite/", {
            contestRegistererId: this.options.contestRegistererId
          }).then(() => {
            let name = ContestRegistererStore.get(this.options.contestRegistererId).getContest().longName;
            Router.changeURL(["contest", "custom-v-" + name.substr(name.length - 12), "tasks"]);
          }, error => {
            this.registerButton.setLevel(Level.DANGER);
            this.errorArea.showMessage(error.message, "red");
            setTimeout(() => {
              this.registerButton.setLevel(Level.PRIMARY);
            }, 2000);
          });
        });
      }
    }

    class ContestAnnouncementList extends UI$1.Element {
      getContest() {
        return this.options.contest;
      }
      renderAnnouncement(announcement) {
        let formattedDate = announcement.getDate().format("HH:mm:ss");
        let title = UI$1.createElement("div", null, formattedDate, " ", UI$1.createElement("strong", null, announcement.getTarget()));
        return UI$1.createElement("div", {
          style: {
            padding: "10px",
            width: "450px",
            maxWidth: "100%"
          }
        }, UI$1.createElement(CardPanel, {
          key: announcement.id,
          title: title,
          id: "announcement" + announcement.id,
          bodyStyle: {
            padding: "15px"
          }
        }, UI$1.createElement(MarkupRenderer, {
          value: announcement.getMessage()
        })));
      }
      render() {
        return this.getContest().getAnnouncements().map(this.renderAnnouncement, this);
      }
      onMount() {
        this.attachCreateListener(ContestAnnouncementStore, announcement => {
          if (announcement.getContest() === this.getContest()) {
            this.redraw();
          }
        });
      }
    }
    class AnnouncementBroadcastModal extends Modal {
      render() {
        const tasks = [{
          general: true,
          toString: () => "General"
        }].concat(this.options.contest.getContestTasks());
        return [UI$1.createElement("h4", {
          className: "text-center"
        }, "New announcement"), UI$1.createElement(FormField, {
          label: "Task name"
        }, UI$1.createElement(Select, {
          ref: "contestTaskSelect",
          options: tasks
        })), UI$1.createElement(FormField, {
          label: "Message"
        }, UI$1.createElement(TextArea, {
          ref: "messageInput"
        })), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: UI$1.T("Broadcast announcement"),
          onClick: () => this.broadcastAnnouncement()
        }))];
      }
      broadcastAnnouncement() {
        const contestTask = this.contestTaskSelect.get();
        let request = {
          contestId: this.options.contest.id,
          message: this.messageInput.getValue()
        };
        if (!contestTask.general) {
          request.contestTaskId = contestTask.id;
        }
        Ajax.postJSON("/contest/broadcast_announcement/", request).then(() => this.hide());
      }
    }

    const PermissionsPresets = {
      VIEW_ONLY: {
        toString: () => "View only",
        permissions: {
          "view": true
        }
      },
      ANSWER_QUESTIONS: {
        toString: () => "Answer questions",
        permissions: {
          "view": true,
          "answer-question": true
        }
      },
      QUESTIONS_AND_ANNOUNCEMENTS: {
        toString: () => "Answer questions & broadcast announcements",
        permissions: {
          "view": true,
          "answer-question": true,
          "broadcast-announcement": true
        }
      },
      FULL: {
        toString: () => "Full permissions",
        permissions: {
          "view": true,
          "edit-settings": true,
          "edit-tasks": true,
          "answer-question": true,
          "broadcast-announcement": true
        }
      },
      CUSTOM: {
        toString: () => "Custom"
      }
    };
    class ContestPermissionsEditor extends UI$1.Element {
      getContest() {
        return this.options.contest;
      }
      removePermission(userId, permissionName, redraw = true) {
        return this.getContest().removePermission(userId.userId || userId, permissionName, () => redraw && this.redraw());
      }
      addPermission(userId, permissionName, redraw = true) {
        return this.getContest().addPermission(userId.userId || userId, permissionName, () => redraw && this.redraw());
      }
      togglePermission(userId, permissionName, redraw = true) {
        if (this.getContest().getUserPermission(userId.userId || userId, permissionName)) {
          this.removePermission(userId, permissionName, redraw);
        } else {
          this.addPermission(userId, permissionName, redraw);
        }
      }
      tryMatchPreset(userId) {
        if (this.forceCustomForUsers && this.forceCustomForUsers.has(userId)) {
          return PermissionsPresets.CUSTOM;
        }
        for (const preset of Object.values(PermissionsPresets)) {
          if (preset !== PermissionsPresets.CUSTOM) {
            const permissions = preset.permissions;
            let ok = true;
            for (const permName of Object.values(Contest.ModeratedAction)) {
              if (this.getContest().getUserPermission(userId, permName) !== !!permissions[permName]) {
                ok = false;
                break;
              }
            }
            if (ok) {
              return preset;
            }
          }
        }
        return PermissionsPresets.CUSTOM;
      }
      changeUserToPreset(groupMember, preset) {
        const userId = groupMember.userId;
        if (preset === PermissionsPresets.CUSTOM) {
          this.forceCustomForUsers = this.forceCustomForUsers || new Set();
          this.forceCustomForUsers.add(userId);
          this.redraw();
          return;
        }
        this.forceCustomForUsers && this.forceCustomForUsers.delete(userId);
        let xhrPromises = [];
        for (const permName of Object.values(Contest.ModeratedAction)) {
          const shouldHavePermission = !!preset.permissions[permName];
          if (shouldHavePermission) {
            xhrPromises.push(this.addPermission(userId, permName, false));
          } else {
            xhrPromises.push(this.removePermission(userId, permName, false));
          }
        }
        Promise.all(xhrPromises).then(() => this.redraw());
      }
      getTableColumns() {
        let columns = [{
          value: member => UI$1.createElement(UserHandle$1, {
            id: member.userId
          }),
          headerName: "User"
        }, {
          value: member => UI$1.createElement(Select, {
            options: [...Object.values(PermissionsPresets)],
            selected: this.tryMatchPreset(member.userId),
            ref: this.refLink("presetSelect" + member.id),
            onChange: () => this.changeUserToPreset(member, this["presetSelect" + member.id].get())
          }),
          headerName: "Preset"
        }];
        for (const permKey of Object.keys(Contest.ModeratedAction)) {
          const permName = Contest.ModeratedAction[permKey];
          const verbosePermName = Contest.VerboseModeratedAction[permKey];
          columns.push({
            value: member => UI$1.createElement(RawCheckboxInput, {
              initialValue: this.getContest().getUserPermission(member.userId, permName),
              disabled: permName === Contest.ModeratedAction.VIEW || this.tryMatchPreset(member.userId) !== PermissionsPresets.CUSTOM,
              onChange: () => this.togglePermission(member.userId, permName)
            }),
            headerName: verbosePermName
          });
        }
        columns.push({
          value: member => UI$1.createElement(Button$1, {
            level: Level.DANGER,
            size: Size.EXTRA_SMALL,
            icon: "minus",
            onClick: () => this.removePermission(member, Contest.ModeratedAction.VIEW)
          })
        });
        return columns;
      }
      getTableEntries() {
        return this.getContest().getPermissionGroup(Contest.ModeratedAction.VIEW).getMembers();
      }
      render() {
        return [UI$1.createElement(Table, {
          ref: "usersTable",
          entries: this.getTableEntries(),
          columns: this.getTableColumns()
        }), UI$1.createElement("h4", {
          style: {
            marginTop: "20px"
          }
        }, "Give access to a new user:"), UI$1.createElement(UserInputField, {
          ref: "userInputField"
        })];
      }
      onMount() {
        this.attachListener(this.userInputField, "user", userId => {
          this.userInputField.clear();
          this.addPermission(userId, Contest.ModeratedAction.VIEW);
        });
      }
    }

    class ContestExporter {
      draw() {
        window.currentWidget.addClass("hidden");
        this.element.removeClass("hidden");
      }
      revert() {
        window.currentWidget.removeClass("hidden");
        this.element.destroyNode();
      }
      renderTaskArticle(contestTask) {
        const language = this.options.language || Language.ENGLISH;
        const evalTask = contestTask.getEvalTask();
        let articleClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["TaskExamples", EvalTaskExamplesTable(evalTask)], ["TaskTestGrouping", EvalTaskTestGroupingTable(evalTask)], ["RawHTML", RawHTML], ["ServerInputTest", ServerInputTest]]);
        const article = contestTask.getStatementArticle().getTranslation(language);
        return UI$1.createElement(ArticleRenderer, {
          article: article,
          classMap: articleClassMap
        });
      }
      renderTask(contestTask) {
        const evalTask = contestTask.getEvalTask();
        const taskArticle = this.renderTaskArticle(contestTask);
        return [UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement("h1", null, UI$1.T(evalTask.longName))), taskArticle];
      }
      renderTaskWrapped(contestTask) {
        return UI$1.createElement("div", {
          style: {
            pageBreakAfter: "always"
          }
        }, this.renderTask(contestTask));
      }
      render() {
        let newChildren = [];
        for (let contestTask of this.contest.getContestTasks()) {
          newChildren.push(this.renderTaskWrapped(contestTask));
        }
        this.element.setChildren(newChildren);
      }
      requestAllLatestTasks() {
        let xhrPromises = [];
        for (const contestTask of this.contest.getContestTasks()) {
          xhrPromises.push(Ajax.postJSON("/contest/get_contest_task/", {
            contestTaskId: contestTask.id
          }));
        }
        return Promise.all(xhrPromises);
      }

      // API
      constructor(contest, options = {}) {
        this.contest = contest;
        this.options = options;
        this.element = UI$1.createElement("div", {
          className: "hidden"
        });
        this.element.mount(document.body);
        this.requestAllLatestTasks().then(() => this.render());
      }
      updateOptions(options) {
        this.options = Object.assign(this.options, options);
        this.render();
      }
      exportToPDF() {
        this.draw();
        setTimeout(() => {
          print();
          this.revert();
        }, 0);
      }
    }

    class PlagiarismReport extends StoreObject {}
    const PlagiarismReportStore = MakeStore("PlagiarismReport", PlagiarismReport);

    class PlagiarismReportBatch extends StoreObject {}
    const PlagiarismReportBatchStore = MakeStore("PlagiarismReportBatch", PlagiarismReportBatch);

    class PlagiarismMatch extends VirtualStoreObjectMixin(StoreObject) {
      isVirtual() {
        return String(this.id).startsWith("temp");
      }
    }
    class PlagiarismMatchStoreClass extends VirtualStoreMixin(GenericObjectStore) {
      constructor() {
        super("PlagiarismMatch", PlagiarismMatch);
      }
      createVirtualObject(submission1, submission2) {
        if (submission1.id > submission2.id) {
          [submission1, submission2] = [submission2, submission1];
        }
        const virtualObject = {
          id: `temp-${submission1.id}-${submission2.id}`,
          contestId: submission1.contestId,
          submission1Id: submission1.id,
          submission2Id: submission2.id
        };
        return this.create(virtualObject, {
          isVirtual: true
        });
      }
      getFromSubmissions(submission1, submission2) {
        if (!submission1 || !submission2) {
          return null;
        }
        if (submission1.id > submission2.id) {
          [submission1, submission2] = [submission2, submission1];
        }
        const existing = this.findBy({
          submission1Id: submission1.id,
          submission2Id: submission2.id
        });
        if (existing) {
          return existing;
        }
        return this.createVirtualObject(submission1, submission2);
      }
    }
    const PlagiarismMatchStore = new PlagiarismMatchStoreClass();
    async function apiChangePlagiarismMatchDecision(plagiarismMatch, decision) {
      const uniqueIdentifiers = plagiarismMatch.isVirtual() ? {
        contestId: plagiarismMatch.contestId,
        submission1Id: plagiarismMatch.submission1Id,
        submission2Id: plagiarismMatch.submission2Id
      } : {
        matchId: plagiarismMatch.id
      };
      const response = await Ajax.postJSON("/contest/decide_on_plagiarism_match/", {
        ...uniqueIdentifiers,
        decision
      }, {
        disableStateImport: true
      });
      PlagiarismMatchStore.applyUpdateObjectId(plagiarismMatch, response.matchId);
      GlobalState.importState(response.state);
    }
    async function apiLoadAllPlagiarismMatches(plagiarismBatch) {
      const response = await Ajax.getJSON("/contest/load_all_plagiarism_matches/", {
        batchId: plagiarismBatch.id
      });
      return PlagiarismMatchStore.load(response);
    }

    class EvalJobComparator extends UI$1.Element {
      render() {
        const {
          submissions
        } = this.options;
        return UI$1.createElement(DelayedDiffWidget, {
          style: {
            height: 500
          },
          leftEditable: false,
          rightEditable: false,
          leftTextValue: submissions[0].sourceText,
          rightTextValue: submissions[1].sourceText
        });
      }
    }

    var _class$v;
    function SubmissionToContestUser(submission) {
      // TODO terribly inefficient
      return ContestUserStore.findBy({
        contestId: submission.contestId,
        userId: submission.userId
      });
    }
    let ContestUserWithDecision = autoredraw(_class$v = class ContestUserWithDecision extends UI$1.Primitive("span") {
      render() {
        const {
          contestUser
        } = this.options;
        const result = [UI$1.createElement(UserHandle$1, {
          userId: contestUser.userId
        })];
        if (contestUser.isDisqualified()) {
          result.push(" (Disq.)");
        }
        return result;
      }
      static fromSubmission(submission) {
        const contestUser = SubmissionToContestUser(submission);
        return UI$1.createElement(this, {
          contestUser: contestUser
        });
      }
    }) || _class$v;
    class ContestUserSummarizer extends UI$1.Element {
      render() {
        const {
          contestUser
        } = this.options;
        return [UI$1.createElement(ContestUserWithDecision, {
          contestUser: contestUser
        }), UI$1.createElement("div", null, "Score: ", Formatter.truncate(contestUser.totalScore, 2), " points.")];
      }
    }
    function RenderContestUserSummaries(contestUsers) {
      return UI$1.createElement("div", {
        style: {
          display: "flex",
          paddingTop: 12
        }
      }, contestUsers.map(contestUser => UI$1.createElement("div", {
        style: {
          flex: 1
        }
      }, UI$1.createElement(ContestUserSummarizer, {
        contestUser: contestUser
      }))));
    }

    var _class$u, _class2$h;
    const PLAGIARISM_DECISION = {
      1: "Not cheating",
      2: "Suspicious",
      3: "Cheating"
    };
    let PlagiarismMatchDecision = autoredraw(_class$u = class PlagiarismMatchDecision extends UI$1.Primitive("span") {
      render() {
        const {
          match
        } = this.options;
        const result = [PLAGIARISM_DECISION[match.decision] || "Undecided"];
        if (match.lastEditedByUserId) {
          result.push([" (", UI$1.createElement(UserHandle$1, {
            userId: match.lastEditedByUserId
          }), ")"]);
        }
        return result;
      }
    }) || _class$u;
    let PlagiarismMatchEditor = autoredraw(_class2$h = class PlagiarismMatchEditor extends UI$1.Element {
      render() {
        const {
          match,
          currentIndex
        } = this.options;
        return [currentIndex != null && `Match #${currentIndex + 1} `, "Current decision: ", UI$1.createElement(PlagiarismMatchDecision, {
          match: match
        }), UI$1.createElement(Select, {
          ref: "decisionInput",
          options: Object.values(PLAGIARISM_DECISION),
          initialValue: PLAGIARISM_DECISION[match.decision] || PLAGIARISM_DECISION[1]
        }), UI$1.createElement(Button$1, {
          style: {
            marginLeft: 16
          },
          label: "Change decision",
          onClick: () => apiChangePlagiarismMatchDecision(match, this.decisionInput.getIndex() + 1)
        })];
      }
    }) || _class2$h;

    var _class$t;
    let PlagiarismMatchModal = autoredraw(_class$t = class PlagiarismMatchModal extends Modal {
      constructor(...args) {
        super(...args);
        this.skipJudged = true;
        this.skipDisqualified = true;
      }
      // TODO implement

      render() {
        const {
          currentIndex,
          entries
        } = this.options;
        const match = entries[currentIndex];
        const submission1 = EvalJobStore.get(match.submission1Id);
        const submission2 = EvalJobStore.get(match.submission2Id);
        const allDisqualified = match => {
          for (const subId of [match.submission1Id, match.submission2Id]) {
            const sub = EvalJobStore.get(subId);
            const contestUser = SubmissionToContestUser(sub);
            if (!contestUser.isDisqualified()) {
              return false;
            }
          }
          return true;
        };
        const shouldSkip = match => {
          if (this.skipDisqualified && allDisqualified(match)) {
            return true;
          }
          return this.skipJudged && (match.decision === 1 || match.decision === 3);
        };
        let prevIndex = currentIndex - 1;
        while (prevIndex >= 0 && shouldSkip(entries[prevIndex])) {
          prevIndex -= 1;
        }
        let nextIndex = currentIndex + 1;
        while (nextIndex < entries.length && shouldSkip(entries[nextIndex])) {
          nextIndex += 1;
        }
        const contestUsers = [submission1, submission2].map(SubmissionToContestUser);
        return [UI.createElement(PlagiarismMatchEditor, {
          currentIndex: currentIndex,
          match: match
        }), UI.createElement("div", null, UI.createElement(Button$1, {
          label: "\u2190 Previous",
          disabled: prevIndex < 0,
          onClick: () => this.updateOptions({
            currentIndex: prevIndex
          })
        }), UI.createElement(Button$1, {
          label: "Next \u2192",
          disabled: nextIndex >= entries.length,
          onClick: () => this.updateOptions({
            currentIndex: nextIndex
          })
        }), UI.createElement(RawCheckboxInput, {
          onChange: () => {
            this.skipJudged = this.checkboxSkipInput.getValue();
            this.redraw();
          },
          value: this.skipJudged,
          ref: "checkboxSkipInput"
        }), " Skip judged matches (Cheating or Not cheating)", UI.createElement(RawCheckboxInput, {
          onChange: () => {
            this.skipDisqualified = this.checkboxSkipDisqualifiedInput.getValue();
            this.redraw();
          },
          value: this.skipDisqualified,
          ref: "checkboxSkipDisqualifiedInput"
        }), " Skip if both disqualified"), RenderContestUserSummaries(contestUsers), UI.createElement(EvalJobComparator, {
          submissions: [submission1, submission2]
        })];
      }
    }) || _class$t;
    class PlagiarismBatchModal extends Modal {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "90%"
        });
      }
      async loadMatches() {
        const {
          batch
        } = this.options;
        this.matches = await apiLoadAllPlagiarismMatches(batch);
        this.redraw();
      }
      renderSubmissionDescription(evalJobId) {
        const evalJob = EvalJobStore.get(evalJobId);
        return ContestUserWithDecision.fromSubmission(evalJob);
      }
      render() {
        this.options;
        if (!this.matches) {
          this.loadMatches().then();
          return UI.createElement("h1", null, "Loading...");
        }
        for (let index = 0; index < this.matches.length; index++) {
          const prevIndex = index > 0 ? index - 1 : this.matches.length - 1;
          const nextIndex = index + 1 < this.matches.length ? index + 1 : 0;
          this.matches[index].prevEntry = this.matches[prevIndex];
          this.matches[index].nextEntry = this.matches[nextIndex];
        }
        const columns = [["First submission", match => this.renderSubmissionDescription(match.submission1Id)], ["Second submission", match => this.renderSubmissionDescription(match.submission2Id)], ["Decision", match => UI.createElement(PlagiarismMatchDecision, {
          match: match
        })], ["Actions", (match, rowIndex) => UI.createElement("div", null, UI.createElement(Button$1, {
          label: "Judge",
          onClick: () => PlagiarismMatchModal.show({
            currentIndex: rowIndex,
            entries: this.matches
          })
        }))]];
        return UI.createElement(Table, {
          entries: this.matches,
          columns: columns
        });
      }
    }

    const contestUserSubmissionCache = new Map();
    const contestUserSubmissionResponse = new Map();
    async function LoadContestUserSubmissions(contestUser, contestTask) {
      const userId = contestUser.userId;
      const contestTaskId = contestTask.id;
      const uniqueId = `${userId}-${contestTaskId}`;
      if (!contestUserSubmissionCache.has(uniqueId)) {
        const request = {
          userId,
          contestTaskId
        };
        const responsePromise = Ajax.getJSON("/eval/get_eval_jobs/", request);
        contestUserSubmissionCache.set(uniqueId, responsePromise);
      }
      const responsePromise = contestUserSubmissionCache.get(uniqueId);
      const response = await responsePromise;
      const evalJobs = EvalJobStore.load(response);
      evalJobs.sort((a, b) => b.timeSubmitted - a.timeSubmitted);
      contestUserSubmissionResponse.set(uniqueId, evalJobs);
      return evalJobs;
    }
    class ContestUserComparatorModal extends Modal {
      // getDefaultOptions() {
      //     return {
      //         width: "85%",
      //     }
      // }

      renderSubmissionSelect(contestUser, contestTask, refIndex) {
        if (!contestTask) {
          return "Loading...";
        }
        const userId = contestUser.userId;
        const contestTaskId = contestTask.id;
        const uniqueId = `${userId}-${contestTaskId}`;
        const evalJobs = contestUserSubmissionResponse.get(uniqueId);
        if (evalJobs == null) {
          LoadContestUserSubmissions(contestUser, contestTask).then(() => {
            setTimeout(() => this.redraw(), 16);
          });
          return "Loading...";
        }
        if (evalJobs.length === 0) {
          return "Did not submit for " + contestTask;
        }
        return UI.createElement(Select, {
          ref: `submission${refIndex}Input`,
          options: evalJobs,
          formatter: submission => {
            const score = Formatter.truncate(submission.score * contestTask.pointsWorth, 2);
            const contestStartTime = new StemDate(contestUser.getContestStartTime());
            const solutionTime = new StemDate(submission.timeSubmitted);
            const solutionTimeRelative = solutionTime.diffDuration(contestStartTime).format("HH:mm");
            return `Submission #${submission.id} ${score} points at ${solutionTimeRelative}`;
          },
          onChange: () => this.redraw()
        });
      }
      render() {
        const {
          contestUsers
        } = this.options;
        const contest = contestUsers[0].getContest();
        const selectedContestTask = this.contestTaskInput?.getValue() || contest.getContestTasks()[0];
        const submission1 = this.submission1Input?.getValue();
        const submission2 = this.submission2Input?.getValue();
        const plagiarismMatch = PlagiarismMatchStore.getFromSubmissions(submission1, submission2);
        return [UI.createElement("div", null, "Task: ", UI.createElement(Select, {
          ref: "contestTaskInput",
          options: contest.getContestTasks(),
          onChange: () => this.redraw()
        }), plagiarismMatch && UI.createElement(PlagiarismMatchEditor, {
          match: plagiarismMatch
        })), RenderContestUserSummaries(contestUsers), UI.createElement("div", {
          style: {
            display: "flex",
            paddingTop: 6
          }
        }, contestUsers.map((contestUser, index) => UI.createElement("div", {
          style: {
            flex: 1,
            alignSelf: "center"
          }
        }, this.renderSubmissionSelect(contestUser, selectedContestTask, index + 1)))), submission1 && submission2 && UI.createElement(EvalJobComparator, {
          submissions: [submission1, submission2]
        })];
      }
      static promptForContestUsers(contestUsers) {
        this.show({
          contestUsers
        });
      }
      onMount() {
        this.redraw();
      }
    }

    var _dec$m, _class$s;
    class MultiselectInput extends UI$1.Element {
      getAllOptions() {
        return this.options.options;
      }
      getValue() {
        return this.getAllOptions().filter((entry, index) => this["checkbox" + index].getValue());
      }
      render() {
        return this.getAllOptions().map((entry, index) => UI$1.createElement("div", null, UI$1.createElement(RawCheckboxInput, {
          onChange: () => this.dispatch("change"),
          ref: "checkbox" + index,
          noStupid: true
        }), " " + (entry || "None")));
      }
    }
    class ContestUserAttributeFilter extends CollapsiblePanel {
      getTitle() {
        let numSelected = this.getSelectedOptions().size;
        if (numSelected === 0) {
          numSelected = "All";
        }
        return `Filter by ${this.options.attrName} (${numSelected} selected)`;
      }
      getAllOptions() {
        const {
          attrName,
          contestUsers
        } = this.options;
        const allOptions = new Set(contestUsers.map(cu => cu[attrName]));
        return Array.from(allOptions);
      }
      getSelectedOptions() {
        return new Set(this.input?.getValue() || []);
      }
      filterContestUsers(contestUsers) {
        const {
          attrName
        } = this.options;
        const validAttributes = this.getSelectedOptions();
        if (validAttributes.size === 0) {
          return contestUsers;
        }
        return contestUsers.filter(cu => validAttributes.has(cu[attrName]));
      }
      render() {
        return [UI$1.createElement(MultiselectInput, {
          ref: "input",
          options: this.getAllOptions(),
          onChange: () => {
            this.redraw();
            this.options.onChange();
          }
        })];
      }
    }
    class ContestUserMultiselectInput extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.selectedContestUsers = new Set();
      }
      getSelectedUsers() {
        return Array.from(this.selectedContestUsers);
      }
      dispatchChange() {
        this.options.onChange();
        this.redraw();
      }
      removeContestUser(contestUser) {
        this.selectedContestUsers.delete(contestUser);
        this.dispatchChange();
      }
      addUserFromInput() {
        const {
          contest
        } = this.options;
        const username = this.userInput.getValue().trim();
        if (!username) {
          return;
        }
        for (const contestUser of contest.getUsers()) {
          const user = contestUser.getPublicUser();
          if (user.name === username || user.username === username) {
            this.selectedContestUsers.add(contestUser);
          }
        }
        this.dispatchChange();
      }
      render() {
        const entries = Array.from(this.selectedContestUsers);
        const columns = [["User", contestUser => UI$1.createElement(ContestUserWithDecision, {
          contestUser: contestUser
        })], ["Score", contestUser => contestUser.totalScore], ["", contestUser => UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          label: "Remove",
          onClick: () => this.removeContestUser(contestUser)
        }))]];
        return [UI$1.createElement("div", null, "Add user manually: ", UI$1.createElement(Input, {
          ref: "userInput"
        }), " ", UI$1.createElement(Button$1, {
          label: "Add User",
          onClick: () => this.addUserFromInput()
        })), UI$1.createElement("div", null, entries.length, " users selected manually."), entries.length > 0 && UI$1.createElement(Table, {
          entries: entries,
          columns: columns
        })];
      }
    }
    class ContestTaskFilter extends CollapsiblePanel {
      getTitle() {
        let numSelected = this.getContestTaskIds().length;
        if (numSelected === this.getAllContestTasks().length) {
          numSelected = "All";
        }
        return `Only for certain tasks (${numSelected} selected)`;
      }
      getAllContestTasks() {
        return this.options.contest.getContestTasks();
      }
      getContestTaskIds() {
        let selected = this.input?.getValue() || [];
        if (selected.length == 0) {
          selected = this.getAllContestTasks();
        }
        return selected.map(task => task.id);
      }
      render() {
        return [UI$1.createElement(MultiselectInput, {
          ref: "input",
          options: this.getAllContestTasks(),
          onChange: () => {
            this.redraw();
          }
        })];
      }
    }
    class PlagiarismReportPanel extends UI$1.Element {
      reviewBatch(batch) {
        PlagiarismBatchModal.show({
          batch
        });
      }
      render() {
        const {
          plagiarismReport
        } = this.options;
        const entries = PlagiarismReportBatchStore.all().filter(batch => batch.reportId === plagiarismReport.id);
        const columns = [["Task", reportBatch => ContestTaskStore.get(reportBatch.contestTaskId)], ["Language", reportBatch => {
          const languageName = String(ProgrammingLanguage.get(reportBatch.programmingLanguageId));
          return languageName.startsWith("Python") ? "Python" : languageName;
        }], ["Moss link", reportBatch => UI$1.createElement(Link, {
          href: reportBatch.mossOriginalURL,
          newTab: true
        }, reportBatch.mossOriginalURL)], ["Num matches", reportBatch => reportBatch.numMatches], ["Actions", reportBatch => UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          label: "Review",
          onClick: () => this.reviewBatch(reportBatch)
        }))]];
        return UI$1.createElement(Table, {
          columns: columns,
          entries: entries
        });
      }
    }
    class NewPlagiarismReportPanel extends Panel {
      constructor(...args) {
        super(...args);
        this.cachedRequest = null;
        this.allContestUsers = [];
        this.filteredContestUsers = [];
      }
      getDefaultOptions() {
        return {
          contest: null,
          title: "New Run",
          style: {
            margin: 8
          }
        };
      }
      async updateFilteredUsers() {
        await this.ensureUsersLoaded(); // Make sure we're ready

        let contestUsers = this.allContestUsers;
        const manuallySelectedUsers = this.individualUserInput.getSelectedUsers();
        contestUsers = this.countryFilter.filterContestUsers(contestUsers);
        contestUsers = this.universityFilter.filterContestUsers(contestUsers);
        if (manuallySelectedUsers.length) {
          contestUsers = manuallySelectedUsers;
        }
        this.filteredContestUsers = contestUsers;
        this.redraw();
      }
      async ensureUsersLoaded() {
        if (this.cachedRequest) {
          return this.cachedRequest;
        }
        const {
          contest
        } = this.options;
        this.cachedRequest = Ajax.getJSON("/contest/scoreboard_state/", {
          contestId: contest.id
        });
        await this.cachedRequest;
        this.allContestUsers = contest.getUsers().filter(cu => cu.haveSubmitted());
        for (const cu of this.allContestUsers) {
          cu.country = cu.getPublicUser().getCountry();
        }
        this.allContestUsers.sort(compareContestUsers);
        this.updateFilteredUsers().then();
      }
      async createReport() {
        const {
          contest
        } = this.options;
        const teamsCap = this.numTeamsCapInput.getValue();
        const contestUsers = this.filteredContestUsers.slice(0, teamsCap);
        const userIds = contestUsers.map(cu => cu.userId);
        const contestTaskIds = this.contestTaskInput.getContestTaskIds();
        await Ajax.postJSON("/contest/create_plagiarism_report/", {
          contestId: contest.id,
          name: this.reportNameInput.getValue() || "Report-" + new StemDate().format("YYYY-MM-DD-HH:mm"),
          userIds,
          contestTaskIds
        });
        this.options.onNewReport();
      }
      render() {
        const {
          contest
        } = this.options;
        return [UI$1.createElement("div", null, "New report name: ", UI$1.createElement(Input, {
          ref: "reportNameInput",
          placeholder: "Report-" + new StemDate().format("YYYY-MM-DD-HH:mm")
        })), UI$1.createElement("div", null, UI$1.createElement(ContestTaskFilter, {
          ref: "contestTaskInput",
          contest: contest
        })), UI$1.createElement("div", null, UI$1.createElement(ContestUserAttributeFilter, {
          ref: "countryFilter",
          attrName: "country",
          contestUsers: this.allContestUsers,
          onChange: () => this.updateFilteredUsers()
        })), UI$1.createElement("div", null, UI$1.createElement(ContestUserAttributeFilter, {
          ref: "universityFilter",
          attrName: "university",
          contestUsers: this.allContestUsers,
          onChange: () => this.updateFilteredUsers()
        })), UI$1.createElement("div", null, UI$1.createElement(CollapsiblePanel, {
          title: "Add individual contestants"
        }, UI$1.createElement(ContestUserMultiselectInput, {
          ref: "individualUserInput",
          contest: contest,
          onChange: () => this.updateFilteredUsers()
        }))), UI$1.createElement("div", null, this.filteredContestUsers.length, " filtered contest users.", UI$1.createElement("div", null, "Limit to the top (by score): ", UI$1.createElement(NumberInput, {
          ref: "numTeamsCapInput",
          min: 2,
          max: 150,
          initialValue: 15
        }))), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          label: "Create Report",
          onClick: () => this.createReport(),
          disabled: this.filteredContestUsers.length < 2
        }))];
      }
      onMount() {
        this.ensureUsersLoaded().then();
      }
    }
    let PlagiarismReportsPanel = (_dec$m = autoredraw(PlagiarismReportStore, PlagiarismReportBatchStore), _dec$m(_class$s = class PlagiarismReportsPanel extends Panel {
      constructor(...args) {
        super(...args);
        this.selectedReport = null;
      }
      getDefaultOptions() {
        return {
          contest: null,
          title: "Runs",
          style: {
            margin: 8
          },
          onNewReport: NOOP_FUNCTION
        };
      }
      setSelectedReport(report) {
        this.selectedReport = report;
        this.redraw();
      }
      async rerunReport(report) {
        if (!confirm("Are you sure you want to rerun this report?")) {
          return;
        }
        const batches = PlagiarismReportBatchStore.filterBy({
          reportId: report.id
        });
        for (const batch of batches) {
          PlagiarismReportBatchStore.applyDeleteEvent({
            objectId: batch.id
          });
        }
        await Ajax.postJSON("/contest/rerun_plagiarism_report/", {
          id: report.id
        });
      }
      async deleteReport(report) {
        if (!confirm("Are you sure you want to delete this report?")) {
          return;
        }
        await Ajax.postJSON("/contest/delete_plagiarism_report/", {
          id: report.id
        });
      }
      render() {
        const reports = PlagiarismReportStore.all();
        reports.sort((a, b) => b.createdAt - a.createdAt);
        const columns = [["ID", report => report.id], ["Name", report => report.name], ["Num users", report => report.userIds.length], ["Status", report => {
          const STATUS = ["Waiting", "In progress", "Failed", "Done"];
          return STATUS[report.status];
        }], ["Actions", report => UI$1.createElement("div", null, UI$1.createElement(Button$1, null, UI$1.createElement("a", {
          href: `/static/storage/plagiarism/report-${report.urlKey}.zip`,
          target: "_blank"
        }, "Download")), UI$1.createElement(Button$1, {
          label: "Rerun",
          onClick: () => this.rerunReport(report)
        }), UI$1.createElement(Button$1, {
          label: "Delete",
          onClick: () => this.deleteReport(report)
        }))]];
        if (reports.length === 0) {
          return ["No plagiarism reports, create one in the New Report tab"];
        }
        return [UI$1.createElement(CollapsibleTable, {
          entries: reports,
          columns: columns,
          renderCollapsible: report => UI$1.createElement(PlagiarismReportPanel, {
            plagiarismReport: report
          })
        })];
      }
    }) || _class$s);
    class ManualUserComparatorPanel extends Panel {
      render() {
        const {
          contest
        } = this.options;
        const selectedContestUsers = this.contestUserInput?.getSelectedUsers() || [];
        return [UI$1.createElement("div", null, selectedContestUsers.length == 2 ? UI$1.createElement(Button$1, {
          onClick: () => ContestUserComparatorModal.promptForContestUsers(selectedContestUsers),
          label: "Compare selected participants"
        }) : "Select exactly two participants to compare"), UI$1.createElement(ContestUserMultiselectInput, {
          ref: "contestUserInput",
          contest: contest,
          onChange: () => this.redraw()
        })];
      }
    }
    class ContestPlagiarismPanel extends UI$1.Element {
      render() {
        const {
          contest
        } = this.options;
        return [UI$1.createElement(TabArea, {
          ref: "tabArea"
        }, UI$1.createElement(PlagiarismReportsPanel, {
          ref: "reportsTab",
          contest: contest
        }), UI$1.createElement(NewPlagiarismReportPanel, {
          contest: contest,
          onNewReport: () => this.tabArea.setActive(this.reportsTab)
        }), UI$1.createElement(ManualUserComparatorPanel, {
          title: "Custom user comparator",
          contest: contest
        }))];
      }
    }

    function addTaskToContest(contest, options, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
      let request = {
        contestId: contest.id,
        evalTaskId: options.evalTaskId,
        sourceSize: options.sourceSizeLimit || 64 * 1024
      };
      Ajax.postJSON("/contest/add_task/", request).then(onSuccess, onError);
    }
    class AddTaskModal extends ActionModal {
      getBody() {
        let evalTasks = EvalTaskStore.all();
        return [UI$1.createElement(FormField, {
          label: "Task name"
        }, UI$1.createElement(Select, {
          options: evalTasks,
          ref: "evalTaskSelect"
        })), UI$1.createElement(FormField, {
          label: "Source size"
        }, UI$1.createElement("div", null, UI$1.createElement(NumberInput, {
          placeholder: "Source size",
          value: "32768",
          ref: "sourceSizeInput"
        }), UI$1.createElement("div", {
          style: {
            display: "inline-block",
            marginLeft: "4px"
          }
        }, "bytes")))];
      }
      action() {
        addTaskToContest(this.options.contest, {
          evalTaskId: this.evalTaskSelect.get().id,
          sourceSizeLimit: this.sourceSizeInput.getValue()
        }, () => {
          this.hide();
          this.options.tasksTable.redraw();
        }, error => {
          this.messageArea.showMessage(error.message, "red");
        });
      }
    }
    const AddTaskButton = ActionModalButton(AddTaskModal);
    class EditContestModal extends CreateContestModal {
      getDefaultValues() {
        let contest = this.options.contest;
        let duration = {
          days: 0,
          hours: 0,
          minutes: 0
        };
        if (contest.getStartTime() && contest.getEndTime()) {
          let contestDuration = new Duration((contest.getEndTime() - contest.getStartTime()) * 1000);
          duration = {
            days: contestDuration.toDays(),
            hours: contestDuration.getHours(),
            minutes: contestDuration.getMinutes()
          };
        }
        return {
          contestName: contest.name,
          contestLongName: contest.longName,
          startDate: contest.getStartTime() ? new StemDate(contest.getStartTime() * 1000) : null,
          durationDays: duration.days,
          durationHours: duration.hours,
          durationMinutes: duration.minutes,
          visible: contest.isVisible,
          rated: contest.rated,
          publicSources: contest.publicSources,
          scoringId: contest.scoringId,
          liveResults: contest.liveResults
        };
      }
      getBody() {
        let contest = this.options.contest;
        let discussionMutedCheckbox = null;
        let chat = contest.getChat();
        if (chat) {
          discussionMutedCheckbox = UI$1.createElement(FormField, {
            label: "Mute discussion"
          }, UI$1.createElement(RawCheckboxInput, {
            ref: "discussionMutedCheckbox",
            initialValue: chat.getMessageThread().muted
          }));
        }
        return [...super.getBody(), discussionMutedCheckbox];
      }
      getRequest() {
        const request = super.getRequest();
        const {
          contest
        } = this.options;
        request.contestId = contest.id;
        if (contest.getChat()) {
          request.discussionMuted = this.discussionMutedCheckbox.getValue();
        }
        return request;
      }
      getAjaxUrl() {
        return "/contest/change_settings/";
      }
      getErrorMessage() {
        return "Error in changing contest settings!!";
      }
      getTitle() {
        return "Edit contest " + this.options.contest.longName;
      }
      getActionName() {
        return "Save";
      }
    }
    const EditContestButton = ActionModalButton(EditContestModal);
    class ContestStatisticsModal extends ActionModal {
      constructor(...args) {
        super(...args);
        this.response = null;
      }
      getTitle() {
        return "Contest statistics";
      }
      getActionName() {
        return "Rerun query";
      }
      getBody() {
        const {
          response
        } = this;
        if (this.response) {
          const text = JSON.stringify(response, null, 2);
          return [UI$1.createElement("h2", null, "General stats "), UI$1.createElement(StaticCodeHighlighter, {
            aceMode: "json",
            value: text,
            maxLines: 40,
            fontSize: 16
          })];
        }
        // No response
        return [UI$1.createElement("h2", null, "Still running query"), UI$1.createElement("h2", null, "Sent at ", Date())];
      }
      action() {
        const query = {
          contestId: this.options.contest.id
        };
        this.response = null;
        this.redraw();
        this.actionButton.disable();
        Ajax.getJSON("/contest/statistics/", query).then(response => {
          this.response = response;
          this.redraw();
          this.actionButton.enable();
        }).catch(error => {
          console.log("Error from ajax", error);
          this.actionButton.enable();
        });
      }
      onMount() {
        this.action();
      }
    }
    const ContestStatisticsButton = ActionModalButton(ContestStatisticsModal);
    class CreateVirtualContestModal extends ActionModal {
      getBody() {
        return UI$1.createElement("p", null, "Create virtual contest for ", this.options.contest.longName, "?");
      }
      action() {
        if (!this.options.contest.hasFinished()) {
          window.alert("The contest has not finished yet.");
          return;
        }
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/create_virtual_contest/", request).then(() => this.hide());
      }
    }
    const CreateVirtualContestButton = ActionModalButton(CreateVirtualContestModal);
    class AddToArchiveModal extends ActionModal {
      getBody() {
        this.contestTasks = this.options.contest.getContestTasks();
        let taskList = [];
        for (let task of this.contestTasks) {
          taskList.push(UI$1.createElement("li", null, task.longName));
        }
        return [UI$1.createElement("p", null, "Add the following tasks to the archive?"), UI$1.createElement("ul", null, taskList), UI$1.createElement(FormField, {
          label: "Which archive?"
        }, UI$1.createElement(Select, {
          ref: "archiveSelect",
          options: ArchiveStore.all()
        }))];
      }
      action() {
        let request = {
          contestId: this.options.contest.id,
          archiveId: this.archiveSelect.get().id
        };
        this.messageArea.showMessage("Adding to archive...", "black", null);
        Ajax.postJSON("/contest/add_to_archive/", request).then(() => this.hide());
      }
    }
    const AddToArchiveButton = ActionModalButton(AddToArchiveModal);
    class CreateDiscussionModal extends ActionModal {
      getBody() {
        return UI$1.createElement("p", null, "Create discussion for ", this.options.contest.longName, "?");
      }
      action() {
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/create_discussion/", request).then(() => this.hide());
      }
    }
    const CreateDiscussionButton = ActionModalButton(CreateDiscussionModal);
    class DeleteContestModal extends ActionModal {
      getBody() {
        return UI$1.createElement("p", null, "Delete ", this.options.contest.longName, "?");
      }
      action() {
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/delete/", request).then(() => window.location.replace("/contests/"));
      }
    }
    const DeleteContestButton = ActionModalButton(DeleteContestModal);
    class PublishAnalysisModal extends ActionModal {
      getBody() {
        return UI$1.createElement("p", null, "Publish analysis for ", this.options.contest.longName, "?");
      }
      action() {
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/publish_analysis/", request).then(() => this.hide());
      }
    }
    const PublishAnalysisButton = ActionModalButton(PublishAnalysisModal);
    class ContestAnalysisEditor extends UI$1.Element {
      render() {
        let contest = this.options.contest;
        if (contest.getAnalysisArticle()) {
          return [UI$1.createElement(ArticleEditor, {
            ref: "solutionEditor",
            articleId: contest.analysisArticleId,
            style: {
              height: "600px"
            }
          })];
        } else {
          return [UI$1.createElement("h2", null, "The contest does not have an analysis article, click bellow to create one"), UI$1.createElement(Button$1, {
            label: "Create analysis article",
            onClick: () => {
              this.createAnalysisArticle();
            }
          })];
        }
      }
      createAnalysisArticle() {
        let request = {
          contestId: this.options.contest.id,
          createAnalysisArticle: true
        };
        Ajax.postJSON("/contest/create_analysis_article/", request).then(data => {
          this.options.contest.analysisArticleId = parseInt(data.analysisArticleId);
          this.redraw();
        });
      }
    }
    class PrintModal extends ActionModal {
      getBody() {
        return [UI$1.createElement(FormField, {
          label: "Language:"
        }, UI$1.createElement(Select, {
          options: Language.all(),
          ref: "languageSelect"
        }))];
      }
      getExporterOptions() {
        return {
          language: this.languageSelect.get()
        };
      }
      onMount() {
        super.onMount();
        this.exporter = new ContestExporter(this.options.contest, this.getExporterOptions());
        this.languageSelect.addNodeListener("change", () => this.exporter.updateOptions(this.getExporterOptions()));
      }
      action() {
        this.hide();
        this.exporter.updateOptions(this.getExporterOptions());
        this.exporter.exportToPDF();
      }
    }
    const PrintButton = ActionModalButton(PrintModal);
    class ContestEditPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%",
          display: "flex",
          flexDirection: "column",
          width: "1100px",
          maxWidth: "100%",
          margin: "0 auto",
          padding: "0 15px"
        });
      }
      render() {
        let contest = ContestStore.get(this.options.contestId);
        let tasksTable = UI$1.createElement(AdminContestTasksTable, {
          ref: "tasksTable",
          contest: contest
        });
        let createVirtualContestButton = null;
        if (!contest.virtualContestId && contest.hasFinished()) {
          createVirtualContestButton = UI$1.createElement(CreateVirtualContestButton, {
            label: "Create virtual contest",
            modalOptions: {
              contest: contest
            }
          });
        }
        let createDiscussionButton = null;
        if (!contest.getChat()) {
          createDiscussionButton = UI$1.createElement(CreateDiscussionButton, {
            label: "Create discussion",
            modalOptions: {
              contest: contest
            }
          });
        }
        let publishAnalysisButton = null;
        if (contest.hasFinished()) {
          publishAnalysisButton = UI$1.createElement(PublishAnalysisButton, {
            label: "Publish analysis",
            modalOptions: {
              contest: contest
            }
          });
        }
        let addToArchiveButton = null,
          printButton = null;
        if (USER.isSuperUser) {
          addToArchiveButton = UI$1.createElement(AddToArchiveButton, {
            label: "Add to archive",
            modalOptions: {
              contest: contest
            }
          });
          printButton = UI$1.createElement(PrintButton, {
            label: "Print",
            modalOptions: {
              contest: contest
            }
          });
        }
        let analysisPanel = null;
        if (USER.isSuperUser) {
          analysisPanel = UI$1.createElement(Panel, {
            title: "Analysis",
            style: {
              height: "100%"
            }
          }, UI$1.createElement(ContestAnalysisEditor, {
            contest: contest,
            style: {
              height: "100%"
            }
          }));
        }
        let permissionsPanel = null;
        let descriptionPanel = null;
        if (USER.isSuperUser || USER.id === contest.ownerId) {
          permissionsPanel = UI$1.createElement(Panel, {
            title: "Permissions",
            style: {
              height: "100%"
            }
          }, UI$1.createElement(ContestPermissionsEditor, {
            contest: contest,
            style: {
              height: "100%"
            }
          }));
          if (contest.getDescriptionArticle()) {
            descriptionPanel = UI$1.createElement(Panel, {
              title: "Description",
              style: {
                height: "100%"
              }
            }, UI$1.createElement(ArticleEditor, {
              articleId: contest.descriptionArticleId
            }));
          }
        }
        return [UI$1.createElement("h1", null, contest.longName), UI$1.createElement(ButtonGroup, {
          level: Level.PRIMARY,
          style: {
            margin: "10px 0"
          }
        }, UI$1.createElement(Button$1, {
          label: "Return to contest page",
          onClick: () => window.location.replace("/contest/" + contest.name + "/")
        }), UI$1.createElement(EditContestButton, {
          label: "Edit contest",
          modalOptions: {
            contest: contest
          }
        }), createVirtualContestButton, addToArchiveButton, publishAnalysisButton, createDiscussionButton, printButton, UI$1.createElement(ContestStatisticsButton, {
          label: "Stats",
          modalOptions: {
            contest: contest
          }
        }), USER.id === contest.ownerId && UI$1.createElement(DeleteContestButton, {
          label: "Delete contest",
          level: Level.DANGER,
          modalOptions: {
            contest: contest
          }
        })), UI$1.createElement(TabArea, {
          variableHeightPanels: true,
          style: {
            flex: "1"
          }
        }, UI$1.createElement(Panel, {
          title: "Tasks",
          active: true
        }, UI$1.createElement(AddTaskButton, {
          label: "Add task",
          level: Level.PRIMARY,
          style: {
            margin: "10px 0"
          },
          modalOptions: {
            contest: contest,
            tasksTable: tasksTable
          }
        }), tasksTable), descriptionPanel, UI$1.createElement(Panel, {
          title: "Announcements"
        }, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Broadcast announcement",
          style: {
            margin: "5px"
          },
          onClick: () => {
            AnnouncementBroadcastModal.show({
              contest
            });
          }
        }), UI$1.createElement(ContestAnnouncementList, {
          contest: contest
        })), UI$1.createElement(Panel, {
          title: "Questions",
          style: {
            height: "100%"
          }
        }, UI$1.createElement(AdminContestQuestionPanel, {
          contest: contest,
          style: {
            height: "100%"
          }
        })), analysisPanel, permissionsPanel, UI$1.createElement(ContestPlagiarismPanel, {
          title: "Plagiarism Checking",
          contest: contest,
          style: {
            height: "100%"
          }
        }))];
      }
      onMount() {
        GlobalState$1.registerStream("contest-" + this.options.contestId + "-announcements");
        GlobalState$1.registerStream("contest-" + this.options.contestId + "-scores");
        GlobalState$1.registerStream("contest-" + this.options.contestId + "-owner");
        ContestStore.get(this.options.contestId);
        let request = {};
        if (USER.isSuperUser) {
          Ajax.getJSON("/contest/fetch_archives/", request);
        }
      }
    }

    var _class$r, _descriptor$f, _descriptor2$f, _descriptor3$e, _descriptor4$d, _class2$g, _descriptor5$b, _descriptor6$9;
    let ContestSummaryStyle = (_class$r = class ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "label", _descriptor$f, this);
        _initializerDefineProperty(this, "statisticsPanelContainer", _descriptor2$f, this);
        this.cardPanelBodyStyle = {
          padding: "0px"
        };
        _initializerDefineProperty(this, "cardPanelRow", _descriptor3$e, this);
        _initializerDefineProperty(this, "title", _descriptor4$d, this);
      }
    }, (_descriptor$f = _applyDecoratedDescriptor(_class$r.prototype, "label", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "18px"
        };
      }
    }), _descriptor2$f = _applyDecoratedDescriptor(_class$r.prototype, "statisticsPanelContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "300px",
          maxWidth: "100%",
          marginTop: "30px"
        };
      }
    }), _descriptor3$e = _applyDecoratedDescriptor(_class$r.prototype, "cardPanelRow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "space-between",
          flex: "1"
        };
      }
    }), _descriptor4$d = _applyDecoratedDescriptor(_class$r.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "30px",
          paddingTop: "15px",
          fontSize: "26px"
        };
      }
    })), _class$r);
    let ContestPanelStyle = (_class2$g = class ContestPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "questionContainer", _descriptor5$b, this);
        _initializerDefineProperty(this, "askQuestionButton", _descriptor6$9, this);
      }
    }, (_descriptor5$b = _applyDecoratedDescriptor(_class2$g.prototype, "questionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "920px",
          maxWidth: "100%",
          margin: "0 auto",
          paddingLeft: "10px",
          paddingRight: "10px"
        };
      }
    }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$g.prototype, "askQuestionButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "20px",
          marginLeft: this.themeProps.CONTEST_QUESTION_CARD_PANEL_BODY_PADDING
        };
      }
    })), _class2$g);

    var _dec$l, _class$q;
    let ContestSummary = (_dec$l = registerStyle(ContestSummaryStyle), _dec$l(_class$q = class ContestSummary extends UI$1.Element {
      getInfoLines() {
        const {
          contest
        } = this.options;
        const stats = contest.getStatistics() || {};
        return [{
          label: UI$1.T("Users Registered"),
          value: contest.getNumUsers() || "N/A"
        }, {
          label: UI$1.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI$1.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI$1.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI$1.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI$1.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
      }
      getInfo(showRegisterButton) {
        const {
          contest
        } = this.options;
        const infoLines = this.getInfoLines();
        return [UI$1.createElement("div", {
          className: this.styleSheet.label
        }, UI$1.T("Start time"), ": ", contest.getFormattedStartTime()), UI$1.createElement("div", {
          className: this.styleSheet.label
        }, UI$1.T("Duration"), ": ", contest.getFormattedDuration()), showRegisterButton && this.getRegisterButton(), infoLines.length > 0 && UI$1.createElement("div", {
          className: this.styleSheet.statisticsPanelContainer
        }, UI$1.createElement(CardPanel, {
          title: "Contest statistics",
          bodyStyle: this.styleSheet.cardPanelBodyStyle
        }, UI$1.createElement(RowList, {
          rows: infoLines,
          rowParser: infoLine => {
            return UI$1.createElement("div", {
              className: this.styleSheet.cardPanelRow
            }, UI$1.createElement("span", null, infoLine.label), UI$1.createElement("span", null, infoLine.value));
          }
        })))];
      }
      getRegisterButton() {
        const {
          contest,
          baseContest
        } = this.options;
        if (!contest.hasFinished()) {
          let userRegistered = contest.getUser(USER.id);
          return UI$1.createElement(Button$1, {
            level: Level.INFO,
            label: userRegistered ? UI$1.T("Registered") : UI$1.T("Register"),
            onClick: () => this.registerUser(),
            style: {
              marginRight: "5px",
              marginTop: "10px"
            },
            disabled: userRegistered
          });
        }
        if (!contest.isVirtual() && baseContest) {
          //TODO: actually check if there's a virtual contest
          return UI$1.createElement(VirtualParticipationButton, {
            modalOptions: {
              contest: baseContest
            },
            style: {
              marginRight: "5px",
              marginTop: "10px"
            }
          });
        }
      }
      getDescription() {
        const {
          contest
        } = this.options;
        if (contest.systemGenerated) {
          contest.description = "On CS Academy, a contest takes place every hour.\n" + "This contest is scheduled on the " + StemDate.format(contest.getStartTime(), "Do of MMMM Y, at HH:mm") + " your local time";
        }
        const descriptionArticle = contest.getDescriptionArticle();
        if (descriptionArticle) {
          const articleClassMap = new MarkupClassMap(ArticleRenderer.markupClassMap, [["RawHTML", RawHTML]]);
          return UI$1.createElement(ArticleRenderer, {
            style: {
              marginTop: "1.5em"
            },
            article: descriptionArticle,
            classMap: articleClassMap
          });
        }
        return UI$1.createElement(RawHTML, {
          style: {
            marginTop: "1.5em"
          },
          __innerHTML: contest.description
        });
      }
      render() {
        const {
          contest
        } = this.options;
        return [UI$1.createElement("div", {
          className: this.styleSheet.title
        }, UI$1.T(contest.getName()), USER.isSuperUser && UI$1.createElement(Link, {
          href: "/contest/" + contest.name + "/edit/",
          value: UI$1.T("Edit"),
          style: {
            padding: 6
          }
        })), UI$1.createElement("div", null, this.getInfo(true)), this.getDescription()];
      }
      onMount() {
        const {
          contest
        } = this.options;
        const contestSummaryChanges = ["startTime", "endTime", "description", "longName", "name", "numRegistered", "numUsersOnline", "numSubmissions", "numExampleRuns", "numCompiles", "numCustomRuns"];
        this.attachChangeListener(contest, event => {
          for (const summaryField of contestSummaryChanges) {
            if (event.data.hasOwnProperty(summaryField) || event.hasOwnProperty(summaryField)) {
              this.redraw();
              break;
            }
          }
        });
      }
      registerUser() {
        if (!USER.isAuthenticated) {
          LoginModal.show();
          return;
        }
        const request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/register/", request);
      }
    }) || _class$q);

    var _class$p, _descriptor$e, _dec$k, _class2$f, _class3$7, _class4$3, _descriptor2$e, _descriptor3$d, _dec2$8, _class5$1;
    let ImprovedSubmissionSummaryStyle = (_class$p = class ImprovedSubmissionSummaryStyle extends SubmissionSummaryStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "submissionSummary", _descriptor$e, this);
      }
    }, (_descriptor$e = _applyDecoratedDescriptor(_class$p.prototype, "submissionSummary", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: 0
        };
      }
    })), _class$p);
    let ImprovedSubmissionSummary = (_dec$k = registerStyle(ImprovedSubmissionSummaryStyle), _dec$k(_class2$f = class ImprovedSubmissionSummary extends SubmissionSummary {
      getContest() {
        return this.getEvalJob().getContestTask().getContest();
      }
      getTimeSubmittedLabel() {
        const duration = new Duration({
          seconds: this.getEvalJob().timeSubmitted - this.getContest().getStartTime()
        });
        return duration.format("HH:mm:ss");
      }
      render() {
        const evalJobUIHandler = new EvalJobUIHandler(this.getEvalJob());
        return UI$1.createElement("div", null, [evalJobUIHandler.getJobIdWithExternalLink(), " (", evalJobUIHandler.getTimeSubmitted(), ") -- ", evalJobUIHandler.getStatus()]);
      }
      onMount() {
        super.onMount();
        this.addListener("expand", () => {
          this.options.contestTaskSubmissions.dispatch("expand", this);
        });
      }
    }) || _class2$f);
    let ContestTaskSubmissions = autoredraw(_class3$7 = class ContestTaskSubmissions extends UI$1.Element {
      getEvalJobs() {
        const {
          contestTask,
          contestUser
        } = this.options;
        return EvalJobStore.filterBy({
          contestTaskId: contestTask.id,
          userId: contestUser.userId,
          onlyExamples: false
        }).sort((a, b) => b.id - a.id);
      }
      getSubmissions() {
        const evalJobs = this.getEvalJobs();
        if (!evalJobs.length) {
          return UI$1.createElement("div", {
            style: {
              height: "30px",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              fontSize: "16px"
            }
          }, UI$1.createElement("em", null, UI$1.T("No submissions for this task")));
        }
        return evalJobs.map(evalJob => UI$1.createElement(ImprovedSubmissionSummary, {
          evalJob: evalJob,
          contestTaskSubmissions: this,
          ref: this.refLink("evalJob" + evalJob.id)
        }));
      }
      render() {
        const {
          contestUser,
          contestTask
        } = this.options;
        const score = contestUser.getContestTaskScore(contestTask);
        const cardTitle = UI$1.createElement("span", {
          style: {
            fontSize: "16px"
          }
        }, UI$1.T(this.options.contestTask.longName), " ", Formatter.truncate(score, 3), " ", UI$1.T("points"));
        return [UI$1.createElement(CardPanel, {
          title: cardTitle,
          size: Size.LARGE,
          ref: "cardPanel"
        }, this.getSubmissions())];
      }
      onMount() {
        this.attachListener(EvalJobStore, ["create", "refresh"], evalJob => {
          if (evalJob.userId === this.options.contestUser.userId && evalJob.contestId === this.options.contest.id) {
            this.redraw();
          }
        });
        this.addListener("expand", expandingElement => {
          for (const evalJob of this.getEvalJobs()) {
            const submissionSummary = this["evalJob" + evalJob.id];
            if (expandingElement !== submissionSummary) {
              if (!submissionSummary.options.collapsed) {
                setTimeout(() => submissionSummary.collapse(), 250);
              }
            }
          }
        });
      }
    }) || _class3$7;
    let ContestSubmissionsStyle = (_class4$3 = class ContestSubmissionsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor2$e, this);
        _initializerDefineProperty(this, "sectionContainer", _descriptor3$d, this);
      }
    }, (_descriptor2$e = _applyDecoratedDescriptor(_class4$3.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "25px",
          display: "flex",
          justifyContent: "center",
          alignItems: "flex-start",
          flexWrap: "wrap",
          flexDirection: "row"
        };
      }
    }), _descriptor3$d = _applyDecoratedDescriptor(_class4$3.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "12.5px",
          minWidth: "425px",
          width: "30%"
        };
      }
    })), _class4$3);
    let ContestSubmissions = (_dec2$8 = registerStyle(ContestSubmissionsStyle), _dec2$8(_class5$1 = class ContestSubmissions extends UI$1.Element {
      getContestTasks() {
        return this.getContest().getContestTasks();
      }
      render() {
        const {
          contest,
          contestUser
        } = this.options;
        return contest.getContestTasks().map(contestTask => UI$1.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI$1.createElement(ContestTaskSubmissions, {
          contest: contest,
          contestUser: contestUser,
          contestTask: contestTask
        })));
      }
      onMount() {
        Ajax.getJSON("/eval/get_eval_jobs/", {
          contestId: this.options.contest.id,
          userId: this.options.contestUser.userId
        });
      }
    }) || _class5$1);

    class NextContestModal extends ActionModal {
      getTitle() {
        return UI$1.T("This contest has finished");
      }
      getBody() {
        let congrats;
        let contestUser = this.options.contest.getUser(USER.id);
        if (contestUser) {
          let rank = contestUser.rank;
          congrats = UI$1.createElement("p", null, UI$1.T("Your rank:"), " ", rank, ". ", UI$1.T("Congratulations!"));
        }
        return UI$1.createElement("div", null, congrats, UI$1.createElement("p", null, UI$1.T("A new hourly contest will start soon!")), UI$1.createElement("p", null, UI$1.T("What would you like to do?")));
      }
      getFooter() {
        return UI$1.createElement(ButtonGroup, {
          level: Level.PRIMARY
        }, UI$1.createElement(Button$1, {
          label: UI$1.T("Stay here"),
          onClick: () => this.hide()
        }), UI$1.createElement(Button$1, {
          label: UI$1.T("Go to homepage"),
          onClick: () => {
            Router.changeURL([]);
            this.hide();
          }
        }), UI$1.createElement(Button$1, {
          label: UI$1.T("Go to next contest"),
          onClick: () => {
            Router.changeURL(["contest", this.options.nextContestData.name]);
            this.hide();
          }
        }));
      }
    }
    class ContestCancelledModal extends ActionModal {
      getTitle() {
        return UI$1.T("This contest has been cancelled");
      }
      getBody() {
        return UI$1.createElement("div", null, UI$1.createElement("p", null, UI$1.T("For an hourly contest to take place, at least one " + "person should be registered before the contest starts.")));
      }
      getFooter() {
        let nextContestButton;
        if (this.options.nextContestName) {
          nextContestButton = UI$1.createElement(Button$1, {
            label: UI$1.T("Go to next contest"),
            onClick: () => {
              Router.changeURL(["contest", this.options.nextContestName]);
              this.hide();
            }
          });
        }
        return UI$1.createElement(ButtonGroup, {
          level: Level.PRIMARY
        }, UI$1.createElement(Button$1, {
          label: UI$1.T("Stay here"),
          onClick: () => this.hide()
        }), UI$1.createElement(Button$1, {
          label: UI$1.T("Go to homepage"),
          onClick: () => {
            Router.changeURL([]);
            this.hide();
          }
        }), nextContestButton);
      }
    }

    class ContestLoadingPage extends UI$1.Element {
      render() {
        const textStyle = {
          textAlign: "center",
          marginTop: "10px",
          fontSize: "2em"
        };
        if (this.options.error) {
          return UI$1.createElement("div", {
            style: textStyle
          }, this.options.error.message, UI$1.createElement("br", null), "Try refreshing the page.");
        }
        return [StateDependentElement.renderLoading(), UI$1.createElement("div", {
          style: textStyle
        }, "Contest is loading. Please do not refresh the page.")];
      }
      onMount() {
        const contest = this.options.contest;
        if (contest.isVirtual()) {
          return;
        }
        if (contest.hasAnyTask()) {
          contest.dispatch("loadedManually");
          return;
        }
        const delay = (Math.max(contest.getStartTime() - ServerTime.now().unix(), 0) + 5 + Math.random() * 10) * 1000;
        this.timerId = setTimeout(() => {
          if (!contest.hasAnyTask()) {
            Ajax.getJSON("/contest/" + contest.name + "/", {}).then(() => contest.dispatch("loadedManually"), error => this.updateOptions({
              error
            }));
          }
          delete this.timerId;
        }, delay);
      }
      onUnmount() {
        if (this.timerId) {
          clearTimeout(this.timerId);
        }
      }
    }

    var _class$o, _descriptor$d, _descriptor2$d, _descriptor3$c, _descriptor4$c, _dec$j, _class2$e;
    let ContestNotificationStyle = (_class$o = class ContestNotificationStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);
        this.timeout = 1000;
        _initializerDefineProperty(this, "className", _descriptor$d, this);
        this.body = {
          width: "320px",
          padding: "10px"
        };
        _initializerDefineProperty(this, "visible", _descriptor2$d, this);
        _initializerDefineProperty(this, "buttonGroup", _descriptor3$c, this);
        _initializerDefineProperty(this, "textBoxClass", _descriptor4$c, this);
      }
    }, (_descriptor$d = _applyDecoratedDescriptor(_class$o.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxShadow: "none",
          backgroundColor: this.themeProps.COLOR_BACKGROUND,
          zIndex: 9999,
          position: "fixed",
          right: "10px",
          top: "-100px",
          opacity: "0",
          transition: this.timeout / 1000 + "s all ease",
          fontSize: "110%"
        };
      }
    }), _descriptor2$d = _applyDecoratedDescriptor(_class$o.prototype, "visible", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          top: "39px",
          opacity: "1"
        };
      }
    }), _descriptor3$c = _applyDecoratedDescriptor(_class$o.prototype, "buttonGroup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "right",
          marginBottom: "5px",
          marginRight: "-5px",
          ">*": {
            padding: "2px 4px"
          }
        };
      }
    }), _descriptor4$c = _applyDecoratedDescriptor(_class$o.prototype, "textBoxClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "block",
          cursor: "pointer",
          height: "2em",
          marginBottom: "15px",
          ":hover": {
            textDecoration: "none"
          }
        };
      }
    })), _class$o);
    let ContestNotification = (_dec$j = registerStyle(ContestNotificationStyle), _dec$j(_class2$e = class ContestNotification extends CardPanel {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          level: Level.WARNING,
          bodyStyle: this.styleSheet.body
        });
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        if (this.options.manager.notificationCount === 1) {
          attr.setStyle("boxShadow", Theme.props.DARK_BOX_SHADOW);
        }
        attr.addClass(this.styleSheet.className);
      }
      show() {
        this.addClass(this.styleSheet.visible);
      }
      hide() {
        this.removeClass(this.styleSheet.visible);
        setTimeout(() => this.options.manager.deleteNotification(this.options.data), this.styleSheet.timeout);
      }
      render() {
        const {
          manager
        } = this.options;
        if (this.options.data.link) {
          this.message = UI$1.createElement(Link, {
            className: this.styleSheet.textBoxClass,
            href: this.options.data.link,
            value: this.options.data.message
          });
        } else {
          this.message = UI$1.createElement("div", {
            className: this.styleSheet.textBoxClass
          }, this.options.data.message);
        }
        const closeAllButton = manager.notificationCount > 1 && UI$1.createElement(Button$1, {
          ref: "closeAll",
          onClick: () => manager.deleteAll()
        }, "Close all(" + manager.notificationCount + ")");
        return [this.message, UI$1.createElement(ButtonGroup, {
          size: Size.SMALL,
          level: Level.DANGER,
          className: this.styleSheet.buttonGroup
        }, closeAllButton, UI$1.createElement(Button$1, {
          ref: "close",
          onClick: () => this.hide()
        }, "Close"))];
      }
      onMount() {
        setTimeout(() => this.show(), 100);
        if (this.options.data.link) {
          this.message.addClickListener(() => {
            if (this.options.data.id) {
              window.location.hash = this.options.data.id;
            }
            this.hide();
          });
        }
      }
    }) || _class2$e);
    class ContestNotificationManager {
      // contestId is needed as an identifier only.
      constructor(contestId) {
        this.notifications = new Map();
        this.notificationCount = 0;
        this.localStorageMap = ContestLocalStorageManager.getNotificationsLocalStorageMap(contestId);
        const notificationData = this.getAllDataFromStorage();
        for (const [key, data] of notificationData) {
          this.createNotification(data, false);
        }
        this.localStorageMap.addChangeListener(event => {
          if (!event.newValue) {
            // removed
            this.deleteNotification(event.oldValue, false);
          }
        });
      }
      getAllDataFromStorage() {
        return this.localStorageMap.entries().sort((a, b) => a[1].timeAdded - b[1].timeAdded);
      }

      // data is an object that contains the fields "message", "link", "title" and "id".
      createNotification(data, addData = true) {
        if (addData) {
          data.timeAdded = StemDate.now().unix();
          this.localStorageMap.set(data.key, data);
        }
        this.notificationCount += 1;
        this.notifications.set(data.key, ContestNotification.create(document.body, {
          title: data.title,
          data: data,
          manager: this
        }));
      }
      deleteNotification(data, deleteData = true) {
        if (deleteData) {
          this.localStorageMap.delete(data.key);
        }
        this.notificationCount -= 1;
        const notificationElement = this.notifications.get(data.key);
        this.notifications.delete(data.key);
        if (notificationElement) {
          notificationElement.destroyNode();
        }
      }
      deleteAll() {
        for (let notificationElement of this.notifications.values()) {
          notificationElement.hide();
        }
      }
    }

    var _dec$i, _class$n;
    let ContestPanel = (_dec$i = registerStyle(ContestPanelStyle), _dec$i(_class$n = class ContestPanel extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new ContestNavigationHandler(this.getContest(), this);
        this.contestTaskPanelsMap = new Map();
      }
      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }
      setOptions(options) {
        super.setOptions(options);
        this.getBaseContest().recalculateUsers();
      }
      getContest() {
        return ContestStore.get(this.options.contestId);
      }
      getContestUser() {
        return this.getContest().getUser(USER.id);
      }
      getBaseContest() {
        return this.getContest().getBaseContest();
      }
      getVirtualContest() {
        if (this.getContest().virtualContestId || this.getContest().isVirtual()) {
          return this.getContest().getVirtualContest();
        }
        return null;
      }
      playbackScoring() {
        // TODO: refactor contestEvents to priorityQueue
        let contestEvents = ContestEventStore.all().sort((a, b) => {
          return a.event.contestTime - b.event.contestTime;
        });
        let shouldApplyEvent = event => {
          return ServerTime.now().unix() - this.getVirtualContest().getStartTime() > event.contestTime;
        };
        let updateInterval = setInterval(() => {
          if (this.getVirtualContest().hasFinished()) {
            clearInterval(updateInterval);
          }
          while (contestEvents.length && shouldApplyEvent(contestEvents[0].event)) {
            GlobalState$1.applyEvent(contestEvents.shift().event);
          }
        }, 1000);
        ContestEventStore.addCreateListener(contestEvent => {
          contestEvents.push(contestEvent);
          contestEvents.sort((a, b) => {
            return a.event.contestTime - b.event.contestTime;
          });
        });
      }
      setActive(element) {
        super.setActive(element);
        this.dispatch("activeElementChanged");
      }
      switchToTask(contestTask) {
        if (this.loadingPage) {
          this.loadingPage.destroyNode();
          delete this.loadingPage;
        }
        Router.changeURL(contestTask.getFullURL());
      }
      getSummaryPanel() {
        return UI$1.createElement(ContestSummary, {
          contest: this.getContest(),
          baseContest: this.getBaseContest(),
          className: GlobalStyle.Container.MEDIUM
        });
      }
      getTasksListPanel() {
        return UI$1.createElement(ContestTaskList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }
      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI$1.createElement(Scoreboard, {
          ref: this.refLink("scoreboard"),
          className: GlobalStyle.Container.MEDIUM,
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }
      getChatPanel() {
        const chatId = this.getContest().chatId;
        return chatId && UI$1.createElement(ContestChat, {
          chatId: chatId,
          ref: this.refLink("chat"),
          className: GlobalStyle.Container.MEDIUM
        });
      }
      getSubmissionsPanel() {
        const contest = this.getContest();
        return USER.isAuthenticated && UI$1.createElement(ContestSubmissions, {
          contest: contest,
          contestUser: contest.getUser(USER.id),
          className: GlobalStyle.Container.MEDIUM
        });
      }
      getAnnouncementsPanel() {
        if (!this.announcementsList) {
          this.announcementsList = UI$1.createElement(ContestAnnouncementList, {
            ref: this.refLink("announcements"),
            contest: this.getBaseContest(),
            style: {
              display: "flex",
              alignItems: "center",
              flexDirection: "column"
            },
            className: GlobalStyle.Container.MEDIUM
          });
        }
        return this.announcementsList;
      }
      getAnalysisPanel() {
        if (this.getContest().hasFinished() && this.getContest().isAnalysisPublic) {
          return UI$1.createElement(ContestAnalysis, {
            contest: this.getContest(),
            className: GlobalStyle.Container.MEDIUM
          });
        }
      }
      getLoadingPanel() {
        return UI$1.createElement(ContestLoadingPage, {
          ref: this.refLink("loadingPage"),
          contest: this.getContest()
        });
      }
      getContestTaskPanel(contestTask) {
        if (!this.contestTaskPanelsMap.has(contestTask.id)) {
          this.contestTaskPanelsMap.set(contestTask.id, UI$1.createElement(DelayedContestTaskPanel, {
            contestTaskId: contestTask.id
          }));
        }
        return this.contestTaskPanelsMap.get(contestTask.id);
      }
      getSubroutes() {
        const contest = this.getContest();
        return [new Route("summary", () => this.getSummaryPanel()), new Route("tasks", () => this.getTasksListPanel(), [], "Tasks"), new Route("task", () => this.getTasksListPanel(), [new TerminalRoute("%s", options => {
          const contestTask = ContestTaskStore.getByContestIdAndUrlName(this.options.contestId, options.args[0]);
          return contestTask && this.getContestTaskPanel(contestTask);
        })]), new Route("scoreboard", () => this.getScoreboardPanel(), [], "Scoreboard"), new Route("chat", () => this.getChatPanel(), [], "Chat"), new Route("submissions", () => this.getSubmissionsPanel(), [], "Submissions"), new Route("announcements", () => this.getAnnouncementsPanel(), [], "Announcements"), new Route("analysis", () => this.getAnalysisPanel(), [], "Analysis"), new Route("loading", () => this.getLoadingPanel(), [], "Loading"),
        // Special subpages configurable per contest
        contest.getSubpages().map(subpage => {
          const generator = () => UI$1.createElement(RecursiveArticleRenderer, {
            articleId: subpage.articleId,
            style: {
              maxWidth: 800,
              margin: "auto",
              padding: 8
            }
          });
          return new Route(subpage.url, generator, [], subpage.name);
        })];
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }
      setURL(urlParts) {
        if (urlParts) {
          super.setURL(urlParts);
          PageTitleManager.setTitle(this.pageTitle);
        }
      }
      get pageTitle() {
        let title = this.getContest().getName();
        const currentPageTitle = this.getActive().pageTitle;
        if (currentPageTitle) {
          title = currentPageTitle + " " + title;
        }
        return title;
      }
      getURLPrefix(str) {
        let url = "/contest/" + this.getContest().name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      updateOnNewTasks() {
        this.redraw();
        this.navHandler.apply();
        this.scoreboard?.scoreboardTable.redraw();
      }
      processTaskBroadcast(event) {
        if (this.getContest().id !== event.task.contestId || this.getContest().loadedManually) {
          return;
        }
        // Ensure that the problem which marks the contest as started is the first one
        if (!this.getContest().hasStarted() && !event.task.forceTaskOpen) {
          setTimeout(() => {
            GlobalState$1.applyEvent(event);
          }, 1000);
          return;
        }
        if (!this.getContest().hasStarted() && event.task.forceTaskOpen) {
          // HACK: If the contest MUST start now, ensure that contest.hasStarted() returns true
          this.getContest().startTime = ServerTime.now().unix();
        }
        GlobalState$1.importState(event.task.state);
        if (event.state) {
          GlobalState$1.importState(event.state);
        }
        let contestTask = ContestTaskStore.get(event.task.contestTaskId);
        this.getContest().addContestTask(contestTask);
        this.updateOnNewTasks();
        if (event.objectType !== "contest") {
          GlobalState$1.applyEvent({
            "objectType": "contest",
            "objectId": this.getContest().id,
            "type": event.type,
            "data": event.data,
            "task": event.task
          });
        }
        if (event.task.forceTaskOpen) {
          this.switchToTask(contestTask);
        }
      }
      createUserListener() {
        this.attachChangeListener(UserStore.getCurrentUser(), event => {
          if (event.type !== "contestTaskBroadcast") {
            return;
          }
          if (!this.getContest().getUser(USER.id)) {
            return;
          }
          this.processTaskBroadcast(event);
        });
        this.attachEventListener(this.getContest(), "contestTaskBroadcast", event => {
          let extra = event.extra || {};
          Object.assign(event, extra);
          this.processTaskBroadcast(event);
        });
      }
      requestScoreboard() {
        const contest = this.getContest();
        Ajax.getJSON("/contest/scoreboard_state/", {
          contestId: contest.id
        }).then(() => {
          this._loadedScoreboard = true;
          contest._loadedScoreboard = true;
          this.navHandler.apply();
          this.contestTaskList && this.contestTaskList.refreshBubbles();
          if (contest.isVirtual()) {
            for (let contestUser of contest.getBaseContest().getUsers()) {
              contestUser.resetScore();
            }
            for (let contestUser of contest.getUsers()) {
              contestUser.resetScore();
            }
            contest.getBaseContest().recalculateUsers();
            if (!contest.hasStarted()) {
              //TODO: find a way to remove timeout, maybe simulate contestTaskBroadcast event?
              setTimeout(() => {
                this.redraw();
                this.navHandler.apply();
                let firstTask = contest.getBaseContest().getContestTasks()[0];
                this.switchToTask(firstTask.getVirtualTask());
                this.playbackScoring();
              }, (contest.getStartTime() - ServerTime.now().unix()) * 1000);
            } else {
              this.playbackScoring();
            }
          }
        });
      }
      requestChat() {
        const contest = this.getContest();
        const chatId = contest.chatId;
        if (chatId) {
          GroupChatStore.fetch(this.getContest().chatId, () => {
            this.chat && this.chat.redraw();
            this.navHandler.apply();
          });
        }
      }
      initializeContestLoading() {
        const contest = this.getContest();
        if (!contest.isVirtual() && !contest.hasStarted()) {
          const contestStartTime = contest.getStartTime();
          const currentServerTime = ServerTime.now().unix();
          const timeRemainingInMilliseconds = (contestStartTime - currentServerTime) * 1000;
          if (timeRemainingInMilliseconds < 20 * TimeUnit.DAY) {
            setTimeout(() => {
              if (!contest.hasAnyTask()) {
                Router.changeURL(this.getURLPrefix("loading"));
              }
            }, timeRemainingInMilliseconds);
          }
        }
        this.attachListener(contest, "loadedManually", () => {
          contest.loadedManually = true;
          this.updateOnNewTasks();

          // Jump to the task with the lowest contest index (the "first" task)
          this.switchToTask(contest.getContestTasks()[0]);
        });
      }
      attachHourlyContestListeners() {
        const contest = this.getContest();
        this.attachEventListener(contest, "contestEnd", event => {
          if (this.isInDocument()) {
            NextContestModal.show({
              contest: this.getContest(),
              nextContestData: event.nextContestData
            });
          }
        });
        this.attachDeleteListener(contest, event => {
          if (event.reason && event.reason === "noRegisteredUsers" && this.isInDocument()) {
            ContestCancelledModal.show({
              nextContestName: event.nextContestData.name
            });
          }
        });
      }
      attachAnalysisListeners() {
        this.attachEventListener(this.getContest(), "publishAnalysis", () => {
          if (this.isInDocument()) {
            this.redraw();
            this.navHandler.apply();
            AnalysisModal.show({
              contestPanel: this
            });
          }
        });
        this.addListener("gotoAnalysis", () => {
          Router.changeURL(this.getURLPrefix("analysis"));
        });
      }
      registerStreams() {
        GlobalState$1.registerStream("contest-" + this.getBaseContest().id + "-announcements");
        if (USER.isSuperUser || this.getContest().liveResults) {
          GlobalState$1.registerStream("contest-" + this.getBaseContest().id + "-scores");
        }
        if (!this.getBaseContest().getUser(USER.id)) {
          GlobalState$1.registerStream("contest-" + this.getBaseContest().id + "-unregistered");
        }
        if (this.getVirtualContest()) {
          GlobalState$1.registerStream("contest-" + this.getVirtualContest().id + "-scoreevents");
        }
        if (!this.getContest().isVirtual() && this.getVirtualContest()) {
          GlobalState$1.registerStream("contest-" + this.getVirtualContest().id + "-scores");
        }
      }
      handleAnnotationsAndQuestionsChanges() {
        const contest = this.getContest();
        const questionsLocalStorageMap = ContestLocalStorageManager.getQuestionsLocalStorageMap(contest.id);
        const announcementsLocalStorageMap = ContestLocalStorageManager.getAnnouncementsLocalStorageMap(contest.id);
        const contestNotificationManager = new ContestNotificationManager(contest.id);
        const createQuestionNotificationHandler = question => {
          const task = question.getContestTask();
          if (question.contestId === contest.id && question.isAnswered() && question.shouldAppear()) {
            const message = question.isAskedByCurrentUser() ? 'Your question for task "' + task.longName + '" has been answered.' : "A user's question for task " + '"' + task.longName + '" has been answered publicly.';
            contestNotificationManager.createNotification({
              message: message,
              link: task.getFullURL() + "questions",
              title: "Question notification",
              id: "question" + question.id,
              key: question.id
            });
            const badgeValue = parseInt(this.getContestTaskPanel(task) && this.getContestTaskPanel(task).badge && this.getContestTaskPanel(task).badge.getValue() || 0);
            questionsLocalStorageMap.set(task.id, badgeValue + 1);
          }
        };
        const createAnnouncementNotificationHandler = announcement => {
          if (announcement.contestId === contest.id) {
            let link = this.getURLPrefix("") + "announcements";
            let message = "New announcement: " + announcement.getTarget();
            let id = "announcement" + announcement.id;
            if (announcement.isTaskBroadcast()) {
              link = this.getURLPrefix("task/" + announcement.getContestTask().name);
              message = 'Task "' + announcement.getContestTask().longName + '" is now available!';
              id = null;
            }
            contestNotificationManager.createNotification({
              message: message,
              title: announcement.getTarget(),
              id: id,
              key: announcement.id,
              link: link
            });
            const badgeValue = parseInt(this.navHandler.announcementsBadge && this.navHandler.announcementsBadge.getValue() || 0);
            announcementsLocalStorageMap.set("counter", badgeValue + 1);
          }
        };
        this.attachCreateListener(ContestQuestionStore, question => {
          if (!question.isAskedByCurrentUser()) {
            createQuestionNotificationHandler(question);
          }
        });
        this.attachListener(this.getContest(), "updateQuestion", createQuestionNotificationHandler);
        this.attachCreateListener(ContestAnnouncementStore, createAnnouncementNotificationHandler);
      }
      onMount() {
        this.navHandler.apply();
        this.requestScoreboard();
        this.requestChat();
        if (UserStore.getCurrentUser()) {
          this.createUserListener();
        }
        this.initializeContestLoading();
        this.attachAnalysisListeners();
        if (this.getContest().systemGenerated) {
          this.attachHourlyContestListeners();
        }
        this.registerStreams();
        if (!this.getContest().hasFinished()) {
          this.handleAnnotationsAndQuestionsChanges();
        }
      }
    }) || _class$n);

    class DelayedArchiveOrContestPanel extends StateDependentElement(UI$1.Element) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "100%"
        });
      }
      importState(data) {
        super.importState(data);
        if (data.contest) {
          this.contestId = data.contest.id;
        } else {
          this.archiveId = data.archive.id;
        }
      }
      renderLoaded() {
        if (this.options.error) {
          return this.renderError();
        }
        if (this.contestId) {
          return UI$1.createElement(ContestPanel, {
            contestId: this.contestId,
            ref: "child"
          });
        }
        return UI$1.createElement(ArchivePanel, {
          archiveId: this.archiveId,
          ref: "child"
        });
      }
      setURL(urlParts) {
        if (this.child) {
          this.child.setURL(urlParts);
        } else {
          this.urlParts = urlParts;
        }
      }
      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }
      onDelayedMount() {
        this.dispatchUrlChange();
        this.addListener("urlExit", () => {
          if (!this.options.error) {
            this.child.navHandler.reset();
          }
        });
        this.addListener("urlEnter", () => {
          // This works because the very first time the child is create, it makes sure to update the Navbar
          if (this.child && !this.options.error) {
            this.child.navHandler.apply();
          }
        });
      }
    }

    class CreatePrivateArchiveModal extends ActionModal {
      getActionName() {
        return "Create private archive";
      }
      getBody() {
        return UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "urlNameFormField",
          label: "URL name"
        }, UI$1.createElement(TextInput, {
          ref: "urlNameInput",
          value: ""
        })), UI$1.createElement(FormField, {
          ref: "longNameFormField",
          label: "Long name"
        }, UI$1.createElement(TextInput, {
          ref: "longNameInput",
          value: ""
        })));
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "New archive",
          onClick: () => this.createPrivateArchive()
        }))];
      }
      createPrivateArchive() {
        let privateArchiveName = this.urlNameInput.getValue();
        let privateArchivelongName = this.longNameInput.getValue();
        let request = {
          privateArchiveName: privateArchiveName,
          privateArchiveLongName: privateArchivelongName
        };
        Ajax.postJSON("/contest/create_private_archive/", request).then(data => {
          this.hide();
          this.options.privateArchiveList.redraw();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    class DeletePrivateArchiveModal extends ActionModal {
      getPrivateArchives() {
        let privateArchives = this.options.privateArchiveList.getPrivateArchives();
        privateArchives.sort((a, b) => {
          return b.id - a.id;
        });
        return privateArchives;
      }
      getActionName() {
        return "Delete private archive";
      }
      getBody() {
        return UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "typeFormField",
          label: "Archive"
        }, UI$1.createElement(Select, {
          ref: "privateArchiveSelect",
          options: this.getPrivateArchives()
        })));
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(Button$1, {
          level: Level.DANGER,
          label: "Delete archive",
          onClick: () => this.deletePrivateArchive()
        })];
      }
      deletePrivateArchive() {
        let privateArchive = this.privateArchiveSelect.get();
        let request = {
          privateArchiveId: privateArchive.id
        };
        Ajax.postJSON("/contest/delete_private_archive/", request).then(() => {
          PrivateArchiveStore.applyDeleteEvent({
            type: "delete",
            objectId: privateArchive.id
          });
          this.hide();
          this.options.privateArchiveList.redraw();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    class PrivateArchiveTable extends Table {
      getDefaultColumns() {
        return [{
          value: privateArchive => UI$1.createElement(Link, {
            href: "/private-archive/" + privateArchive.name,
            value: privateArchive.getName()
          }),
          headerName: "Archive",
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }];
      }
    }
    class PrivateArchiveList extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      getPrivateArchives() {
        return PrivateArchiveStore.all();
      }
      render() {
        this.createPrivateArchiveModal = UI$1.createElement(CreatePrivateArchiveModal, {
          privateArchiveList: this
        });
        this.deletePrivateArchiveModal = UI$1.createElement(DeletePrivateArchiveModal, {
          privateArchiveList: this
        });
        return [UI$1.createElement("div", {
          className: "pull-right"
        }, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "New archive",
          onClick: () => this.createPrivateArchiveModal.show(),
          style: {
            margin: "5px"
          }
        }), UI$1.createElement(Button$1, {
          level: Level.DANGER,
          label: "Delete archive",
          onClick: () => this.deletePrivateArchiveModal.show(),
          style: {
            margin: "5px"
          }
        })), UI$1.createElement("h3", null, "All private archives:"), UI$1.createElement(PrivateArchiveTable, {
          entries: this.getPrivateArchives()
        })];
      }
    }

    class UserHandle extends UI$1.Element {
      setOptions(options) {
        options.userId = options.userId || options.id;
        super.setOptions(options);
        this.options.color = this.options.color || "#2089b5";
        this.setUser(PublicUserStore.get(this.options.userId));
      }
      setUser(user) {
        this.user = user;
      }
      getNodeType() {
        return "span";
      }
      setColor(color) {
        this.options.color = color;
        this.handle.setStyle("color", color);
      }
      render() {
        let handle;
        if (!this.user) {
          PublicUserStore.fetch(this.options.userId, user => {
            this.setUser(user);
            this.redraw();
          });
          handle = UI$1.createElement("b", {
            ref: "handle",
            style: {
              color: "#BBB"
            }
          }, "user-" + this.options.userId);
        } else {
          handle = UI$1.createElement("span", {
            ref: "handle",
            style: {
              cursor: "pointer",
              color: this.options.color
            },
            onClick: () => {
              window.open(this.user.getProfileUrl(), "_blank");
            }
          }, UI$1.createElement("b", null, this.user.getDisplayHandle()));
        }

        //The purpose of the container is to simplify the usage of the popup.
        return [UI$1.createElement("span", {
          ref: "container",
          style: {
            position: "relative",
            overflow: "hidden"
          }
        }, handle, this.options.children)];
      }
    }

    class UserGroupMemberUI extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-top", "5px");
      }
      getDestroyButton() {
        return UI$1.createElement(Button$1, {
          level: Level.DANGER,
          size: Size.EXTRA_SMALL,
          icon: "minus",
          ref: "destroyButton",
          style: {
            marginRight: "5px"
          }
        });
      }
      getUserHandle() {
        return UI$1.createElement(UserHandle, {
          userId: this.options.member.userId
        });
      }
      render() {
        return [this.getDestroyButton(), this.getUserHandle()];
      }
      onMount() {
        this.destroyButton.addClickListener(() => Ajax.postJSON("/accounts/change_user_group/", {
          groupId: this.options.member.groupId,
          userId: this.options.member.userId,
          action: "remove"
        }).then(() => this.options.member.delete()));
      }
    }
    class UserGroupEditor extends UI$1.Element {
      getGroup() {
        return UserGroupStore.get(this.options.groupId);
      }
      renderUserGroupMember(member) {
        return UI$1.createElement(UserGroupMemberUI, {
          member: member
        });
      }
      render() {
        const members = this.getGroup().getMembers();
        return [members.map(member => this.renderUserGroupMember(member)), UI$1.createElement(UserInputField, {
          ref: "addUserField",
          style: {
            marginTop: "10px"
          }
        })];
      }
      onMount() {
        this.addUserField.addListener("user", userId => Ajax.postJSON("/accounts/change_user_group/", {
          groupId: this.options.groupId,
          userId: userId,
          action: "add"
        }).then(() => this.addUserField.clear()));
        this.attachListener(UserGroupMemberStore, ["create", "delete"], userGroupMember => {
          if (userGroupMember.groupId === this.options.groupId) {
            this.redraw();
          }
        });
      }
    }

    class PrivateArchiveCreateEvalTaskModal extends CreateEvalTaskModal {
      getPrivateArchive() {
        return this.options.privateArchiveWidget.getPrivateArchive();
      }
      addEvalTask(evalTaskId) {
        let request = {
          privateArchiveId: this.getPrivateArchive().id,
          evalTaskId: evalTaskId
        };
        Ajax.postJSON("/contest/private_archive_add_eval_task/", request).then(() => this.hide());
      }
      createTask() {
        let urlName = this.urlNameInput.getValue();
        let longName = this.longNameInput.getValue();
        let type = this.typeSelect.get().id;
        let timeLimit = this.timeLimitInput.getValue();
        let memoryLimit = this.memoryLimitInput.getValue() * 1024;
        let request = {
          urlName: urlName,
          longName: longName,
          type: type,
          timeLimit: timeLimit,
          memoryLimit: memoryLimit
        };
        Ajax.postJSON("/eval/create_eval_task/", request).then(data => {
          this.addEvalTask(data.evalTaskId);
          window.location.pathname = "/task/" + urlName + "/edit/";
        }, error => this.messageArea.showMessage(error.message, "red"));
      }
    }
    class PrivateArchiveRemoveEvalTaskModal extends ActionModal {
      getPrivateArchive() {
        return this.options.privateArchiveWidget.getPrivateArchive();
      }
      getActionName() {
        return "Remove eval task";
      }
      getBody() {
        return UI$1.createElement(FormField, {
          ref: "typeFormField",
          label: "Task"
        }, UI$1.createElement(Select, {
          ref: "taskSelect",
          options: this.getPrivateArchive().getEvalTasks()
        }));
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), ",", UI$1.createElement(Button$1, {
          level: Level.WARNING,
          label: "Remove task",
          onClick: () => this.removeTask()
        }))];
      }
      removeTask() {
        let task = this.taskSelect.get();
        let request = {
          privateArchiveId: this.getPrivateArchive().id,
          evalTaskId: task.id
        };
        Ajax.postJSON("/contest/private_archive_remove_eval_task/", request).then(() => {
          this.hide();
          window.location.reload();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    class PrivateArchiveAddEvalTaskModal extends Modal {
      getPrivateArchive() {
        return this.options.privateArchiveWidget.getPrivateArchive();
      }
      renderModal(bodyContent) {
        return [UI$1.createElement("div", {
          style: {
            margin: "0px"
          }
        }, UI$1.createElement("div", null, UI$1.createElement("h4", null, "Add eval task")), UI$1.createElement("div", {
          ref: "body"
        }, bodyContent), UI$1.createElement("div", null, UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Add task",
          onClick: () => this.addTask()
        })))];
      }
      render() {
        if (!this.isLoaded) {
          this.fetchEvalTasks();
          return this.renderModal(UI$1.createElement(Form, {
            style: {
              marginTop: "10px"
            }
          }, UI$1.createElement(FormField, {
            ref: "typeFormField",
            label: "Loading Tasks"
          })));
        }
        return this.renderModal(UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "typeFormField",
          label: "Task"
        }, UI$1.createElement(Select, {
          ref: "taskSelect",
          options: this.getEvalTasks()
        }))));
      }
      getEvalTasks() {
        let allEvalTasks = EvalTaskStore.all();
        let privateArchiveEvalTasks = this.getPrivateArchive().getEvalTasks();
        let evalTasks = allEvalTasks.filter(evalTask => privateArchiveEvalTasks.indexOf(evalTask) == -1);
        evalTasks.sort((a, b) => {
          return b.id - a.id;
        });
        return evalTasks;
      }
      fetchEvalTasks() {
        if (this.isLoading) {
          return;
        }
        this.isLoading = true;
        let request = {};
        Ajax.getJSON("/eval/get_available_tasks/", request).then(() => {
          this.isLoading = false;
          this.isLoaded = true;
          this.body.options.children = [UI$1.createElement(Form, {
            style: {
              marginTop: "10px"
            }
          }, UI$1.createElement(FormField, {
            ref: this.refLink("typeFormField"),
            label: "Task"
          }, UI$1.createElement(Select, {
            ref: this.refLink("taskSelect"),
            options: this.getEvalTasks()
          })))];
          this.body.redraw();
        });
      }
      addTask() {
        let task = this.taskSelect.get();
        let request = {
          privateArchiveId: this.getPrivateArchive().id,
          evalTaskId: task.id
        };
        Ajax.postJSON("/contest/private_archive_add_eval_task/", request).then(() => window.location.reload(), error => this.messageArea.showMessage(error.message, "red"));
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
    }
    class DelayedPrivateArchiveContestTaskPanel extends DelayedContestTaskPanel {
      modifyIde() {
        const privateArchiveAjaxHandler = new FixedURLAjaxHandler("/contest/submit_private_archive_job/");
        privateArchiveAjaxHandler.addPreprocessor(request => {
          request.data.privateArchiveId = this.options.privateArchiveId;
        });
        this.ide.getPlugin("ContestSubmit").setAjaxHandler(privateArchiveAjaxHandler);
      }
      onDelayedMount() {
        super.onDelayedMount();
        if (this.ide) {
          this.ide.whenLoaded(() => this.modifyIde());
        } else {
          this.addListener("workspaceLoaded", () => {
            this.ide.whenLoaded(() => this.modifyIde());
          });
        }
      }
      getSubURL(section) {
        let url = "/private-archive/" + PrivateArchiveStore.get(this.options.privateArchiveId).name + "/";
        url += "task/" + this.getContestTask().name + "/";
        if (section) {
          url += section + "/";
        }
        return url;
      }
    }
    class PrivateArchiveContestTaskList extends ContestTaskList {
      getPrivateArchive() {
        return this.options.privateArchive;
      }
      getTasks() {
        return this.getPrivateArchive().getContestTasks();
      }
      getHeader() {
        return undefined;
      }
      getContestTaskBubble(task) {
        return UI$1.createElement(ContestTaskBubble, {
          isArchive: this.options.isArchive,
          href: "/private-archive/" + this.getPrivateArchive().name + "/task/" + task.name + "/",
          showTags: this.options.showTags,
          contestTask: task
        });
      }
    }
    class PrivateArchiveUserGroupMemberUI extends UserGroupMemberUI {
      getGlobalAccessButton() {
        return UI$1.createElement(Button$1, {
          ref: "globalAccessButton",
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL,
          style: {
            marginRight: "5px"
          }
        }, "Give access to all problems");
      }
      render() {
        return [this.getDestroyButton(), this.getGlobalAccessButton(), this.getUserHandle()];
      }
      onMount() {
        super.onMount();
        this.globalAccessButton.addClickListener(() => Ajax.postJSON("/contest/private_archive_give_testing_access/", {
          userId: this.options.member.userId,
          privateArchiveId: this.options.privateArchiveId
        }));
      }
    }
    class PrivateArchiveUserGroupEditor extends UserGroupEditor {
      renderUserGroupMember(member) {
        return UI$1.createElement(PrivateArchiveUserGroupMemberUI, {
          member: member,
          privateArchiveId: this.options.privateArchiveId
        });
      }
    }
    class PrivateArchivePanel extends Router {
      getDefaultOptions() {
        return {
          fullHeight: true,
          children: []
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        // attr.addClass(GlobalStyle.Container.MEDIUM);
      }
      getPrivateArchive() {
        return PrivateArchiveStore.get(this.options.privateArchiveId);
      }
      getContestTasks() {
        return this.getPrivateArchive().getContestTasks();
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getTasks(), [new Route("tasks", () => this.getTasks()), new Route("task", () => this.getTasks(), [new TerminalRoute("%s", options => {
          const contestTask = this.getContestTasks().find(contestTask => contestTask.name === options.args[0]);
          return contestTask && UI$1.createElement(DelayedPrivateArchiveContestTaskPanel, {
            contestTask: contestTask,
            contestTaskId: contestTask.id,
            urlPrefix: this.getUrlPrefix("task/" + contestTask.name),
            privateArchiveId: this.options.privateArchiveId
          });
        })]), new Route("scoreboard", () => this.getScoreboard()), new Route("submissions", () => this.getSubmissions()), new Route("permissions", () => this.getPermissions())]);
        return this.routes;
      }
      getTasks() {
        let buttons;
        if (USER.isSuperUser || USER.id === this.getPrivateArchive().ownerId) {
          buttons = [UI$1.createElement(ButtonGroup, {
            level: Level.PRIMARY,
            style: {
              float: "right"
            }
          }, UI$1.createElement(Button$1, {
            label: "Add task",
            onClick: () => PrivateArchiveAddEvalTaskModal.show({
              privateArchiveWidget: this
            })
          }), UI$1.createElement(Button$1, {
            label: "Remove task",
            onClick: () => PrivateArchiveRemoveEvalTaskModal.show({
              privateArchiveWidget: this
            })
          }), UI$1.createElement(Button$1, {
            label: "Create task",
            onClick: () => PrivateArchiveCreateEvalTaskModal.show({
              privateArchiveWidget: this
            })
          })), UI$1.createElement("div", {
            style: {
              clear: "both"
            }
          })];
        }
        return UI$1.createElement("div", {
          style: {
            margin: "auto",
            maxWidth: 800
          }
        }, buttons, UI$1.createElement(PrivateArchiveContestTaskList, {
          privateArchive: this.getPrivateArchive()
        }));
      }
      getScoreboard() {
        return UI$1.createElement(PrivateArchiveUsersTable, {
          privateArchive: this.getPrivateArchive()
        });
      }
      getSubmissions() {
        return UI$1.createElement(SubmissionSummaryPrivateArchiveFilter, {
          privateArchiveId: this.options.privateArchiveId
        });
      }
      getPermissions() {
        if (!USER.isSuperUser && USER.id !== this.getPrivateArchive().ownerId) {
          return UI$1.createElement("div", null);
        }
        return UI$1.createElement("div", null, UI$1.createElement("h3", null, "Here are the users that can edit this private archive: "), UI$1.createElement(PrivateArchiveUserGroupEditor, {
          groupId: this.getPrivateArchive().ownerGroupId,
          privateArchiveId: this.getPrivateArchive().id,
          style: {
            fontSize: "1.2em"
          }
        }));
      }
      onMount() {
        if (this.isInDocument()) {
          this.createNavbarElements();
        }
        GlobalState$1.registerStream("private-archive-" + this.getPrivateArchive().id);
      }
      getUrlPrefix(str) {
        let url = "/private-archive/" + this.getPrivateArchive().name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      createNavbarElements() {
        let leftSideChildren = [UI$1.createElement(NavLinkElement, {
          href: "/private-archives/",
          value: UI$1.T("All archives")
        }), UI$1.createElement(NavLinkElement, {
          href: this.getUrlPrefix("tasks"),
          value: UI$1.T("Tasks")
        }), UI$1.createElement(NavLinkElement, {
          href: this.getUrlPrefix("scoreboard"),
          value: UI$1.T("Scoreboard")
        }), UI$1.createElement(NavLinkElement, {
          href: this.getUrlPrefix("submissions"),
          value: UI$1.T("Submissions")
        })];
        if (USER.isSuperUser || USER.id === this.getPrivateArchive().ownerId) {
          leftSideChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getUrlPrefix("permissions"),
            value: UI$1.T("Permissions")
          }));
        }
        NavManager.Global.getLeftConditioned().setChildren(leftSideChildren);
        NavManager.Global.checkForWrap();
      }
      destroyNavbarElements() {
        NavManager.Global.getLeftConditioned().setChildren([]);
        NavManager.Global.checkForWrap();
      }
    }
    class PrivateArchivePanelWrapper extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%"
        });
      }
      render() {
        return UI$1.createElement(PrivateArchivePanel, {
          ref: "privateArchivePanel",
          privateArchiveId: this.options.privateArchiveId
        });
      }
      setURL(urlParts) {
        if (this.privateArchivePanel) {
          this.privateArchivePanel.setURL(urlParts);
        } else {
          this.initialUrlParts = urlParts;
        }
      }
      onMount() {
        this.setURL(this.initialUrlParts);
        this.addListener("urlEnter", () => {
          this.privateArchivePanel.createNavbarElements();
        });
        this.addListener("urlExit", () => {
          this.privateArchivePanel.destroyNavbarElements();
        });
      }
    }

    class Interview extends StoreObject {
      constructor(obj) {
        super(obj);
        this.interviewTasks = new Map();
      }
      getStartTime() {
        return this.startTime;
      }
      getDuration() {
        if (this.getEndTime()) {
          return this.getEndTime() - this.getStartTime();
        } else {
          return ServerTime.now().unix() - this.getStartTime();
        }
      }
      getEndTime() {
        return this.endTime;
      }
      getExpectedDuration() {
        return this.duration;
      }
      getExpectedEndTime() {
        return this.getStartTime() + this.getExpectedDuration();
      }
      getDifficulty() {
        return Difficulty.get(this.difficulty);
      }
      hasEnded() {
        return this.getStartTime() + this.getExpectedDuration() < ServerTime.now().unix();
      }
      addInterviewTask(interviewTask, event) {
        if (this.interviewTasks.has(interviewTask.id)) {
          return false;
        }
        this.interviewTasks.set(interviewTask.id, interviewTask);
        this.dispatch("addInterviewTask", interviewTask);
        return true;
      }
      getInterviewTasks() {
        // Because the interview tasks are created in their order, their ids also represent the order
        return Array.from(this.interviewTasks.values()).sort((a, b) => {
          return a.id - b.id;
        });
      }
      getAvailableTask() {
        let interviewTasks = this.getInterviewTasks();
        for (let i = interviewTasks.length - 1; i >= 0; i--) {
          let interviewTask = interviewTasks[i];

          // The first task after the last solved/locked
          if (interviewTask.getSolvedTime() || interviewTask.getLockedTime()) {
            return interviewTasks[i + 1];
          }
          // if (interviewTask.getReadTime()) {
          //     return interviewTask;
          // }

          // if (interviewTask.getReadTime() && !this.getSolvedTime()) {
          //     return interviewTask;
          // }
          // if (!interviewTask.getReadTime()) {
          //     return interviewTask;
          // }
        }
        return interviewTasks[0];
      }
      getContestTasks() {
        let contestTasks = [];
        // TODO: Should be sorted by difficulty
        for (let interviewTask of this.getInterviewTasks()) {
          contestTasks.push(interviewTask.getContestTask());
        }
        return contestTasks;
      }
      endInterview(onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        if (this.getEndTime()) {
          onError("Interview already finished");
          return;
        }
        Ajax.postJSON("/interview/end_interview/", {
          interviewId: this.id
        }).then(onSuccess, onError);
      }
    }
    class InterviewStoreClass extends GenericObjectStore {
      constructor() {
        super("interview", Interview);
        this.possibleDifficulties = [Difficulty.EASY, Difficulty.MEDIUM, Difficulty.HARD];
        this.defaultDifficulty = Difficulty.MEDIUM;
      }
    }
    const InterviewStore = new InterviewStoreClass();
    class InterviewTask extends StoreObject {
      getInterview() {
        return InterviewStore.get(this.interviewId);
      }
      getContestTask() {
        return ContestTaskStore.get(this.contestTaskId);
      }
      getNextTask() {
        let interviewTasks = this.getInterview().getInterviewTasks();
        for (let i = 0; i < interviewTasks.length; i += 1) {
          if (interviewTasks[i] === this) {
            // Will return undefined if it's the last task
            return interviewTasks[i + 1];
          }
        }
      }
      getReadTime() {
        return this.readTime;
      }
      getSolvedTime() {
        return this.solvedTime;
      }
      getLockedTime() {
        return this.lockedTime;
      }
      canOpen() {
        // TODO: should also be || this.getLockedTime()
        return this.getSolvedTime() || this.isAvailableTask();
      }
      isAvailableTask() {
        return this.getInterview().getAvailableTask() === this;
      }
      isLastTask() {
        return this.getNextTask() == null;
      }
      markAsRead() {
        if (this.getReadTime()) {
          return;
        }
        Ajax.postJSON("/interview/edit_interview_task/", {
          interviewId: this.interviewId,
          interviewTaskId: this.id,
          markAsRead: true
        });
      }
      markAsLocked() {
        if (this.getLockedTime()) {
          return;
        }
        Ajax.postJSON("/interview/edit_interview_task/", {
          interviewId: this.interviewId,
          interviewTaskId: this.id,
          markAsLocked: true
        });
      }
    }
    class InterviewTaskStoreClass extends GenericObjectStore {
      constructor() {
        super("interviewtask", InterviewTask, {
          dependencies: ["interview", "contesttask"]
        });
        this.addCreateListener((interviewTask, createEvent) => {
          interviewTask.getInterview().addInterviewTask(interviewTask, createEvent);
        });
      }
    }
    const InterviewTaskStore = new InterviewTaskStoreClass();

    var _class$m, _descriptor$c, _descriptor2$c, _descriptor3$b, _descriptor4$b, _descriptor5$a, _descriptor6$8, _class2$d, _descriptor7$5, _descriptor8$5, _class3$6, _descriptor9$4, _descriptor10$3, _descriptor11$3, _class4$2, _descriptor12$2, _descriptor13$2, _descriptor14$2;
    let InterviewTaskBubbleStyle = (_class$m = class InterviewTaskBubbleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.fontColor = "rgb(55, 55, 55)";
        this.height = 110;
        _initializerDefineProperty(this, "className", _descriptor$c, this);
        _initializerDefineProperty(this, "userScore", _descriptor2$c, this);
        _initializerDefineProperty(this, "taskDescription", _descriptor3$b, this);
        _initializerDefineProperty(this, "taskName", _descriptor4$b, this);
        _initializerDefineProperty(this, "originalContest", _descriptor5$a, this);
        _initializerDefineProperty(this, "taskDifficulty", _descriptor6$8, this);
      }
    }, (_descriptor$c = _applyDecoratedDescriptor(_class$m.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxShadow: "0px 0px 1px " + this.fontColor,
          width: "99%",
          marginLeft: "0.5%",
          marginRight: "0.5%",
          height: this.height + "px",
          fontColor: this.fontColor,
          display: "inline-block",
          float: "left",
          marginTop: "20px",
          whiteSpace: "nowrap",
          ":hover": {
            transition: "0.23s",
            boxShadow: "0px 0px 5px " + this.fontColor
          }
        };
      }
    }), _descriptor2$c = _applyDecoratedDescriptor(_class$m.prototype, "userScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height + "px",
          lineHeight: this.height + "px",
          width: "11%",
          color: this.fontColor,
          fontSize: "20px",
          textAlign: "center",
          display: "inline-block",
          float: "left"
        };
      }
    }), _descriptor3$b = _applyDecoratedDescriptor(_class$m.prototype, "taskDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height + "px",
          width: "35%",
          display: "inline-block",
          float: "left"
        };
      }
    }), _descriptor4$b = _applyDecoratedDescriptor(_class$m.prototype, "taskName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height / 2 + "px",
          lineHeight: this.height / 2 + "px",
          width: "100%",
          fontSize: "130%",
          paddingLeft: "15%"
        };
      }
    }), _descriptor5$a = _applyDecoratedDescriptor(_class$m.prototype, "originalContest", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height / 2 + "px",
          lineHeight: this.height / 2 + "px",
          width: "100%",
          fontSize: "100%",
          paddingLeft: "15%"
        };
      }
    }), _descriptor6$8 = _applyDecoratedDescriptor(_class$m.prototype, "taskDifficulty", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height + "px",
          width: "9%",
          lineHeight: this.height + "px",
          fontSize: "16px",
          textAlign: "center",
          display: "inline-block",
          float: "left"
        };
      }
    })), _class$m);
    let InterviewTagsStyle = (_class2$d = class InterviewTagsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.tagsHeight = 40;
        _initializerDefineProperty(this, "className", _descriptor7$5, this);
        _initializerDefineProperty(this, "header", _descriptor8$5, this);
      }
    }, (_descriptor7$5 = _applyDecoratedDescriptor(_class2$d.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          borderBottom: "2px solid #e4e6e7",
          color: "#aaa"
        };
      }
    }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$d.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "display": "flex",
          "justify-content": "center",
          "align-items": "center",
          "float": "left",
          "width": "18%",
          "height": () => this.tagsHeight + "px",
          "font-size": "13px",
          "text-align": "center"
        };
      }
    })), _class2$d);
    let InterviewBubbleStyle = (_class3$6 = class InterviewBubbleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.bubbleHeight = 50;
        this.baseBubble = {
          height: this.bubbleHeight + "px",
          width: "100%",
          color: "#555",
          borderBottom: "2px solid #e4e6e7",
          cursor: "pointer"
        };
        _initializerDefineProperty(this, "lightBubble", _descriptor9$4, this);
        _initializerDefineProperty(this, "darkBubble", _descriptor10$3, this);
        _initializerDefineProperty(this, "element", _descriptor11$3, this);
      }
    }, (_descriptor9$4 = _applyDecoratedDescriptor(_class3$6.prototype, "lightBubble", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.baseBubble, {
          backgroundColor: "#fff",
          ":hover": {
            backgroundColor: "#fafafa"
          }
        });
      }
    }), _descriptor10$3 = _applyDecoratedDescriptor(_class3$6.prototype, "darkBubble", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.baseBubble, {
          backgroundColor: "#f4f6f7",
          ":hover": {
            backgroundColor: "#eff1f2"
          }
        });
      }
    }), _descriptor11$3 = _applyDecoratedDescriptor(_class3$6.prototype, "element", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          float: "left",
          width: "18%",
          height: this.bubbleHeight + "px",
          fontSize: "14px",
          textAlign: "center",
          color: "#767676"
        };
      }
    })), _class3$6);
    let InterviewAppStyle = (_class4$2 = class InterviewAppStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.textColor = "#555659";
        // default CSAcademy navbar color
        this.headerHeight = 60;
        _initializerDefineProperty(this, "title", _descriptor12$2, this);
        _initializerDefineProperty(this, "button", _descriptor13$2, this);
        _initializerDefineProperty(this, "header", _descriptor14$2, this);
      }
    }, (_descriptor12$2 = _applyDecoratedDescriptor(_class4$2.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          lineHeight: this.headerHeight + "px",
          height: this.headerHeight + "px",
          paddingLeft: "1%",
          fontSize: "24px",
          color: this.textColor
        };
      }
    }), _descriptor13$2 = _applyDecoratedDescriptor(_class4$2.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          marginRight: "1%",
          marginTop: "14px"
        };
      }
    }), _descriptor14$2 = _applyDecoratedDescriptor(_class4$2.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.headerHeight + "px",
          width: "100%"
        };
      }
    })), _class4$2);

    var _dec$h, _class$l, _dec2$7, _class2$c, _dec3$2, _class3$5;
    class CreateInterviewModal extends ActionModal {
      getTitle() {
        return "Interview settings";
      }
      getBody() {
        let durations = [];
        for (let duration of [30, 45, 60, 90, 120]) {
          durations.push({
            duration: duration,
            toString: () => duration + " minutes"
          });
        }
        // Default is 45 minutes
        let defaultDuration = durations[2];
        return [UI$1.createElement("div", null, UI$1.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI$1.createElement(FormField, {
          ref: "durationFormField",
          label: "Duration"
        }, UI$1.createElement(Select, {
          ref: "durationSelect",
          options: durations,
          selected: defaultDuration
        })), UI$1.createElement(FormField, {
          ref: "difficultyFormField",
          label: "Difficulty"
        }, UI$1.createElement(Select, {
          ref: "difficultySelect",
          options: InterviewStore.possibleDifficulties,
          selected: InterviewStore.defaultDifficulty
        }))))];
      }
      getActionName() {
        return "Create";
      }
      getActionLevel() {
        return Level.SUCCESS;
      }
      action() {
        let request = {
          durationInMinutes: this.durationSelect.get().duration,
          difficulty: this.difficultySelect.get().id
        };
        Ajax.postJSON("/interview/create_interview/", request).then(data => window.location.replace("/interview/" + data.interviewId), error => this.messageArea.showMessage("Error: " + error.message));
      }
    }
    const CreateInterviewButton = ActionModalButton(CreateInterviewModal);
    class InterviewList extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("height", "50px");
        attr.setStyle("width", "100%");
      }
      render() {
        let interviews = InterviewStore.all().sort((a, b) => {
          return b.getStartTime() - a.getStartTime();
        });
        let color = 0;
        let interviewBubbles = [];
        for (let interview of interviews) {
          interviewBubbles.push(UI$1.createElement(InterviewBubble, {
            interview: interview,
            color: color % 2
          }));
          color = !color;
        }
        if (interviews.length === 0) {
          return [UI$1.createElement("em", {
            style: {
              "font-size": "1.2em",
              "padding-left": "1%"
            }
          }, "You have not simulated any interviews.")];
        }
        return [UI$1.createElement(InterviewTags, null), ...interviewBubbles];
      }
      onMount() {
        super.onMount();
        InterviewStore.addCreateListener(() => {
          this.redraw();
        });
      }
    }
    let InterviewTags = (_dec$h = registerStyle(InterviewTagsStyle), _dec$h(_class$l = class InterviewTags extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }
      getTitle() {
        return UI$1.createElement("div", {
          className: this.styleSheet.header
        }, "Start Date");
      }
      getAuthor() {
        return UI$1.createElement("div", {
          className: this.styleSheet.header
        }, "Intended duration");
      }
      getReplies() {
        return UI$1.createElement("div", {
          className: this.styleSheet.header
        }, "Actual duration");
      }
      getViews() {
        return UI$1.createElement("div", {
          className: this.styleSheet.header
        }, "Difficulty");
      }
      getActivity() {
        return UI$1.createElement("div", {
          className: this.styleSheet.header
        }, "Review");
      }
      render() {
        return [this.getTitle(), this.getAuthor(), this.getReplies(), this.getViews(), this.getActivity()];
      }
    }) || _class$l);
    let InterviewBubble = (_dec2$7 = registerStyle(InterviewBubbleStyle), autoredraw(_class2$c = _dec2$7(_class2$c = class InterviewBubble extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.options.color ? this.styleSheet.lightBubble : this.styleSheet.darkBubble);
      }
      getInterview() {
        return this.options.interview;
      }
      getStartDate() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.element
        }, UI$1.createElement(TimePassedSpan, {
          timeStamp: this.getInterview().getStartTime(),
          style: {
            color: "#797979"
          }
        }))];
      }
      getFormattedMinutesDuration(seconds) {
        let durationInMinutes = seconds / 60;
        durationInMinutes = Math.floor(durationInMinutes);
        if (durationInMinutes < 1) {
          return "< 1 minute";
        }
        let label = durationInMinutes + " minute";
        if (durationInMinutes != 1) {
          label += "s";
        }
        return label;
      }
      getIntendedDuration() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.element
        }, UI$1.createElement("span", {
          style: {
            color: "#AAA"
          }
        }, this.getFormattedMinutesDuration(this.getInterview().getExpectedDuration())))];
      }
      getActualDuration() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.element
        }, UI$1.createElement("span", {
          style: {
            color: "#AAA"
          }
        }, this.getFormattedMinutesDuration(this.getInterview().getDuration())))];
      }
      getDifficulty() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.element
        }, UI$1.T(this.getInterview().getDifficulty().toString()))];
      }
      getReview() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.element
        }, "N/A")];
      }
      render() {
        return [this.getStartDate(), this.getIntendedDuration(), this.getActualDuration(), this.getDifficulty(), this.getReview()];
      }
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          Router.changeURL(["interview", this.getInterview().id]);
        });
      }
    }) || _class2$c) || _class2$c);
    class InterviewContestList extends UI$1.Element {
      getTableColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        return [{
          value: contest => UI$1.createElement(Link, {
            href: "/contest/" + contest.name,
            value: contest.getName()
          }),
          headerName: "Name",
          headerStyle: {
            verticalAlign: "middle",
            width: "70%"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contest => contest.getUser(USER.id).totalScore,
          headerName: "Your score",
          headerStyle: {
            verticalAlign: "middle",
            textAlign: "right",
            width: "30%"
          },
          cellStyle: numberStyle
        }];
      }
      getContests() {
        return ContestStore.all().filter(contest => contest.systemGenerated && contest.originArchiveId === this.options.interviewArchiveId && contest.hasFinished() && contest.getUser(USER.id)).sort((a, b) => b.getStartTime() - a.getStartTime());
      }
      render() {
        const contests = this.getContests();
        if (!contests.length) {
          return UI$1.createElement("em", {
            style: {
              "font-size": "1.2em",
              "padding-left": "1%"
            }
          }, "You have not participated in any hourly interview contests.");
        }
        return UI$1.createElement(Table, {
          columns: this.getTableColumns(),
          entries: contests
        });
      }
    }
    let InterviewApp = (_dec3$2 = registerStyle(InterviewAppStyle), _dec3$2(_class3$5 = class InterviewApp extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-left", "8%");
        attr.setStyle("width", "84%");
      }
      getTitle() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.title
        }, "My interviews")];
      }
      getButton() {
        return [UI$1.createElement(CreateInterviewButton, {
          label: "New interview",
          level: Level.SUCCESS,
          className: this.styleSheet.button
        })];
      }
      getInterviewList() {
        return [UI$1.createElement(InterviewList, null)];
      }
      getContestList() {
        return UI$1.createElement(InterviewContestList, {
          interviewArchiveId: this.options.interviewArchiveId
        });
      }
      render() {
        return [UI$1.createElement("div", {
          style: {
            "float": "left",
            "width": "49%"
          }
        }, UI$1.createElement("div", {
          className: this.styleSheet.header
        }, this.getTitle(), this.getButton()), this.getInterviewList()), UI$1.createElement("div", {
          style: {
            "float": "right",
            "width": "49%"
          }
        }, UI$1.createElement("div", {
          className: this.styleSheet.header
        }, UI$1.createElement("div", {
          className: this.styleSheet.title
        }, "Hourly interviews contests")), this.getContestList())];
      }
    }) || _class3$5);

    var _dec$g, _class$k, _dec2$6, _class2$b;
    class InterviewTaskPanel extends DelayedContestTaskPanel {
      getInterview() {
        return this.options.interviewTask.getInterview();
      }
      getCommentsPanel() {
        if (this.getInterview().getEndTime()) {
          return super.getCommentsPanel();
        }
      }
      getSolutionPanel() {
        if (this.getInterview().getEndTime()) {
          return super.getSolutionPanel();
        }
      }
      getStatisticsPanel() {
        if (this.getInterview().getEndTime()) {
          return super.getStatisticsPanel();
        }
      }
      getSubmissionPanel() {
        return UI$1.createElement(SubmissionSummaryInterviewFilter, {
          ref: "submissionsPanel",
          title: UI$1.T("Submissions"),
          tabHref: this.getSubURL("submissions"),
          contestTask: this.getContestTask()
        });
      }
      modifyIde() {
        const interviewSubmitAjaxHandler = new FixedURLAjaxHandler("/interview/submit_interviewjob/");
        interviewSubmitAjaxHandler.addPreprocessor(request => {
          request.data.interviewId = this.getInterview().id;
        });
        this.ide.getPlugin("ContestSubmit").setAjaxHandler(interviewSubmitAjaxHandler);
      }
      onDelayedMount() {
        super.onDelayedMount();
        // TODO: fix this hack
        if (this.ide) {
          this.ide.whenLoaded(() => this.modifyIde());
        } else {
          this.addListener("workspaceLoaded", () => {
            this.ide.whenLoaded(() => this.modifyIde());
          });
        }

        // TODO: fix this in case it fails, (No Denis, No setInterval/setTimeout here)
        // Mark problem as read
        this.options.interviewTask.markAsRead();
        this.attachChangeListener(this.getInterview(), () => {
          this.redraw();
        });
      }
    }
    class SkipTaskModal extends ActionModal {
      getTitle() {
        return "Skip task";
      }
      getActionName() {
        return "Skip";
      }
      getBody() {
        return UI$1.createElement("p", null, "Are you sure you want to skip ", this.options.interviewTask.getContestTask().longName, "? You will not be able to solve this task later.");
      }
      action() {
        this.options.interviewTask.markAsLocked();
        this.hide();
      }
    }
    class SkipTaskButton extends ActionModalButton(SkipTaskModal) {
      onMount() {
        super.onMount();
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();
        });
      }
    }
    let InterviewTaskBubble = (_dec$g = registerStyle(InterviewTaskBubbleStyle), _dec$g(_class$k = class InterviewTaskBubble extends Link {
      setOptions(options) {
        super.setOptions(options);
        this.options.contestTask = this.getInterviewTask().getContestTask();
        this.options.href = this.options.href || this.getFullTaskUrl();
      }
      getFullTaskUrl() {
        return "/interview/" + this.getInterviewTask().interviewId + "/task/" + this.options.contestTask.name + "/";
      }
      getInterviewTask() {
        return this.options.interviewTask;
      }
      getContestTask() {
        return this.options.contestTask;
      }
      getTaskDifficulty() {
        let taskDifficulty = Difficulty.get(this.getContestTask().getDifficulty());
        return UI$1.createElement("div", {
          className: this.styleSheet.taskDifficulty,
          style: {
            "color": taskDifficulty.color
          }
        }, taskDifficulty.toString());
      }
      getUserScore() {
        let points;
        let getSolvedIcon = () => UI$1.createElement("span", {
          className: "fa fa-check fa-lg",
          style: {
            color: "green"
          }
        });
        let getUnsolvedIcon = () => UI$1.createElement("span", {
          className: "fa fa-times fa-lg",
          style: {
            color: "red"
          }
        });
        let getLockIcon = () => UI$1.createElement("span", {
          className: "fa fa-lock fa-lg",
          style: {
            color: "gray"
          }
        });
        if (!this.getInterviewTask().canOpen()) {
          points = getLockIcon();
        } else if (!this.getInterviewTask().isAvailableTask()) {
          points = this.getInterviewTask().getSolvedTime() ? getSolvedIcon() : getUnsolvedIcon();
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.userScore
        }, points);
      }
      getTaskDescription() {
        return UI$1.createElement("div", {
          className: this.styleSheet.taskDescription
        }, UI$1.createElement("div", {
          className: this.styleSheet.taskName
        }, UI$1.T(this.getContestTask().longName)), UI$1.createElement("div", {
          className: this.styleSheet.originalContest
        }));
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass(String(this.styleSheet.className));
        if (this.getInterviewTask().canOpen()) {
          attr.setStyle("cursor", "pointer");
        } else {
          attr.setStyle("backgroundColor", "lightgray");
        }
        return attr;
      }
      render() {
        let skipTaskButton;
        if (this.getInterviewTask().isAvailableTask() && !this.getInterviewTask().isLastTask()) {
          skipTaskButton = UI$1.createElement(SkipTaskButton, {
            style: {
              marginRight: "5%",
              marginTop: "20px"
            },
            className: "pull-right",
            label: "Skip",
            modalOptions: {
              interviewTask: this.getInterviewTask()
            }
          });
        }
        return [this.getTaskDescription(), this.getUserScore(), this.getTaskDifficulty(), skipTaskButton];
      }
    }) || _class$k);
    let InterviewTaskList = (_dec2$6 = autoredraw(InterviewTaskStore), _dec2$6(_class2$b = class InterviewTaskList extends UI$1.Element {
      render() {
        const {
          interview
        } = this.getInterview();
        return interview.getInterviewTasks().map(interviewTask => UI$1.createElement(InterviewTaskBubble, {
          key: interviewTask.id,
          interviewTask: interviewTask
        }));
      }
    }) || _class2$b);
    class InterviewAnalysis extends UI$1.Element {
      render() {
        return UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement("h3", null, "Congratulations"), UI$1.createElement("p", null, "You can continue training in the ", UI$1.createElement(Link, {
          href: "/contest/interview-archive/",
          value: "interview archive"
        }), "."));
      }
    }
    class GoNextModal extends ActionModal {
      getInterviewTask() {
        return this.options.interviewTask;
      }
      getTitle() {
        if (this.getInterviewTask().getLockedTime() && !this.getInterviewTask().isLastTask()) {
          return "New problem unlocked";
        }
        return "Congratulations";
      }
      getActionName() {
        if (this.getInterviewTask().isLastTask()) {
          return "End interview";
        } else {
          return "Next problem";
        }
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getCloseName() {
        return "Not now";
      }
      getBody() {
        if (this.getInterviewTask().isLastTask()) {
          return "You finished all the problems!";
        } else {
          return "You unlocked a new problem.";
        }
      }
      action() {
        let interviewTask = this.getInterviewTask();
        if (interviewTask.isLastTask()) {
          // TODO: duplicated from EndInterviewModal.action
          let onSuccess = () => {
            this.hide();
            Router.changeURL(["interview", interviewTask.interviewId, "analysis"]);
          };
          let onError = error => {
            if (typeof error === "string") {
              this.messageArea.showMessage("Error: " + error);
            } else {
              this.messageArea.showMessage("Error: " + error.message);
            }
          };
          interviewTask.getInterview().endInterview(onSuccess, onError);
        } else {
          this.hide();
          Router.changeURL(["interview", interviewTask.interviewId, "task", interviewTask.getNextTask().getContestTask().name]);
        }
      }
    }
    class EndInterviewModal extends ActionModal {
      getActionName() {
        return "End interview";
      }
      getActionLevel() {
        return Level.WARNING;
      }
      getBody() {
        return "Are you sure you want to end your interview?";
      }
      action() {
        let onSuccess = () => {
          this.hide();
          Router.changeURL(["interview", this.options.interview.id, "analysis"]);
        };
        let onError = error => {
          if (typeof error === "string") {
            this.messageArea.showMessage("Error: " + error);
          } else {
            this.messageArea.showMessage("Error: " + error.message);
          }
        };
        this.options.interview.endInterview(onSuccess, onError);
      }
    }
    const EndInterviewButton = ActionModalButton(EndInterviewModal);
    class InterviewPanel extends Router {
      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          },
          children: []
        };
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.MEDIUM);
      }
      getInterview() {
        return InterviewStore.get(this.options.interviewId);
      }
      getUrlPrefix(str) {
        let url = "/interview/" + this.options.interviewId + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      setOptions(options) {
        super.setOptions(options);
        this.tasksWithShowedModal = new Set();
        // TODO: add solved tasks to the set
        GlobalState$1.importState(options.state || {});
      }
      getAnalysis() {
        if (this.getInterview().getEndTime()) {
          return UI$1.createElement(InterviewAnalysis, {
            interview: this.getInterview()
          });
        }
      }
      getTasks() {
        let endInterviewButton;
        if (!this.getInterview().getEndTime()) {
          endInterviewButton = UI$1.createElement("div", {
            style: {
              marginRight: "12%"
            }
          }, UI$1.createElement(EndInterviewButton, {
            modalOptions: {
              interview: this.getInterview()
            },
            label: "End interview",
            level: Level.WARNING,
            className: "pull-right"
          }));
        }
        return UI$1.createElement("div", null, endInterviewButton, UI$1.createElement(InterviewTaskList, {
          interview: this.getInterview(),
          style: {
            marginLeft: "12%",
            marginRight: "12%"
          }
        }));
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getTasks(), [new Route("tasks", () => this.getTasks()), new Route("task", null, [new TerminalRoute("%s", options => {
          const interviewTask = this.getInterview().getInterviewTasks().find(interviewTask => interviewTask.getContestTask().name === options.args[0]);
          const customURLPrefix = "/interview/" + this.getInterview().id + "/task/" + options.args[0] + "/";
          return interviewTask && UI$1.createElement(InterviewTaskPanel, {
            interviewTask: interviewTask,
            customURLPrefix: customURLPrefix,
            contestTaskId: interviewTask.contestTaskId
          });
        })]), new Route("analysis", () => this.getAnalysis())]);
        return this.routes;
      }
      showModalForTask(interviewTask) {
        if (this.tasksWithShowedModal.has(interviewTask)) {
          return;
        }
        this.tasksWithShowedModal.add(interviewTask);
        let modal = UI$1.createElement(GoNextModal, {
          interviewTask: interviewTask
        });
        modal.show();
      }
      onMount() {
        this.createNavbarElements();
        this.attachChangeListener(this.getInterview(), () => {
          this.createNavbarElements();
          if (this.getInterview().getEndTime() && this.endInterviewButton) {
            this.endInterviewButton.hide();
          }
          this.redraw();
        });
        this.attachChangeListener(InterviewTaskStore, interviewTask => {
          if (interviewTask.getSolvedTime()) {
            // TODO: show congrats modal
            this.showModalForTask(interviewTask);
          } else if (interviewTask.getLockedTime()) {
            // TODO: show next problem modal
            this.showModalForTask(interviewTask);
          }
        });
      }
      createNavbarElements() {
        if (!this.isInDocument()) {
          return;
        }
        let leftChildren = [];
        if (this.getInterview().getEndTime()) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: "/interview/",
            value: UI$1.T("My Interviews")
          }));
        }
        leftChildren.push(UI$1.createElement(NavLinkElement, {
          href: this.getUrlPrefix("tasks"),
          value: UI$1.T("Tasks")
        }));
        if (this.getInterview().getEndTime()) {
          leftChildren.push(UI$1.createElement(NavLinkElement, {
            href: this.getUrlPrefix("analysis"),
            value: UI$1.T("Analysis")
          }));
        }
        NavManager.Global.getLeftConditioned().setChildren(leftChildren);
        NavManager.Global.getRightConditioned().setChildren([this.createTimeCounter()]);
        NavManager.Global.checkForWrap();
      }
      destroyNavbarElements() {
        NavManager.Global.getLeftConditioned().setChildren([]);
        NavManager.Global.getRightConditioned().setChildren([]);
        NavManager.Global.checkForWrap();
      }
      createTimeCounter() {
        let timeCounter = UI$1.createElement(NavElement, {
          value: ""
        });
        let timerInterval = setInterval(() => {
          let serverTime = ServerTime.now();
          let value;
          if (this.getInterview().getEndTime()) {
            // User finished interview
            let interviewStartTime = new StemDate(this.getInterview().getStartTime());
            let interviewEndTime = new StemDate(this.getInterview().getEndTime());
            let timeDifference = interviewEndTime.diffDuration(interviewStartTime);
            let diffFormat = timeDifference.format("h:mm:ss");
            value = "Done in " + diffFormat;
            clearInterval(timerInterval);
          } else if (this.getInterview().hasEnded()) {
            // Interview time finished, user can still continue
            let interviewEndTime = new StemDate(this.getInterview().getStartTime() + this.getInterview().getExpectedDuration());
            let timeDifference = serverTime.diffDuration(interviewEndTime);
            let diffFormat = timeDifference.format("h:mm:ss");
            value = "Extra " + diffFormat;
          } else {
            // Interview is running
            let interviewEndTime = new StemDate(this.getInterview().getStartTime() + this.getInterview().getExpectedDuration());
            let timeDifference = serverTime.diffDuration(interviewEndTime);
            let diffFormat = timeDifference.format("h:mm:ss");
            value = "Ends in " + diffFormat;
          }
          timeCounter.updateOptions({
            value
          });
        }, 1000);
        timeCounter.addCleanupJob(() => {
          clearInterval(timerInterval);
        });
        return timeCounter;
      }
    }
    class InterviewPanelWrapper extends UI$1.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Utils.fullHeight);
      }
      setURL(urlParts) {
        if (this.interviewPanel) {
          this.interviewPanel.setURL(urlParts);
        } else {
          this.initialUrlParts = urlParts;
        }
      }
      render() {
        return UI$1.createElement(InterviewPanel, {
          ref: "interviewPanel",
          interviewId: this.options.interviewId
        });
      }
      onMount() {
        this.setURL(this.initialUrlParts);
        this.addListener("urlEnter", () => {
          this.interviewPanel.createNavbarElements();
        });
        this.addListener("urlExit", () => {
          this.interviewPanel.destroyNavbarElements();
        });
      }
    }

    class GeneralInformationPanel extends Panel {
      getFormFields() {
        return [UI$1.createElement(FormField, {
          ref: "firstNameFormField",
          label: "First Name"
        }, UI$1.createElement(TextInput, {
          ref: "firstNameFormInput",
          placeholder: "John",
          value: this.options.user.firstName
        })), UI$1.createElement(FormField, {
          ref: "lastNameFormField",
          label: "Last Name"
        }, UI$1.createElement(TextInput, {
          ref: "lastNameFormInput",
          placeholder: "Smith",
          value: this.options.user.lastName
        })), UI$1.createElement(FormField, {
          ref: "userNameFormField",
          label: "Username"
        }, UI$1.createElement(TextInput, {
          ref: "userNameFormInput",
          placeholder: "johnsmith",
          value: this.options.user.username || ""
        })), UI$1.createElement(FormField, {
          ref: "displayNameFormField",
          label: "Display name"
        }, UI$1.createElement(Select, {
          ref: "displayNameSelect",
          options: ["Name", "Username"]
        }))];
      }
      render() {
        return [UI$1.createElement("h3", null, UI$1.T("General Info")), UI$1.createElement("div", null, UI$1.createElement(Form, null, this.getFormFields()), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement("div", null, UI$1.createElement(AjaxButton, {
          ref: "saveProfileButton",
          level: Level.PRIMARY,
          statusOptions: ["Save changes", {
            icon: "spinner fa-spin",
            label: " Saving changes..."
          }, "Saved changes", "Save failed"]
        }))))];
      }
      onMount() {
        super.onMount();
        this.displayNameSelect.set(this.options.user.displayName ? "Name" : "Username");
        this.saveProfileButton.addClickListener(() => {
          this.saveProfileChanges();
        });
      }
      getSaveRequestData() {
        let firstName = this.firstNameFormInput.getValue();
        let lastName = this.lastNameFormInput.getValue();
        let userName = this.userNameFormInput.getValue();
        let displayName = this.displayNameSelect.get();
        return {
          firstName: firstName,
          lastName: lastName,
          userName: userName,
          displayName: displayName === "Name"
        };
      }
      saveProfileChanges() {
        const request = this.getSaveRequestData();
        this.saveProfileButton.setIcon("");
        this.firstNameFormField.removeError();
        this.lastNameFormField.removeError();
        this.userNameFormField.removeError();
        this.saveProfileButton.postJSON("/accounts/profile_changed/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }), error => {
          if (error.first_name) {
            this.firstNameFormField.setError(error.first_name);
          }
          if (error.last_name) {
            this.lastNameFormField.setError(error.last_name);
          }
          if (error.username) {
            this.userNameFormField.setError(error.username);
          }
        });
      }
    }
    class SecuritySettingsPanel extends Panel {
      render() {
        return [UI$1.createElement("h3", null, UI$1.T("Password")), UI$1.createElement("div", null, UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          ref: "oldPasswordGroup",
          label: UI$1.T("Current Password")
        }, UI$1.createElement(PasswordInput, {
          ref: "oldPasswordInput"
        })), UI$1.createElement(FormField, {
          ref: "newPasswordGroup",
          label: UI$1.T("New Password")
        }, UI$1.createElement(PasswordInput, {
          ref: "newPasswordInput",
          required: true
        })), UI$1.createElement(FormField, {
          ref: "newPasswordGroup2",
          label: [UI$1.T("New Password"), " (", UI$1.T("again"), ")"]
        }, UI$1.createElement(PasswordInput, {
          ref: "newPasswordInput2",
          required: true
        }))), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement("div", null, UI$1.createElement(AjaxButton, {
          ref: "setPasswordButton",
          level: Level.PRIMARY,
          statusOptions: ["Set Password", {
            icon: "spinner fa-spin",
            label: " Setting Password..."
          }, "Password set", "Failed"]
        }))))];
      }
      onMount() {
        super.onMount();
        if (!this.options.user.hasPassword) {
          this.oldPasswordGroup.hide();
        }
        this.setPasswordButton.addClickListener(() => {
          this.setPassword();
        });
      }
      setPassword() {
        let oldPassword = this.oldPasswordInput.getValue();
        let password1 = this.newPasswordInput.getValue();
        let password2 = this.newPasswordInput2.getValue();
        this.oldPasswordGroup.removeError();
        this.newPasswordGroup.removeError();
        this.newPasswordGroup2.removeError();
        if (password1 != password2) {
          this.newPasswordGroup2.setError("Passwords don't match.");
          return;
        }
        if (!password1) {
          this.newPasswordGroup.setError("Password can't be empty.");
          return;
        }
        let request = {
          newPassword: password1
        };
        if (oldPassword) {
          request["oldPassword"] = oldPassword;
        }
        this.setPasswordButton.postJSON("/accounts/password_change/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }), error => this.oldPasswordGroup.setError(error.message));
      }
    }
    class EmailPanel extends Panel {
      render() {
        let emails = this.options.user.emails.slice();
        emails.sort((a, b) => {
          return a.verified == b.verified ? b.primary - a.primary : b.verified - a.verified;
        });
        let emailForms = [];
        for (let email of emails) {
          let primaryLabel, verifiedLabel, unverifiedLabel;
          let primaryAction, removeAction, resendAction; // TODO: handle onclick
          let labelStyle = {
            borderRadius: "10px",
            "margin-left": "5px"
          };
          let actionStyle = {
            "margin-left": "7px"
          };
          let makePrimaryCallback = () => {
            this.makePrimaryEmail(email.email);
          };
          let removeCallback = () => {
            this.removeEmail(email.email);
          };
          let resendCallback = () => {
            this.sendConfirmation(email.email);
          };
          if (email.verified) {
            if (email.primary) {
              primaryLabel = UI$1.createElement(Label, {
                level: Level.PRIMARY,
                style: labelStyle,
                label: "Primary"
              });
            } else {
              verifiedLabel = UI$1.createElement(Label, {
                level: Level.SUCCESS,
                style: labelStyle,
                label: "Verified"
              });
              primaryAction = UI$1.createElement(Button, {
                onClick: makePrimaryCallback,
                size: Size.EXTRA_SMALL,
                level: Level.PRIMARY,
                label: "Make Primary",
                style: actionStyle
              });
            }
          } else {
            unverifiedLabel = UI$1.createElement(Label, {
              level: Level.DANGER,
              style: labelStyle,
              label: "Unverified"
            });
            resendAction = UI$1.createElement(Button, {
              onClick: resendCallback,
              size: Size.EXTRA_SMALL,
              label: "Re-send confirmation",
              style: actionStyle
            });
          }
          if (!email.primary) {
            removeAction = UI$1.createElement(Button, {
              onClick: removeCallback,
              size: Size.EXTRA_SMALL,
              level: Level.DANGER,
              label: "Remove",
              style: actionStyle
            });
          }
          emailForms.push(UI$1.createElement("div", {
            style: {
              width: "100%",
              position: "relative",
              paddingTop: "4px",
              paddingBottom: "4px"
            }
          }, UI$1.createElement("strong", null, email.email), primaryLabel, verifiedLabel, unverifiedLabel, UI$1.createElement("div", {
            style: {
              right: "0",
              top: "0",
              position: "absolute"
            }
          }, primaryAction, resendAction, removeAction)));
        }
        return [UI$1.createElement("h3", null, UI$1.T("E-mail Addresses")), UI$1.createElement("p", null, UI$1.T("The following e-mail addresses are associated with your account:")), emailForms, UI$1.createElement("h3", null, UI$1.T("Add E-mail Address")), UI$1.createElement("div", null, UI$1.createElement(Form, null, UI$1.createElement(FormField, {
          ref: "emailFormField",
          label: "Email"
        }, UI$1.createElement(EmailInput, {
          ref: "emailFormInput",
          placeholder: "john.smith@mail.com"
        })), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement("div", null, UI$1.createElement(AjaxButton, {
          ref: "addEmailButton",
          onClick: () => {
            this.addEmail();
          },
          level: Level.PRIMARY,
          statusOptions: ["Add Email", {
            icon: "spinner fa-spin",
            label: " Adding Email..."
          }, "Email added", "Failed"]
        }))))), UI$1.createElement("h5", null, UI$1.createElement(FormField, {
          label: UI$1.T("Receive email notifications"),
          inline: false
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "emailSubscriptionCheckbox",
          initialValue: this.options.user.receivesEmailAnnouncements,
          onClick: () => {
            this.changeEmailSubscription(this.emailSubscriptionCheckbox.getValue());
          }
        })))];
      }
      addEmail() {
        let email = this.emailFormInput.getValue();
        let request = {
          email: email
        };
        this.emailFormField.removeError();
        this.addEmailButton.postJSON("/accounts/email_address_add/", request).then(data => {
          this.emailFormInput.setValue("");
          UserStore.applyEvent({
            objectId: data.user.id,
            data: data.user
          });
        }, error => this.emailFormField.setError(error.message));
      }
      removeEmail(email) {
        let request = {
          email: email
        };
        if (!confirm("Are you sure you want to remove this email from your account?")) {
          return;
        }
        Ajax.postJSON("/accounts/email_address_remove/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }));
      }
      makePrimaryEmail(email) {
        let request = {
          email: email
        };
        Ajax.postJSON("/accounts/email_address_make_primary/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }));
      }
      sendConfirmation(email) {
        Ajax.postJSON("/accounts/email_address_verification_send/", {
          email: email
        });
      }
      changeEmailSubscription(receivesEmailAnnouncements) {
        Ajax.postJSON("/accounts/profile_changed/", {
          receivesEmailAnnouncements: receivesEmailAnnouncements
        });
      }
    }
    class SocialAccountsPanel extends Panel {
      constructor(options) {
        super(options);
        // Ensure Social managers are initialized
        // TODO: should use the Social App store!
        FacebookManager.getInstance();
        GoogleManager.getInstance();
      }
      render() {
        let addSocialAccountGroup = [UI$1.createElement("h3", null, UI$1.T("Add a 3rd Party Account")), UI$1.createElement("div", null, UI$1.createElement("a", {
          style: {
            cursor: "pointer"
          },
          onClick: () => GoogleManager.connect()
        }, UI$1.createElement("i", {
          className: "fa fa-google fa-2x"
        }), UI$1.createElement("span", {
          className: "google-login-text"
        }, " ", UI$1.T("Connect Google account")))), UI$1.createElement("div", null, UI$1.createElement("a", {
          onClick: () => {
            FacebookManager.connect();
          }
        }, UI$1.createElement("i", {
          className: "fa fa-facebook fa-2x"
        }), UI$1.createElement("span", null, " ", UI$1.T("Connect Facebook account"), " ")))];
        if (this.options.user.social.length) {
          let socialAccounts = [];
          for (let account of this.options.user.social) {
            socialAccounts.push(UI$1.createElement("div", null, UI$1.createElement("label", null, UI$1.createElement("img", {
              src: account.picture,
              height: "42",
              width: "42"
            }), UI$1.createElement("a", {
              href: account.link,
              target: "_blank"
            }, " ", account.name), UI$1.createElement("span", null, " ", "- " + account.platform)), UI$1.createElement("div", {
              className: "pull-right"
            }, UI$1.createElement(Button, {
              label: "Remove",
              size: Size.SMALL,
              level: Level.DANGER,
              style: {
                "margin-top": "7px"
              },
              onClick: () => {
                this.removeSocialAccount(account.id);
              }
            }))));
          }
          return [UI$1.createElement("h3", null, UI$1.T("Social accounts")), UI$1.createElement("p", null, UI$1.T("You can sign in to your account using any of the following third party accounts:")), UI$1.createElement("div", null, socialAccounts), ...addSocialAccountGroup];
        } else {
          return [UI$1.createElement("h3", null, UI$1.T("Social accounts")), UI$1.createElement("p", null, UI$1.T("You currently have no social network accounts connected to this account.")), ...addSocialAccountGroup];
        }
      }
      removeSocialAccount(socialAccountId) {
        Ajax.postJSON("/accounts/remove_social_account/", {
          socialAccountId: socialAccountId
        }).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }));
      }
    }
    class UserSettingsPanel extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "500px"
        });
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      getUrlPrefix(str) {
        let url = "/accounts/settings/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      setURL(urlParts) {
        if (this.tabArea) {
          this.showUrlTab(urlParts[0] || "general");
        } else {
          this.initialUrlParts = urlParts;
        }
      }
      showUrlTab(tabName) {
        if (this[tabName + "Panel"]) {
          this[tabName + "Panel"].dispatch("show");
        } else {
          this["generalPanel"].dispatch("show");
        }
      }
      getUser() {
        return UserStore.getCurrentUser();
      }
      getPanels() {
        return [UI$1.createElement(GeneralInformationPanel, {
          title: UI$1.T("General Info"),
          active: true,
          user: this.getUser(),
          ref: "generalPanel",
          tabHref: this.getUrlPrefix("general")
        }), UI$1.createElement(EmailPanel, {
          title: UI$1.T("Email"),
          user: this.getUser(),
          ref: "emailPanel",
          tabHref: this.getUrlPrefix("email")
        }), UI$1.createElement(SocialAccountsPanel, {
          title: UI$1.T("Social accounts"),
          user: this.getUser(),
          ref: "socialPanel",
          tabHref: this.getUrlPrefix("social")
        }), UI$1.createElement(SecuritySettingsPanel, {
          title: UI$1.T("Security"),
          user: this.getUser(),
          ref: "securityPanel",
          tabHref: this.getUrlPrefix("security")
        })];
      }
      render() {
        return [UI$1.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, this.getPanels())];
      }
      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlPars;
      }
    }

    const DEFAULT_THEME = {
      COLOR_PRIMARY: "#202e3e",
      FONT_MONOSPACE: "'Source Code Pro', 'Monaco', 'Consolas', monospace",
      FONT_FAMILY_DEFAULT: "Lato, 'Segoe UI', 'Lucida Sans Unicode', 'Helvetica Neue', Helvetica, Arial, sans-serif",
      CSA_PLAYER_COLOR_FOCUSED: "#9bc",
      CSA_PLAYER_COLOR_UNFOCUSED: "#555",
      CARD_PANEL_TEXT_TRANSFORM: "initial",
      CONTEST_QUESTION_CARD_PANEL_WIDTH: 450,
      CONTEST_QUESTION_CARD_PANEL_MIN_WIDTH: 350,
      CONTEST_QUESTION_CARD_PANEL_PADDING: 10,
      CONTEST_QUESTION_CARD_PANEL_BODY_PADDING: 15,
      CONTEST_QUESTION_CARD_PANEL_LINE_HEIGHT: 18,
      CONTEST_QUESTION_CONTAINER: 920,
      MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP: 10,
      MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE: 25,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_DESKTOP: 0,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_MOBILE: 0,
      NAV_MANAGER_BOX_SHADOW_NAVBAR: "0px 1px 0px rgb(0, 0, 0)",
      COLOR_COMPILE: "#3DB7C6",
      COLOR_RUN: "#3D7FC6",
      COLOR_SUBMIT: "#CC4949",
      COLOR_WORKSPACE: "#34435b"
    };
    Object.assign(DEFAULT_THEME, self.THEME_PROPS);
    Theme.setProperties(DEFAULT_THEME);
    const predefinedThemes = {
      "1": {
        COLOR_SECONDARY: "#358ba4",
        COLOR_BACKGROUND_BODY: "#f8f8f8",
        COLOR_BACKGROUND_ALTERNATIVE: "#eee"
      },
      "2": {
        COLOR_PRIMARY: "#202",
        COLOR_SECONDARY: "#358ba4",
        COLOR_BACKGROUND_BODY: "#493349",
        COLOR_BACKGROUND_ALTERNATIVE: "#392339",
        FONT_FAMILY_DEFAULT: "Lato, 'Segoe UI', 'Lucida Sans Unicode', 'Helvetica Neue', Helvetica, Arial, sans-serif"
      },
      "3": {
        COLOR_PRIMARY: "#000",
        COLOR_SECONDARY: "#070",
        COLOR_BACKGROUND_BODY: "#222",
        COLOR_BACKGROUND_ALTERNATIVE: "#392339",
        FONT_FAMILY_DEFAULT: "monospace"
      },
      "custom": {
        // leave this empty
      }
    };
    const defaultThemeProperties = Object.assign({}, Theme.Global.properties);
    function setUserThemeProperties() {
      let userThemeProperties = Object.assign({}, UserStore.getCurrentUser().getCustomSetting("theme", {}));
      let userThemeId = UserStore.getCurrentUser().getCustomSetting("themeId");
      if (!userThemeId) {
        return;
      }
      if (userThemeId === "custom") {
        for (let key in userThemeProperties) {
          let value = userThemeProperties[key];
          if (value === "null" || value === null) {
            value = defaultThemeProperties[key];
          }
          Theme.setProperties({
            [key]: value
          });
        }
        return;
      }
      Theme.setProperties(predefinedThemes[userThemeId]);
    }
    function attachProfileThemeListeners() {
      if (USER.isAuthenticated) {
        setUserThemeProperties();
        UserStore.getCurrentUser().addListener("updateCustomSetting", event => {
          if (event.key.startsWith("theme:") && event.origin === "set" || event.key === "themeId") {
            setUserThemeProperties();
          }
        });
      }
    }

    var _class$j, _descriptor$b, _descriptor2$b, _descriptor3$a, _descriptor4$a, _descriptor5$9, _descriptor6$7, _descriptor7$4, _descriptor8$4, _dec$f, _class2$a, _dec2$5, _class3$4;
    class CSAGeneralInformationPanel extends GeneralInformationPanel {
      getFormFields() {
        const userLimits = USER_CONSTANTS;
        return [UI$1.createElement(FormField, {
          ref: "firstNameFormField",
          label: UI$1.T("First Name")
        }, UI$1.createElement(TextInput, {
          ref: "firstNameFormInput",
          maxLength: userLimits.first_name_max_length || 30,
          placeholder: "John",
          value: this.options.user.firstName
        })), UI$1.createElement(FormField, {
          ref: "lastNameFormField",
          label: UI$1.T("Last Name")
        }, UI$1.createElement(TextInput, {
          ref: "lastNameFormInput",
          maxLength: userLimits.last_name_max_length || 30,
          placeholder: "Smith",
          value: this.options.user.lastName
        })), UI$1.createElement(FormField, {
          ref: "userNameFormField",
          label: UI$1.T("Username")
        }, UI$1.createElement(TextInput, {
          ref: "userNameFormInput",
          maxLength: userLimits.username_max_length || 30,
          placeholder: "johnsmith",
          value: this.options.user.username || ""
        })), UI$1.createElement(FormField, {
          ref: "displayNameFormField",
          label: UI$1.T("Display name")
        }, UI$1.createElement(Select, {
          ref: "displayNameSelect",
          options: ["Name", "Username"]
        })), UI$1.createElement(FormField, {
          ref: "countryFormField",
          label: UI$1.T("Country")
        }, UI$1.createElement(Select, {
          ref: "countrySelect",
          options: CountryStore.allWithNone(),
          selected: CountryStore.get(USER.countryId)
        }))];
      }
      onMount() {
        super.onMount();
        this.userNameFormInput.addChangeListener(() => {
          this.validateUsername();
        });
      }
      validateUsername() {
        let userName = this.userNameFormInput.getValue();
        let validators = USER_CONSTANTS.username_regexes;
        let usernameErrors = false;
        for (let validator of validators) {
          let usernameRegex = new RegExp(String.raw`${validator.pattern}`);
          if (!usernameRegex.test(userName)) {
            this.userNameFormField.setError(validator.message);
            usernameErrors = true;
          }
        }
        if (!usernameErrors) {
          this.userNameFormField.removeError();
          this.saveProfileButton.enable();
        } else {
          this.saveProfileButton.disable();
        }
      }
      getSaveRequestData() {
        const request = super.getSaveRequestData();
        request.countryId = this.countrySelect.get().id;
        return request;
      }
    }
    class ExternalAccountsPanel extends Panel {
      render() {
        if (this.options.user.codeforcesHandle) {
          let showImportHandle = this.options.user.username !== this.options.user.codeforcesHandle;
          for (let validator of USER_CONSTANTS.username_regexes) {
            let usernameRegex = new RegExp(String.raw`${validator.pattern}`);
            if (!usernameRegex.test(this.options.user.codeforcesHandle)) {
              showImportHandle = false;
              break;
            }
          }
          let importHandleButtonClass = "pull-right" + (showImportHandle ? "" : " hidden");
          return [UI$1.createElement("h3", null, UI$1.T("Codeforces account")), UI$1.createElement("p", null, UI$1.T("The following codeforces account is linked with your account:")), UI$1.createElement("div", {
            style: {
              "margin-top": "15px"
            }
          }, UI$1.createElement("a", {
            href: "http://www.codeforces.com/profile/" + this.options.user.codeforcesHandle,
            target: "_blank"
          }, this.options.user.codeforcesHandle), UI$1.createElement(Button$1, {
            label: UI$1.T("Unlink"),
            className: "pull-right",
            size: Size.EXTRA_SMALL,
            level: Level.DANGER,
            onClick: () => {
              this.unlinkCodeforces();
            }
          }), UI$1.createElement(Button$1, {
            ref: "importHandleButton",
            label: UI$1.T("Import handle"),
            className: importHandleButtonClass,
            style: {
              "margin-right": "7px"
            },
            size: Size.EXTRA_SMALL,
            level: Level.SUCCESS,
            onClick: () => {
              this.importCodeforcesHandle();
            }
          }))];
        } else {
          return [UI$1.createElement("h3", null, UI$1.T("Link Codeforces account")), UI$1.createElement("div", null, UI$1.createElement(FormField, {
            ref: "handleGroup",
            label: UI$1.T("Handle")
          }, UI$1.createElement(TextInput, {
            ref: "handleInput"
          })), UI$1.createElement(FormField, {
            label: " "
          }, UI$1.createElement("div", null, UI$1.createElement(AjaxButton, {
            ref: "getTokenButton",
            level: Level.PRIMARY,
            onClick: () => {
              this.linkCodeforces();
            },
            statusOptions: ["Verify user", {
              icon: "spinner fa-spin",
              label: " Verifying user..."
            }, "User verified", "Failed"]
          }))), UI$1.createElement("div", {
            ref: "sendTokenGroup",
            style: {
              "margin-top": "40px"
            },
            className: "hidden"
          }, UI$1.createElement("p", null, UI$1.T("Send us a private message with this token:")), UI$1.createElement(FormField, {
            label: "Token"
          }, UI$1.createElement(TextInput, {
            ref: "tokenInput",
            readonly: true
          })), UI$1.createElement("p", null, UI$1.T("Click bellow to open Codeforces (in a new window) to send us this token:")), UI$1.createElement(Button$1, {
            label: UI$1.T("Open Codeforces"),
            level: Level.PRIMARY,
            onClick: () => {
              window.open("http://codeforces.com/usertalk?other=csacademy", "_blank");
            }
          })))];
        }
      }
      linkCodeforces() {
        this.handleGroup.removeError();
        this.sendTokenGroup.hide();
        this.getTokenButton.postJSON("/accounts/link_external_account/", {
          platform: "codeforces",
          username: this.handleInput.getValue()
        }).then(data => {
          this.tokenInput.setValue(data.token);
          this.tokenInput.addClickListener(() => {
            this.tokenInput.node.select();
          });
          this.sendTokenGroup.show();
          if (this.codeforcesTokenTimeout != null) {
            clearTimeout(this.codeforcesTokenTimeout);
          }
          this.codeforcesTokenTimeout = setTimeout(() => {
            this.sendTokenGroup.hide();
          }, 10 * 60 * 1000);
        }, error => {
          this.handleGroup.setError(error.message);
        });
      }
      unlinkCodeforces() {
        let request = {
          platform: "codeforces"
        };
        Ajax.postJSON("/accounts/unlink_external_account/", request).then(data => {
          UserStore.applyEvent({
            objectId: data.user.id,
            data: data.user
          });
        });
      }
      importCodeforcesHandle() {
        var request = {
          platform: "codeforces"
        };
        if (this.options.user.username && !confirm("Your current username (" + this.options.user.username + ")" + " will be available for other users to use. Are you sure you want to change your username?")) {
          return;
        }
        Ajax.postJSON("/accounts/import_external_username/", request).then(data => {
          UserStore.applyEvent({
            objectId: data.user.id,
            data: data.user
          });
        });
      }
    }
    function setUserThemeProperty(key, value) {
      UserStore.getCurrentUser().saveCustomSetting("theme:" + key, value);
    }
    function setUserPredefinedTheme(value) {
      UserStore.getCurrentUser().saveCustomSetting("themeId", value);
    }
    let ThemeSettingsStyle = (_class$j = class ThemeSettingsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.dimensions = 26;
        this.horizontalMargin = "1em";
        this.verticalMargin = 12;
        _initializerDefineProperty(this, "themeSettingsPanel", _descriptor$b, this);
        _initializerDefineProperty(this, "themeSettingsContainer", _descriptor2$b, this);
        _initializerDefineProperty(this, "themeSettingsField", _descriptor3$a, this);
        _initializerDefineProperty(this, "label", _descriptor4$a, this);
        _initializerDefineProperty(this, "colorBox", _descriptor5$9, this);
        _initializerDefineProperty(this, "textInput", _descriptor6$7, this);
        _initializerDefineProperty(this, "button", _descriptor7$4, this);
        _initializerDefineProperty(this, "paragraph", _descriptor8$4, this);
      }
    }, (_descriptor$b = _applyDecoratedDescriptor(_class$j.prototype, "themeSettingsPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor2$b = _applyDecoratedDescriptor(_class$j.prototype, "themeSettingsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // maxWidth: "600px",
          // width: "600px",
        };
      }
    }), _descriptor3$a = _applyDecoratedDescriptor(_class$j.prototype, "themeSettingsField", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0 auto",
          marginTop: this.verticalMargin,
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          maxWidth: "600px"
        };
      }
    }), _descriptor4$a = _applyDecoratedDescriptor(_class$j.prototype, "label", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "40%",
          textAlign: "right",
          lineHeight: this.dimensions,
          marginRight: this.horizontalMargin,
          color: "#555"
        };
      }
    }), _descriptor5$9 = _applyDecoratedDescriptor(_class$j.prototype, "colorBox", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.dimensions,
          width: this.dimensions,
          marginRight: this.horizontalMargin
        };
      }
    }), _descriptor6$7 = _applyDecoratedDescriptor(_class$j.prototype, "textInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.dimensions,
          marginRight: this.horizontalMargin,
          flex: 1,
          outline: 0,
          minWidth: "30px",
          fontSize: "14px"
        };
      }
    }), _descriptor7$4 = _applyDecoratedDescriptor(_class$j.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.dimensions,
          padding: "0 10px !important",
          marginRight: this.horizontalMargin
        };
      }
    }), _descriptor8$4 = _applyDecoratedDescriptor(_class$j.prototype, "paragraph", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "16px",
          wordBreak: "break-all"
        };
      }
    })), _class$j);
    let ThemeSettingsField = (_dec$f = registerStyle(ThemeSettingsStyle), _dec$f(_class2$a = class ThemeSettingsField extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.themeSettingsField);
      }
      getDefaultOptions() {
        return {
          textInputStyle: this.options.textInputStyle || {},
          colorBoxStyle: this.options.colorBoxStyle || {}
        };
      }
      getCurrentThemeFieldValue() {
        return Theme.props[this.options.fieldName];
      }
      getCustomThemeFieldValue() {
        const customTheme = USER.getCustomSetting("theme", {});
        const value = customTheme[this.options.fieldName];
        if (typeof value === "function") {
          return value();
        }
        return value;
      }
      getDefaultFieldValue() {
        const value = defaultThemeProperties[this.options.fieldName];
        if (typeof value === "function") {
          return value();
        }
        return value;
      }
      getInputValue() {
        return this.input.getValue();
      }
      render() {
        return [UI$1.createElement("label", {
          className: this.styleSheet.label
        }, UI$1.createElement("strong", null, this.options.label)), UI$1.createElement(TextInput, {
          value: this.options.fieldValue,
          ref: "input",
          onChange: () => this.updateField(),
          className: this.styleSheet.textInput,
          style: this.options.textInputStyle
        }), UI$1.createElement("div", {
          className: this.styleSheet.colorBox,
          style: this.options.colorBoxStyle
        }), UI$1.createElement(Button$1, {
          ref: "changeThemeButton",
          onClick: () => this.applyThemeField(),
          level: Level.PRIMARY,
          className: this.styleSheet.button
        }, "Apply"), UI$1.createElement(Button$1, {
          ref: "resetThemeButton",
          onClick: () => this.resetThemeField(),
          level: Level.PRIMARY,
          className: this.styleSheet.button
        }, "Reset")];
      }
      updateField() {
        this.updateOptions({
          fieldValue: this.getInputValue()
        });
      }
      applyThemeField() {
        const inputValue = this.getInputValue();
        setUserThemeProperty(this.options.fieldName, inputValue);
        this.updateOptions({
          fieldValue: inputValue
        });
        this.updateStyle();
      }
      resetThemeField() {
        setUserThemeProperty(this.options.fieldName, null);
        this.updateOptions({
          fieldValue: this.getDefaultFieldValue()
        });
        this.updateStyle();
      }
    }) || _class2$a);
    class ThemeSettingsColorField extends ThemeSettingsField {
      getDefaultOptions() {
        let fieldValue = this.getCustomThemeFieldValue();
        if (fieldValue == null || fieldValue === "null") {
          fieldValue = this.getCurrentThemeFieldValue();
        }
        return Object.assign({}, super.getDefaultOptions(), {
          fieldValue,
          colorBoxStyle: {
            backgroundColor: fieldValue,
            border: "2px solid " + (fieldValue && enhance(fieldValue, 0.2) || "black")
          }
        });
      }
      updateStyle() {
        this.updateOptions({
          colorBoxStyle: {
            backgroundColor: this.options.fieldValue,
            border: "2px solid " + (fieldValue && enhance(fieldValue, 0.2) || "black")
          }
        });
      }
    }
    class ThemeSettingsFontFamilyField extends ThemeSettingsField {
      getDefaultOptions() {
        let fieldValue = this.getCustomThemeFieldValue();
        if (fieldValue == null || fieldValue === "null") {
          fieldValue = this.getCurrentThemeFieldValue();
        }
        return Object.assign({}, super.getDefaultOptions(), {
          fieldValue,
          textInputStyle: {
            fontFamily: fieldValue
          }
        });
      }
      updateStyle() {
        this.updateOptions({
          textInputStyle: {
            fontFamily: this.options.fieldValue
          }
        });
      }
    }
    let ThemeSettingsPanel = (_dec2$5 = registerStyle(ThemeSettingsStyle), _dec2$5(_class3$4 = class ThemeSettingsPanel extends Panel {
      constructor(options) {
        super(options);
        this.colorFields = [{
          label: "Primary Color",
          fieldName: "COLOR_PRIMARY"
        }, {
          label: "Secondary Color",
          fieldName: "COLOR_SECONDARY"
        }, {
          label: "Primary Background Color",
          fieldName: "COLOR_BACKGROUND_BODY"
        }, {
          label: "Secondary Background Color",
          fieldName: "COLOR_BACKGROUND_ALTERNATIVE"
        }];
        this.fontFamilyFields = [{
          label: "Primary Font Family",
          fieldName: "FONT_FAMILY_DEFAULT"
        }];
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.themeSettingsPanel);
      }
      render() {
        let themeSettingsColorFields = this.colorFields.map((colorField, index) => {
          return UI$1.createElement(ThemeSettingsColorField, {
            label: colorField.label,
            fieldName: colorField.fieldName
          });
        });
        let themeSettingsFontFamilyFields = this.fontFamilyFields.map((fontFamilyField, index) => {
          return UI$1.createElement(ThemeSettingsFontFamilyField, {
            label: fontFamilyField.label,
            fieldName: fontFamilyField.fieldName
          });
        });
        return [UI$1.createElement("h3", null, "Theme"), UI$1.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Color examples:", UI$1.createElement("code", null, "#345abc"), ",", UI$1.createElement("code", null, "#678"), ",", UI$1.createElement("code", null, "rgb(123,123,123)"), ",", UI$1.createElement("code", null, "rgba(123,123,123,0.5)"), ",", UI$1.createElement("code", null, "blue"), ",", UI$1.createElement("code", null, "aqua"), "."), UI$1.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Font examples:", UI$1.createElement("code", null, "monospace"), ",", UI$1.createElement("code", null, "Arial"), ",", UI$1.createElement("code", null, "cursive"), ",", UI$1.createElement("code", null, "Helvetica"), "."), UI$1.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Select your theme:\xA0", UI$1.createElement(Select, {
          options: [{
            value: "",
            toString: () => "Current theme"
          }, {
            value: "1",
            toString: () => "Default"
          }, {
            value: "2",
            toString: () => "Dark"
          }, {
            value: "3",
            toString: () => "Console"
          }, {
            value: "custom",
            toString: () => "Custom"
          }],
          ref: "select"
        })), UI$1.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Configure custom theme settings:"), UI$1.createElement("div", {
          className: this.styleSheet.themeSettingsContainer
        }, themeSettingsColorFields, themeSettingsFontFamilyFields)];
      }
      onMount() {
        this.select.addChangeListener(() => {
          setUserPredefinedTheme(this.select.get().value);
        });
      }
    }) || _class3$4);
    class AccountSettingsPanel extends UserSettingsPanel {
      getPanels() {
        return [UI$1.createElement(CSAGeneralInformationPanel, {
          title: UI$1.T("General Info"),
          active: true,
          user: this.getUser(),
          ref: "generalPanel",
          tabHref: this.getUrlPrefix("general")
        }), UI$1.createElement(EmailPanel, {
          title: UI$1.T("Email"),
          user: this.getUser(),
          ref: "emailPanel",
          tabHref: this.getUrlPrefix("email")
        }), UI$1.createElement(ExternalAccountsPanel, {
          title: UI$1.T("External accounts"),
          user: this.getUser(),
          ref: "externalPanel",
          tabHref: this.getUrlPrefix("external")
        }), UI$1.createElement(SocialAccountsPanel, {
          title: UI$1.T("Social accounts"),
          user: this.getUser(),
          ref: "socialPanel",
          tabHref: this.getUrlPrefix("social")
        }), UI$1.createElement(SecuritySettingsPanel, {
          title: UI$1.T("Security"),
          user: this.getUser(),
          ref: "securityPanel",
          tabHref: this.getUrlPrefix("security")
        }), UI$1.createElement(ThemeSettingsPanel, {
          title: UI$1.T("Theme"),
          user: this.getUser(),
          ref: "themePanel",
          tabHref: this.getUrlPrefix("theme")
        })];
      }
    }

    class EmailConfirmed extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center"
        });
      }
      render() {
        if (this.options.confirmSuccess) {
          location.replace("/accounts/settings/");
        }
        return [UI$1.createElement("div", null, UI$1.createElement("h1", null, "Invalid email confirmation link."), UI$1.createElement("h3", null, "The email confirmation link is incomplete or has been used already."))];
      }
    }

    class EmailUnsubscribe extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center"
        });
      }
      render() {
        let message;
        if (this.options.unsubscribeSuccess) {
          message = UI$1.createElement("div", null, UI$1.createElement("h1", null, "Email unsubscribed!"), UI$1.createElement("h3", null, "You can continue navigating on the website."), UI$1.createElement(Link, {
            href: "/accounts/settings/",
            className: ButtonStyle.getInstance().container,
            value: "Edit user profile"
          }));
        } else {
          message = UI$1.createElement("div", null, UI$1.createElement("h1", null, "Invalid email unsubscribe link."), UI$1.createElement("h3", null, "Please try to change the settings from your profile page."));
        }
        return message;
      }
    }

    class PasswordReset extends UI$1.Element {
      render() {
        if (USER.isAuthenticated) {
          window.location.href = "/accounts/settings/";
        }
        return [UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement("h1", null, "Password reset"), UI$1.createElement("p", null, "Forgotten your password? Enter your e-mail address below, and we'll send you an e-mail allowing you to reset it.")), UI$1.createElement(FormField, {
          ref: "emailFormField",
          label: "Email"
        }, UI$1.createElement(TextInput, {
          ref: "emailInput"
        })), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement("div", null, UI$1.createElement(AjaxButton, {
          ref: "resetPasswordButton",
          level: Level.PRIMARY,
          onClick: () => this.sendPasswordReset(),
          statusOptions: ["Send password reset email", {
            icon: "spinner fa-spin",
            label: " Sending..."
          }, "Email sent", "Email failed"]
        })))];
      }
      sendPasswordReset() {
        this.emailFormField.removeError();
        let url = window.location.href;
        if (!url.endsWith("/")) {
          url += "/";
        }
        this.resetPasswordButton.postJSON(url, {
          email: this.emailInput.getValue().trim()
        }).then(() => {}, error => this.emailFormField.setError(error.message));
      }
    }

    class CodeforcesUserRatingBackground extends SVG.Group {
      getDefaultOptions() {
        return {
          ratingBands: [{
            color: "#AA0000",
            minRating: 2900,
            maxRating: 5000
          }, {
            color: "#FF3333",
            minRating: 2600,
            maxRating: 2900
          }, {
            color: "#FF7777",
            minRating: 2400,
            maxRating: 2600
          }, {
            color: "#FFBB55",
            minRating: 2300,
            maxRating: 2400
          }, {
            color: "#FFCC88",
            minRating: 2200,
            maxRating: 2300
          }, {
            color: "#FF88FF",
            minRating: 1900,
            maxRating: 2200
          }, {
            color: "#AAAAFF",
            minRating: 1600,
            maxRating: 1900
          }, {
            color: "#77DDBB",
            minRating: 1400,
            maxRating: 1600
          }, {
            color: "#77FF77",
            minRating: 1200,
            maxRating: 1400
          }, {
            color: "#CCCCCC",
            minRating: 0,
            maxRating: 1200
          }],
          interpolation: "linear"
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("pointer-events", "none");
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }
      getRatingBands() {
        this.ratingBands = [];
        this.showBandsAsPaths = true;
        if (this.showBandsAsPaths) {
          // Create the area path generator
          this.areaPathGenerator = area().y0(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.minRating);
          }).y1(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.maxRating);
          }).x(bandData => {
            return bandData.x;
          });

          // Create the rating bands
          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI$1.createElement(SVG.Path, {
              ref: this.refLinkArray("ratingBands", i),
              d: this.areaPathGenerator([Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[0]
              }), Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[1]
              })]),
              fill: bandData.color,
              stroke: "none"
            });
          }
        } else {
          // Create the rating bands
          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI$1.createElement(SVG.Rect, {
              ref: this.refLinkArray("ratingBands", i),
              x: this.options.chart.xAxisOptions.scale.range()[0],
              y: this.options.chart.yAxisOptions.scale(bandData.maxRating),
              width: this.options.chart.xAxisOptions.scale.range()[1] - this.options.chart.xAxisOptions.scale.range()[0],
              height: this.options.chart.yAxisOptions.scale(bandData.minRating) - this.options.chart.yAxisOptions.scale(bandData.maxRating),
              fill: bandData.color,
              stroke: "none"
            });
          }
        }
        return this.ratingBands;
      }
      render() {
        return this.getRatingBands();
      }
    }
    class CodeforcesUserRatingChart extends TimeChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0.4, 0.25],
          paddingYOnNoPoints: 500,
          zoomScaleExtent: [1, 50]
        });
      }
      defaultYNoPoints() {
        return [1000, 3000];
      }
      getBackground() {
        return UI$1.createElement(CodeforcesUserRatingBackground, {
          ref: this.refLink("background"),
          chart: this
        });
      }
    }
    class CodeforcesRatingPoint extends PointPlotElement {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fill: "white",
          radius: 5,
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 1.5,
          style: {
            cursor: "pointer"
          }
        });
      }
      getPopupTitle(data = this.options.data) {
        let contestName = data.contestName.replace("Codeforces", "CF").replace("<br>", "\n");
        return UI$1.createElement("a", {
          href: "http://codeforces.com/contest/" + data.contestId,
          target: "_blank"
        }, contestName);
      }
      getPopupContent(data = this.options.data) {
        return [UI$1.createElement("p", null, "Rating: " + data.newRating + " (" + data.ratingChange + ")"), UI$1.createElement("p", null, "Title: " + data.title), UI$1.createElement("a", {
          href: "http://codeforces.com" + data.contestUrl,
          target: "_blank"
        }, "Contest rank: " + data.rank)];
      }
      getPopupPosition() {
        let boundingRect = this.getBoundingClientRect();
        return {
          x: boundingRect.left + boundingRect.width / 2,
          y: boundingRect.bottom - boundingRect.height * 0.1
        };
      }
      isPopupVisible() {
        let chartBoundingRect = this.parent.options.chart.interactiveLayer.getBoundingClientRect();
        let popupPosition = this.getPopupPosition();
        return chartBoundingRect.left <= popupPosition.x && popupPosition.x <= chartBoundingRect.right && chartBoundingRect.top <= popupPosition.y && popupPosition.y <= chartBoundingRect.bottom;
        //return (this.options.xAxisScale.range()[0] <= this.options.center.x &&
        //    this.options.center.x <= this.options.xAxisScale.range()[1]) &&
        //    (this.options.yAxisScale.range()[0] >= this.options.center.y &&
        //    this.options.center.y >= this.options.yAxisScale.range()[1]);
      }
      onMount() {
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();
          if (this.popup && this.popup.isInDocument()) {
            this.popup.hide();
            return;
          }
          this.popup = Popup.create(document.body, Object.assign({
            title: this.getPopupTitle(),
            children: this.getPopupContent(),
            transitionTime: 300,
            titleFontSize: "9pt",
            contentFontSize: "9pt",
            style: {
              minWidth: "180px",
              maxWidth: "250px"
            }
          }, this.getPopupPosition()));
        });
      }
      redraw() {
        super.redraw();
        if (this.popup) {
          if (this.popup.isInDocument()) {
            this.popup.setCenter(this.getPopupPosition());
          }
          if (!this.isPopupVisible()) {
            this.popup.hide();
          }
        }
      }
    }
    const CodeforcesRatingPointPlot = PointPlot(CodeforcesRatingPoint);
    class CodeforcesUserRatingSVG extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          height: 500,
          width: 970
        };
        if (!this.options.data.hasOwnProperty("result")) {
          this.options.data["result"] = [];
        }
        this.plotOptions = {
          pointsAlias: data => {
            return data.result;
          },
          xCoordinateAlias: data => {
            return data.contestTime;
          },
          yCoordinateAlias: data => {
            return data.newRating;
          }
        };
        this.linePlotOptions = Object.assign({}, this.plotOptions, {
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 2.5
        });
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("height", this.chartOptions.height);
        attr.setAttribute("width", this.chartOptions.width);
        return attr;
      }
      render() {
        return [UI$1.createElement(CodeforcesUserRatingChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          data: this.options.data
        }, UI$1.createElement(LinePlot, {
          plotOptions: this.linePlotOptions,
          data: this.options.data
        }), UI$1.createElement(CodeforcesRatingPointPlot, {
          plotOptions: this.plotOptions,
          data: this.options.data
        }))];
      }
    }
    class CSAUserRatingBackground extends SVG.Group {
      getDefaultOptions() {
        return {
          ratingBands: window.RATING_BANDS,
          interpolation: "linear"
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("pointer-events", "none");
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }
      getRatingBands() {
        this.ratingBands = [];
        this.showBandsAsPaths = true;
        if (this.showBandsAsPaths) {
          // Create the area path generator
          this.areaPathGenerator = area().y0(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.minRating);
          }).y1(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.maxRating);
          }).x(bandData => {
            return bandData.x;
          });

          // Create the rating bands
          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI$1.createElement(SVG.Path, {
              ref: this.refLinkArray("ratingBands", i),
              d: this.areaPathGenerator([Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[0]
              }), Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[1]
              })]),
              fill: bandData.color,
              stroke: "none"
            });
          }
        } else {
          // Create the rating bands
          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI$1.createElement(SVG.Rect, {
              ref: this.refLinkArray("ratingBands", i),
              x: this.options.chart.xAxisOptions.scale.range()[0],
              y: this.options.chart.yAxisOptions.scale(bandData.maxRating),
              width: this.options.chart.xAxisOptions.scale.range()[1] - this.options.chart.xAxisOptions.scale.range()[0],
              height: this.options.chart.yAxisOptions.scale(bandData.minRating) - this.options.chart.yAxisOptions.scale(bandData.maxRating),
              fill: bandData.color,
              stroke: "none"
            });
          }
        }
        return this.ratingBands;
      }
      render() {
        return this.getRatingBands();
      }
    }
    class CSAUserRatingChart extends TimeChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0.4, 0.25],
          zoomScaleExtent: [1, 20]
        });
      }
      getYAxisDomain(points, coordinateAlias) {
        if (!Array.isArray(points) || points.length === 0) {
          return [1450, 1750];
        }
        let domain = this.getMinMaxDomain(points, coordinateAlias, 200);
        return [Math.min(domain[0], 1450), Math.max(domain[1], 1750)];
      }
      getBackground() {
        return UI$1.createElement(CSAUserRatingBackground, {
          ref: this.refLink("background"),
          chart: this
        });
      }
    }
    class CSARatingPoint extends PointPlotElement {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fill: "white",
          radius: 5,
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 1.5,
          style: {
            cursor: "pointer"
          }
        });
      }
      getPopupTitle(data = this.options.data) {
        return UI$1.createElement("a", {
          href: "/contest/" + data.contestURL,
          target: "_blank"
        }, data.contest);
      }
      getPopupContent(data = this.options.data) {
        let ratingChange = Math.floor(data.rating) - Math.floor(data.oldRating);
        let ratingChangeStyle;
        if (ratingChange < 0) {
          ratingChangeStyle = {
            color: "red"
          };
        } else {
          ratingChangeStyle = {
            color: "green"
          };
        }
        let ratingChangeDisplay = UI$1.createElement("span", {
          style: ratingChangeStyle
        }, (ratingChange > 0 ? "+" : "") + ratingChange);
        return [UI$1.createElement("p", null, "Rating: " + Math.floor(data.rating), " (", ratingChangeDisplay, ")"), UI$1.createElement("a", {
          href: "/contest/" + data.contestURL + "/scoreboard",
          target: "_blank"
        }, "Contest rank: " + data.rank)];
      }
      getPopupPosition() {
        let boundingRect = this.getBoundingClientRect();
        return {
          x: boundingRect.left + boundingRect.width / 2,
          y: boundingRect.bottom - boundingRect.height * 0.1
        };
      }
      isPopupVisible() {
        let chartBoundingRect = this.parent.options.chart.interactiveLayer.getBoundingClientRect();
        let popupPosition = this.getPopupPosition();
        return chartBoundingRect.left <= popupPosition.x && popupPosition.x <= chartBoundingRect.right && chartBoundingRect.top <= popupPosition.y && popupPosition.y <= chartBoundingRect.bottom;
        //return (this.options.xAxisScale.range()[0] <= this.options.center.x &&
        //    this.options.center.x <= this.options.xAxisScale.range()[1]) &&
        //    (this.options.yAxisScale.range()[0] >= this.options.center.y &&
        //    this.options.center.y >= this.options.yAxisScale.range()[1]);
      }
      onMount() {
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();
          if (this.popup && this.popup.isInDocument()) {
            this.popup.hide();
            return;
          }
          this.popup = Popup.create(document.body, Object.assign({
            title: this.getPopupTitle(),
            children: this.getPopupContent(),
            transitionTime: 300,
            titleFontSize: "9pt",
            contentFontSize: "9pt",
            style: {
              maxWidth: "270px"
            }
          }, this.getPopupPosition()));
        });
      }
      redraw() {
        super.redraw();
        if (this.popup) {
          if (this.popup.isInDocument()) {
            this.popup.setCenter(this.getPopupPosition());
          }
          if (!this.isPopupVisible()) {
            this.popup.hide();
          }
        }
      }
    }
    const CSARatingPointPlot = PointPlot(CSARatingPoint);
    class CSAUserRatingSVG extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          height: 500,
          width: 970
        };
        if (!this.options.data.hasOwnProperty("contestHistory")) {
          this.options.data["contestHistory"] = [];
        }
        this.plotOptions = {
          pointsAlias: data => {
            return data.contestHistory;
          },
          xCoordinateAlias: data => {
            return data.contestEndDate * 1000;
          },
          yCoordinateAlias: data => {
            return Math.floor(data.rating);
          }
        };
        this.plotOptions.pointsAlias(this.options.data).sort((a, b) => {
          return this.plotOptions.xCoordinateAlias(a) - this.plotOptions.xCoordinateAlias(b);
        });
        this.linePlotOptions = Object.assign({}, this.plotOptions, {
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 2.5
        });
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("height", this.chartOptions.height);
        attr.setAttribute("width", this.chartOptions.width);
        return attr;
      }
      render() {
        return [UI$1.createElement(CSAUserRatingChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          data: this.options.data
        }, UI$1.createElement(LinePlot, {
          plotOptions: this.linePlotOptions,
          data: this.options.data
        }), UI$1.createElement(CSARatingPointPlot, {
          plotOptions: this.plotOptions,
          data: this.options.data
        }))];
      }
    }

    const LinkLabel = UI$1.Primitive(Label, "a");
    class ActivityPanel extends UI$1.Element {
      getTaskLinks() {
        let taskLinks = [];
        for (let summary of EvalTaskUserSummaryStore.all()) {
          if (summary.userId === this.options.user.id && summary.solved) {
            taskLinks.push(UI$1.createElement(LinkLabel, {
              style: {
                margin: "4px",
                display: "inline-block"
              },
              target: "_blank",
              href: "/contest/archive/task/" + EvalTaskStore.get(summary.evalTaskId).urlName,
              level: Level.INFO
            }, EvalTaskStore.get(summary.evalTaskId).longName));
          }
        }
        return taskLinks;
      }
      getContestLinks() {
        let contestLinks = [];
        for (let contestUser of ContestUserStore.all()) {
          if (contestUser.userId === this.options.user.id) {
            let contest = contestUser.getBaseContest();
            contestLinks.push(UI$1.createElement("p", null, UI$1.createElement(Link, {
              href: "/contest/" + contest.name,
              value: contest.longName
            })));
          }
        }
        return contestLinks;
      }
      render() {
        if (this.options.loaded) {
          //let reputation;
          //if (USER.isSuperUser) {
          //    reputation = [
          //        <h4 style={{"margin-left": "35px"}}>{UI.T("Contribution")}</h4>,
          //        <LargeReputationWidget reputation={this.options.user.reputation} style={{"margin-left": "50px", "margin-bottom": "20px"}}/>
          //    ];
          //}
          let taskLinks = this.getTaskLinks();
          let contestLinks = this.getContestLinks();
          return [UI$1.createElement("h3", null, UI$1.T("Activity")), UI$1.createElement("h4", {
            style: {
              "margin-left": "35px"
            }
          }, UI$1.T("Algorithms")), UI$1.createElement("div", {
            style: {
              "margin-bottom": "20px",
              "display": "inline-flex"
            }
          }, UI$1.createElement("div", {
            style: {
              "width": "40%",
              "margin-left": "50px",
              "display": "inline-block"
            }
          }, UI$1.createElement("span", {
            style: {
              "font-size": "1.3em",
              "margin-bottom": "10px"
            }
          }, UI$1.T("Problems solved"), ": ", taskLinks.length), UI$1.createElement("div", {
            style: {
              "max-height": "200px",
              "overflow-y": "auto",
              "overflow-x": "none",
              "background-color": "#f3f4f6",
              "padding": "5px",
              "font-size": "1.2em"
            }
          }, taskLinks)), UI$1.createElement("div", {
            style: {
              "width": "40%",
              "margin-left": "20px",
              "display": "inline-block"
            }
          }, UI$1.createElement("span", {
            style: {
              "font-size": "1.3em",
              "margin-bottom": "10px"
            }
          }, UI$1.T("Contest history"), ": ", contestLinks.length), UI$1.createElement("div", {
            style: {
              "max-height": "200px",
              "overflow-y": "auto",
              "overflow-x": "none",
              "background-color": "#f3f4f6",
              "padding": "5px",
              "font-size": "1.2em"
            }
          }, contestLinks)))

          //TODO: interviews
          ];
        }
        if (this.options.errorInLoading) {
          return [UI$1.createElement("h3", null, UI$1.T("Activity")), UI$1.createElement("p", {
            style: {
              "marginLeft": "50px"
            }
          }, "Error in loading activity")];
        }
        Ajax.getJSON("/accounts/user_activity/", {
          "userId": this.options.user.id
        }).then(() => this.updateOptions({
          loaded: true
        }), () => this.updateOptions({
          errorInLoading: true
        }));
        return [UI$1.createElement("h3", null, UI$1.T("Activity")), UI$1.createElement("p", {
          style: {
            "marginLeft": "50px"
          }
        }, "Loading...")];
      }
    }
    class ProfilePanel extends Panel {
      render() {
        let infos = [UI$1.createElement("p", null, "Username: ", UI$1.createElement(UserHandle$1, {
          style: {
            display: "inline"
          },
          userId: this.options.user.id
        }))];
        if (this.options.user.name != "") {
          infos.push(UI$1.createElement("p", null, "Name: " + this.options.user.name));
        }
        if (this.options.user.globalRatingRank) {
          infos.push(UI$1.createElement("p", null, " ", UI$1.createElement(Link, {
            href: "/ratings/",
            value: "Rank: " + this.options.user.globalRatingRank
          }), " "));
        } else {
          infos.push(UI$1.createElement("p", null, "Rank: N/A"));
        }
        if (this.options.user.countryId) {
          let country = this.options.user.getCountry();
          infos.push(UI$1.createElement("p", null, " Country: ", country.name, UI$1.createElement(Emoji, {
            style: {
              paddingLeft: "3px"
            },
            title: country.name,
            value: country.getEmojiName(),
            height: "1.6em",
            width: "1.6em"
          })));
        }
        let rating = [];
        if (this.options.user.rating) {
          infos.push(UI$1.createElement("p", null, "Rating: " + this.options.user.rating));
          rating.push(UI$1.createElement("h3", null, "Rating"));
          rating.push(UI$1.createElement(CSAUserRatingSVG, {
            ref: "rating",
            data: this.options.user
          }));
        }
        return [UI$1.createElement("h3", null, "General Info"), UI$1.createElement("div", {
          style: {
            "marginLeft": "50px"
          }
        }, infos), UI$1.createElement(ActivityPanel, {
          user: this.options.user,
          active: false
        }), ...rating];
      }
    }
    class ExternalPanel extends Panel {
      render() {
        let rating = [];
        if (this.options.user.codeforcesRating.result && this.options.user.codeforcesRating.result.length > 0) {
          rating.push(UI$1.createElement("h4", null, "Rating"));
          rating.push(UI$1.createElement(CodeforcesUserRatingSVG, {
            data: this.options.user.codeforcesRating
          }));
        }
        return [UI$1.createElement("h3", null, "Codeforces Profile"), UI$1.createElement("div", {
          style: {
            "marginLeft": "50px"
          }
        }, UI$1.createElement("p", null, "Handle: ", UI$1.createElement("a", {
          href: "http://codeforces.com/profile/" + this.options.user.codeforcesHandle,
          target: "_blank"
        }, this.options.user.codeforcesHandle))), ...rating];
      }
    }
    class UserProfilePanel extends TabArea {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      getSwitcher(tabPanels) {
        return UI$1.createElement(Switcher, {
          ref: "switcherArea",
          style: {
            display: "table"
          },
          lazyRender: this.options.lazyRender
        }, tabPanels);
      }
      setUser(user) {
        this.user = user;
      }
      render() {
        this.setUser(PublicUserStore.get(this.options.userId));
        this.options.children = [UI$1.createElement(ProfilePanel, {
          title: "Profile",
          user: this.user,
          active: true
        })];
        if (this.user.codeforcesRating) {
          this.options.children.push(UI$1.createElement(ExternalPanel, {
            title: "External profiles",
            user: this.user
          }));
        }
        return this.options.children;
      }
      getChildrenToRender() {
        let ownUserInfo = [];
        if (this.options.userId == USER.id) {
          if (!USER.username) {
            ownUserInfo.push(UI$1.createElement("h3", null, "You don't have a username set, please edit your profile"));
          }
          ownUserInfo.push(UI$1.createElement("h4", null, "To edit your account settings, please ", UI$1.createElement(Link, {
            href: "/accounts/settings/general/"
          }, "click here")));
        }
        return [ownUserInfo, super.getChildrenToRender()];
      }
    }

    var _class$i;
    class DeleteWorkspaceModal extends ActionModal {
      getTitle() {
        return "Delete workspace";
      }
      getActionName() {
        return "Delete";
      }
      getBody() {
        return UI$1.createElement("p", null, "Are you sure you want to delete ", this.options.workspace.name, "?");
      }
      action() {
        let request = this.options.workspace.getBaseRequest();
        Ajax.postJSON("/workspace/delete/", request).then(() => {
          WorkspaceStore.applyDeleteEvent({
            type: "delete",
            objectId: request.workspaceId
          });
        });
        this.hide();
      }
    }
    const DeleteWorkspaceButton = ActionModalButton(DeleteWorkspaceModal);
    let WorkspacePreviewPanel = autoredraw(_class$i = class WorkspacePreviewPanel extends CardPanel {
      getTitle() {
        let title, editSpan;
        if (this.isEditing) {
          title = UI$1.createElement(TextInput, {
            ref: "workspaceNameInput",
            value: this.options.workspace.name,
            className: "text-center",
            style: {
              width: "80%",
              marginTop: "-3px",
              marginBottom: "-3px",
              display: "inline-table",
              outline: "none",
              border: 0
            }
          });
          editSpan = UI$1.createElement("span", {
            ref: "settingsButton",
            className: "fa fa-floppy-o",
            style: {
              cursor: "pointer",
              margin: "3px"
            }
          });
        } else {
          title = this.options.title || this.options.workspace.name;
          editSpan = UI$1.createElement("span", {
            ref: "settingsButton",
            className: "fa fa-pencil",
            style: {
              cursor: "pointer",
              margin: "3px",
              color: Theme.Global.COLOR_BACKGROUND
            }
          });
        }
        return [UI$1.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "space-between",
            width: "100%",
            textTransform: "initial"
          }
        }, title, editSpan)];
      }
      getDefaultOptions(options) {
        return {
          size: Size.LARGE
        };
      }
      render() {
        let results = [];
        let workspace_files = this.options.workspace.getFiles();
        if (workspace_files.length > 0) {
          for (let file of this.options.workspace.getFiles()) {
            if (!file.hasTemporaryId()) {
              results.push(UI$1.createElement("p", null, file.name));
            }
          }
        } else {
          results.push(UI$1.createElement("p", null, "No files"));
        }
        let footer = UI$1.createElement("div", null, UI$1.createElement("hr", {
          style: {
            marginTop: 0,
            marginBottom: "5px"
          }
        }), UI$1.createElement("div", null, UI$1.createElement("h5", {
          style: {
            color: "#AAA",
            "white-space": "nowrap",
            textAlign: "left",
            paddingLeft: "12px"
          }
        }, UI$1.T("Updated"), " ", UI$1.createElement(TimePassedSpan, {
          timeStamp: this.options.workspace.getLastUpdate()
        })), UI$1.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "flex-end",
            padding: "5px 10px"
          }
        }, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: UI$1.T("Open"),
          onClick: () => Router.changeURL(["workspace", this.options.workspace.id])
        }), UI$1.createElement(DeleteWorkspaceButton, {
          icon: "trash",
          level: Level.DANGER,
          style: {
            marginLeft: "7px"
          },
          modalOptions: {
            workspace: this.options.workspace
          }
        }))));
        return [UI$1.createElement("div", {
          style: {
            overflow: "auto",
            height: "145px"
          }
        }, results), footer];
      }
      saveChanges() {
        let request = this.options.workspace.getBaseRequest();
        if (this.workspaceNameInput && this.workspaceNameInput.getValue() !== this.options.workspace.name) {
          request.name = this.workspaceNameInput.getValue();
        } else {
          return;
        }
        Ajax.postJSON("/workspace/edit/", request);
      }
      onMount() {
        super.onMount();
        this.attachListener(WorkspaceFileStore, "createOrUpdate", workspaceFile => {
          if (workspaceFile.getWorkspace().id === this.options.workspace.id) {
            this.redraw();
          }
        });

        // Settings button behavior
        // this.settingsButton.addNodeListener("mouseover", () => {
        //     this.settingsButton.setStyle("color", "#0082AD");
        // });
        // this.settingsButton.addNodeListener("mouseleave", () => {
        //     this.settingsButton.setStyle("color", Theme.Global.COLOR_BACKGROUND);
        // });
        this.settingsButton.addClickListener(() => {
          this.isEditing = !this.isEditing;
          if (!this.isEditing) {
            this.saveChanges();
          }
          this.redraw();
          if (this.isEditing) {
            this.workspaceNameInput.node.focus();
            this.workspaceNameInput.node.select();
            this.workspaceNameInput.addNodeListener("keypress", event => {
              if (event.keyCode === 13) {
                // Pressed enter
                this.isEditing = false;
                this.saveChanges();
                this.redraw();
              }
            });
          }
        });
      }
    }) || _class$i;
    class CreateWorkspacePanel extends CardPanel {
      getTitle() {
        return UI$1.createElement("div", {
          style: {
            height: "26px"
          }
        }, UI$1.createElement(TextInput, {
          ref: "workspaceNameInput",
          placeholder: "Title",
          className: "text-center",
          style: {
            height: "100%",
            width: "90%",
            border: "0",
            outline: "none"
          }
        }));
      }
      render() {
        return [UI$1.createElement("div", {
          style: {
            paddingTop: "85px"
          }
        }, UI$1.createElement(Button$1, {
          icon: "plus",
          level: Level.SUCCESS,
          size: Size.LARGE,
          onClick: () => {
            this.createWorkspace();
          }
        }), UI$1.createElement("p", null, UI$1.T("Create new workspace")))];
      }
      getDefaultOptions(options) {
        return {
          size: Size.LARGE,
          headingCentered: true
        };
      }
      createWorkspace() {
        Ajax.postJSON("/workspace/create/", {
          name: this.workspaceNameInput.getValue()
        }).then(data => Router.changeURL(["workspace", data.workspaceId]));
      }
    }
    class WorkspacePanels extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass("text-center");
        attr.setStyle({
          width: "1200px",
          maxWidth: "100%",
          margin: "0 auto",
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "center",
          alignItems: "center"
        });
      }
      render() {
        let panelStyle = {
          width: "350px",
          height: "262px",
          margin: "25px"
        };
        let results = [];
        const userWorkspaces = WorkspaceStore.getUserWorkspaces().sort((a, b) => {
          return b.lastModified - a.lastModified;
        });
        // TODO: this should depend on the user maxWorkspaces
        results.push(UI$1.createElement(CreateWorkspacePanel, {
          style: panelStyle
        }));
        for (let workspace of userWorkspaces) {
          results.push(UI$1.createElement(WorkspacePreviewPanel, {
            key: workspace.id,
            workspace: workspace,
            style: panelStyle
          }));
        }
        return results;
      }
      onMount() {
        this.attachListener(WorkspaceStore, "create", () => {
          this.redraw();
        });
        this.attachListener(WorkspaceStore, "delete", () => {
          this.redraw();
        });
      }
    }
    class WorkspaceManager extends Router {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fullHeight: true
        });
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, WorkspacePanels, [new Route("%s", options => {
          const workspace = WorkspaceStore.get(parseInt(options.args[0]));
          return workspace && UI$1.createElement(WorkspaceIDE, {
            workspace: workspace,
            plugins: PluginTypes.GLOBAL
          });
        })]);
        return this.routes;
      }
    }
    class AnonymousWorkspaceManager extends UI$1.Element {
      getDefaultOptions() {
        return {
          style: {
            height: "100%",
            width: "100%"
          }
        };
      }
      getWorkspace() {
        if (!this.options.workspace) {
          this.options.workspace = WorkspaceStore.createVirtualWorkspace();
        }
        return this.options.workspace;
      }
      render() {
        return this.workspaceIDE || UI$1.createElement("h1", null, UI$1.T("Loading the workspace"), " ", UI$1.createElement("i", {
          className: "fa fa-spinner fa-spin"
        }));
      }
      setURL(urlParts) {
        if (urlParts.length === 2 && urlParts[0] === "fork") {
          this.getCustomRun(urlParts[1]);
        } else {
          this.workspaceIDE = UI$1.createElement(WorkspaceIDE, {
            workspace: this.getWorkspace(),
            plugins: PluginTypes.GLOBAL
          });
          this.redraw();
        }
        Router.changeURL(["workspace"], true);
      }
      getCustomRun(urlHash) {
        Ajax.postJSON("/eval/get_custom_run/", {
          urlHash: urlHash
        }).then(data => {
          let customRun = CustomRunStore.get(data.customRunId);
          this.options.workspace.createFile(customRun.sourceName, customRun.sourceText);
          if (customRun.stdin) {
            this.options.workspace.createFile(".stdin", customRun.stdin);
          }
          this.workspaceIDE = UI$1.createElement(WorkspaceIDE, {
            workspace: this.options.workspace,
            plugins: PluginTypes.GLOBAL
          });
          this.redraw();
        }, error => {
          this.workspaceIDE = UI$1.createElement("h1", null, "Error: ", error.message);
          this.redraw();
        });
      }
    }
    class WorkspaceManagerWrapper extends StateDependentElement(UI$1.Element) {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%"
        });
      }
      renderLoaded() {
        if (USER.isAuthenticated) {
          return UI$1.createElement(WorkspaceManager, {
            ref: "workspaceManager"
          });
        }
        return UI$1.createElement(AnonymousWorkspaceManager, {
          ref: "workspaceManager"
        });
      }
      setURL(urlParts) {
        if (this.workspaceManager) {
          this.workspaceManager.setURL(urlParts);
        } else {
          this.initialUrlParts = urlParts;
        }
      }
      onDelayedMount() {
        this.setURL(this.initialUrlParts);
      }
    }

    class EmailGateway extends StoreObject {
      toString() {
        return this.name;
      }
    }
    class EmailGatewayStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState$1.registerStream("admin-email-manager");
      }
    }
    const EmailGatewayStore = new EmailGatewayStoreClass("EmailGateway", EmailGateway);

    var _dec$e, _class$h;
    class EmailGatewayModal extends ActionModal {
      constructor(options) {
        super(options);
        this.fields = ["name", "host", "port", "useTLS", "username"];
      }
      getBody() {
        const gatewayValues = this.options.gateway || {};
        return [UI$1.createElement(FormField, {
          label: "Name",
          ref: "nameField"
        }, UI$1.createElement(TextInput, {
          value: gatewayValues.name || "",
          ref: "nameInput"
        })), UI$1.createElement(FormField, {
          label: "Host",
          ref: "hostField"
        }, UI$1.createElement(TextInput, {
          value: gatewayValues.host || "",
          ref: "hostInput"
        })), UI$1.createElement(FormField, {
          label: "Port",
          ref: "portField"
        }, UI$1.createElement(NumberInput, {
          value: gatewayValues.port || "",
          ref: "portInput"
        })), UI$1.createElement(FormField, {
          label: "Use TLS",
          ref: "useTLSField"
        }, UI$1.createElement(RawCheckboxInput, {
          value: gatewayValues.useTLS || "",
          ref: "useTLSInput"
        })), UI$1.createElement(FormField, {
          label: "Username",
          ref: "usernameField"
        }, UI$1.createElement(TextInput, {
          value: gatewayValues.username || "",
          ref: "usernameInput"
        })), UI$1.createElement(FormField, {
          label: "Password",
          ref: "passwordField"
        }, UI$1.createElement(PasswordInput, {
          value: gatewayValues.password || "",
          ref: "passwordInput"
        }))];
      }
      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "gateway",
          name: this.nameInput.getValue(),
          host: this.hostInput.getValue(),
          port: this.portInput.getValue(),
          useTLS: this.useTLSInput.getValue(),
          username: this.usernameInput.getValue(),
          password: this.passwordInput.getValue(),
          id: this.options.gateway ? this.options.gateway.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
    }
    class AddEmailGatewayModal extends EmailGatewayModal {
      getTitle() {
        return "New Email gateway";
      }
      getActionName() {
        return "Add Email gateway";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getAjaxAction() {
        return "new";
      }
    }
    class EditEmailGatewayModal extends EmailGatewayModal {
      getTitle() {
        return "Edit Email gateway";
      }
      getActionName() {
        return "Save Email gateway";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getAjaxAction() {
        return "update";
      }
    }
    let GenericConfirmModal$2 = class GenericConfirmModal extends ActionModal {
      constructor(options) {
        super(options);
      }
      getBody() {
        return [UI$1.createElement("div", null, this.getActionText())];
      }
      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "gateway",
          id: this.options.gateway ? this.options.gateway.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
      getActionName() {
        return "Confirm!";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
    };
    class DeleteGatewayConfirmModal extends GenericConfirmModal$2 {
      getActionText() {
        return "Are you sure you want to delete this entry?";
      }
      getAjaxAction() {
        return "delete";
      }
    }
    class EmailGatewayTableRow extends TableRow {
      onMount() {
        super.onMount();
        this.deleteGatewayButton.addClickListener(() => {
          const deleteGatewayConfirmModal = UI$1.createElement(DeleteGatewayConfirmModal, {
            gateway: this.options.entry
          });
          deleteGatewayConfirmModal.show();
        });
        this.editGatewayButton.addClickListener(() => {
          const editGatewayModal = UI$1.createElement(EditEmailGatewayModal, {
            gateway: this.options.entry
          });
          editGatewayModal.show();
        });
      }
    }
    let EmailGatewayTable = (_dec$e = autoredraw(EmailGatewayStore), _dec$e(_class$h = class EmailGatewayTable extends SortableTable {
      getRowClass() {
        return EmailGatewayTableRow;
      }
      getEntries() {
        return EmailGatewayStore.all();
      }
      getDefaultColumns() {
        const cellStyle = {
          textAlign: "center"
        };
        const headerStyle = {
          textAlign: "center",
          width: "16%"
        };
        const deleteButton = gateway => {
          return UI$1.createElement(Button$1, {
            level: Level.DANGER,
            ref: "deleteGatewayButton"
          }, "Delete");
        };
        const editButton = gateway => {
          return UI$1.createElement(Button$1, {
            level: Level.INFO,
            ref: "editGatewayButton"
          }, "Edit");
        };
        return [{
          value: gateway => gateway.name,
          headerName: UI$1.T("Name"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: gateway => gateway.host,
          headerName: UI$1.T("Host"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: gateway => gateway.port,
          headerName: UI$1.T("Port"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: gateway => gateway.useTLS,
          headerName: UI$1.T("Use TLS"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: gateway => gateway.username,
          headerName: UI$1.T("Username"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: deleteButton,
          headerName: "Delete",
          headerStyle: {
            width: "10%"
          }
        }, {
          value: editButton,
          headerName: "Edit",
          headerStyle: {
            width: "10%"
          }
        }];
      }
    }) || _class$h);
    class EmailGatewayWidget extends Panel {
      render() {
        return [UI$1.createElement(EmailGatewayTable, null), UI$1.createElement(Button$1, {
          level: Level.SUCCESS,
          ref: "addGatewayButton"
        }, "Add Gateway")];
      }
      onMount() {
        EmailGatewayStore.registerStreams();
        this.addGatewayButton.addClickListener(() => {
          const addGatewayModal = UI$1.createElement(AddEmailGatewayModal, null);
          addGatewayModal.show();
        });
      }
    }

    class EmailCampaign extends StoreObject {
      toString() {
        return this.name;
      }
    }
    class EmailCampaignStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState$1.registerStream("admin-email-manager");
      }
    }
    const EmailCampaignStore = new EmailCampaignStoreClass("EmailCampaign", EmailCampaign);

    var _dec$d, _class$g;
    let GenericConfirmModal$1 = class GenericConfirmModal extends ActionModal {
      getBody() {
        return [UI$1.createElement("div", null, this.getActionText())];
      }
      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "campaign",
          id: this.options.campaign ? this.options.campaign.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
      getActionName() {
        return "Confirm!";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
    };
    class DeleteCampaignConfirmModal extends GenericConfirmModal$1 {
      getActionText() {
        return "Are you sure you want to delete this entry?";
      }
      getAjaxAction() {
        return "delete";
      }
    }
    class ClearStatusCampaignConfirmModal extends GenericConfirmModal$1 {
      getActionText() {
        return "Are you sure you want to clear all status for this entry?";
      }
      getAjaxAction() {
        return "clearStatus";
      }
    }
    class SendCampaignConfirmModal extends GenericConfirmModal$1 {
      getActionText() {
        return "Are you sure you want to start sending this email campaign?";
      }
      getAjaxAction() {
        return "start";
      }
    }
    class TestSendCampaignModal extends ActionModal {
      constructor(options) {
        super(options);
      }
      getBody() {
        return [UI$1.createElement(FormField, {
          label: "Receiver id",
          ref: "receiverIdField"
        }, UI$1.createElement(TextInput, {
          ref: "receiverIdInput"
        }))];
      }
      action() {
        const request = {
          action: "test",
          objectType: "campaign",
          receiverId: this.receiverIdInput.getValue(),
          id: this.options.campaign ? this.options.campaign.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
      getTitle() {
        return "Campaign send test";
      }
      getActionName() {
        return "Send test emails!";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
    }
    class EmailCampaignModal extends ActionModal {
      constructor(options) {
        super(options);
        this.fields = ["name", "fromAddress", "gatewayId", "isNewsletter"];
      }
      getBody() {
        const campaignValues = this.options.campaign || {};
        return [UI$1.createElement(FormField, {
          label: "Name",
          ref: "nameField"
        }, UI$1.createElement(TextInput, {
          value: campaignValues.name || "",
          ref: "nameInput"
        })), UI$1.createElement(FormField, {
          label: "From address",
          ref: "fromAddressField"
        }, UI$1.createElement(TextInput, {
          value: campaignValues.fromAddress || "",
          ref: "fromAddressInput"
        })), UI$1.createElement(FormField, {
          label: "Gateway",
          ref: "gatewayIdField"
        }, UI$1.createElement(Select, {
          ref: "gatewaySelect",
          options: EmailGatewayStore.all(),
          selected: EmailGatewayStore.get(campaignValues.gatewayId)
        })), UI$1.createElement(FormField, {
          label: "Is newsletter",
          ref: "isNewsletterField"
        }, UI$1.createElement(RawCheckboxInput, {
          value: campaignValues.isNewsletter || "",
          ref: "isNewsletterInput"
        }))];
      }
      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "campaign",
          name: this.nameInput.getValue(),
          fromAddress: this.fromAddressInput.getValue(),
          gatewayId: this.gatewaySelect.get().id,
          isNewsletter: this.isNewsletterInput.getValue(),
          id: this.options.campaign ? this.options.campaign.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
    }
    class AddEmailCampaignModal extends EmailCampaignModal {
      getTitle() {
        return "New Email campaign";
      }
      getActionName() {
        return "Add Email campaign";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getAjaxAction() {
        return "new";
      }
    }
    class EditEmailCampaignModal extends EmailCampaignModal {
      getTitle() {
        return "Edit Email campaign";
      }
      getActionName() {
        return "Save Email campaign";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getAjaxAction() {
        return "update";
      }
    }
    class EmailCampaignTableRow extends TableRow {
      onMount() {
        super.onMount();
        this.deleteCampaignButton.addClickListener(() => {
          const deleteCampaignConfirmModal = UI$1.createElement(DeleteCampaignConfirmModal, {
            campaign: this.options.entry
          });
          deleteCampaignConfirmModal.show();
        });
        this.editCampaignButton.addClickListener(() => {
          const editCampaignModal = UI$1.createElement(EditEmailCampaignModal, {
            campaign: this.options.entry
          });
          editCampaignModal.show();
        });
        this.testSendCampaignButton.addClickListener(() => {
          const testSendCampaignModal = UI$1.createElement(TestSendCampaignModal, {
            campaign: this.options.entry
          });
          testSendCampaignModal.show();
        });
        this.sendCampaignButton.addClickListener(() => {
          const sendCampaignConfirmModal = UI$1.createElement(SendCampaignConfirmModal, {
            campaign: this.options.entry
          });
          sendCampaignConfirmModal.show();
        });
        this.clearStatusCampaignButton.addClickListener(() => {
          const clearStatusCampaignConfirmModal = UI$1.createElement(ClearStatusCampaignConfirmModal, {
            campaign: this.options.entry
          });
          clearStatusCampaignConfirmModal.show();
        });
      }
    }
    let EmailCampaignTable = (_dec$d = autoredraw(EmailCampaignStore), _dec$d(_class$g = class EmailCampaignTable extends SortableTable {
      getRowClass() {
        return EmailCampaignTableRow;
      }
      getEntries() {
        return EmailCampaignStore.all();
      }
      getDefaultColumns() {
        const cellStyle = {
          textAlign: "center"
        };
        const headerStyle = {
          textAlign: "center",
          width: "20%"
        };
        const deleteButton = campaign => {
          return UI$1.createElement(Button$1, {
            level: Level.DANGER,
            ref: "deleteCampaignButton"
          }, "Delete");
        };
        const editButton = campaign => {
          return UI$1.createElement(Button$1, {
            level: Level.INFO,
            ref: "editCampaignButton"
          }, "Edit");
        };
        const testSendButton = campaign => {
          return UI$1.createElement(Button$1, {
            level: Level.INFO,
            ref: "testSendCampaignButton"
          }, "Test Send");
        };
        const sendButton = campaign => {
          return UI$1.createElement(Button$1, {
            level: Level.INFO,
            ref: "sendCampaignButton"
          }, "Send");
        };
        const clearStatusButton = campaign => {
          return UI$1.createElement(Button$1, {
            level: Level.DANGER,
            ref: "clearStatusCampaignButton"
          }, "Clear Status");
        };
        return [{
          value: campaign => campaign.name,
          headerName: UI$1.T("Name"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: campaign => campaign.fromAddress,
          headerName: UI$1.T("From Address"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: campaign => campaign.isNewsletter,
          headerName: UI$1.T("Is Newsletter"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: campaign => campaign.gatewayId && EmailGatewayStore.get(campaign.gatewayId).name || "default",
          headerName: UI$1.T("Gateway"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: campaign => campaign.emailsRead,
          headerName: UI$1.T("Emails Read"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: campaign => campaign.emailsSent,
          headerName: UI$1.T("Emails Sent"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: deleteButton,
          headerName: "Delete",
          headerStyle: {
            width: "10%"
          }
        }, {
          value: editButton,
          headerName: "Edit",
          headerStyle: {
            width: "10%"
          }
        }, {
          value: testSendButton,
          headerName: "Test Send",
          headerStyle: {
            width: "10%"
          }
        }, {
          value: sendButton,
          headerName: "Send",
          headerStyle: {
            width: "10%"
          }
        }, {
          value: clearStatusButton,
          headerName: "Clear Status",
          headerStyle: {
            width: "10%"
          }
        }];
      }
    }) || _class$g);
    class EmailCampaignWidget extends Panel {
      render() {
        return [UI$1.createElement(EmailCampaignTable, null), UI$1.createElement(Button$1, {
          level: Level.SUCCESS,
          ref: "addCampaignButton"
        }, "Add Campaign")];
      }
      onMount() {
        super.onMount();
        EmailGatewayStore.registerStreams();
        EmailCampaignStore.registerStreams();
        this.addCampaignButton.addClickListener(() => {
          const addCampaignModal = UI$1.createElement(AddEmailCampaignModal, {
            campaign: this.options.entry
          });
          addCampaignModal.show();
        });
      }
    }

    class EmailTemplate extends StoreObject {}
    class EmailTemplateStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState$1.registerStream("admin-email-manager");
      }
    }
    const EmailTemplateStore = new EmailTemplateStoreClass("EmailTemplate", EmailTemplate);

    var _dec$c, _class$f;
    class EmailTemplateModal extends ActionModal {
      constructor(options) {
        super(options);
        this.fields = ["subject", "html", "campaignId", "languageId", "gatewayId"];
      }
      getModalWindowStyle() {
        return Object.assign({}, super.getModalWindowStyle(), {
          height: "90vh",
          width: "70vw",
          display: "flex",
          flexDirection: "column"
        });
      }
      render() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.header
        }, this.getHeader()), this.getBody() ? UI$1.createElement("div", {
          className: this.styleSheet.body,
          style: {
            flex: "1",
            display: "flex",
            flexDirection: "column"
          }
        }, this.getBody()) : null, this.getFooter() ? UI$1.createElement("div", {
          className: this.styleSheet.footer
        }, this.getFooter()) : null];
      }
      getBody() {
        const templateValues = this.options.template || {};
        return [UI$1.createElement(FormField, {
          label: "Subject",
          ref: "subjectField",
          style: {
            margin: "initial"
          }
        }, UI$1.createElement(TextInput, {
          value: templateValues.subject || "",
          ref: "subjectInput"
        })), UI$1.createElement(FormField, {
          label: "Campaign",
          ref: "campaignIdField",
          style: {
            margin: "initial"
          }
        }, UI$1.createElement(Select, {
          ref: "campaignSelect",
          options: EmailCampaignStore.all(),
          selected: EmailCampaignStore.get(templateValues.campaignId)
        })), UI$1.createElement(FormField, {
          label: "Language",
          ref: "languageIdField",
          style: {
            margin: "initial"
          }
        }, UI$1.createElement(Select, {
          ref: "languageSelect",
          options: Language.all(),
          selected: Language.get(templateValues.languageId)
        })), UI$1.createElement(FormField, {
          label: "Gateway",
          ref: "gatewayIdField",
          style: {
            margin: "initial"
          }
        }, UI$1.createElement(Select, {
          ref: "gatewaySelect",
          options: EmailGatewayStore.all(),
          selected: EmailGatewayStore.get(templateValues.gatewayId)
        })), UI$1.createElement(FormField, {
          label: "Html",
          ref: "htmlField",
          inline: false,
          style: {
            margin: "initial"
          }
        }), UI$1.createElement(SectionDivider, {
          orientation: Orientation$1.HORIZONTAL,
          style: {
            width: "100%",
            flex: "1"
          }
        }, UI$1.createElement("div", {
          style: {
            width: "50%",
            height: "100%",
            overflow: "hidden"
          }
        }, UI$1.createElement(TextArea, {
          value: templateValues.html || "",
          ref: "htmlInput",
          style: {
            height: "100%",
            width: "100%",
            resize: "none"
          }
        })), UI$1.createElement("div", {
          style: {
            width: "50%",
            height: "100%",
            overflow: "auto",
            position: "relative"
          }
        }, UI$1.createElement(Panel, {
          ref: "htmlRenderer",
          style: {
            height: "100%",
            position: "absolute"
          }
        })))];
      }
      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "template",
          subject: this.subjectInput.getValue(),
          html: this.htmlInput.getValue(),
          campaignId: this.campaignSelect.get().id,
          languageId: this.languageSelect.get().id,
          gatewayId: this.gatewaySelect.get().id,
          id: this.options.template ? this.options.template.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
      onMount() {
        this.htmlRenderer.node.innerHTML = this.htmlInput.getValue();
        this.htmlInput.addNodeListener("keyup", () => {
          this.htmlRenderer.node.innerHTML = this.htmlInput.getValue();
        });
        this.htmlInput.addNodeListener("change", () => {
          this.htmlRenderer.node.innerHTML = this.htmlInput.getValue();
        });
      }
    }
    class AddEmailTemplateModal extends EmailTemplateModal {
      getTitle() {
        return "New Email template";
      }
      getActionName() {
        return "Add Email template";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getAjaxAction() {
        return "new";
      }
    }
    class EditEmailTemplateModal extends EmailTemplateModal {
      getTitle() {
        return "Edit Email template";
      }
      getActionName() {
        return "Save Email template";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      getAjaxAction() {
        return "update";
      }
    }
    class GenericConfirmModal extends ActionModal {
      constructor(options) {
        super(options);
      }
      getBody() {
        return [UI$1.createElement("div", null, this.getActionText())];
      }
      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "template",
          id: this.options.template ? this.options.template.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }
          this.messageArea.showMessage(error.message, "red");
        });
      }
      getActionName() {
        return "Confirm!";
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
    }
    class DeleteTemplateConfirmModal extends GenericConfirmModal {
      getActionText() {
        return "Are you sure you want to delete this entry?";
      }
      getAjaxAction() {
        return "delete";
      }
    }
    class EmailTemplateTableRow extends TableRow {
      onMount() {
        super.onMount();
        this.deleteTemplateButton.addClickListener(() => {
          const deleteTemplateConfirmModal = UI$1.createElement(DeleteTemplateConfirmModal, {
            template: this.options.entry
          });
          deleteTemplateConfirmModal.show();
        });
        this.editTemplateButton.addClickListener(() => {
          const editTemplateModal = UI$1.createElement(EditEmailTemplateModal, {
            template: this.options.entry
          });
          editTemplateModal.show();
        });
      }
    }
    let EmailTemplateTable = (_dec$c = autoredraw(EmailTemplateStore), _dec$c(_class$f = class EmailTemplateTable extends SortableTable {
      getRowClass() {
        return EmailTemplateTableRow;
      }
      getEntries() {
        return EmailTemplateStore.all();
      }
      getDefaultColumns() {
        const cellStyle = {
          textAlign: "center"
        };
        const headerStyle = {
          textAlign: "center",
          width: "20%"
        };
        const deleteButton = template => {
          return UI$1.createElement(Button$1, {
            level: Level.DANGER,
            ref: "deleteTemplateButton"
          }, "Delete");
        };
        const editButton = template => {
          return UI$1.createElement(Button$1, {
            level: Level.INFO,
            ref: "editTemplateButton"
          }, "Edit");
        };
        return [{
          value: template => template.subject,
          headerName: UI$1.T("Subject"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: template => EmailCampaignStore.get(template.campaignId).name,
          headerName: UI$1.T("Campaign"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: template => Language.get(template.languageId).name,
          headerName: UI$1.T("Language"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: template => EmailGatewayStore.get(template.gatewayId).name,
          headerName: UI$1.T("Gateway"),
          cellStyle: cellStyle,
          headerStyle: headerStyle
        }, {
          value: deleteButton,
          headerName: "Delete",
          headerStyle: {
            width: "10%"
          }
        }, {
          value: editButton,
          headerName: "Edit",
          headerStyle: {
            width: "10%"
          }
        }];
      }
    }) || _class$f);
    class EmailTemplateWidget extends Panel {
      render() {
        return [UI$1.createElement(EmailTemplateTable, null), UI$1.createElement(Button$1, {
          level: Level.SUCCESS,
          ref: "addTemplateButton"
        }, "Add Template")];
      }
      onMount() {
        super.onMount();
        EmailGatewayStore.registerStreams();
        EmailCampaignStore.registerStreams();
        EmailTemplateStore.registerStreams();
        this.addTemplateButton.addClickListener(() => {
          const addTemplateModal = UI$1.createElement(AddEmailTemplateModal, {
            template: this.options.entry
          });
          addTemplateModal.show();
        });
      }
    }

    class EmailManager extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      getUrlPrefix(urlPart) {
        let url = "/email/manager/";
        if (urlPart) {
          url += urlPart + "/";
        }
        return url;
      }
      setURL(urlParts) {
        if (this.tabArea) {
          this.showUrlTab(urlParts[0] || "campaigns");
        } else {
          this.initialUrlParts = urlParts;
        }
      }
      render() {
        return [UI$1.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, UI$1.createElement(EmailCampaignWidget, {
          ref: "campaignsWidget",
          tabHref: this.getUrlPrefix("campaigns"),
          title: "Campaigns",
          active: true
        }), UI$1.createElement(EmailTemplateWidget, {
          ref: "templatesWidget",
          tabHref: this.getUrlPrefix("templates"),
          title: "Templates"
        }), UI$1.createElement(EmailGatewayWidget, {
          ref: "gatewaysWidget",
          tabHref: this.getUrlPrefix("gateways"),
          title: "Gateways"
        }))];
      }
      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlPars;
      }
      showUrlTab(urlPart) {
        if (this[urlPart + "Widget"]) {
          this[urlPart + "Widget"].dispatch("show");
        } else {
          this.campaignsWidget.dispatch("show");
        }
      }
    }

    class StorageMeta {
      constructor(usedSpace, fileCount) {
        this.usedSpace = usedSpace;
        this.fileCount = fileCount;
      }
      getUsedSpace() {
        return this.usedSpace;
      }
      getFileCount() {
        return this.fileCount;
      }
    }

    class PublicStorageFile extends StoreObject {
      getStorageServer() {
        return StorageServerStore.get(this.storageServerId);
      }
      getPublicURL() {
        let storageServer = this.getStorageServer();
        return storageServer.domain + storageServer.urlBasePath + this.serverPath;
      }
    }
    class PublicStorageFileStoreClass extends GenericObjectStore {
      getStorageMeta() {
        let usedSpace = 0;
        let files = this.all();
        for (let file of files) {
          usedSpace += file.size;
        }
        return new StorageMeta(usedSpace, files.length);
      }
      getAllIds() {
        let files = this.all();
        let ids = [];
        for (let file of files) {
          ids.push(file.id);
        }
        return ids;
      }
    }
    const PublicStorageFileStore = new PublicStorageFileStoreClass("PublicStorageFile", PublicStorageFile);
    class StorageServer extends StoreObject {}
    const StorageServerStore = new GenericObjectStore("StorageServer", StorageServer);

    class StorageLimits {
      static userFileMaxCount() {
        if (!USER.isAuthenticated) {
          return 0;
        }
        if (USER.isSuperUser) {
          return -1;
        }
        return 512;
      }
      static userUploadMaxCount() {
        if (!USER.isAuthenticated) {
          return 0;
        }
        if (USER.isSuperUser) {
          return -1;
        }
        return 16;
      }
      static userFileMaxSize() {
        if (!USER.isAuthenticated) {
          return 0;
        }
        if (USER.isSuperUser) {
          return -1;
        }
        return 128 * 1024 * 1024;
      }
      static userTotalMaxSize() {
        if (!USER.isAuthenticated) {
          return 0;
        }
        if (USER.isSuperUser) {
          return 1024 * 1024 * 1024;
        }
        return 256 * 1024 * 1024;
      }
      static validateFileMaxCount(storageMeta, fileCount) {
        let maxFileCount = StorageLimits.userFileMaxCount();
        if (maxFileCount == -1) {
          return true;
        }
        return storageMeta.getFileCount() + fileCount <= maxFileCount;
      }
      static validateUploadMaxCount(fileCount) {
        let uploadMaxCount = StorageLimits.userUploadMaxCount();
        if (uploadMaxCount == -1) {
          return true;
        }
        return fileCount <= uploadMaxCount;
      }
      static validateFileMaxSize(fileSize) {
        let fileMaxSize = StorageLimits.userFileMaxSize();
        if (fileMaxSize == -1) {
          return true;
        }
        return fileSize <= fileMaxSize;
      }
      static validateTotalMaxSize(storageMeta, totalSize) {
        let totalMaxSize = StorageLimits.userTotalMaxSize();
        if (totalMaxSize == -1) {
          return true;
        }
        return storageMeta.getUsedSpace() + totalSize <= totalMaxSize;
      }
    }

    class DeleteFileModal extends ActionModal {
      getActionName() {
        return "Delete file";
      }
      getBody() {
        return "Delete " + this.options.file.name + "?";
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "deleteFileButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteFile();
          },
          statusOptions: ["Delete file", {
            icon: "spinner fa-spin",
            label: " deleting file ..."
          }, "Delete file", "Failed"]
        }))];
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
      deleteFile() {
        const request = {
          ids: [this.options.file.id]
        };
        this.deleteFileButton.postJSON("/storage/delete_request/", request).then(() => this.hide(), error => this.messageArea.showMessage(error.message, "red"));
      }
    }
    class UploadFilesModal extends ActionModal {
      getActionName() {
        return "Upload files";
      }
      getBody() {
        return [UI$1.createElement("div", null, UI$1.createElement(FileInput, {
          className: "pull-left",
          ref: "fileInput",
          multipleFiles: true
        })), UI$1.createElement("br", null), UI$1.createElement(ProgressBar, {
          level: Level.SUCCESS,
          ref: "progress"
        }, "Progress")];
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(Button$1, {
          level: Level.SUCCESS,
          label: "Upload",
          onClick: () => this.upload()
        }))];
      }
      onMount() {
        super.onMount();
        this.fileInput.addChangeListener(() => {
          this.messageArea.clear();
          this.progress.set(0);
        });
      }
      upload() {
        let files = this.fileInput.getFiles();
        if (files.length === 0) {
          this.messageArea.showMessage("Please select some files!", "red");
          return;
        }
        if (!StorageLimits.validateUploadMaxCount(files.length)) {
          this.messageArea.showMessage("You cannot upload more than " + StorageLimits.userUploadMaxCount() + " files at once!", "red");
          return;
        }
        let storageMeta = PublicStorageFileStore.getStorageMeta();
        if (!StorageLimits.validateFileMaxCount(storageMeta, files.length)) {
          this.messageArea.showMessage("Completion of this request will exceed the maximum number of total files you can " + "store (" + StorageLimits.userFileMaxCount() + ").", "red");
          return;
        }
        let totalSize = 0;
        let formData = new FormData();
        for (const file of files) {
          if (!StorageLimits.validateFileMaxSize(file.size)) {
            this.messageArea.showMessage("File " + file.name + " is too big (" + formatBytes(file.size) + " while maximum size per file is " + formatBytes(StorageLimits.userFileMaxSize()) + ").", "red");
            return;
          }
          formData.append(file.name, file);
          totalSize += file.size;
        }
        if (!StorageLimits.validateTotalMaxSize(storageMeta, totalSize)) {
          this.messageArea.showMessage("Completion of this request will exceed the maximum total size you can store (" + formatBytes(StorageLimits.userTotalMaxSize()) + ").", "red");
          return;
        }
        const fileUploadRequest = Ajax.post("/storage/upload_request/", {
          dataType: "json",
          data: formData,
          cache: false,
          processData: false,
          contentType: false
        });
        fileUploadRequest.then(data => this.hide(), error => {
          this.messageArea.showMessage("Error in uploading files: status:" + error.message, "red");
        });
        fileUploadRequest.xhr.upload.addEventListener("progress", event => console.warn("E", event));
        fileUploadRequest.addProgressListener(event => {
          console.warn("Progress", event);
          this.progressHandling(event);
        });
      }
      hide() {
        this.messageArea.clear();
        this.progress.set(0);
        super.hide();
      }
      progressHandling(event) {
        if (event.lengthComputable) {
          this.progress.set(event.loaded / event.total);
        }
      }
    }
    class RenameFileModal extends ActionModal {
      getActionName() {
        return "Rename file";
      }
      getBody() {
        return [UI$1.createElement(UI$1.TextElement, {
          ref: "text",
          value: "Choose your new file name:"
        }), UI$1.createElement(TextInput, {
          ref: "nameInput",
          value: this.options.file.name
        })];
      }
      getFooter() {
        return [UI$1.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI$1.createElement(ButtonGroup, null, UI$1.createElement(Button$1, {
          label: "Close",
          onClick: () => this.hide()
        }), UI$1.createElement(AjaxButton, {
          ref: "renameFileButton",
          level: Level.SUCCESS,
          onClick: () => {
            this.renameFile();
          },
          statusOptions: ["Rename file", {
            icon: "spinner fa-spin",
            label: " renaming file ..."
          }, "Rename file", "Failed"]
        }))];
      }
      hide() {
        this.messageArea.clear();
        super.hide();
      }
      renameFile() {
        const request = {
          id: this.options.file.id,
          newName: this.nameInput.getValue()
        };
        this.renameFileButton.postJSON("/storage/rename_request/", request).then(() => this.hide(), error => this.messageArea.showMessage(error.message, "red"));
      }
    }

    var _dec$b, _class$e;
    class FileTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }
      resetColumnSortingOrder() {
        const {
          columns
        } = this.options;
        this.columnSortingOrder = [columns[4], columns[3], columns[0], columns[2], columns[1]];
      }
      addFile(file) {
        this.options.files.push(file);
        this.redraw();
      }
      getDefaultColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let headerStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        return [{
          value: file => file.name,
          rawValue: file => file.name,
          headerName: "Filename",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => UI$1.createElement(Link, {
            href: file.getPublicURL(),
            target: "_blank_",
            value: file.getPublicURL()
          }),
          rawValue: file => file.getPublicURL(),
          headerName: "URL",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => formatBytes(file.size),
          rawValue: file => file.size,
          headerName: "Size",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => StemDate.unix(file.dateModified).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: file => file.dateModified,
          sortDescending: true,
          headerName: "Date modified",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => StemDate.unix(file.dateCreated).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: file => file.dateCreated,
          sortDescending: true,
          headerName: "Date created",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => UI$1.createElement(Button$1, {
            level: Level.SUCCESS,
            label: "Rename",
            onClick: () => RenameFileModal.show({
              file
            })
          }),
          headerName: "Rename",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => UI$1.createElement(Button$1, {
            level: Level.DANGER,
            label: "Delete",
            onClick: () => DeleteFileModal.show({
              file
            })
          }),
          headerName: "Delete",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }];
      }
      getEntries() {
        return this.sortEntries(this.options.files);
      }
    }
    let StorageManager = (_dec$b = autoredraw(PublicStorageFileStore), _dec$b(_class$e = class StorageManager extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle("margin", "20px 10%");
      }
      getDefaultOptions() {
        return {
          title: "File manager"
        };
      }
      render() {
        const files = PublicStorageFileStore.all();
        return [UI$1.createElement("div", {
          className: "pull-left"
        }, UI$1.createElement("h4", null, UI$1.createElement("strong", null, this.options.title))), UI$1.createElement("div", {
          className: "pull-right"
        }, UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Upload files",
          onClick: () => UploadFilesModal.show(),
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          }
        })), files.length > 0 ? UI$1.createElement(FileTable, {
          files: files
        }) : UI$1.createElement("h3", null, "No files uploaded")];
      }
    }) || _class$e);

    class AdminPanel extends CardPanel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes();
        attr.setStyle("margin", "20px 10%");
      }
      getDefaultOptions() {
        return {
          title: "Admin Panel",
          level: Level.INFO,
          style: {
            margin: "10px"
          }
        };
      }
      render() {
        return UI$1.createElement("table", {
          className: "table"
        }, UI$1.createElement("tbody", null, UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/manage/icarus/#machines",
          value: "Icarus"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/manage/icarus/#machine_logging",
          value: "Machine logging"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/manage/icarus/#website_logging",
          value: "Website logging"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/analytics",
          value: "Analytics"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/manage/users",
          value: "Users"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/manage/charts",
          value: "Charts"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/email/manager",
          value: "Email Manager"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/storage/manager",
          value: "Storage Manager"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/manage/translation",
          value: "Translation"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/real_ratings",
          value: "Real ratings"
        }))), UI$1.createElement("tr", null, UI$1.createElement("td", null, UI$1.createElement(Link, {
          href: "/private-archives",
          value: "Private Archives"
        })))));
      }
    }

    class MachineInstance extends StoreObject {
      logMessage(event) {
        this.dispatch("logMessage", event);
      }
      applyEvent(event) {
        if (event.type === "logMessage") {
          // TODO save messages in store object
          return;
        }
        if (event.type === "serviceStatusUpdate") {
          this.serviceUpdate(event.serviceStatus);
          return;
        }
        super.applyEvent(event);
      }
      serviceStop(status) {
        this.updateServiceStatus(status);
        this.services[status.service].current.meta.status = MachineInstance.statusType.OFFLINE;
        this.setServiceOfflineTimeout(status.service, 1000);
      }
      serviceUpdate(status) {
        const {
          lifecycle
        } = status;
        if (lifecycle === "stop") {
          this.serviceStop(status);
          return;
        }
        this.updateServiceStatus(status);
        this.services[status.service].current.meta.status = lifecycle === "start" ? MachineInstance.statusType.NEW : MachineInstance.statusType.ONLINE;
        this.setServiceWarningTimeout(status.service, 1.5);
        this.setServiceDangerTimeout(status.service, 3.5);
        this.clearServiceOfflineTimeout(status.service);
      }
      updateServiceStatus(status) {
        // TODO: save in a rolling window to enable graph data
        if (!this.hasOwnProperty("services")) {
          this.services = {};
        }
        if (!this.services.hasOwnProperty(status.service)) {
          this.services[status.service] = {};
        }
        if (!this.services[status.service].hasOwnProperty("current")) {
          this.services[status.service].current = {};
        }
        if (!this.services[status.service].current.hasOwnProperty("meta")) {
          this.services[status.service].current.meta = {};
        }
        this.services[status.service].current.data = status;
      }
      clearServiceWarningTimeout(serviceName) {
        if (this.services[serviceName].current.meta.warningTimeout) {
          clearTimeout(this.services[serviceName].current.meta.warningTimeout);
          this.services[serviceName].current.meta.warningTimeout = null;
        }
      }
      clearServiceDangerTimeout(serviceName) {
        if (this.services[serviceName].current.meta.dangerTimeout) {
          clearTimeout(this.services[serviceName].current.meta.dangerTimeout);
          this.services[serviceName].current.meta.dangerTimeout = null;
        }
      }
      clearServiceOfflineTimeout(serviceName) {
        if (this.services[serviceName].current.meta.offlineTimeout) {
          clearTimeout(this.services[serviceName].current.meta.offlineTimeout);
          this.services[serviceName].current.meta.offlineTimeout = null;
        }
      }
      serviceWarning(serviceName) {
        this.services[serviceName].current.meta.status = MachineInstance.statusType.WARNING;
      }
      serviceDanger(serviceName) {
        this.services[serviceName].current.meta.status = MachineInstance.statusType.DANGER;
      }
      serviceOffline(serviceName) {
        delete this.services[serviceName];
      }
      setServiceWarningTimeout(serviceName, factor) {
        this.services[serviceName].current.meta.warningThreshold = this.services[serviceName].current.data.updateInterval * factor;
        this.clearServiceWarningTimeout(serviceName);
        this.services[serviceName].current.meta.warningTimeout = setTimeout(() => {
          this.serviceWarning(serviceName);
          this.services[serviceName].current.meta.warningTimeout = null;
        }, this.services[serviceName].current.meta.warningThreshold);
      }
      setServiceDangerTimeout(serviceName, factor) {
        this.services[serviceName].current.meta.dangerThreshold = this.services[serviceName].current.data.updateInterval * factor;
        this.clearServiceDangerTimeout(serviceName);
        this.services[serviceName].current.meta.dangerTimeout = setTimeout(() => {
          this.serviceDanger(serviceName);
          this.services[serviceName].current.meta.dangerTimeout = null;
        }, this.services[serviceName].current.meta.dangerThreshold);
      }
      setServiceOfflineTimeout(serviceName, timeout) {
        this.clearServiceWarningTimeout(serviceName);
        this.clearServiceDangerTimeout(serviceName);
        this.services[serviceName].current.meta.offlineThreshold = timeout;
        this.clearServiceOfflineTimeout(serviceName);
        this.services[serviceName].current.meta.offlineTimeout = setTimeout(() => {
          this.serviceOffline(serviceName);
        }, this.services[serviceName].current.meta.offlineThreshold);
      }
    }
    MachineInstance.statusType = {
      NEW: 1,
      ONLINE: 2,
      OFFLINE: 3,
      WARNING: 4,
      DANGER: 5
    };
    class MachineInstanceStoreClass extends GenericObjectStore {
      applyEvent(event) {
        if (event.type == "logMessage") {
          this.dispatch("logMessage", event);
        }
        super.applyEvent(event);
      }
      registerStreams() {
        GlobalState$1.registerStream("machine_status");
        GlobalState$1.registerStream("service_status");
        GlobalState$1.registerStream("machine_log");
        GlobalState$1.registerStream("meta-uranus-linode-a");
      }
    }
    const MachineInstanceStore = new MachineInstanceStoreClass("MachineInstance", MachineInstance);

    var _class$d;
    let dontAsk = false;
    class ConfirmActionModal extends ActionModal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          closeName: "No",
          level: Level.DANGER,
          actionName: "Yes"
        });
      }
      getActionName() {
        return "Confirm action";
      }
      getBody() {
        return UI$1.createElement(SectionDivider, {
          ref: "divider",
          orientation: Orientation$1.VERTICAL,
          style: {
            height: "100%",
            width: "100%",
            overflow: "hidden"
          }
        }, UI$1.createElement("div", null, UI$1.createElement(UI$1.TextElement, {
          ref: "text",
          value: "Are you sure you want to complete this action?"
        }), UI$1.createElement("br", null), UI$1.createElement(UI$1.TextElement, {
          ref: "customText",
          value: this.options.text || ""
        })), UI$1.createElement("div", null, UI$1.createElement(FormField, {
          labelWidth: "92%",
          contentWidth: "3%",
          contentFirst: true,
          label: "I am not high and I am not drunk, please don't bother me for the next 2 minutes!"
        }, UI$1.createElement(RawCheckboxInput, {
          ref: "rememberDecisionCheckbox",
          style: {
            display: "inline-block",
            marginTop: "11px"
          }
        }))));
      }
      action() {
        if (this.rememberDecisionCheckbox.getValue()) {
          dontAsk = true;
          setTimeout(() => {
            dontAsk = false;
          }, 2 * 60 * 1000);
        }
        this.options.callbackAction();
        this.hide();
      }
      static start(text, callback) {
        if (dontAsk) {
          callback();
          return;
        }
        this.show({
          callbackAction: callback,
          text: text
        });
      }
    }
    class ConfirmDestroyModal extends ActionModal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          closeName: "No",
          level: Level.DANGER,
          actionName: "Confirm destroy"
        });
      }
      action() {
        this.options.callbackAction();
        this.hide();
      }
      getBody() {
        return UI$1.createElement("div", null, UI$1.createElement(UI$1.TextElement, {
          value: "Are you sure you want to complete this action?"
        }), UI$1.createElement("br", null), UI$1.createElement(UI$1.TextElement, {
          value: this.options.text || ""
        }));
      }
      static start(text, callback) {
        if (dontAsk) {
          text += ". I know you are sober, but this is a serious action and you have to be fully aware!";
        }
        this.show({
          callbackAction: callback,
          text: text
        });
      }
    }
    let MachineInstanceCollapsibleRow = autoredraw(_class$d = class MachineInstanceCollapsibleRow extends CollapsibleTableRow {
      setOptions(options) {
        super.setOptions(options);
        if (options.entry) {
          this.machine = options.entry;
        }
      }
      onMount() {
        super.onMount();
        const simpleActions = [{
          name: "Boot",
          commandName: "boot"
        }, {
          name: "Shutdown",
          commandName: "shutdown"
        }, {
          name: "Reboot",
          commandName: "reboot"
        }, {
          name: "Clone",
          commandName: "clone"
        }, {
          name: "Update",
          commandName: "update"
        }];
        for (const action of simpleActions) {
          this["machine" + action.name + "Button"].addClickListener(() => this.sendCommand(action.commandName));
        }
        this.machineDestroyButton.addClickListener(() => {
          ConfirmDestroyModal.start(`Destroy machine with id ${this.machine.id} (${this.machine.label})`, () => this.sendCommand("destroy"));
        });
        if (this.machine.scripts && this.machine.scripts.length > 0) {
          this.runCustomScriptButton.addClickListener(() => {
            ConfirmActionModal.start(`Run script "${this.customScriptSelect.get()}" on machine ${this.machine.id}`, () => this.sendCommand("script", this.customScriptSelect.get()));
          });
        }
        this.machine.addEventListener("logMessage", event => {
          this.machineLogsHighlighter.append(event.message);
        });
      }
      redraw() {
        if (!super.redraw()) {
          return false;
        }
        if (this.scriptChoice) {
          this.setScriptChoice(this.scriptChoice);
        }
        return true;
      }
      renderCollapsible() {
        const publicIPAddress = this.machine.publicIPAddress || "N/A";
        const privateIPAddress = this.machine.privateIPAddress || "N/A";
        return [UI$1.createElement("div", {
          ref: "machineInfo"
        }, UI$1.createElement("p", null, "RAM: ", this.machine.ramSize, " MB"), UI$1.createElement("p", null, "Disk: ", this.machine.diskSize, " MB"), UI$1.createElement("p", null, "Public IP address: ", publicIPAddress), UI$1.createElement("p", null, "Private IP address: ", privateIPAddress), UI$1.createElement("p", null, "Date created: ", this.machine.dateCreated)), UI$1.createElement(CodeEditor, {
          ref: "machineLogsHighlighter",
          maxLines: 30,
          value: this.machine.logs
        })];
      }
      sendCommand(command, scriptName) {
        MachineInstanceCollapsibleRow.sendCommand([this.machine.id], command, scriptName);
      }
      static sendCommand(ids, command, scriptName) {
        let request = {
          action: command,
          ids: ids
        };
        if (command === "script") {
          request.scriptName = scriptName;
        }
        Ajax.postJSON("/manage/control_machine/", request);
      }
    }) || _class$d;
    class MachineGroupTable extends CollapsibleTable {
      onMount() {
        super.onMount();
      }
      getRowClass() {
        return MachineInstanceCollapsibleRow;
      }
      static renderMachineServices(machine) {
        let services = [];
        if (machine.hasOwnProperty("services")) {
          services = Object.keys(machine.services);
        }
        if (services.length === 0) {
          return UI$1.createElement(Label, {
            level: Level.DANGER
          }, "No service running");
        }
        let excludeFromTooltip = new Set(["service", "machineId", "timestamp", "clientTimestamp"]);
        let serviceSpans = [];
        for (let serviceName of services) {
          let service = machine.services[serviceName].current;
          let serviceStatusTooltip = "";
          for (let serviceField of Object.keys(service.data)) {
            if (excludeFromTooltip.has(serviceField)) continue;
            serviceStatusTooltip += serviceField + ": " + service.data[serviceField] + "\n";
          }
          serviceStatusTooltip += "timestamp: " + new Date(service.data.timestamp);
          let titleSuffix = "";
          let serviceStatus = null;
          if (service.meta.status == MachineInstance.statusType.DANGER) {
            serviceStatus = Level.DANGER;
          } else if (service.meta.status == MachineInstance.statusType.WARNING) {
            serviceStatus = Level.WARNING;
          } else if (service.meta.status == MachineInstance.statusType.NEW) {
            serviceStatus = Level.PRIMARY;
            titleSuffix = " (New)";
          } else if (service.meta.status == MachineInstance.statusType.OFFLINE) {
            serviceStatus = Level.WARNING;
          } else {
            serviceStatus = Level.SUCCESS;
          }
          serviceSpans.push(UI$1.createElement(Label, {
            key: serviceName,
            level: serviceStatus,
            title: serviceStatusTooltip
          }, serviceName + titleSuffix));
        }
        return serviceSpans;
      }
      renderMachineActions(machine) {
        let scriptsButton = UI$1.createElement("a", {
          className: "btn btn-info disabled"
        }, "No scripts");
        let disableActions = false;
        if (machine.inCloning) {
          disableActions = true;
        }
        let disableDestroy = false;
        if (disableActions || machine.isProtected) {
          disableDestroy = true;
        }
        if (machine.hasOwnProperty("scripts") && machine.scripts.length > 0) {
          machine.scripts.map((scriptName, index) => {
            return UI$1.createElement("li", {
              key: index
            }, UI$1.createElement("a", {
              ref: "scriptChoice" + "-" + scriptName
            }, scriptName));
          });
          scriptsButton = UI$1.createElement("div", {
            className: "btn-group"
          }, UI$1.createElement(Button$1, {
            ref: "runCustomScriptButton",
            level: Level.INFO,
            label: "Run",
            disabled: disableActions,
            parent: this
          }), UI$1.createElement(Select, {
            ref: "customScriptSelect",
            options: machine.scripts,
            style: {
              width: "auto",
              height: "30px"
            },
            disabled: disableActions,
            parent: this
          }));
        }
        return [UI$1.createElement("div", {
          className: "btn-toolbar"
        }, UI$1.createElement("div", {
          className: "btn-group btn-group-sm",
          role: "group"
        }, UI$1.createElement(Button$1, {
          ref: "machineBootButton",
          level: Level.INFO,
          label: "Boot",
          disabled: disableActions,
          parent: this
        }), UI$1.createElement(Button$1, {
          ref: "machineShutdownButton",
          level: Level.INFO,
          label: "Shutdown",
          disabled: disableActions,
          parent: this
        }), UI$1.createElement(Button$1, {
          ref: "machineRebootButton",
          level: Level.INFO,
          label: "Reboot",
          disabled: disableActions,
          parent: this
        }), UI$1.createElement(Button$1, {
          ref: "machineCloneButton",
          level: Level.INFO,
          label: "Clone",
          disabled: disableActions,
          parent: this
        }), UI$1.createElement(Button$1, {
          ref: "machineUpdateButton",
          level: Level.INFO,
          label: "Update",
          disabled: disableActions,
          parent: this
        })), scriptsButton, UI$1.createElement(Button$1, {
          ref: "machineDestroyButton",
          className: "pull-right",
          level: Level.DANGER,
          label: "Destroy",
          disabled: disableDestroy,
          parent: this
        }))];
      }
      static renderMachineStatus(machine) {
        if (machine.inCloning) {
          return [UI$1.createElement("p", null, "Cloning ...")];
        } else {
          return [UI$1.createElement("p", null, capitalize(machine.status))];
        }
      }
      getEntries() {
        return this.options.machines || [];
      }
      getDefaultColumns() {
        return [{
          value: machine => machine.id,
          headerName: "Id"
        }, {
          value: machine => machine.label,
          headerName: "Label"
        }, {
          value: MachineGroupTable.renderMachineStatus,
          headerName: "Status"
        }, {
          value: MachineGroupTable.renderMachineServices,
          headerName: "Running services"
        }, {
          value: this.renderMachineActions,
          headerName: "Actions"
        }];
      }
    }
    class MachineInstanceWidget extends Panel {
      constructor(options) {
        super(options);
        MachineInstanceStore.addCreateListener(data => {
          this.redraw();
        }, false);
        MachineInstanceStore.addDeleteListener((obj, event) => {
          this.redraw();
        });
        MachineInstanceStore.registerStreams();
        this.machineGroups = new Map();
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass("panel-group");
        attr.setAttribute("role", "tablist");
        //TODO: see if this should
        attr.setAttribute("aria-multiselectable", "true");
        return attr;
      }
      onMount() {
        super.onMount();
        for (let [machineGroupName, machineGroup] of this.machineGroups) {
          this["groupUpdateAll-" + machineGroupName].addClickListener(event => {
            event.preventDefault();
            event.stopPropagation();
            ConfirmActionModal.start("\"Update\" all machines from group \"" + machineGroupName + "\".", () => {
              let ids = [];
              for (let machine of machineGroup) {
                ids.push(machine.id);
              }
              MachineInstanceCollapsibleRow.sendCommand(ids, "update");
            });
          });
        }
      }
      render() {
        let machines = MachineInstanceStore.all(true);
        let otherMachines = [];
        this.machineGroups = new Map();
        for (let machine of machines) {
          if (!machine.machineGroup) {
            otherMachines.push(machine);
            continue;
          }
          if (!this.machineGroups.has(machine.machineGroup)) {
            this.machineGroups.set(machine.machineGroup, []);
          }
          this.machineGroups.get(machine.machineGroup).push(machine);
        }
        let renderedMachineGroups = [];
        for (let [machineGroupName, machineGroup] of this.machineGroups) {
          renderedMachineGroups.push(this.renderMachineGroup(machineGroupName, machineGroup));
        }
        if (otherMachines.length > 0) {
          renderedMachineGroups.push(this.renderMachineGroup("Other", otherMachines));
        }
        return [renderedMachineGroups];
      }
      renderMachineGroup(machineGroupName, machineGroup) {
        let style = {
          float: "right",
          marginTop: "-7px"
        };
        let title = [machineGroupName, UI$1.createElement(Button$1, {
          ref: "groupUpdateAll-" + machineGroupName,
          style: style,
          level: Level.INFO,
          label: "Update All",
          parent: this
        })];
        return UI$1.createElement(CollapsiblePanel, {
          key: machineGroupName,
          title: title,
          collapsed: false
        }, UI$1.createElement(MachineGroupTable, {
          machines: machineGroup,
          parent: this
        }));
      }
    }

    class WebsiteLoggingWidget extends Panel {
      render() {
        return [UI$1.createElement(StaticCodeHighlighter, {
          ref: "logger",
          numLines: 40,
          readOnly: true
        })];
      }
      onMount() {
        super.onMount();
        WebsocketSubscriber.addListener("global-logging", logMessage => {
          let formattedMessage = "[" + logMessage.levelname + " " + logMessage.asctime + "] [" + logMessage.service.name + "] " + logMessage.message + "\n";
          if (logMessage.hasOwnProperty("exc_info")) {
            formattedMessage += "Stack trace:\n" + logMessage.exc_info + "\n";
          }
          this.logger.append(formattedMessage);
        });
      }
    }

    class MachineLoggingWidget extends Panel {
      constructor(options) {
        super(options);
      }
      render() {
        return [UI$1.createElement(StaticCodeHighlighter, {
          ref: "logger",
          numLines: 40,
          readOnly: true
        })];
      }
      onMount() {
        super.onMount();
        MachineInstanceStore.registerStreams();
        this.attachListener(MachineInstanceStore, "logMessage", logMessage => {
          let formattedMessage = "[" + logMessage.objectId + "] " + logMessage.message;
          if (!formattedMessage.endsWith("\n")) {
            formattedMessage += "\n";
          }
          this.logger.append(formattedMessage);
        });
      }
    }

    class Deque {
      constructor() {
        this._values = new Array(8);
        this._length = 0;
        this._offset = this._values.length / 2 | 0;
      }
      shouldShrink() {
        return this._values.length > 4 * this._length + 8;
      }
      maybeShrink() {
        if (this.shouldShrink()) {
          this.rebalance(true);
        }
      }
      rebalance(forceResize) {
        let capacity = this._values.length;
        let length = this._length;
        let optimalCapacity = length * 1.618 + 8 | 0;
        let shouldResize = forceResize || capacity < optimalCapacity;
        if (shouldResize) {
          // Allocate a new array and balance objects around the middle
          let values = new Array(optimalCapacity);
          let optimalOffset = optimalCapacity / 2 - length / 2 | 0;
          for (let i = 0; i < length; i += 1) {
            values[optimalOffset + i] = this._values[this._offset + i];
          }
          this._values = values;
          this._offset = optimalOffset;
        } else {
          //Just balance the elements in the middle of the array
          let optimalOffset = capacity / 2 - length / 2 | 0;
          this._values.copyWithin(optimalOffset, this._offset, this._offset + this._length);
          // Remove references, to not mess up gc
          if (optimalOffset < this._offset) {
            this._values.fill(undefined, optimalOffset + this._length, this._offset + this._length);
          } else {
            this._values.fill(undefined, this._offset + this._length, optimalOffset + this._length);
          }
          this._offset = optimalOffset;
        }
      }
      pushFront(value) {
        if (this._offset == 0) {
          this.rebalance();
        }
        this._values[--this._offset] = value;
        this._length += 1;
      }
      popFront() {
        let value = this.peekBack();
        this._values[this._offset++] = undefined;
        this._length -= 1;
        this.maybeShrink();
        return value;
      }
      peekFront() {
        if (this._length == 0) {
          throw Error("Invalid operation, empty deque");
        }
        return this._values[this._offset];
      }
      pushBack(value) {
        if (this._offset + this._length === this._values.length) {
          this.rebalance();
        }
        this._values[this._offset + this._length] = value;
        this._length += 1;
      }
      popBack() {
        let value = this.peekFront();
        this._length -= 1;
        this._values[this._offset + this._length] = undefined;
        this.maybeShrink();
        return value;
      }
      peekBack() {
        if (this._length == 0) {
          throw Error("Invalid operation, empty deque");
        }
        return this._values[this._offset + this._length - 1];
      }
      get(index) {
        if (index < 0 || index >= this._length) {
          throw Error("Invalid index", index);
        }
        return this._values[this._offset + index];
      }
      get length() {
        return this._length;
      }
      set length(value) {
        throw Error("Can't resize a deque");
      }
      toArray() {
        return this._values.slice(this._offset, this._offset + this._length);
      }
      toString() {
        return this.toArray().toString();
      }
      entries() {
        // TODO: implement with yield?
        return this.toArray()[Symbol.iterator];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    }

    // Also support the standard javascript method names
    Deque.prototype.pop = Deque.prototype.popBack;
    Deque.prototype.push = Deque.prototype.pushBack;
    Deque.prototype.shift = Deque.prototype.popFront;
    Deque.prototype.unshift = Deque.prototype.pushFront;

    class MaxLengthDeque extends Deque {
      constructor(maxLength) {
        super();
        this.maxLength = maxLength;
      }
      last() {
        return this.peekBack();
      }
      push(value) {
        if (this.length + 1 > this.maxLength) {
          this.popFront();
        }
        super.push(value);
      }
    }
    const MetricType = {
      VALUE: Symbol("Value"),
      COUNTER: Symbol("Counter"),
      COUNTER_SUM: Symbol("CounterSum")
    };
    class ChunkAverager {
      constructor(type, duration, maxLength) {
        this.values = new MaxLengthDeque(maxLength);
        this.lastTimestamp = null;
        this.type = type;
      }
      addInterval(start, end, value) {
        if (this.lastTimestamp && start != this.lastTimestamp) {
          console.error("Timestamp inconsistency in latest chunk", time.lastTimestamp, start);
        }
        this.lastTimestamp = end;
        // Ignore the value for now
      }
    }
    class MetricSummary extends Dispatchable {
      constructor(type, options = {}) {
        super();
        this.type = type;
        this.options = options;
        // To not have dequeues all resizing at the same time
        this.maxLength = this.options.maxLength || 8;
        this.rawTimestamps = new MaxLengthDeque(this.maxLength);
        this.rawValues = new MaxLengthDeque(this.maxLength);
        this.averagers = [];
        for (let i = 0, duration = 5; i < 7; i++, duration *= 4) {
          this.averagers.push(new ChunkAverager(duration, this.maxLength));
        }
      }
      addInterval(start, end, value) {
        for (let averager of this.averagers) {
          averager.addInterval(start, end, value);
        }
      }
      addValue(timestamp = Date.now(), value = 1) {
        // Normalize timestamp to miliseconds
        timestamp = +new StemDate(timestamp);
        const lastTimestamp = this.rawTimestamps.length && this.rawTimestamps.last();
        if (lastTimestamp && lastTimestamp >= timestamp) {
          if (lastTimestamp > timestamp) {
            // Only warn for strictly larger timestamps
            console.warn("Invalid new timestamp:", timestamp, lastTimestamp);
          }
          return;
        }
        this.rawTimestamps.push(timestamp);
        this.rawValues.push(value);
        if (this.type === MetricType.COUNTER_SUM) {
          if (this.rawValues.length > 0) {
            const prevValue = this.rawValues.last();
            if (prevValue <= value) {
              value = value - prevValue;
            }
          } else {
            // We'll add once we have a previous value, to not have strange data
            value = null;
          }
        }
        if (lastTimestamp && value != null) {
          this.addInterval(lastTimestamp, timestamp, value);
        }
        this.dispatchChange({
          timestamp,
          value,
          lastTimestamp
        });
      }
      getValues(startDate = this.rawTimestamps.peekFront(), endDate = this.rawTimestamps.last(), maxValues = 1024) {
        startDate = +new StemDate(startDate);
        endDate = +new StemDate(endDate);
        let values = [];
        for (let i = 0; i < this.rawValues.length; i++) {
          const timestamp = this.rawTimestamps.get(i);
          if (startDate <= timestamp && timestamp <= endDate) {
            let value = this.rawValues.get(i);
            if (this.type === MetricType.COUNTER_SUM) {
              if (i === 0) {
                // Ignore the first one
                continue;
              }
              const prevValue = this.rawValues.get(i - 1);
              value = value > prevValue ? value - prevValue : value;
            }
            if (this.type === MetricType.COUNTER || this.type === MetricType.COUNTER_SUM) {
              if (i === 0) {
                continue;
              }
              // Normalize to counts per second
              const prevTimestamp = this.rawTimestamps.get(i - 1);
              value = 1000.0 * value / (timestamp - prevTimestamp);
            }
            values.push({
              timestamp: timestamp,
              value: value
            });
          }
        }
        return values;
      }
    }

    class PerformanceMetricsSummarizer {
      constructor(metricDescriptors) {
        this.machineMap = new Map();
        this.metricDescriptors = metricDescriptors;
        for (let descriptor of this.metricDescriptors) {
          const [key, type] = descriptor;
          if (descriptor.length === 2) {
            const keyParts = key.split(".");
            descriptor.push(data => {
              for (const propKey of keyParts) {
                if (!data.hasOwnProperty(propKey)) {
                  return;
                } else {
                  data = data[propKey];
                }
              }
              return data;
            });
          }
        }
      }
      getForMachineId(machineId) {
        if (this.machineMap.has(machineId)) {
          return this.machineMap.get(machineId);
        }
        const metricsMap = new Map();
        for (let [key, type] of this.metricDescriptors) {
          metricsMap.set(key, new MetricSummary(type, {
            maxLength: 8192
          }));
        }
        this.machineMap.set(machineId, metricsMap);
        return this.machineMap.get(machineId);
      }
      addMetrics(metrics) {
        const machineId = metrics.meta.machineId;
        const timestamp = metrics.meta.timestamp;
        const metricsMap = this.getForMachineId(machineId);
        for (let [key, type, func] of this.metricDescriptors) {
          const value = func(metrics);
          metricsMap.get(key).addValue(timestamp, value);
        }
      }
    }
    class MetricsChart extends TimeChart {
      setOptions(options) {
        super.setOptions(options);
        this.xAxisOptions.ticks = 3;
      }
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0.1, 0.1],
          margin: {
            top: 0,
            bottom: 30,
            left: 80,
            right: 0
          }
        });
      }
    }
    class MetricsChartSVG extends ChartSVG {
      setOptions(options) {
        super.setOptions(options);
        this.plotOptions = {
          pointsAlias: data => [].concat(...data),
          xCoordinateAlias: data => data.timestamp,
          yCoordinateAlias: data => data.value
        };
        this.linePlotOptions = Object.assign({}, this.plotOptions, {
          strokeWidth: 1.5,
          stroke: "red",
          pointsAlias: data => data
        });
      }
      render() {
        return [UI$1.createElement(MetricsChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain,
          yAxisLabelFormatFunction: this.options.valueFormatter,
          data: this.options.data,
          enableZoom: this.options.enableZoom
        }, UI$1.createElement(LinePlot, {
          plotOptions: this.linePlotOptions,
          data: this.options.data
        }))];
      }
    }
    class MachineMetricsInfo extends CardPanel {
      getDefaultOptions() {
        return {
          style: {
            width: "400px",
            margin: "10px",
            display: "inline-block"
          },
          bodyStyle: {
            paddingTop: "10px"
          }
        };
      }
      getMachineId() {
        return this.options.machineId;
      }
      getMachineLabel() {
        const machineInstance = MachineInstanceStore.get(this.getMachineId());
        return machineInstance && machineInstance.label || "Machine " + this.getMachineId();
      }
      getVerboseMetrics() {
        const verboseMetricsNameMap = new Map([["cpu.percent", "CPU %"], ["disk.space.percent", "Disk Space %"], ["network.counters.bytes_sent", "Data sent"], ["network.counters.bytes_recv", "Data received"], ["virtualMemory.percent", "VMemory %"]]);
        return verboseMetricsNameMap.get(this.options.metricName) || this.options.metricsName;
      }
      getTitle() {
        return this.getMachineLabel() + " -- " + this.getVerboseMetrics();
      }
      render() {
        const metrics = this.options.metrics;
        let values;
        if (!this.options.timeframe) {
          values = metrics.getValues();
        } else {
          values = metrics.getValues(StemDate.now() - this.options.timeframe, StemDate.now());
        }
        return [UI$1.createElement(MetricsChartSVG, {
          data: values,
          width: 400,
          height: 350,
          valueFormatter: x => metrics.type === MetricType.VALUE ? x + "%" : Formatter.memory(x, true)
        })];
      }
      onMount() {
        this.attachChangeListener(this.options.metrics, () => this.redraw());
      }
    }
    class PerformanceMetricsPanel extends Panel {
      constructor(...args) {
        super(...args);
        this.performanceMetricsSummarizer = new PerformanceMetricsSummarizer([["cpu.percent", MetricType.VALUE], ["disk.space.percent", MetricType.VALUE], ["network.counters.bytes_sent", MetricType.COUNTER_SUM], ["network.counters.bytes_recv", MetricType.COUNTER_SUM], ["virtualMemory.percent", MetricType.VALUE]]);
      }
      getDefaultOptions() {
        return {
          timeframe: 60 * 1000
        };
      }
      addPerformanceMetrics(metrics) {
        let oldSize = this.performanceMetricsSummarizer.machineMap.size;
        this.performanceMetricsSummarizer.addMetrics(metrics);
        if (this.performanceMetricsSummarizer.machineMap.size != oldSize) {
          this.redraw();
        }
      }
      render() {
        const result = [];
        for (let [machineId, metricsData] of this.performanceMetricsSummarizer.machineMap.entries()) {
          for (let [key, summary] of metricsData.entries()) {
            result.push(UI$1.createElement(MachineMetricsInfo, {
              machineId: machineId,
              metricName: key,
              metrics: summary,
              timeframe: this.options.timeframe
            }));
          }
          result.push(UI$1.createElement("hr", null));
        }
        return [UI$1.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          givenOptions: ["1m", "5m", "30m", "6h", ""],
          style: {
            marginTop: "10px",
            textAlign: "center"
          },
          ref: "timeframeSelect"
        }), result];
      }
      onMount() {
        const timeframeSelectParser = new Map([["1m", 60 * 1000], ["5m", 5 * 60 * 1000], ["30m", 30 * 60 * 1000], ["6h", 6 * 60 * 60 * 1000], ["", 0]]);
        this.timeframeSelect.addListener("setIndex", data => {
          this.updateOptions({
            timeframe: timeframeSelectParser.get(data.value)
          });
        });
        this.attachListener(WebsocketSubscriber, "machine-performance-stats", metrics => this.addPerformanceMetrics(metrics));
      }
    }

    class Icarus extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle("margin", "20px 10%");
      }
      getUrlPrefix(urlPart) {
        let url = "/manage/icarus/";
        if (urlPart) {
          url += urlPart + "/";
        }
        return url;
      }
      render() {
        return [UI$1.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, UI$1.createElement(MachineInstanceWidget, {
          ref: "machineInstanceWidget",
          tabHref: this.getUrlPrefix("machines"),
          title: "Machines",
          active: true
        }), UI$1.createElement(MachineLoggingWidget, {
          ref: "machineLoggingWidget",
          tabHref: this.getUrlPrefix("machine-logging"),
          title: "Machines Logging"
        }), UI$1.createElement(WebsiteLoggingWidget, {
          ref: "websiteLoggingWidget",
          tabHref: this.getUrlPrefix("website-logging"),
          title: "Website Logging"
        }), UI$1.createElement(PerformanceMetricsPanel, {
          tabHref: this.getUrlPrefix("performance-metrics"),
          title: "Performance metrics"
        }))];
      }
      setURL(urlParts) {
        if (!this.tabArea) {
          this.initialUrlParts = urlParts;
        } else {
          this.showUrlTab(urlParts[0] || "machines");
        }
      }
      onMount() {
        super.onMount();
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
      }
      showUrlTab(urlPart) {
        if (urlPart === "machines") {
          this.machineInstanceWidget.dispatch("show");
        } else if (urlPart === "machine-logging") {
          this.machineLoggingWidget.dispatch("show");
        } else if (urlPart === "website-logging") {
          this.websiteLoggingWidget.dispatch("show");
        } else if (urlPart === "general-control-panel") {
          this.generalControlPanelWidget.dispatch("show");
        }
      }
    }

    class WSUserData extends StoreObject {
      applyEvent(event) {
        if (event.type === "logMessage") {
          return;
        }
        super.applyEvent(event);
      }
    }
    class WSUserDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        if (event.type == "logMessage") {
          this.dispatch("logMessage", event);
        }
        super.applyEvent(event);
      }
    }

    // TODO @cleanup Is this still a thing?
    const WSUserDataStore = new WSUserDataStoreClass("WSUserData", WSUserData);

    class WSConnectionData extends StoreObject {}
    class WSConnectionDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        super.applyEvent(event);
      }
    }
    const WSConnectionDataStore = new WSConnectionDataStoreClass("WSConnectionData", WSConnectionData);

    class WSUserDataUI extends UI$1.Element {
      render() {
        return [UI$1.createElement(CollapsiblePanel, {
          ref: "usersPanel",
          title: "Users online: " + WSUserDataStore.all().length
        }, WSUserDataUI.renderAllUserData())];
      }
      static renderConnectionTitle(connectionData) {
        let labelStyle = {
          margin: "1px"
        };
        let badgeStyle = {
          "background-color": "black"
        };
        return [UI$1.createElement("h3", null, UI$1.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Id: ", UI$1.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, connectionData.id)), UI$1.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "IP: ", UI$1.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, connectionData.data["IP"])), UI$1.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Streams: ", UI$1.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, connectionData.streams.length)))];
      }
      static renderConnectionStreams(connectionData) {
        let result = [];
        let labelStyle = {
          margin: "0px",
          "background-color": "#953b39"
        };
        for (let stream of connectionData.streams) {
          result.push(UI$1.createElement("span", {
            className: "badge",
            style: labelStyle
          }, "#" + stream));
        }
        return result;
      }
      static renderConnectionData(userData) {
        let result = [];
        for (let connectionId of userData.connectionIds) {
          let connectionData = WSConnectionDataStore.get(connectionId);
          result.push(UI$1.createElement(CardPanel, {
            ref: "connectionCardPanel",
            title: WSUserDataUI.renderConnectionTitle(connectionData)
          }, UI$1.createElement("h4", null, WSUserDataUI.renderConnectionStreams(connectionData))));
        }
        return result;
      }
      static renderUserDataTitle(userData) {
        let labelStyle = {
          margin: "5px"
        };
        return [UI$1.createElement("div", null, "User: ", UI$1.createElement(UserHandle$1, {
          id: userData.id
        }), UI$1.createElement("span", {
          className: "label label-success",
          style: labelStyle
        }, "Websocket connections: ", userData.connectionIds.length), UI$1.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Total Redis streams: ", userData.streams.length))];
      }
      static renderUserData(userData) {
        let panelStyle = {
          margin: "5px",
          padding: "0px"
        };
        return [UI$1.createElement(CollapsiblePanel, {
          ref: "userPanel",
          title: WSUserDataUI.renderUserDataTitle(userData),
          style: panelStyle,
          collapsed: true
        }, UI$1.createElement("div", null, " ", WSUserDataUI.renderConnectionData(userData), " "))];
      }
      static renderAllUserData() {
        let allUserData = [];
        for (let userData of WSUserDataStore.all()) {
          allUserData.push(WSUserDataUI.renderUserData(userData));
        }
        return allUserData;
      }
    }

    class WSConnectionDataUI extends UI$1.Element {
      render() {
        return [UI$1.createElement(CollapsiblePanel, {
          ref: "connectionsPanel",
          collapsed: true,
          title: "Websocket connections: " + WSConnectionDataStore.all().length
        })];
      }
      onMount() {
        GlobalState$1.registerStream("meta_ws_data");
      }
    }

    class WSStreamData extends StoreObject {}
    class WSStreamDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        super.applyEvent(event);
      }
    }
    const WSStreamDataStore = new WSStreamDataStoreClass("WSStreamData", WSStreamData);

    class WSStreamDataUI extends UI$1.Element {
      render() {
        return [UI$1.createElement(CollapsiblePanel, {
          ref: "streamPanel",
          title: "Streams: " + WSStreamDataStore.all().length
        }, WSStreamDataUI.renderAllStreamData())];
      }
      static renderUserConnections(userData) {
        let result = [];
        let labelStyle = {
          margin: "1px"
        };
        let badgeStyle = {
          "background-color": "black"
        };
        for (let connectionId of userData.connectionIds) {
          let connectionData = WSConnectionDataStore.get(connectionId);
          result.push(UI$1.createElement("span", {
            className: "label label-success",
            style: labelStyle
          }, UI$1.createElement("span", {
            className: "label label-primary",
            style: labelStyle
          }, "Id: ", UI$1.createElement("span", {
            className: "badge",
            style: badgeStyle
          }, connectionData.id)), UI$1.createElement("span", {
            className: "label label-primary",
            style: labelStyle
          }, "IP: ", UI$1.createElement("span", {
            className: "badge",
            style: badgeStyle
          }, connectionData.data["IP"])), UI$1.createElement("span", {
            className: "label label-primary",
            style: labelStyle
          }, "Streams: ", UI$1.createElement("span", {
            className: "badge",
            style: badgeStyle
          }, connectionData.streams.length))));
        }
        return result;
      }
      static renderUserTitle(userData) {
        let labelStyle = {
          margin: "5px"
        };
        return [UI$1.createElement("div", null, "User: ", UI$1.createElement(UserHandle$1, {
          id: userData.id
        }), UI$1.createElement("span", {
          className: "label label-success",
          style: labelStyle
        }, "Websocket connections: ", userData.connectionIds.length), UI$1.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Total Redis streams: ", userData.streams.length))];
      }
      static renderUserData(streamData) {
        let result = [];
        for (let userId of streamData.userIds) {
          let userData = WSUserDataStore.get(userId);
          result.push(UI$1.createElement(CardPanel, {
            ref: "userCardPanel",
            title: WSStreamDataUI.renderUserTitle(userData)
          }, UI$1.createElement("h4", null, WSStreamDataUI.renderUserConnections(userData))));
        }
        return result;
      }
      static renderStreamDataTitle(streamData) {
        let badgeStyle = {
          margin: "5px",
          "background-color": "#953b39"
        };
        return [UI$1.createElement("div", null, "Stream: ", UI$1.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, "#" + streamData.id))];
      }
      static renderStreamData(streamData) {
        let panelStyle = {
          margin: "5px",
          padding: "0px"
        };
        return [UI$1.createElement(CollapsiblePanel, {
          ref: "streamPanel",
          title: WSStreamDataUI.renderStreamDataTitle(streamData),
          style: panelStyle,
          collapsed: true
        }, UI$1.createElement("div", null, " ", WSStreamDataUI.renderUserData(streamData), " "))];
      }
      static renderAllStreamData() {
        let allStreamData = [];
        for (let streamData of WSStreamDataStore.all()) {
          allStreamData.push(WSStreamDataUI.renderStreamData(streamData));
        }
        return allStreamData;
      }
    }

    class UserStats extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin", "20px 10%");
      }
      render() {
        return [UI$1.createElement(WSUserDataUI, {
          ref: "wsUserDataUI"
        }), UI$1.createElement(WSConnectionDataUI, {
          ref: "wsConnectionDataUI"
        }), UI$1.createElement(WSStreamDataUI, {
          ref: "wsStreamDataUI"
        })];
      }
    }

    var _class$c, _descriptor$a, _descriptor2$a, _descriptor3$9, _descriptor4$9, _descriptor5$8, _descriptor6$6, _dec$a, _class2$9, _dec2$4, _class3$3;
    class StatisticChart extends TimeChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0, 0]
        });
      }
      initZoom() {
        if (this.options.enableZoom) {
          super.initZoom(true);
        }
      }
    }
    class StatisticChartSVG extends ChartSVG {
      setOptions(options) {
        super.setOptions(options);
        this.plotOptions = {
          pointsAlias: data => [].concat(...data),
          xCoordinateAlias: data => data.moment,
          yCoordinateAlias: data => data.index
        };
        this.linePlotOptions = [];
        let startTime;
        for (let i = 0; i < this.options.timestamps.length; i += 1) {
          let timestamps = this.options.timestamps[i];
          timestamps.sort();
          if (i === 0) {
            startTime = timestamps[0];
          }
          let localStartTime = timestamps[0];
          for (let j = 0; j < timestamps.length; j += 1) {
            timestamps[j] = {
              moment: 1000 * (timestamps[j] - localStartTime + startTime),
              index: j
            };
          }
          while (timestamps.length > 5000) {
            timestamps = timestamps.filter((t, index) => index % 3 !== 2);
          }
          this.options.timestamps[i] = timestamps;
          this.linePlotOptions.push(Object.assign({}, this.plotOptions, {
            stroke: ColorGenerator.getPersistentColor(i),
            strokeWidth: 1.5,
            pointsAlias: data => data
          }));
        }
      }
      render() {
        let linePlots = this.options.timestamps.map((timestampArray, index) => UI$1.createElement(LinePlot, {
          plotOptions: this.linePlotOptions[index],
          data: timestampArray
        }));
        return [UI$1.createElement(StatisticChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain,
          data: this.options.timestamps,
          enableZoom: this.options.enableZoom
        }, linePlots)];
      }
    }
    let StatisticChartsStyle = (_class$c = class StatisticChartsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.chartContainerPadding = 40;
        _initializerDefineProperty(this, "className", _descriptor$a, this);
        _initializerDefineProperty(this, "select", _descriptor2$a, this);
        _initializerDefineProperty(this, "chartContainer", _descriptor3$9, this);
        _initializerDefineProperty(this, "defaultMessage", _descriptor4$9, this);
        _initializerDefineProperty(this, "statisticDataForm", _descriptor5$8, this);
        _initializerDefineProperty(this, "colorBubble", _descriptor6$6, this);
      }
    }, (_descriptor$a = _applyDecoratedDescriptor(_class$c.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "10%",
          marginRight: "10%"
        };
      }
    }), _descriptor2$a = _applyDecoratedDescriptor(_class$c.prototype, "select", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "10px"
        };
      }
    }), _descriptor3$9 = _applyDecoratedDescriptor(_class$c.prototype, "chartContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "600px",
          width: "100%",
          border: "1px solid grey",
          borderRadius: "10px",
          padding: this.chartContainerPadding + "px",
          marginTop: "20px",
          backgroundImage: "linear-gradient(to top right, #fff 60%, #dfdfdf)",
          textAlign: "center",
          justifyContent: "center",
          display: "flex",
          flexDirection: "column"
        };
      }
    }), _descriptor4$9 = _applyDecoratedDescriptor(_class$c.prototype, "defaultMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.5em"
        };
      }
    }), _descriptor5$8 = _applyDecoratedDescriptor(_class$c.prototype, "statisticDataForm", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "10px",
          textAlign: "initial",
          justifyContent: "initial"
        };
      }
    }), _descriptor6$6 = _applyDecoratedDescriptor(_class$c.prototype, "colorBubble", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "20px",
          width: "20px",
          borderRadius: "20px"
        };
      }
    })), _class$c);
    class Timeframe extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-bottom", "5px");
      }
      render() {
        let date;
        if (this.options.value) {
          date = new StemDate(this.options.value);
        }
        return [UI$1.createElement(DateTimePicker, {
          date: date,
          ref: "endDatePicker",
          style: {
            display: "inline-block",
            marginRight: "3px"
          }
        }), UI$1.createElement(ButtonGroup, {
          size: Size.EXTRA_SMALL,
          level: Level.PRIMARY,
          style: {
            display: "inline-block"
          }
        }, UI$1.createElement(Button$1, {
          icon: "times",
          onClick: () => this.options.form.dispatch("removeTimeframe", this)
        }), UI$1.createElement(Button$1, {
          icon: "clock-o",
          onClick: () => this.endDatePicker.setDate(StemDate.now())
        }), UI$1.createElement(Button$1, {
          icon: "level-down",
          onClick: () => this.options.form.dispatch("newTimeframe", this)
        }))];
      }
      getValue() {
        if (!this.endDatePicker.getDate()) {
          return this.options.value;
        }
        return this.endDatePicker.getDate().toUnix();
      }
      fetchData(timeframeLength, callback) {
        if (!this._cachedData) {
          this._cachedData = new Map();
        }
        if (!this._cachedData.has(timeframeLength)) {
          const endDate = this.endDatePicker.getDate().toUnix();
          const startDate = endDate - timeframeLength;
          Ajax.getJSON("/manage/charts/", {
            objectType: this.options.objectType,
            startDate: startDate,
            endDate: endDate
          }).then(data => {
            this._cachedData.set(timeframeLength, data.timestamps);
            callback(this._cachedData.get(timeframeLength));
          });
        } else {
          callback(this._cachedData.get(timeframeLength));
        }
      }
      setColor(color) {
        this.setStyle("background-color", color);
      }
    }
    let StatisticDataInput = (_dec$a = registerStyle(StatisticChartsStyle), _dec$a(_class2$9 = class StatisticDataInput extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.statisticDataForm);
      }
      setInterval(timeUnit) {
        return () => this.timeframeLengthInput.setValue((timeUnit / 1000).toString());
      }
      getTimeframeLength() {
        return parseInt(this.timeframeLengthInput.getValue());
      }
      render() {
        return [UI$1.createElement(FormField, {
          label: "Interval length"
        }, UI$1.createElement(NumberInput, {
          ref: "timeframeLengthInput",
          placehoder: "seconds"
        })), UI$1.createElement(FormField, {
          label: "Presets",
          style: {
            marginBottom: "10px"
          }
        }, UI$1.createElement(ButtonGroup, {
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL
        }, UI$1.createElement(Button$1, {
          onClick: this.setInterval(TimeUnit.HOUR)
        }, "Hour"), UI$1.createElement(Button$1, {
          onClick: this.setInterval(TimeUnit.DAY)
        }, "Day"), UI$1.createElement(Button$1, {
          onClick: this.setInterval(TimeUnit.WEEK)
        }, "Week"), UI$1.createElement(Button$1, {
          onClick: this.setInterval(TimeUnit.MONTH)
        }, "Month"), UI$1.createElement(Button$1, {
          onClick: this.setInterval(TimeUnit.YEAR)
        }, "Year"))), UI$1.createElement("div", {
          ref: "timeframesArea"
        }), UI$1.createElement(ButtonGroup, {
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL
        }, UI$1.createElement(Button$1, {
          onClick: () => this.addTimeframe()
        }, "Add timeframe"), UI$1.createElement(Button$1, {
          onClick: () => this.compute()
        }, "Compute"))];
      }
      compute() {
        const numTimeframes = this.timeframesArea.children.length;
        const timeframeLength = this.getTimeframeLength();
        let loaded = 0;
        let timestampArrays = new Array(numTimeframes);
        let timeframesData = new Array(numTimeframes);
        for (let i = 0; i < numTimeframes; i += 1) {
          const timeframe = this.timeframesArea.children[i];
          timeframe.setColor(ColorGenerator.getPersistentColor(i));
          timeframe.fetchData(timeframeLength, data => {
            loaded += 1;
            timestampArrays[i] = data;
            timeframesData[i] = {
              startDate: new StemDate(timeframe.getValue() - timeframeLength),
              endDate: new StemDate(timeframe.getValue()),
              color: ColorGenerator.getPersistentColor(i)
            };
            if (loaded === numTimeframes) {
              this.dispatch("data", timestampArrays, timeframesData);
            }
          });
        }
      }
      addTimeframe() {
        this.timeframesArea.appendChild(UI$1.createElement(Timeframe, {
          form: this,
          objectType: this.options.objectType
        }));
      }
      onMount() {
        this.addListener("removeTimeframe", timeframe => {
          this.timeframesArea.eraseChild(timeframe);
        });
        this.addListener("newTimeframe", parentTimeframe => {
          this.timeframesArea.insertChild(UI$1.createElement(Timeframe, {
            value: parentTimeframe.getValue() - this.getTimeframeLength(),
            form: this,
            objectType: this.options.objectType
          }), this.timeframesArea.options.children.indexOf(parentTimeframe) + 1);
        });
      }
    }) || _class2$9);
    let SingleStatisticChart = (_dec2$4 = registerStyle(StatisticChartsStyle), _dec2$4(_class3$3 = class SingleStatisticChart extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }
      render() {
        return [UI$1.createElement("div", {
          ref: "chartArea",
          className: this.styleSheet.chartContainer
        }, UI$1.createElement("em", {
          className: this.styleSheet.defaultMessage
        }, "No data available"), UI$1.createElement("div", null, UI$1.createElement(Button$1, {
          onClick: () => this.loadFull(),
          level: Level.PRIMARY
        }, "Load full chart"), UI$1.createElement(Button$1, {
          onClick: () => this.enterCompareMode(),
          level: Level.PRIMARY,
          className: this.styleSheet.select
        }, "Compare timeframes")))];
      }
      loadFull() {
        Ajax.getJSON("/manage/charts/", {
          objectType: this.options.objectType
        }).then(data => {
          this.chartArea.setChildren([UI$1.createElement("div", null, UI$1.createElement(Button$1, {
            onClick: () => this.redraw(),
            level: Level.PRIMARY,
            style: {
              float: "left"
            }
          }, "Back")), UI$1.createElement(StatisticChartSVG, {
            timestamps: [data.timestamps],
            enableZoom: true,
            width: this.chartArea.getWidth() - 2 * this.styleSheet.chartContainerPadding
          })]);
        });
      }
      getTableColumns() {
        const centeredText = {
          textAlign: "center"
        };
        return [{
          value: info => info.startDate.format("DD MMMM YYYY HH:mm"),
          headerName: "Start date",
          headerStyle: centeredText,
          cellStyle: centeredText
        }, {
          value: info => info.endDate.format("DD MMMM YYYY HH:mm"),
          headerName: "End date",
          headerStyle: centeredText,
          cellStyle: centeredText
        }, {
          value: info => UI$1.createElement("div", {
            style: {
              backgroundColor: info.color
            },
            className: this.styleSheet.colorBubble
          }),
          headerName: "Color",
          headerStyle: {
            textAlign: "left"
          }
        }, {
          value: info => info.numTimestamps,
          headerName: "Number",
          headerStyle: centeredText,
          cellStyle: centeredText
        }];
      }
      enterCompareMode() {
        const chartWidth = this.chartArea.getWidth() * 0.7 - 2 * this.styleSheet.chartContainerPadding;
        this.chartArea.setChildren([UI$1.createElement("div", {
          style: {
            height: "100%"
          }
        }, UI$1.createElement("div", {
          style: {
            float: "left",
            width: "30%",
            height: "100%"
          }
        }, UI$1.createElement(Button$1, {
          onClick: () => this.redraw(),
          level: Level.PRIMARY,
          style: {
            float: "left"
          }
        }, "Back"), UI$1.createElement("div", {
          style: {
            clear: "both"
          }
        }), UI$1.createElement(StatisticDataInput, {
          ref: this.refLink("dataInput"),
          objectType: this.options.objectType
        })), UI$1.createElement("div", {
          style: {
            float: "right",
            width: "70%",
            height: "100%"
          }
        }, UI$1.createElement(TabArea, null, UI$1.createElement(Panel, {
          title: "Chart",
          ref: this.refLink("chartContainer")
        }, UI$1.createElement(StatisticChartSVG, {
          timestamps: [],
          width: chartWidth
        })), UI$1.createElement(Panel, {
          title: "Table",
          ref: this.refLink("tableContainer")
        }, UI$1.createElement(Table, {
          columns: this.getTableColumns(),
          entries: []
        })))))]);
        this.chartContainer.attachListener(this.dataInput, "data", data => {
          this.chartContainer.setChildren([UI$1.createElement(StatisticChartSVG, {
            timestamps: data,
            width: chartWidth,
            key: Math.random()
          })]);
        });
        this.tableContainer.attachListener(this.dataInput, "data", (data, timeframesInfo) => {
          let entries = [];
          for (let i = 0; i < data.length; i += 1) {
            entries.push(Object.assign({}, timeframesInfo[i], {
              numTimestamps: data[i].length
            }));
          }
          this.tableContainer.setChildren([UI$1.createElement(Table, {
            columns: this.getTableColumns(),
            entries: entries,
            key: Math.random()
          })]);
        });
      }
    }) || _class3$3);
    class StatisticCharts extends UI$1.Element {
      render() {
        return [UI$1.createElement("h3", null, "Users"), UI$1.createElement(SingleStatisticChart, {
          objectType: "users"
        }), UI$1.createElement("h3", null, "Submissions"), UI$1.createElement(SingleStatisticChart, {
          objectType: "submissions"
        }), UI$1.createElement("h3", null, "Custom runs"), UI$1.createElement(SingleStatisticChart, {
          objectType: "customruns"
        })];
      }
    }

    class CommandInstance extends StoreObject {
      toString() {
        return this.name;
      }
      requiresConfirmation() {
        return this.promptForConfirmation || this.runOptions.length !== 0;
      }
    }
    const verboseStatus = ["Waiting", "Running", "Failed", "Successful"];
    class CommandRun extends StoreObject {
      update(event) {
        if (event.type === "logMessage") {
          this.logEntries = this.logEntries || {
            entries: [],
            progress: {}
          };
          this.logEntries.entries.push(event.data);
        } else {
          super.update(event);
        }
      }
      getVerboseStatus() {
        return verboseStatus[this.status];
      }
    }
    let CommandInstanceStore = new GenericObjectStore("CommandInstance", CommandInstance);
    let CommandRunStore = new GenericObjectStore("CommandRun", CommandRun);

    var _class$b, _class2$8;
    let CommandRunStatus = autoredraw(_class$b = class CommandRunStatus extends UI$1.Element {
      render() {
        switch (this.options.commandRun.status) {
          case 0:
            {
              return "In queue..";
            }
          case 1:
            {
              return UI$1.createElement(ProgressBar, {
                ref: "progressBar",
                style: {
                  margin: "0 auto"
                }
              });
            }
          case 2:
            {
              return UI$1.createElement(FAIcon, {
                icon: "times",
                style: {
                  color: "red"
                }
              });
            }
          case 3:
            {
              return UI$1.createElement(FAIcon, {
                icon: "check",
                style: {
                  color: "green"
                }
              });
            }
        }
      }
    }) || _class$b;
    class CommandRunDetailsModal extends Modal {
      render() {
        let children = [UI$1.createElement("h2", null, "Command run #", this.options.commandRun.id), UI$1.createElement("h4", null, "Ran by ", UI$1.createElement(UserHandle$1, {
          userId: this.options.commandRun.userId
        })), UI$1.createElement("h4", null, "Command instance: ", CommandInstanceStore.get(this.options.commandRun.commandInstanceId).name), UI$1.createElement("h4", {
          ref: "statusField"
        }, "Status: ", this.options.commandRun.getVerboseStatus()), UI$1.createElement("h4", null, "Logs"), UI$1.createElement(StaticCodeHighlighter, {
          ref: "logger",
          numLines: 40,
          readOnly: true
        })];
        if (this.options.commandRun.status >= 2) {
          // The command is finished, show the result
          children.push(UI$1.createElement("h4", null, "Result:"));
          children.push(UI$1.createElement(StaticCodeHighlighter, {
            ref: "resultField",
            numLines: 15,
            readOnly: true
          }));
        }
        return children;
      }
      getFormattedMessage(logEntry) {
        let message = "";
        message += "[" + StemDate.format(logEntry.timestamp, "DD/MM/YYYY HH:mm:SS") + "]";
        message += " ";
        message += logEntry.message;
        message += "\n";
        return message;
      }
      getFormattedResult(resultJson) {
        if (!resultJson) {
          return "Success!";
        }
        return JSON.stringify(resultJson);
      }
      onMount() {
        super.onMount();
        if (this.options.commandRun.logEntries && this.options.commandRun.logEntries.entries) {
          for (let entry of this.options.commandRun.logEntries.entries) {
            this.logger.append(this.getFormattedMessage(entry));
          }
        }
        this.attachEventListener(this.options.commandRun, "logMessage", event => {
          this.logger.append(this.getFormattedMessage(event.data));
        });
        this.attachEventListener(this.options.commandRun, "createOrUpdate", () => {
          this.redraw();
          if (this.options.commandRun.status >= 2) {
            this.resultField.append(this.getFormattedResult(this.options.commandRun.result));
          }
        });
        if (this.options.commandRun.status >= 2) {
          this.resultField.append(this.getFormattedResult(this.options.commandRun.result));
        }
      }
    }
    class CommandRunDetails extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("cursor", "pointer");
        attr.setStyle("text-decoration", "underline");
      }
      render() {
        return UI$1.T("Details");
      }
      onMount() {
        this.addClickListener(() => {
          CommandRunDetailsModal.show({
            commandRun: this.options.commandRun
          });
        });
      }
    }
    let CommandRunDuration = autoredraw(_class2$8 = class CommandRunDuration extends UI$1.Primitive("span") {
      render() {
        if (this.options.commandRun.status === 0) {
          return "-";
        }
        let time;
        if (this.options.commandRun.status === 1) {
          time = StemDate.now() / 1000 - this.options.commandRun.dateCreated;
        } else {
          time = this.options.commandRun.dateFinished - this.options.commandRun.dateCreated;
        }
        return Formatter.truncate(time, 2);
      }
      onMount() {
        this.intervalId = setInterval(() => {
          if (this.options.commandRun.status >= 2) {
            clearInterval(this.intervalId);
            delete this.intervalId;
          } else {
            this.redraw();
          }
        }, 700);
      }
    }) || _class2$8;
    class PastCommandsTable extends Table {
      getEntries() {
        return CommandRunStore.all().sort((a, b) => {
          return b.dateCreated - a.dateCreated;
        });
      }
      getDefaultColumns() {
        return [{
          value: commandRun => CommandInstanceStore.get(commandRun.commandInstanceId).name,
          headerName: "Command"
        }, {
          value: commandRun => UI$1.createElement(UserHandle$1, {
            userId: commandRun.userId
          }),
          headerName: "User"
        }, {
          value: commandRun => StemDate.format(commandRun.dateCreated, "DD/MM/YYYY HH:mm"),
          headerName: "Date"
        }, {
          value: commandRun => UI$1.createElement(CommandRunDuration, {
            commandRun: commandRun
          }),
          headerName: "Duration"
        }, {
          value: commandRun => {
            return UI$1.createElement(CommandRunStatus, {
              commandRun: commandRun
            });
          },
          headerName: "Status",
          headerStyle: {
            textAlign: "center"
          },
          cellStyle: {
            textAlign: "center"
          }
        }, {
          value: commandRun => UI$1.createElement(CommandRunDetails, {
            commandRun: commandRun
          }),
          headerName: "Details"
        }];
      }
    }
    class AutoFormFieldHelper extends UI$1.Element {
      render() {
        return [UI$1.createElement("span", {
          ref: "container",
          style: {
            position: "relative",
            overflow: "hidden",
            "cursor": "pointer"
          }
        }, UI$1.createElement(FAIcon, {
          icon: "question-circle",
          ref: "span"
        }))];
      }
      onMount() {
        this.span.addNodeListener("mouseover", () => {
          this.popup = Popup.create(this.container, Object.assign({
            target: this.span,
            title: this.options.title,
            children: this.options.description,
            transitionTime: 300,
            titleFontSize: "10pt",
            contentStyle: {
              padding: "8px",
              textAlign: "left"
            },
            style: {
              minWidth: "300px",
              maxWidth: "500px"
            }
          }));
        });
        this.span.addNodeListener("mouseout", () => {
          if (this.popup) {
            this.popup.hide();
          }
        });
      }
    }
    class AutoFormFieldSelectOption {
      constructor(options) {
        Object.assign(this, options);
      }
      toString() {
        return this.label;
      }
      getValue() {
        return this.key;
      }
    }
    class AutoFormField extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.fieldType = {
          "text": 1,
          "number": 2,
          "checkbox": 3,
          "select": 4
        };
      }
      getInputRef() {
        return this.options.shortName + "Input";
      }
      render() {
        let formField = null;
        if (this.options.type === this.fieldType.text) {
          formField = UI$1.createElement(TextInput, {
            ref: this.getInputRef(),
            initialValue: this.options.initialValue
          });
        }
        if (this.options.type === this.fieldType.number) {
          formField = UI$1.createElement(NumberInput, {
            ref: this.getInputRef(),
            initialValue: this.options.initialValue
          });
        }
        if (this.options.type === this.fieldType.checkbox) {
          formField = UI$1.createElement(RawCheckboxInput, {
            ref: this.getInputRef(),
            initialValue: this.options.initialValue
          });
        }
        if (this.options.type === this.fieldType.select) {
          let options = [];
          for (let option of this.options.choices) {
            options.push(new AutoFormFieldSelectOption(option));
          }
          formField = UI$1.createElement(Select, {
            ref: this.getInputRef(),
            options: options
          });
        }
        return UI$1.createElement("div", {
          style: {
            width: "100%",
            display: "flex",
            flexDirection: "row"
          }
        }, UI$1.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            width: "12px"
          }
        }, this.options.description && UI$1.createElement(AutoFormFieldHelper, {
          description: this.options.description,
          title: this.options.shortName
        })), UI$1.createElement("div", {
          style: {
            flex: "1"
          }
        }, UI$1.createElement(FormField, {
          label: this.options.longName
        }, formField)));
      }
      getValue() {
        if (this.options.type === this.fieldType.select) {
          return this[this.getInputRef()].get().getValue();
        } else {
          return this[this.getInputRef()].getValue();
        }
      }
    }
    class CommandRunCreationModal extends ActionModal {
      getTitle() {
        return this.options.commandInstance.name;
      }
      getBody() {
        let body = [];
        if (this.options.commandInstance.requiresConfirmation()) {
          if (this.options.commandInstance.promptForConfirmation) {
            body.push(UI$1.createElement("h4", {
              style: {
                color: "red"
              }
            }, "This command requires a confirmation. Are you sure you want to run this command?"));
          }
          for (let entry of this.options.commandInstance.runOptions) {
            body.push(UI$1.createElement(AutoFormField, _extends({
              ref: entry.shortName
            }, entry)));
          }
        }
        return body;
      }
      getActionName() {
        return [UI$1.createElement(FAIcon, {
          icon: "cogs",
          style: {
            paddingRight: "7px"
          }
        }), "Run"];
      }
      getActionLevel() {
        return Level.PRIMARY;
      }
      action() {
        let requestJson = {
          commandInstanceId: this.options.commandInstance.id,
          arguments: {}
        };
        for (let entry of this.options.commandInstance.runOptions) {
          requestJson.arguments[entry.shortName] = this[entry.shortName].getValue();
        }
        requestJson.arguments = JSON.stringify(requestJson.arguments);
        runCommand(requestJson, () => {
          CommandRunStore.dispatch("redrawTable");
        });
        this.hide();
      }
    }
    function runCommand(json, callback) {
      Ajax.postJSON("/baseconfig/run_command/", json).then(callback);
    }
    class CommandManager extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-left", "15%");
        attr.setStyle("margin-right", "15%");
      }
      render() {
        return [UI$1.createElement("h3", null, "Command manager"), UI$1.createElement("div", null, UI$1.createElement("h4", null, "Run a command"), UI$1.createElement(Select, {
          options: CommandInstanceStore.all(),
          style: {
            marginLeft: "10px"
          },
          ref: "commandSelect"
        }), UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          size: Size.SMALL,
          ref: "runCommandButton",
          icon: "cogs",
          style: {
            marginLeft: "10px"
          }
        })), UI$1.createElement("div", {
          ref: "descriptionArea",
          style: {
            margin: "10px"
          }
        }), UI$1.createElement("div", {
          style: {
            marginTop: "20px"
          }
        }, UI$1.createElement("h4", null, "Past commands"), UI$1.createElement(PastCommandsTable, {
          ref: "pastCommandsTable"
        }))];
      }
      onMount() {
        GlobalState$1.registerStream("GlobalCommandRuns");
        let redrawPastCommandsTable = () => {
          this.pastCommandsTable.redraw();
        };
        this.attachCreateListener(CommandRunStore, redrawPastCommandsTable);
        this.attachListener(CommandRunStore, "redrawTable", redrawPastCommandsTable);
        this.descriptionArea.node.textContent = this.commandSelect.get().description;
        this.commandSelect.addChangeListener(() => {
          this.descriptionArea.node.textContent = this.commandSelect.get().description;
        });
        this.runCommandButton.addClickListener(() => {
          let commandInstance = this.commandSelect.get();
          if (commandInstance.requiresConfirmation()) {
            CommandRunCreationModal.show({
              commandInstance
            });
          } else {
            runCommand({
              commandInstanceId: commandInstance.id
            }, redrawPastCommandsTable);
          }
        });
      }
    }

    // TODO: this whole file needs a refactoring
    function ajaxCall(request, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
      Ajax.postJSON("/edit_translation/", request).then(onSuccess, onError);
    }
    class TranslationEntryTableRow extends TableRow {
      setOptions(options) {
        super.setOptions(options);
        this.options.saveButton = this.saveButton;
      }
      onMount() {
        super.onMount();
        this.saveButton.addClickListener(() => {
          this.saveKey();
        });
        this.entryInput.addChangeListener(() => {
          this.markChanged();
        });
      }
      redraw() {
        super.redraw();
        this.options.entryInput = this.entryInput;
      }
      markChanged() {
        this.setStyle("background-color", "lightblue");
      }
      markUnchanged() {
        this.setStyle("background-color", "white");
      }
      saveKey() {
        let entry = this.options.entry;
        let editEntries = [{
          keyId: entry.key.id,
          languageId: entry.language.id,
          newValue: this.entryInput.getValue()
        }];
        let request = {
          editEntries: JSON.stringify(editEntries)
        };
        ajaxCall(request, () => {
          this.markUnchanged();
        });
        n;
      }
      getEntryInput() {
        return this.options.entryInput;
      }
    }
    class TranslationEntryTable extends Table {
      getRowClass() {
        return TranslationEntryTableRow;
      }
      getDefaultColumns() {
        const numberStyle = {
          textAlign: "right"
        };
        return [{
          value: entry => entry.key.id,
          headerName: "Key ID",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.key.value,
          headerName: "Entry value",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return UI$1.createElement("div", {
              className: "form-group"
            }, UI$1.createElement(TextInput, {
              ref: "entryInput",
              value: entry.entry ? entry.entry.value : ""
            }));
          },
          headerName: "Key value",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return UI$1.createElement("div", {
              className: "form-group"
            }, UI$1.createElement(Button$1, {
              ref: "saveButton",
              label: "Save",
              level: Level.INFO
            }));
          },
          headerName: "Actions",
          sortDescending: true
        }];
      }

      // TODO @cleanup shouldn't we just delete all these?
      getEntryKey(entry, index) {
        return index;
      }
      getEntries() {
        const {
          language
        } = this.options;
        let keyEntryMap = new Map();
        for (let entry of TranslationEntryStore.all()) {
          if (entry.getLanguage().id === language.id) {
            keyEntryMap.set(entry.getTranslationKey().id, entry);
          }
        }
        let result = [];
        for (let key of TranslationKeyStore.all()) {
          result.push({
            key,
            entry: keyEntryMap.get(key.id),
            language
          });
        }
        return result;
      }
    }
    class TranslationEntryManager extends Panel {
      setOptions(options) {
        super.setOptions(options);
        this.language = Language.get(1);
      }
      render() {
        let languageOptions = this.getLanguageOptions();
        return [UI$1.createElement("div", {
          className: "form-group"
        }, UI$1.createElement(Select, {
          className: "form-control",
          options: languageOptions,
          ref: "languageSelect"
        }), UI$1.createElement(TranslationEntryTable, {
          ref: "translationTable",
          language: this.language
        })), UI$1.createElement("div", {
          className: "btn-group"
        }, UI$1.createElement(Button$1, {
          ref: "saveAllButton",
          label: "Save all",
          level: Level.INFO
        }), UI$1.createElement(Button$1, {
          className: "pull-left",
          level: Level.INFO,
          label: "Import",
          ref: "importButton",
          style: {
            position: "relative",
            overflow: "hidden"
          }
        }, UI$1.createElement(FileInput, {
          ref: "uploadFile",
          style: {
            position: "absolute",
            top: "0",
            right: "0",
            margin: "0",
            padding: "0",
            cursor: "pointer",
            opacity: "0",
            filter: "alpha(opacity=0)"
          }
        })), UI$1.createElement(Button$1, {
          ref: "exportButton",
          label: "Export",
          level: Level.INFO
        }))];
      }
      getLanguageOptions() {
        let ret = [];
        for (let language of Language.all()) {
          ret.push({
            value: language,
            toString: () => language.name
          });
        }
        return ret;
      }
      onMount() {
        super.onMount();
        this.languageSelect.addChangeListener(() => {
          this.changeLanguage();
        });
        this.saveAllButton.addClickListener(() => {
          this.saveAll();
        });
        this.importButton.addClickListener(() => {
          this.importFromFile();
        });
        this.exportButton.addClickListener(() => {
          this.exportToFile();
        });
      }
      changeLanguage() {
        this.language = this.languageSelect.get().value;
        this.redraw();
      }
      saveAll() {
        let changes = [];
        for (let row of this.translationTable.rows) {
          let entryNewValue = row.options.entryInput.getValue();
          let keyId = row.options.entry.key.id;
          let entry = row.options.entry.entry;
          let change = {};
          if (entryNewValue === "" && !entry) {
            continue;
          }
          if (entry && entryNewValue === entry.value) {
            continue;
          }
          change = {
            keyId: keyId,
            newValue: entryNewValue,
            languageId: this.language.id
          };
          if (entry) {
            change.entryId = entry.id;
          }
          changes.push(change);
        }
        let request = {
          editEntries: JSON.stringify(changes)
        };
        ajaxCall(request, () => {
          // TODO: Find a way to redraw only the changed rows
          this.redraw();
        }, () => {
          this.saveAllButton.disable();
          this.saveAllButton.setLevel(Level.ERROR);
          this.saveAllButton.setLabel("Failed!");
          setTimeout(() => {
            this.saveAllButton.enable();
            this.redraw();
          }, 1000);
        });
      }
      importFromFile() {
        this.uploadFile.node.onchange = () => {
          let reader = new FileReader();
          let file = this.uploadFile.getFile();
          if (file.size > 1e8) {
            this.fileWarningModal.show();
            console.warn("File ", file.name, " too large. Skipping upload.");
            this.uploadFile.setValue("");
            return;
          }
          reader.onprogress = () => {
            this.importButton.setLevel(Level.WARNING);
            this.importButton.setLabel("Uploading...");
            this.importButton.disable();
            this.saveAllButton.disable();
            for (let row of this.translationTable.rows) {
              row.options.saveButton.disable();
            }
          };
          reader.onload = e => {
            let text = e.currentTarget.result;
            let error = false;
            let errmsg = "";
            try {
              let obj = JSON.parse(text);
              if (Object.prototype.toString.call(obj) !== '[object Array]') {
                error = true;
                errmsg = "No array found!";
              } else {
                let changes = [];
                for (let x of obj) {
                  if (!x.keyId) {
                    error = true;
                    errmsg = "Key id missing!";
                    break;
                  }
                  if (x.entryValue === "") {
                    continue;
                  }
                  if (!x.entryValue) {
                    error = true;
                    errmsg = "Entry value missing!";
                    break;
                  }
                  x.entryValue = x.entryValue.trim();
                  let change = {
                    keyId: x.keyId,
                    newValue: x.entryValue,
                    languageId: this.language.id
                  };
                  if (x.entryId) {
                    change.entryId = x.entryId;
                    let entry = TranslationEntryStore.get(x.entryId);
                    if (x.entryValue === entry.value) {
                      continue;
                    }
                  }
                  changes.push(change);
                }
                if (!error) {
                  let request = {
                    editEntries: JSON.stringify(changes)
                  };
                  ajaxCall(request, () => {
                    this.redraw();
                  });
                }
              }
            } catch (ex) {
              error = true;
              errmsg = ex.message;
            }
            let timeout;
            if (error) {
              this.importButton.setLevel(Level.ERROR);
              this.importButton.setLabel(errmsg);
              timeout = 2000;
            } else {
              this.importButton.setLevel(Level.SUCCESS);
              this.importButton.setLabel("Successfully uploaded!");
              timeout = 700;
            }
            setTimeout(() => {
              this.importButton.enable();
              this.importButton.setLevel(Level.INFO);
              this.importButton.setLabel("Import");
              this.saveAllButton.enable();
              for (let row of this.translationTable.rows) {
                row.options.saveButton.enable();
              }
            }, timeout);
            this.uploadFile.setValue("");
          };
          reader.readAsText(file);
        };
      }
      exportToFile() {
        let language = this.language;
        let keyEntryMap = new Map();
        for (let entry of TranslationEntryStore.all()) {
          if (entry.getLanguage().id === language.id) {
            keyEntryMap.set(entry.getTranslationKey().id, entry);
          }
        }
        let output = [];
        for (let key of TranslationKeyStore.all()) {
          let entry = keyEntryMap.get(key.id);
          output.push({
            keyId: key.id,
            entryId: entry ? entry.id : "",
            keyValue: key.value,
            entryValue: entry ? entry.value : ""
          });
        }
        let file = new Blob([JSON.stringify(output, null, 2)], {
          type: 'text/plain;charset=utf-8'
        });
        FileSaver.saveAs(file, "translations.json");
      }
    }
    class TranslationKeyTableRow extends TableRow {
      setOptions(options) {
        super.setOptions(options);
      }
      onMount() {
        super.onMount();
        this.deleteButton.addClickListener(() => {
          this.deleteKey();
        });
        this.renameButton.addClickListener(() => {
          this.rename();
        });
      }
      redraw() {
        super.redraw();
        this.textInput.hide();
        this.renameState = false;
        let editable = this.options.entry.editable;
        if (!editable) {
          this.renameButton.hide();
          this.deleteButton.hide();
        } else {
          this.renameButton.show();
          this.deleteButton.show();
        }
      }
      deleteKey() {
        let key = this.options.entry.key;
        let table = this.options.entry.table;
        let request = {
          editKeys: JSON.stringify({
            type: "delete",
            keyId: key.id
          })
        };
        table.changed = true;
        this.hide();
        ajaxCall(request, () => {
          this.options.entry.table.changed = true;
          TranslationKeyStore.applyDeleteEvent({
            objectId: key.id
          });
          for (let entry of TranslationEntryStore.all()) {
            if (entry.translationKeyId == key.id) {
              TranslationEntryStore.applyDeleteEvent({
                objectId: entry.id
              });
            }
          }
        });
      }
      rename() {
        if (!this.renameState) {
          this.renameButton.setLabel("Save");
          this.textInput.setValue(this.textElement.getValue());
          this.oldTextElementValue = this.textElement.getValue();
          this.textElement.setValue("");
          this.textInput.show();
          this.renameState = true;
        } else {
          this.renameButton.setLabel("Rename");
          this.textInput.hide();
          if (this.textInput.getValue() != "") {
            this.textElement.setValue(this.textInput.getValue());
            let value = this.textInput.getValue();
            let key = this.options.entry.key;
            let request = {
              editKeys: JSON.stringify({
                type: "rename",
                keyId: key.id,
                newValue: value
              })
            };
            ajaxCall(request, () => {
              this.options.entry.table.changed = true;
              this.options.entry.table.redraw();
            });
          } else {
            this.textElement.setValue(this.oldTextElementValue);
          }
          this.renameState = false;
        }
      }
    }
    class TranslationKeyTable extends Table {
      setOptions(options) {
        super.setOptions(options);
        this.editable = false;
      }
      getRowClass() {
        return TranslationKeyTableRow;
      }
      getDefaultColumns() {
        const numberStyle = {
          textAlign: "right"
        };
        return [{
          value: entry => entry.key.id,
          headerName: "Key ID",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => [UI$1.createElement(UI$1.TextElement, {
            ref: "textElement",
            value: entry.key.value
          }), UI$1.createElement(TextInput, {
            ref: "textInput"
          })],
          headerName: "Entry value",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return [UI$1.createElement("div", {
              className: "btn-group"
            }, UI$1.createElement(Button$1, {
              ref: "renameButton",
              label: "Rename",
              level: Level.INFO
            }), UI$1.createElement(Button$1, {
              ref: "deleteButton",
              label: "Delete",
              level: Level.DANGER
            }))];
          },
          headerName: "Actions",
          sortDescending: true
        }];
      }
      onMount() {
        super.onMount();
        this.changed = false;
      }
      getEntryKey(entry, index) {
        return index;
      }
      getEntries() {
        let ret = [];
        for (let key of TranslationKeyStore.all()) {
          ret.push({
            key: key,
            table: this,
            editable: this.editable
          });
        }
        return ret;
      }
      makeEditable() {
        this.editable = true;
        this.redraw();
      }
      makeNoneditable() {
        this.editable = false;
        this.redraw();
      }
    }
    class TranslationKeyManager extends Panel {
      render() {
        let style = {
          display: "inline-block",
          overflow: "auto",
          resize: "none",
          height: "46px",
          width: "300px",
          "vertical-align": "top"
        };
        return [UI$1.createElement("label", null, "Enable editing: \xA0 "), UI$1.createElement(RawCheckboxInput, {
          ref: "editableCheckbox"
        }), UI$1.createElement(TranslationKeyTable, {
          ref: "table"
        }), UI$1.createElement(TextArea, {
          ref: "textArea",
          className: "form-control",
          style: style
        }), UI$1.createElement(Button$1, {
          label: "Add keys",
          ref: "saveButton",
          style: {
            marginLeft: "20px"
          },
          level: Level.INFO
        }), UI$1.createElement(UI$1.TextElement, {
          ref: "addStatus"
        })];
      }
      onMount() {
        super.onMount();
        this.changed = false;
        this.saveButton.addClickListener(() => {
          this.saveKeys();
        });
        this.editableCheckbox.addClickListener(() => {
          this.switchEditable();
        });
      }
      switchEditable() {
        if (this.editableCheckbox.getValue()) {
          this.table.makeEditable();
        } else {
          this.table.makeNoneditable();
        }
      }
      hasChanged() {
        return this.table.changed || this.changed;
      }
      setUnchanged() {
        this.table.changed = false;
        this.changed = false;
      }
      redraw() {
        super.redraw();
      }
      saveKeys() {
        let value = this.textArea.getValue();
        this.textArea.setValue("");
        let request = {
          editKeys: JSON.stringify({
            type: "add",
            keys: value
          })
        };
        this.saveButton.disable();
        this.changed = true;
        ajaxCall(request, data => {
          this.saveButton.setLabel("Success!");
          this.saveButton.setLevel(Level.SUCCESS);
          this.textArea.setValue("");
          this.changed = true;
          this.addStatus.setValue(data.keyInfo.added + " keys added, " + data.keyInfo.alreadyExists + " keys already exists");
          setTimeout(() => {
            this.saveButton.enable();
            this.saveButton.setLabel("Add keys");
            this.saveButton.setLevel(Level.INFO);
            this.addStatus.setValue("");
            this.table.redraw();
          }, 2000);
        }, () => {
          this.saveButton.setLabel("Failed!");
          this.saveButton.setLevel(Level.ERROR);
          setTimeout(() => {
            this.saveButton.enable();
            this.saveButton.setLabel("Add keys");
            this.saveButton.setLevel(Level.INFO);
          }, 700);
        });
      }
    }
    class TranslationManager extends Panel {
      getUrlPrefix(urlPart) {
        let url = "/manage/translation/";
        if (urlPart) {
          url += urlPart + "/";
        }
        return url;
      }
      render() {
        return [UI$1.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, UI$1.createElement(TranslationKeyManager, {
          ref: "keyManager",
          tabHref: this.getUrlPrefix("keys"),
          title: "Edit keys",
          active: true
        }), UI$1.createElement(TranslationEntryManager, {
          ref: "entryManager",
          tabHref: this.getUrlPrefix("entries"),
          title: "Edit entries"
        }))];
      }
      setURL(urlParts) {
        if (!this.tabArea) {
          this.initialUrlParts = urlParts;
        } else {
          this.showUrlTab(urlParts[0] || "keys");
        }
      }
      onMount() {
        super.onMount();
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
        this.tabArea.titleArea.addClass("text-center");
        this.tabArea.children[1].addClickListener(() => {
          if (this.keyManager.hasChanged()) {
            this.entryManager.redraw();
            this.keyManager.setUnchanged();
          }
        });
      }
      showUrlTab(urlPart) {
        if (urlPart === "keys") {
          this.keyManager.dispatch("show");
        } else if (urlPart === "entries") {
          this.entryManager.dispatch("show");
          if (this.keyManager.hasChanged()) {
            this.entryManager.redraw();
            this.keyManager.setUnchanged();
          }
        }
      }
    }

    class DocumentationEntry extends StoreObject {
      getArticle() {
        let article = ArticleStore.get(this.articleId);
        return article && article.getTranslation();
      }
      getParent() {
        return DocumentationEntryStore.get(this.parentId);
      }
      toString() {
        return this.getName();
      }
      getFullURL() {
        let parent = this.getParent();
        if (parent) {
          return parent.getFullURL() + "/" + this.urlName;
        } else {
          return this.urlName;
        }
      }
      getName() {
        return this.name || this.getArticle().getName();
      }
      getParentIndex() {
        return this.parentIndex || this.id;
      }
      getEntries() {
        let entries = [];
        for (let documentationEntry of DocumentationEntryStore.all()) {
          if (documentationEntry.parentId === this.id) {
            entries.push(documentationEntry);
          }
        }
        entries.sort((a, b) => {
          return a.getParentIndex() - b.getParentIndex();
        });
        return entries;
      }
    }
    class DocumentationEntryStoreClass extends GenericObjectStore {
      constructor() {
        super("DocumentationEntry", DocumentationEntry);
      }
    }
    let DocumentationEntryStore = new DocumentationEntryStoreClass();

    class EditEntryModal extends ActionModal {
      getTitle() {
        return "Edit documentation entry";
      }
      getActionName() {
        return "Apply";
      }
      getEntry() {
        return this.options.entry;
      }
      getParentInput() {}
      getAjaxUrl() {
        return "/docs/edit_entry/";
      }
      getAjaxRequest() {
        return {
          entryId: this.getEntry().id,
          urlName: this.urlNameInput.getValue(),
          name: this.nameInput.getValue(),
          articleId: parseInt(this.articleIdInput.getValue()) || 0,
          parentIndex: parseInt(this.parentIndexInput.getValue()) || 0
        };
      }
      getBody() {
        return [UI$1.createElement(Form, {
          style: {
            marginTop: "10px",
            color: "initial",
            fontSize: "initial"
          }
        }, UI$1.createElement(FormField, {
          label: "URL name",
          style: {
            fontWeight: "initial"
          }
        }, UI$1.createElement(TextInput, {
          ref: "urlNameInput",
          value: this.getEntry().urlName
        })), UI$1.createElement(FormField, {
          label: "Name",
          style: {
            fontWeight: "initial"
          }
        }, UI$1.createElement(TextInput, {
          ref: "nameInput",
          value: this.getEntry().name
        })), UI$1.createElement(FormField, {
          label: "Article Id",
          style: {
            fontWeight: "initial"
          }
        }, UI$1.createElement(TextInput, {
          ref: "articleIdInput",
          value: this.getEntry().articleId,
          placeholder: "Enter 0 (or leave blank) to create a new article instead"
        })), this.getParentInput(), UI$1.createElement(FormField, {
          label: "Parent index",
          style: {
            fontWeight: "initial"
          }
        }, UI$1.createElement(TextInput, {
          ref: "parentIndexInput",
          value: this.getEntry().parentIndex
        })))];
      }
      check(data) {
        if (!data.urlName) {
          return "URL name cannot be empty.";
        }
        if (!data.name) {
          return "Name cannot be empty.";
        }
        for (let entry of DocumentationEntryStore.all()) {
          if (entry === this.getEntry()) {
            continue;
          }
          if (entry.getName() === data.name) {
            return "Name already exists.";
          }
          if (entry.urlName === data.urlName) {
            return "URL name already exists";
          }
        }
      }
      action() {
        let request = this.getAjaxRequest();
        let errorMessage = this.check(request);
        if (!errorMessage) {
          Ajax.postJSON(this.getAjaxUrl(), request);
        } else {
          this.messageArea.showMessage(errorMessage, "red");
        }
        this.hide();
      }
    }
    class CreateEntryModal extends EditEntryModal {
      getTitle() {
        return "Create documentation entry";
      }
      getActionName() {
        return "Create";
      }
      getEntry() {
        return {
          urlName: "",
          name: "",
          articleId: "",
          parentIndex: "",
          id: 0
        };
      }
      getParentInput() {
        let entries = DocumentationEntryStore.all();
        entries.push({
          toString: () => {
            return "No Parent";
          },
          id: 0
        });
        return UI$1.createElement(FormField, {
          label: "Parent",
          style: {
            fontWeight: "initial"
          }
        }, UI$1.createElement(Select, {
          ref: "parentInput",
          options: entries,
          selected: entries[entries.length - 1],
          style: {
            height: "30px"
          }
        }));
      }
      getAjaxUrl() {
        return "/docs/create/";
      }
      getAjaxRequest() {
        let request = super.getAjaxRequest();
        request.parentId = this.parentInput.get().id;
        return request;
      }
    }
    const CreateEntryButton = ActionModalButton(CreateEntryModal);

    var _class$a, _descriptor$9, _descriptor2$9, _descriptor3$8, _descriptor4$8, _descriptor5$7, _descriptor6$5;
    let DocumentationStyle = (_class$a = class DocumentationStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        _initializerDefineProperty(this, "panel", _descriptor$9, this);
        _initializerDefineProperty(this, "navPanel", _descriptor2$9, this);
        _initializerDefineProperty(this, "article", _descriptor3$8, this);
        _initializerDefineProperty(this, "articleSwitcher", _descriptor4$8, this);
        _initializerDefineProperty(this, "navElementDiv", _descriptor5$7, this);
        _initializerDefineProperty(this, "documentationPanel", _descriptor6$5, this);
      }
    }, (_descriptor$9 = _applyDecoratedDescriptor(_class$a.prototype, "panel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%"
        };
      }
    }), _descriptor2$9 = _applyDecoratedDescriptor(_class$a.prototype, "navPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "20%",
          maxWidth: "20%",
          height: "100%",
          display: "inline-block",
          float: "left",
          backgroundColor: "#f2f4f9",
          color: "#252525",
          overflowX: "auto",
          overflowY: "auto"
        };
      }
    }), _descriptor3$8 = _applyDecoratedDescriptor(_class$a.prototype, "article", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "80%",
          maxWidth: "80%",
          backgroundColor: "#f2f4f9",
          minHeight: "100%",
          maxHeight: "100%",
          height: "100%",
          display: "inline-block",
          overflowX: "hidden",
          overflowY: "scroll"
        };
      }
    }), _descriptor4$8 = _applyDecoratedDescriptor(_class$a.prototype, "articleSwitcher", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "960px",
          maxWidth: "100%",
          textAlign: "justify",
          // TODO: DO WE WANT THIS ?
          paddingTop: "25px",
          // TODO: HERE, A BETTER PADDING
          paddingBottom: "30px",
          minHeight: "100%",
          marginBottom: "-5px",
          display: "inline-block",
          paddingLeft: "5%",
          paddingRight: "5%",
          backgroundColor: "#fff",
          height: "auto !important"
        };
      }
    }), _descriptor5$7 = _applyDecoratedDescriptor(_class$a.prototype, "navElementDiv", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px",
          paddingLeft: "12px",
          paddingTop: ".75em",
          paddingBottom: ".75em"
        };
      }
    }), _descriptor6$5 = _applyDecoratedDescriptor(_class$a.prototype, "documentationPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => window.innerHeight - 45 + "px",
          overflow: "hidden",
          position: "absolute",
          minWidth: "100%",
          maxWidth: "100%",
          backgroundColor: "#fff"
        };
      }
    })), _class$a);

    class CollapseIconClass extends FACollapseIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        if (!this.options.collapsed) {
          // this is not really a hack, but we might want this with em?
          attr.setStyle("margin-left", "-2px");
          attr.setStyle("margin-right", "2px");
        }
      }
      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
          this.options.parent.toggleCollapsed();
        });
      }
    }
    class DocumentationNavElementContent extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(DocumentationStyle.getInstance().navElementDiv); // TODO: add this later

        // TODO: this should be in 2 separate classes
        if (this.options.active) {
          attr.setStyle("backgroundColor", "#2980b9");
          attr.setStyle("color", "#161616");
          attr.setStyle("fontWeight", "bold");
        } else {
          attr.setStyle("backgroundColor", "#f2f4f9");
          attr.setStyle("color", "#161616");
        }
      }
      setCollapsed(collapsed) {
        if (this.options.collapsed === collapsed) {
          return;
        }
        this.options.collapsed = collapsed;
        if (!this.options.shouldToggle) {
          return;
        }
        this.collapseIcon.setCollapsed(collapsed);
        this.dispatch("toggleCollapsed");
      }
      toggleCollapsed() {
        this.setCollapsed(!this.options.collapsed);
      }
      setActive(active) {
        this.options.active = active;
        this.redraw();
        if (active) {
          let documentationSwitchDispatcher = this.options.documentationSwitchDispatcher;
          documentationSwitchDispatcher.dispatch(this.options.documentationEntry);
          documentationSwitchDispatcher.addListenerOnce(documentationEntry => {
            if (documentationEntry != this.options.documentationEntry) {
              this.setActive(false);
            }
          });
          this.dispatch("setActive", active);
        }
      }
      render() {
        let collapseIcon;
        if (this.options.shouldToggle) {
          collapseIcon = UI$1.createElement(CollapseIconClass, {
            ref: "collapseIcon",
            collapsed: this.options.collapsed,
            style: {
              width: "0.8em"
            },
            parent: this
          });
        }

        // If the collapse Icon shouldn't be displayed, we should add the additional 12px width in order to keep the tags aligned
        let alignTagsStyle = {};
        if (!this.options.shouldToggle) {
          alignTagsStyle = {
            "padding-left": "12px"
          };
        }
        return [collapseIcon, UI$1.createElement("span", {
          style: alignTagsStyle
        }, UI$1.T(this.options.documentationEntry.getName()))];
      }
      onMount() {
        if (this.options.active) {
          this.setActive(true);
        }
        this.addClickListener(() => {
          this.setActive(true);
          if (this.options.shouldToggle) {
            this.toggleCollapsed();
          }
        });
      }
    }
    const dragAndDropHandler = new Dispatcher();
    class DraggableDocumentationNavElementContent extends Draggable(DocumentationNavElementContent) {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("cursor", "pointer");
        return attr;
      }
      getDocumentationEntry() {
        return this.options.parent.getDocumentationEntry();
      }
      render() {
        return [super.render(), UI$1.createElement("span", {
          className: "fa fa-pencil-square-o",
          ref: "editEntry",
          style: {
            "cursor": "pointer",
            "margin-right": "10px",
            "float": "right"
          }
        })];
      }
      getDirectOffsets() {
        return {
          top: this.node.offsetTop,
          left: this.node.offsetLeft,
          height: this.node.offsetHeight,
          width: this.node.offsetWidth
        };
      }
      getOffset(type) {
        return this.getDirectOffsets()[type];
      }
      onMount() {
        super.onMount();
        this.editEntry.addClickListener(() => {
          EditEntryModal.show({
            entry: this.getDocumentationEntry()
          });
        });
        if (!this.options.parent.options.isRoot) {
          let totalDelta = 0;
          this.addDragListener({
            onStart: () => {
              totalDelta = 0;
            },
            onDrag: (deltaX, deltaY) => {
              totalDelta += deltaY;
              if (!this.dragged && Math.abs(totalDelta) > 30) {
                this.dragged = true;
                this.setStyle("cursor", "move");
                if (this.options.shouldToggle) {
                  this.setCollapsed(true);
                }
                this.setStyle("position", "absolute");
                this.setStyle("border", "2px solid red");
                this.setStyle("border-radius", "3px");
                this.setStyle("width", this.node.offsetWidth + 20 + "px");
                this.setStyle("opacity", 0.85);
                deltaY = totalDelta;
              }
              if (this.dragged) {
                this.setStyle("left", this.getOffset("left") + deltaX + "px");
                this.setStyle("top", this.getOffset("top") + deltaY + "px");
                dragAndDropHandler.dispatch("drag", this, this.getOffset("top"));
              }
            },
            onEnd: () => {
              if (this.dragged) {
                this.dragged = false;
                dragAndDropHandler.dispatch("drop", this, this.getOffset("top"));
              }
            }
          });
        }
      }
    }
    const DocumentationNavElement = ContentClass => class DocumentationNavElementClass extends UI$1.Element {
      getDefaultOptions() {
        return {
          collapsed: true
        };
      }
      extraNodeAttributes(attr) {
        attr.setStyle("cursor", "pointer");
        attr.setStyle("padding-left", ((this.options.level || 0) > 0 ? 12 : 0) + "px");
      }
      getDocumentationEntry() {
        return this.options.documentationEntry;
      }
      render() {
        let level = this.options.level || 0;
        let collapsed = this.options.collapsed && !this.options.isRoot;
        this.subEntries = this.subEntries || [];
        const subEntries = this.getDocumentationEntry().getEntries().map((subEntry, index) => UI$1.createElement(DocumentationNavElementClass, {
          documentationEntry: subEntry,
          ref: this.refLinkArray("subEntries", index),
          level: this.options.isRoot ? level : level + 1,
          panel: this.options.panel,
          documentationSwitchDispatcher: this.options.documentationSwitchDispatcher
        }));
        let content = UI$1.createElement(ContentClass, {
          ref: "titleElement",
          documentationEntry: this.getDocumentationEntry(),
          shouldToggle: subEntries.length && !this.options.isRoot,
          collapsed: collapsed,
          parent: this,
          documentationSwitchDispatcher: this.options.documentationSwitchDispatcher
        });
        return [content,
        // TODO: should be hidden, depending on collapsed
        // TODO: do something consistent about this hidden stuff
        UI$1.createElement("div", {
          ref: "subEntryArea",
          className: collapsed ? "hidden" : ""
        }, subEntries)];
      }
      showArticle() {
        let documentationEntry = this.getDocumentationEntry();
        this.options.panel.setArticle(documentationEntry);
      }
      onMount() {
        // TODO: a bit too many listeners here, should probably be done the other way around?
        this.titleElement.addListener("toggleCollapsed", () => {
          this.subEntryArea.toggleClass("hidden");
        });
        this.attachListener(this.getDocumentationEntry(), "show", () => {
          this.showArticle();
          this.titleElement.setActive(true);
        });
        this.attachListener(this.getDocumentationEntry(), "setCollapsed", collapsed => {
          this.titleElement.setCollapsed(collapsed);
        });
        this.titleElement.addListener("setActive", active => {
          if (active) {
            this.showArticle();
          }
        });
      }
    };
    const SimpleDocumentationNavElement = DocumentationNavElement(DocumentationNavElementContent);
    const DraggableDocumentationNavElement = DocumentationNavElement(DraggableDocumentationNavElementContent);

    var _dec$9, _class$9;
    let DocumentationPanel = (_dec$9 = registerStyle(DocumentationStyle), _dec$9(_class$9 = class DocumentationPanel extends UI$1.Element {
      constructor() {
        super(...arguments);
        this.documentationSwitchDispatcher = new Dispatcher();
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.documentationPanel);
      }
      getDocumentationEntry() {
        return DocumentationEntryStore.get(this.options.documentationEntryId);
      }
      render() {
        const documentationEntry = this.getDocumentationEntry();
        return [UI$1.createElement(Panel, {
          orientation: Orientation$1.HORIZONTAL,
          className: this.styleSheet.panel
        }, UI$1.createElement(Panel, {
          ref: "navPanel",
          className: this.styleSheet.navPanel
        }, UI$1.createElement(SimpleDocumentationNavElement, {
          documentationEntry: documentationEntry,
          isRoot: true,
          panel: this,
          level: 0,
          documentationSwitchDispatcher: this.documentationSwitchDispatcher
        })), UI$1.createElement(Panel, {
          className: this.styleSheet.article
        }, UI$1.createElement(ArticleSwitcher, {
          ref: "articleSwitcher",
          className: this.styleSheet.articleSwitcher,
          initialArticle: documentationEntry.getArticle(),
          lazyRender: true
        })))];
      }
      getBaseUrl() {
        return "/docs/";
      }
      getUrlPrefix(suffix) {
        let url = this.getBaseUrl();
        if (suffix) {
          url += suffix + "/";
        }
        return url;
      }
      checkUrl(urlParts, documentationEntry) {
        return documentationEntry.getFullURL() === urlParts.join("/");
      }
      setURL(urlParts) {
        if (this.articleSwitcher) {
          for (let documentationEntry of DocumentationEntryStore.all()) {
            if (this.checkUrl(urlParts, documentationEntry)) {
              this.focusToDocumentationEntry(documentationEntry);
              return;
            }
          }
        } else {
          this.initialUrlParts = urlParts;
        }
      }
      setArticle(documentationEntry) {
        this.articleSwitcher.setActive(documentationEntry.getArticle());
        Router.changeURL(this.getUrlPrefix(documentationEntry.getFullURL()));
      }
      focusToDocumentationEntry(documentationEntry) {
        documentationEntry.dispatch("show");
        this.uncollapsePathTo(documentationEntry);
      }
      uncollapsePathTo(documentationEntry) {
        while (documentationEntry) {
          documentationEntry.dispatch("setCollapsed", false);
          documentationEntry = documentationEntry.getParent();
        }
      }
      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
      }
    }) || _class$9);

    class AdminDocumentationPanel extends DocumentationPanel {
      getBaseUrl() {
        return "/docs/edit/";
      }
      getDocumentationEntry() {
        let documentationEntry = DocumentationEntryStore.get(1);
        documentationEntry.getEntries = function () {
          let entries = [];
          for (let documentationEntry of DocumentationEntryStore.all()) {
            if ((documentationEntry.parentId === this.id || !documentationEntry.parentId) && documentationEntry.id !== this.id) {
              entries.push(documentationEntry);
            }
          }
          entries.sort((a, b) => {
            return a.getParentIndex() - b.getParentIndex();
          });
          return entries;
        };
        return documentationEntry;
      }
      render() {
        const documentationEntry = this.getDocumentationEntry();
        return [UI$1.createElement(Panel, {
          orientation: Orientation.HORIZONTAL,
          className: this.styleSheet.panel,
          key: "container"
        }, UI$1.createElement(Panel, {
          ref: "navPanel",
          className: this.styleSheet.navPanel
        }, UI$1.createElement("div", {
          style: {
            maxHeight: "90%",
            overflowY: "auto"
          },
          key: "navigationContainer"
        }, UI$1.createElement(DraggableDocumentationNavElement, {
          ref: "root",
          documentationEntry: documentationEntry,
          isRoot: true,
          panel: this,
          level: 0,
          documentationSwitchDispatcher: this.documentationSwitchDispatcher
        })), UI$1.createElement("div", {
          style: {
            position: "absolute",
            bottom: "5%"
          }
        }, UI$1.createElement(Button$1, {
          ref: "trash",
          icon: "trash",
          disabled: true,
          level: Level.WARNING,
          size: Size.EXTRA_LARGE,
          style: {
            marginLeft: "50px",
            padding: "16px 22px"
          }
        }), UI$1.createElement(CreateEntryButton, {
          icon: "plus",
          level: Level.PRIMARY,
          size: Size.EXTRA_LARGE,
          style: {
            marginLeft: "50px",
            padding: "16px 22px"
          }
        }))), UI$1.createElement(Panel, {
          className: this.styleSheet.article
        }, UI$1.createElement(ArticleSwitcher, {
          ref: "articleSwitcher",
          initialArticle: documentationEntry.getArticle(),
          lazyRender: true,
          showEditButton: true,
          className: this.styleSheet.articleSwitcher
        })))];
      }
      checkUrl(urlParts, documentationEntry) {
        return "edit/" + documentationEntry.getFullURL() === urlParts.join("/");
      }
      getNavElement(entry) {
        let explore = entryNavElement => {
          if (entryNavElement.getDocumentationEntry() === entry) {
            return entryNavElement;
          }
          let navElement = null;
          for (let subEntry of entryNavElement.subEntries) {
            navElement = navElement || explore(subEntry);
          }
          return navElement;
        };
        explore(this.root);
      }
      modifyEntry(entry, newParent, nextSibling) {
        let modified = [];
        if (newParent === -1) {
          modified.push({
            entryId: entry.id,
            parentId: -1
          });
          DocumentationEntryStore.applyDeleteEvent({
            objectId: entry.id
          });
        } else if (!newParent) {
          entry.parentId = null;
          entry.parentIndex = null;
          modified.push({
            entryId: entry.id,
            parentId: 0,
            parentIndex: 0
          });
        } else {
          let newBrothers = [];
          for (let docEntry of DocumentationEntryStore.all()) {
            if (docEntry.parentId === newParent.id && docEntry !== entry) {
              newBrothers.push(docEntry);
            }
          }
          newBrothers.sort((a, b) => {
            return a.parentIndex - b.parentIndex;
          });
          entry.parentId = newParent.id;
          if (newBrothers.length) {
            newBrothers[0].parentIndex = 1;
            if (nextSibling === newBrothers[0]) {
              entry.parentIndex = 1;
              newBrothers[0].parentIndex = 2;
            }
            modified.push({
              entryId: newBrothers[0].id,
              parentIndex: newBrothers[0].parentIndex
            });
            for (let i = 1; i < newBrothers.length; i += 1) {
              newBrothers[i].parentIndex = newBrothers[i - 1].parentIndex + 1;
              if (newBrothers[i] === nextSibling) {
                entry.parentIndex = newBrothers[i].parentIndex;
                newBrothers[i].parentIndex += 1;
              }
              modified.push({
                entryId: newBrothers[i].id,
                parentIndex: newBrothers[i].parentIndex
              });
            }
            if (!nextSibling) {
              entry.parentIndex = newBrothers.length + 1;
            }
          }
          modified.push({
            entryId: entry.id,
            parentId: newParent.id,
            parentIndex: entry.parentIndex
          });
        }
        Ajax.postJSON("/docs/change_parents/", {
          modifiedEntries: JSON.stringify(modified)
        });
      }
      setTarget(element, eventType, borderType, visibleEntries) {
        for (let visibleElement of visibleEntries) {
          visibleElement.titleElement.setStyle("border", "");
          visibleElement.titleElement.setStyle("border-top", "");
          visibleElement.titleElement.setStyle("border-bottom", "");
        }
        this.trash.setLevel(Level.WARNING);
        if (!element) {
          this.trash.setLevel(Level.DANGER);
          return;
        }
        if (eventType === "drag") {
          element.titleElement.setStyle(borderType, "2px solid red");
          return [null, null, null];
        } else {
          let newParent, nextSibling;
          // Drop: add the element to its new position
          if (borderType === "border") {
            newParent = element.getDocumentationEntry();
            nextSibling = null;
            for (let docEntry of DocumentationEntryStore.all()) {
              if (docEntry.parentId === newParent.id && (nextSibling === null || nextSibling.parentIndex > docEntry.parentIndex)) {
                nextSibling = docEntry;
              }
            }
          } else if (borderType === "border-top") {
            nextSibling = element.getDocumentationEntry();
            newParent = DocumentationEntryStore.get(nextSibling.parentId);
          } else {
            nextSibling = element.getDocumentationEntry();
            newParent = DocumentationEntryStore.get(nextSibling.parentId);
            nextSibling = null;
          }
          return [newParent, nextSibling];
        }
      }
      getTrashOffset() {
        // -50px for the navbar
        return getOffset(this.trash).top - 50;
      }
      redrawAndUncollapse(visibleEntries, entry) {
        this.redraw();
        let exploreAndUncollapse = entryNavElement => {
          if (entryNavElement.getDocumentationEntry() === entry) {
            return;
          }
          if (visibleEntries.indexOf(entryNavElement.getDocumentationEntry()) !== -1 && entryNavElement.getDocumentationEntry().parentId) {
            let parentEntry = DocumentationEntryStore.get(entryNavElement.getDocumentationEntry().parentId);
            let parentEntryNavElement = this.getNavElement(parentEntry);
            if (parentEntryNavElement && parentEntryNavElement.titleElement.options.shouldToggle) {
              parentEntryNavElement.titleElement.setCollapsed(false);
            }
          }
          for (let subEntry of entryNavElement.subEntries) {
            exploreAndUncollapse(subEntry);
          }
        };
        exploreAndUncollapse(this.root);
      }
      getVisibleEntries(draggedItem) {
        let visibleEntries = [];
        let exploreEntries = entryNavElement => {
          if (entryNavElement.titleElement === draggedItem) {
            return;
          }
          visibleEntries.push(entryNavElement);
          if (!entryNavElement.titleElement.options.collapsed) {
            for (let subEntry of entryNavElement.subEntries) {
              exploreEntries(subEntry);
            }
          }
        };
        exploreEntries(this.root);
        return visibleEntries;
      }
      onMount() {
        super.onMount();
        this.attachCreateListener(DocumentationEntryStore, entry => {
          this.attachChangeListener(entry, () => {
            this.focusToDocumentationEntry(entry);
          });
        }, true);
        dragAndDropHandler.addListener((type, draggedItem, top) => {
          let titleHeight = 40;
          let visibleEntries = this.getVisibleEntries(draggedItem);
          if (!visibleEntries.length) {
            return;
          }

          // TODO: Refactor this! Make UIElement or NodeWrapper support direct offsets
          let getTop = element => {
            return element.titleElement.getOffset("top");
          };
          visibleEntries.sort((a, b) => {
            return getTop(a) - getTop(b);
          });
          let entry = draggedItem.getDocumentationEntry(),
            newParent = null,
            nextSibling = null;
          if (Math.abs(this.getTrashOffset() - top) < titleHeight * 2) {
            newParent = -1;
            this.setTarget(null, type, "border", visibleEntries);
          } else {
            if (getTop(visibleEntries[0]) > top) {
              [newParent, nextSibling] = this.setTarget(visibleEntries[0], type, "border-top", visibleEntries);
            } else if (getTop(visibleEntries[visibleEntries.length - 1]) + titleHeight * 0.25 < top) {
              [newParent, nextSibling] = this.setTarget(visibleEntries[visibleEntries.length - 1], type, "border-bottom", visibleEntries);
            } else {
              let bordered = false;
              for (let visibleEntry of visibleEntries) {
                if (Math.abs(getTop(visibleEntry) - top) < titleHeight * 0.25) {
                  [newParent, nextSibling] = this.setTarget(visibleEntry, type, "border", visibleEntries);
                  bordered = true;
                  break;
                }
              }
              if (!bordered) {
                for (let i = 0; i < visibleEntries.length; i += 1) {
                  if (getTop(visibleEntries[i]) > top) {
                    if (i > 0 && top - getTop(visibleEntries[i - 1]) < getTop(visibleEntries[i]) - top && visibleEntries[i].getDocumentationEntry().parentId !== visibleEntries[i - 1].getDocumentationEntry().id) {
                      [newParent, nextSibling] = this.setTarget(visibleEntries[i - 1], type, "border-bottom", visibleEntries);
                    } else {
                      [newParent, nextSibling] = this.setTarget(visibleEntries[i], type, "border-top", visibleEntries);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (type === "drop") {
            let changePosition = modifyEntry => {
              if (modifyEntry) {
                this.modifyEntry(entry, newParent, nextSibling);
              }
              this.redraw();
              this.focusToDocumentationEntry(entry);
            };
            if (newParent === -1) {
              if (window.confirm("Are you sure you want to delete this entry and all it's sub-entries?")) {
                changePosition(true);
              } else {
                changePosition(false);
              }
            } else {
              changePosition(true);
            }
          }
        });
      }
    }

    // Particular case for /docs/ and /docs/edit/
    class DocumentationRoute extends TerminalRoute {
      constructor() {
        super("docs", StateDependentElement(DocumentationPanel), "Documentation");
        this.subroutes = [new TerminalRoute("edit", StateDependentElement(AdminDocumentationPanel), [], "Edit Documentation")];
      }
      matchesOwnNode(urlParts) {
        return urlParts.length === 0 || urlParts[0] !== "edit";
      }
    }

    class AnalyticsPanel extends UI$1.Element {
      render() {
        return UI$1.createElement(CardPanel, {
          title: "Analytics Panel",
          level: Level.PRIMARY,
          style: {
            margin: "10px 30%"
          }
        }, UI$1.createElement("div", {
          style: {
            padding: "5px"
          }
        }, "Analytics is not online right now!"));
      }
    }

    class AceCardPanel extends CardPanel {
      getDefaultOptions() {
        return {
          bodyStyle: {
            padding: "0"
          }
        };
      }
    }

    // This class uses a base user submission as an input to render the code source and details about the code.
    class SourceCardPanel extends AceCardPanel {
      getDefaultOptions() {
        // Currently, only custom runs are forkable.
        return Object.assign({
          fork: false
        }, super.getDefaultOptions());
      }
      getProgrammingLanguage() {
        return this.options.job.getProgrammingLanguage();
      }
      getTitle() {
        let buttonStyle = {
          margin: "0.3em"
        };
        const forkButton = this.options.forkable ? UI$1.createElement(AjaxButton, {
          ref: "forkButton",
          level: Level.INFO,
          size: Size.SMALL,
          style: buttonStyle,
          statusOptions: [{
            icon: "code-fork",
            label: UI$1.T("Fork")
          }, {
            icon: "spinner fa-spin",
            label: " creating workspace..."
          }, "Success", "Failed"]
        }) : null;
        return [UI$1.createElement("span", {
          style: buttonStyle
        }, this.getProgrammingLanguage().toString()), UI$1.createElement("span", {
          style: buttonStyle
        }, Formatter.memory(this.options.job.getSize())), UI$1.createElement(Button$1, {
          ref: "downloadSourceButton",
          label: UI$1.T("Download"),
          level: Level.INFO,
          size: Size.SMALL,
          icon: "download",
          style: buttonStyle
        }), UI$1.createElement(Button$1, {
          label: UI$1.T("Copy to clipboard"),
          icon: "files-o",
          style: buttonStyle,
          level: Level.INFO,
          size: Size.SMALL,
          onClick: () => this.sourceCodeHighlighter.copyTextToClipboard()
        }), forkButton];
      }
      render() {
        let codeHighlighterOptions = {};
        if (this.getProgrammingLanguage()) {
          codeHighlighterOptions.aceMode = this.getProgrammingLanguage().aceMode;
        }
        return UI$1.createElement(StaticCodeHighlighter, _extends({
          ref: "sourceCodeHighlighter"
        }, codeHighlighterOptions, {
          value: this.options.job.sourceText,
          maxLines: 512
        }));
      }
      onMount() {
        this.downloadSourceButton.addClickListener(() => {
          let fileContentBlob = new Blob([this.options.job.sourceText], {
            type: "text/plain;charset=utf-8"
          });
          let programmingLanguage = this.getProgrammingLanguage();
          let fileName = this.options.name;
          if (programmingLanguage) {
            fileName += "." + programmingLanguage.getExtension();
          }
          FileSaver.saveAs(fileContentBlob, fileName);
        });
        if (this.options.forkable) {
          this.forkButton.addClickListener(() => {
            if (USER.isAuthenticated) {
              this.forkToWorkspace();
            } else {
              window.open("/workspace/fork/" + this.options.job.urlHash, "_blank");
            }
          });
        }
      }

      // This fork works only for custom runs.
      forkToWorkspace() {
        if (this.options.forkable) {
          this.forkButton.postJSON("/eval/fork_custom_run/", {
            customRunId: this.options.job.id
          }).then(data => window.open("/workspace/" + data.workspaceId, "_blank"));
        }
      }
    }
    class InputCardPanel extends AceCardPanel {
      getTitle() {
        return UI$1.T("Input");
      }
      render() {
        return UI$1.createElement(StaticCodeHighlighter, {
          value: this.options.customRun.stdin,
          maxLines: 32
        });
      }
    }
    class OutputCardPanel extends AceCardPanel {
      getTitle() {
        return UI$1.T("Output");
      }
      render() {
        return UI$1.createElement(StaticCodeHighlighter, {
          value: this.options.customRun.stdout,
          maxLines: 32
        });
      }
    }
    class StderrCardPanel extends AceCardPanel {
      getTitle() {
        return UI$1.T("Stderr");
      }
      render() {
        return UI$1.createElement(StaticCodeHighlighter, {
          value: this.options.customRun.stderr,
          maxLines: 32
        });
      }
    }
    class CompilationCardPanel extends CardPanel {
      getTitle() {
        return UI$1.T("Compilation");
      }
      render() {
        return UI$1.createElement(CompilationStatusPanel, {
          customRun: this.options.customRun
        });
      }
    }
    class CustomRunPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(GlobalStyle.Container.SMALL);
        attr.setStyle("marginBottom", "20px");
      }
      render() {
        let ioPanel;
        let executionStatusPanel;
        if (!this.options.customRun.compileOnly) {
          ioPanel = this.getIOPanel();
          executionStatusPanel = UI$1.createElement(ExecutionStatusPanel, {
            customRun: this.options.customRun
          });
        }
        let result = [UI$1.createElement("div", {
          style: {
            margin: "25px 0"
          }
        }, UI$1.createElement(SourceCardPanel, {
          job: this.options.customRun,
          name: this.options.customRun.urlHash,
          forkable: true
        }))];
        if (!this.options.customRun.shareOnly) {
          result = [...result, ioPanel, UI$1.createElement("div", {
            style: {
              margin: "25px 0"
            }
          }, UI$1.createElement(CompilationCardPanel, {
            customRun: this.options.customRun
          })), executionStatusPanel];
        }
        return result;
      }
      getIOPanel() {
        let stderrPanel;
        if (this.options.customRun.stderr) {
          stderrPanel = UI$1.createElement(StderrCardPanel, {
            customRun: this.options.customRun
          });
        }
        return UI$1.createElement("div", {
          style: {
            margin: "25px 0"
          }
        }, UI$1.createElement("div", {
          className: `${GlobalStyle.FlexContainer.HORIZONTAL}`
        }, UI$1.createElement(InputCardPanel, {
          customRun: this.options.customRun
        }), UI$1.createElement(OutputCardPanel, {
          customRun: this.options.customRun
        }), stderrPanel));
      }
    }
    class CustomRunWidget extends UI$1.Element {
      render() {
        const customRun = CustomRunStore.get(this.options.customRunId);
        return customRun && UI$1.createElement(CustomRunPanel, {
          customRun: customRun
        });
      }
    }

    var _class$8, _descriptor$8, _descriptor2$8, _descriptor3$7, _descriptor4$7, _dec$8, _class2$7;
    class SubmissionResultsTable extends CardPanel {
      getTitle() {
        return UI$1.T("Results");
      }
      render() {
        return UI$1.createElement(EvalJobResultsTable, {
          evalJob: this.options.evalJob
        });
      }
    }
    class SubmissionSummaryCardPanel extends CardPanel {
      getTitle() {
        return UI$1.T("Summary");
      }
      render() {
        const evalJobUIHandler = new EvalJobUIHandler(this.options.evalJob);
        return UI$1.createElement("div", {
          style: {
            padding: 10
          }
        }, evalJobUIHandler.getSummary());
      }
    }
    let SubmissionWidgetStyle = (_class$8 = class SubmissionWidgetStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$8, this);
        _initializerDefineProperty(this, "section", _descriptor2$8, this);
        _initializerDefineProperty(this, "flexSection", _descriptor3$7, this);
        _initializerDefineProperty(this, "cardPanels", _descriptor4$7, this);
      }
    }, (_descriptor$8 = _applyDecoratedDescriptor(_class$8.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "20px",
          width: "1200px",
          marginLeft: 15,
          marginRight: 15,
          maxWidth: "calc(100% - 30px)"
        };
      }
    }), _descriptor2$8 = _applyDecoratedDescriptor(_class$8.prototype, "section", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "25px 0"
        };
      }
    }), _descriptor3$7 = _applyDecoratedDescriptor(_class$8.prototype, "flexSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column"
          // flexWrap: "wrap",
        };
      }
    }), _descriptor4$7 = _applyDecoratedDescriptor(_class$8.prototype, "cardPanels", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: 25,
          flex: 1
        };
      }
    })), _class$8);
    let SubmissionPanel = (_dec$8 = registerStyle(SubmissionWidgetStyle), _dec$8(_class2$7 = class SubmissionPanel extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }
      render() {
        // TODO: Change the name passed to the Source Card Panel
        const {
          styleSheet
        } = this;
        const {
          evalJob
        } = this.options;
        return [UI$1.createElement("div", {
          className: styleSheet.section
        }, UI$1.createElement(SourceCardPanel, {
          job: evalJob,
          name: evalJob.id,
          forkable: false
        })), UI$1.createElement("div", {
          className: styleSheet.flexSection
        }, UI$1.createElement(SubmissionSummaryCardPanel, {
          evalJob: evalJob,
          className: styleSheet.cardPanels
        }), UI$1.createElement(CompilationCardPanel, {
          customRun: evalJob,
          className: styleSheet.cardPanels
        })), UI$1.createElement(SubmissionResultsTable, {
          evalJob: evalJob,
          bodyStyle: {
            padding: "0% 2%"
          }
        })];
      }
    }) || _class2$7);
    class SubmissionWidget extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          justifyContent: "center"
        });
      }
      renderNotLoaded() {
        let renderLoading = StateDependentElement.renderLoading;
        if (typeof renderLoading === "function") {
          renderLoading = renderLoading();
        }
        return renderLoading;
      }
      renderError() {
        let renderError = StateDependentElement.renderError;
        if (typeof renderError === "function") {
          renderError = renderError({
            message: "Could not find submission with id " + this.options.args[0]
          });
        }
        return renderError;
      }
      render() {
        const evalJobId = parseInt(this.options.args[0]);
        if (this.options.notPublic) {
          return this.renderError();
        }
        const evalJob = EvalJobStore.get(evalJobId);
        if (evalJob) {
          return UI$1.createElement(SubmissionPanel, {
            evalJob: evalJob
          });
        }
        EvalJobStore.fetchWithContest(evalJobId, () => this.redraw(), () => this.updateOptions({
          notPublic: true
        }));
        return this.renderNotLoaded();
      }
    }

    class PasswordResetFromKey extends UI$1.Element {
      render() {
        if (this.options.tokenFail) {
          return [UI$1.createElement("div", {
            className: "col-sm-8 col-sm-offset-2 text-center"
          }, UI$1.createElement("h1", null, "Invalid password reset link"), UI$1.createElement("p", null, "The password reset link is invalid, either because it has already been used or has been copied incorrectly from the email. Please request a ", UI$1.createElement(Link, {
            href: "/accounts/password_reset/",
            value: "new password reset"
          }), "."))];
        }
        return [UI$1.createElement("div", {
          className: "text-center"
        }, UI$1.createElement("h1", null, "Set password")), UI$1.createElement(FormField, {
          ref: "passwordFormField",
          label: "New password"
        }, UI$1.createElement(PasswordInput, {
          ref: "passwordInput"
        })), UI$1.createElement(FormField, {
          label: " "
        }, UI$1.createElement("div", null, UI$1.createElement(AjaxButton, {
          ref: "setPasswordButton",
          level: Level.PRIMARY,
          onClick: () => this.setNewPassword(),
          statusOptions: ["Set password", {
            icon: "spinner fa-spin",
            label: " Setting..."
          }, "Password set", "Password failed"]
        })))];
      }
      setNewPassword() {
        this.passwordFormField.removeError();
        this.setPasswordButton.postJSON("/accounts/password_change/", {
          newPassword: this.passwordInput.getValue()
        }).then(() => location.replace("/"), error => this.passwordFormField.setError(error.message));
      }
    }

    var _class$7, _descriptor$7, _descriptor2$7, _descriptor3$6, _descriptor4$6, _descriptor5$6, _descriptor6$4, _dec$7, _class2$6;
    let PasswordChangeStyle = (_class$7 = class PasswordChangeStyle extends LoginStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "className", _descriptor$7, this);
        _initializerDefineProperty(this, "loginWidget", _descriptor2$7, this);
        _initializerDefineProperty(this, "forgotPassword", _descriptor3$6, this);
        _initializerDefineProperty(this, "signInButtonContainer", _descriptor4$6, this);
        _initializerDefineProperty(this, "signInButton", _descriptor5$6, this);
        _initializerDefineProperty(this, "input", _descriptor6$4, this);
      }
    }, (_descriptor$7 = _applyDecoratedDescriptor(_class$7.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "30%",
          minWidth: "300px",
          margin: "0 auto"
        };
      }
    }), _descriptor2$7 = _applyDecoratedDescriptor(_class$7.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor3$6 = _applyDecoratedDescriptor(_class$7.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor4$6 = _applyDecoratedDescriptor(_class$7.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor5$6 = _applyDecoratedDescriptor(_class$7.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.themeProps.COLOR_PRIMARY,
          color: enhance(this.themeProps.COLOR_PRIMARY, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(this.themeProps.COLOR_PRIMARY, 0.15),
            color: enhance(this.themeProps.COLOR_PRIMARY, 1),
            border: 0
          }
        };
      }
    }), _descriptor6$4 = _applyDecoratedDescriptor(_class$7.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + this.themeProps.COLOR_PRIMARY,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + this.themeProps.COLOR_PRIMARY + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + this.themeProps.COLOR_PRIMARY + " !important"
          }
        };
      }
    })), _class$7);
    let AccountActivation = (_dec$7 = registerStyle(PasswordChangeStyle), _dec$7(_class2$6 = class AccountActivation extends LoginWidget {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }
      getThirdPartyLogin() {}
      getClearBothArea() {}
      getSignInValue() {
        return "Set password";
      }
      sendLogin() {
        this.clearErrorMessage();
        const password = this.passwordInput.getValue();
        const passwordConfirm = this.passwordConfirmInput.getValue();
        if (password !== passwordConfirm) {
          this.setErrorMessage({
            message: "Passwords don't match."
          });
          return;
        }
        Ajax.postJSON("/accounts/password_change/", {
          newPassword: password
        }).then(() => location.href = "/", error => this.setErrorMessage(error));
      }
      render() {
        return [UI$1.createElement("form", {
          ref: "form"
        }, this.getPasswordInput(), this.getPasswordInput({
          ref: "passwordConfirmInput",
          name: "passwordConfirm",
          placeholder: "Confirm Password"
        }), this.getSignInButton(), UI$1.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }
    }) || _class2$6);

    var _class$6, _descriptor$6, _descriptor2$6, _descriptor3$5, _descriptor4$5, _descriptor5$5, _dec$6, _class2$5, _dec2$3, _class3$2;
    let QuestionnaireAnswersStyle = (_class$6 = class QuestionnaireAnswersStyle extends QuestionnaireStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "miniInstance", _descriptor$6, this);
        _initializerDefineProperty(this, "questionnaireResponseWidget", _descriptor2$6, this);
        _initializerDefineProperty(this, "responsesLeftSideContainer", _descriptor3$5, this);
        _initializerDefineProperty(this, "responsesRightSide", _descriptor4$5, this);
        _initializerDefineProperty(this, "rowList", _descriptor5$5, this);
      }
    }, (_descriptor$6 = _applyDecoratedDescriptor(_class$6.prototype, "miniInstance", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "5px",
          border: "1px solid #eee",
          cursor: "pointer"
        };
      }
    }), _descriptor2$6 = _applyDecoratedDescriptor(_class$6.prototype, "questionnaireResponseWidget", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-flex",
          height: "100%",
          width: "100%",
          overflow: "hidden",
          position: "relative"
        };
      }
    }), _descriptor3$5 = _applyDecoratedDescriptor(_class$6.prototype, "responsesLeftSideContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          overflow: "auto",
          width: "150px",
          borderRight: "1px solid #ddd"
        };
      }
    }), _descriptor4$5 = _applyDecoratedDescriptor(_class$6.prototype, "responsesRightSide", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          flex: "1",
          width: "calc(100% - 150px)",
          height: "100%",
          overflow: "auto"
        };
      }
    }), _descriptor5$5 = _applyDecoratedDescriptor(_class$6.prototype, "rowList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxHeight: "200px",
          overflowY: "auto"
        };
      }
    })), _class$6);
    let QuestionSummary = (_dec$6 = registerStyle(QuestionnaireAnswersStyle), _dec$6(_class2$5 = class QuestionSummary extends UI$1.Element {
      getInstanceResponse(instance) {
        return instance.getQuestionResponse(this.options.question.id);
      }
      isOtherResponse(response) {
        if (this.options.question.type === QuestionnaireQuestion.Type.SINGLE_CHOICE) {
          return (response.choiceIds || []).length === 0 && response.text;
        }
        return !!response.text;
      }
      getInstances() {
        return this.options.instances.filter(instance => this.getInstanceResponse(instance));
      }
      buildChoiceFrequencyMap() {
        let frequencyMap = new Map();
        for (const instance of this.getInstances()) {
          const instanceResponse = this.getInstanceResponse(instance);
          for (let choiceId of instanceResponse.choiceIds || []) {
            frequencyMap.set(choiceId, (frequencyMap.get(choiceId) || 0) + 1);
          }
          if (this.isOtherResponse(instanceResponse)) {
            frequencyMap.set(0, (frequencyMap.get(0) || 0) + 1);
          }
        }
        return frequencyMap;
      }
      getQuestionOptions() {
        let options = [...this.options.question.getOptions()];
        if (this.options.question.otherChoice) {
          options.push({
            id: 0,
            answer: "Other"
          });
        }
        return options;
      }
      getPieChart() {
        const frequencyMap = this.buildChoiceFrequencyMap();
        const options = this.options.question.getOptions();
        let sectorData = [];
        for (let i = 0; i < options.length; i += 1) {
          if (frequencyMap.get(options[i].id)) {
            sectorData.push({
              size: frequencyMap.get(options[i].id),
              color: ColorGenerator.getPersistentColor(i)
            });
          }
        }
        if (frequencyMap.get(0)) {
          sectorData.push({
            size: frequencyMap.get(0),
            color: ColorGenerator.getPersistentColor(options.length)
          });
        }
        return UI$1.createElement(PieChartSVG, {
          sectors: sectorData
        });
      }
      getColorList() {
        const frequencyMap = this.buildChoiceFrequencyMap();
        return UI$1.createElement(Table, {
          entries: this.getQuestionOptions(),
          columns: [{
            value: option => UI$1.createElement(MarkupRenderer, {
              value: option.answer,
              className: this.styleSheet.markup
            }),
            headerName: UI$1.T("Choice")
          }, {
            value: option => frequencyMap.get(option.id) || 0,
            headerName: UI$1.T("Votes")
          }, {
            value: (option, index) => UI$1.createElement("div", {
              style: {
                height: "20px",
                width: "20px",
                backgroundColor: ColorGenerator.getPersistentColor(index)
              }
            }),
            headerName: UI$1.T("Color")
          }, {
            value: option => UI$1.createElement(RawCheckboxInput, {
              ref: this.refLink("optionFilter" + option.id)
            }),
            headerName: UI$1.T("Filter")
          }]
        });
      }
      render() {
        const question = this.options.question;
        let content;
        if (question.type === QuestionnaireQuestion.Type.PLAIN_TEXT) {
          content = UI$1.createElement(RowList, {
            rows: this.getInstances(),
            className: this.styleSheet.rowList,
            rowParser: instance => [UI$1.createElement(UserHandle$1, {
              userId: instance.userId
            }), ": ", instance.getQuestionResponse(question.id).text]
          });
        } else {
          content = [UI$1.createElement("div", {
            style: {
              display: "inline-block",
              height: "100%",
              width: "50%",
              textAlign: "center",
              float: "left"
            }
          }, this.getPieChart()), UI$1.createElement("div", {
            style: {
              display: "inline-block",
              height: "100%",
              width: "50%",
              float: "right"
            }
          }, this.getColorList()), UI$1.createElement("div", {
            style: {
              clear: "both"
            }
          })];
          const otherAnswers = this.getInstances().filter(instance => instance.getQuestionResponse(question.id).text);
          if (otherAnswers.length) {
            content.push(UI$1.createElement("h4", {
              style: {
                marginRight: "10px"
              }
            }, "Other answers:"));
            content.push(UI$1.createElement(RowList, {
              rows: otherAnswers,
              className: this.styleSheet.rowList,
              rowParser: instance => [UI$1.createElement(UserHandle$1, {
                userId: instance.userId
              }), ": ", instance.getQuestionResponse(question.id).text]
            }));
          }
        }
        return UI$1.createElement(CardPanel, {
          level: Level.PRIMARY,
          title: question.text,
          headingCentered: false,
          style: {
            marginBottom: "10px",
            width: "80%",
            marginLeft: "10%"
          }
        }, content);
      }
      onMount() {
        if (this.options.question.type !== QuestionnaireQuestion.Type.PLAIN_TEXT) {
          for (const option of this.getQuestionOptions()) {
            this["optionFilter" + option.id].addChangeListener(() => {
              let acceptableChoices = [];
              for (const choice of this.getQuestionOptions()) {
                if (this["optionFilter" + choice.id].getValue()) {
                  acceptableChoices.push(choice.id);
                }
              }
              this.options.widget.dispatch("updateFilter", this.options.question, acceptableChoices);
            });
          }
        }
      }
    }) || _class2$5);
    class QuestionnaireSummaryWidget extends UI$1.Element {
      getDefaultOptions() {
        return {
          filters: {}
        };
      }
      getQuestionnaire() {
        return QuestionnaireStore.get(this.options.questionnaireId);
      }
      respectsFilters(instance) {
        const filters = this.options.filters || {};
        for (const questionId of Object.keys(filters)) {
          const response = instance.getQuestionResponse(parseInt(questionId));
          const acceptableOptions = filters[questionId];
          if (Array.isArray(acceptableOptions) && acceptableOptions.length) {
            if (!response) {
              return false;
            }
            let respectsFilter = false;
            for (const choiceId of response.choiceIds || []) {
              if (acceptableOptions.indexOf(choiceId) >= 0) {
                respectsFilter = true;
              }
            }
            if (!respectsFilter) {
              return false;
            }
          }
        }
        return true;
      }
      getInstances() {
        return this.getQuestionnaire().getAllInstances().filter(instance => this.respectsFilters(instance));
      }
      render() {
        const instances = this.getInstances();
        return this.getQuestionnaire().getQuestions().map(question => UI$1.createElement(QuestionSummary, {
          question: question,
          instances: instances,
          widget: this
        }));
      }
      onMount() {
        this.addListener("updateFilter", (question, acceptableOptions) => {
          this.options.filters[question.id] = acceptableOptions;
          this.redraw();
          this.dispatch("updateInstanceList", this.getInstances());
        });
      }
    }
    class QuestionnaireInstanceSwitcher extends Switcher {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          lazyRender: true
        });
      }
      constructor() {
        super(...arguments);
        this.instanceMap = new Map();
        for (const instanceUIElement of this.options.children) {
          this.instanceMap.set(instanceUIElement.options.instance.id, instanceUIElement);
        }
        if (!this.instanceMap.has(0)) {
          this.instanceMap.set(0, UI$1.createElement("div", null));
        }
      }
      switchToInstance(instance) {
        if (!instance) {
          this.setActive(this.instanceMap.get(0));
          return;
        }
        this.setActive(this.instanceMap.get(instance.id));
      }
    }
    class FullInstancePage extends UI$1.Element {
      render() {
        return this.options.instance.getQuestionnaire().getQuestions().map(question => UI$1.createElement(QuestionPage, {
          question: question,
          instance: this.options.instance,
          editable: false,
          style: {
            paddingBottom: 0
          }
        }));
      }
    }
    let QuestionnaireResponsesWidget = (_dec2$3 = registerStyle(QuestionnaireAnswersStyle), _dec2$3(_class3$2 = class QuestionnaireResponsesWidget extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.questionnaireResponseWidget);
      }
      getQuestionnaire() {
        return QuestionnaireStore.get(this.options.questionnaireId);
      }
      setOptions(options) {
        super.setOptions(options);
        this.options.instances = this.options.instances || this.getQuestionnaire().getAllInstances();
      }
      switchToInstance(instance) {
        this.instanceSwitcher.switchToInstance(instance);
        const allInstances = this.getInstances();
        for (const otherInstance of allInstances) {
          const obj = this["miniInstanceDiv" + otherInstance.id];
          if (instance === otherInstance) {
            obj.setStyle("background-color", Theme.props.COLOR_INFO);
          } else {
            obj.setStyle("background-color", Theme.props.COLOR_BACKGROUND);
          }
        }
      }
      getInstances() {
        return this.options.instances;
      }
      render() {
        const allInstances = this.getInstances();
        const miniResponses = allInstances.map(instance => UI$1.createElement("div", {
          onClick: () => this.switchToInstance(instance),
          ref: "miniInstanceDiv" + instance.id,
          className: this.styleSheet.miniInstance
        }, UI$1.createElement(UserHandle$1, {
          disableClick: true,
          userId: instance.userId
        })));
        const fullInstances = allInstances.map(instance => UI$1.createElement(FullInstancePage, {
          instance: instance
        }));
        return [UI$1.createElement("div", {
          className: this.styleSheet.responsesLeftSideContainer
        }, miniResponses), UI$1.createElement(QuestionnaireInstanceSwitcher, {
          ref: "instanceSwitcher",
          className: this.styleSheet.responsesRightSide
        }, fullInstances)];
      }
      redraw() {
        super.redraw();
        this.switchToInstance(this.getInstances()[0]);
      }
    }) || _class3$2);
    class QuestionnaireAnswersPanel extends UI$1.Element {
      render() {
        return [UI$1.createElement(TabArea, null, UI$1.createElement(Panel, {
          title: UI$1.T("Summary"),
          style: {
            paddingTop: "10px"
          }
        }, UI$1.createElement(QuestionnaireSummaryWidget, {
          questionnaireId: this.options.questionnaireId,
          ref: "questionnaireSummary"
        })), UI$1.createElement(Panel, {
          title: UI$1.T("Responses")
        }, UI$1.createElement(QuestionnaireResponsesWidget, {
          questionnaireId: this.options.questionnaireId,
          ref: "questionnaireResponses"
        })))];
      }
      onMount() {
        this.questionnaireSummary.addListener("updateInstanceList", instances => {
          this.questionnaireResponses.updateOptions({
            instances
          });
        });
      }
    }
    class DelayedQuestionnaireAnswersPanel extends UI$1.Element {
      getDefaultOptions() {
        return {
          style: {
            margin: "0 10%"
          }
        };
      }
      setOptions(options) {
        // this is here since this class can be used as a stand-alone page in a webapp
        // pattern of URL in mind: /questionnaire/{id}/answers/
        options.questionnaireId = options.questionnaireId || parseInt(options.args[0]) || 0;
        super.setOptions(options);
      }
      render() {
        if (this.options.error) {
          return StateDependentElement.renderError(this.options.error);
        }
        if (!this.options.loaded) {
          return StateDependentElement.renderLoading();
        }
        return UI$1.createElement(QuestionnaireAnswersPanel, {
          questionnaireId: this.options.questionnaireId
        });
      }
      onMount() {
        Ajax.getJSON("/questionnaire_all_answers/", {
          questionnaireId: this.options.questionnaireId
        }).then(() => this.updateOptions({
          loaded: true
        }), error => this.updateOptions({
          error
        }));
      }
    }

    const IEEE_PRIMARY_COLOR$1 = "#185e9c";
    const IEEE_SECONDARY_COLOR = "#FF8D3A";

    class IEEEXtremeUserHandle extends UserHandle$1 {
      getRatingColor() {
        const {
          contestTeam
        } = this.options;
        if (contestTeam.ieeeTeamType === 3) {
          // proctor
          return enhance(IEEE_SECONDARY_COLOR, 0.3);
        }
        return enhance(IEEE_PRIMARY_COLOR$1, 0.3);
      }
    }

    const IEEETeamType = {
      OFFICIAL: 1,
      LATE_REGISTRATION: 2,
      PROCTOR: 3,
      HIGH_SCHOOL: 4
    };
    const IEEERegion = {
      "R1": "(R1) Northeastern US",
      "R2": "(R2) Eastern US",
      "R3": "(R3) Southern US",
      "R4": "(R4) Central US",
      "R5": "(R5) Southwestern US",
      "R6": "(R6) Western US",
      "R7": "(R7) Canada",
      "R8": "(R8) Africa, Europe, Middle East",
      "R9": "(R9) Latin America",
      "R0": "(R10) Asia and Pacific"
    };
    const TEAM_TYPE_SET_PARTICIPANTS = new Set([IEEETeamType.OFFICIAL, IEEETeamType.LATE_REGISTRATION]);
    const isXtremeParticipant = contestUser => TEAM_TYPE_SET_PARTICIPANTS.has(contestUser?.ieeeTeamType);
    class IEEEXtremeContestUsersFilter extends ContestUsersFilter {
      render() {
        const teamTypeOptions = [["Teams", TEAM_TYPE_SET_PARTICIPANTS], ["Proctor", new Set([IEEETeamType.PROCTOR])], ["High School", new Set([IEEETeamType.HIGH_SCHOOL])]].map(([name, typeSet]) => {
          return {
            toString: () => name,
            typeSet: typeSet
          };
        });
        let regions = [];
        regions.push({
          toString: () => "All regions",
          region: ""
        });
        for (let key in IEEERegion) {
          regions.push({
            toString: () => IEEERegion[key],
            region: key
          });
        }
        return [UI$1.createElement(Select, {
          ref: "filterUsers",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: teamTypeOptions,
          selected: teamTypeOptions[0]
        }), UI$1.createElement(Select, {
          ref: "filterCountry",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: this.options.contest.getCountries()
        }), UI$1.createElement(Select, {
          ref: "filterRegion",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: regions
        }), UI$1.createElement(TextInput, {
          ref: "findTeamInput",
          style: {
            height: "2.03em",
            marginLeft: "10px",
            verticalAlign: "middle"
          },
          placeholder: "Find team..."
        })];
      }
      getFilter() {
        this.options.findUser = this.findTeamInput.getValue();
        this.options.countryIdFilter = this.filterCountry.get().id;
        this.options.regionIdFilter = this.filterRegion.get().region;
        return contestTeam => {
          const keywords = (this.options.findUser || "").trim().toLowerCase();
          const publicUser = PublicUserStore.get(contestTeam.userId);
          const teamTypeSet = this.filterUsers.get().typeSet;
          const {
            ieeeTeamType
          } = contestTeam; // TODO: get from contest user

          if (!teamTypeSet.has(ieeeTeamType)) {
            return false;
          }
          // TODO: Public user should have been in state.
          if (!publicUser) {
            return false;
          }
          if (keywords !== "") {
            if ((publicUser.name || "").toLowerCase().indexOf(keywords) == -1 && (publicUser.username || "").toLowerCase().indexOf(keywords) == -1) {
              return false;
            }
          }
          if (this.options.countryIdFilter && publicUser.countryId !== this.options.countryIdFilter) {
            return false;
          }
          // check this one, might be regionIdFilter - 1
          if (this.options.regionIdFilter && contestTeam.region !== this.options.regionIdFilter) {
            return false;
          }
          return true;
        };
      }
      onMount() {
        this.filterUsers.addChangeListener(() => {
          this.updateFilter();
        });
        this.filterCountry.addChangeListener(() => {
          this.updateFilter();
        });
        this.filterRegion.addChangeListener(() => {
          this.updateFilter();
        });
        this.findTeamInput.addNodeListener("keyup", () => {
          this.updateFilter();
        });
        this.updateFilter();
        const updateThrottler = new CallThrottler({
          throttle: 300
        });
        const updateCountryFilterThrottled = updateThrottler.wrap(() => this.filterCountry.updateOptions({
          options: this.options.contest.getCountries()
        }));
        this.attachListener(this.options.contest, "contestUserUpdate", updateCountryFilterThrottled);
      }
    }
    class IEEEXtremeContestUsersTable extends ContestUsersTable {
      getUniversityAndRegionColumns() {
        let centerStyle = {
          textAlign: "left",
          margin: "auto",
          verticalAlign: "middle"
        };
        const columns = [{
          value: contestTeam => {
            return contestTeam.university || "-";
          },
          rawValue: contestTeam => {
            return contestTeam.university || "-";
          },
          headerName: "University",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }, {
          value: contestTeam => {
            return contestTeam.region && IEEERegion[contestTeam.region] || "-";
          },
          rawValue: contestTeam => {
            return contestTeam.region && IEEERegion[contestTeam.region] || "-";
          },
          headerName: "Region",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }];
        return columns;
      }
      getUserColumn() {
        let centerStyle = {
          textAlign: "left",
          margin: "auto",
          verticalAlign: "middle"
        };
        return [{
          value: contestTeam => {
            let handle = UI$1.createElement(IEEEXtremeUserHandle, {
              userId: contestTeam.userId,
              contestTeam: contestTeam,
              showCountry: true,
              noPopup: true
            });
            if (!contestTeam.getContest().isVirtual()) {
              return handle;
            } else {
              //TODO: refactor this to update every minute
              return UI$1.createElement("span", null, handle, " virtual ", contestTeam.getContestStartTime() < ServerTime.now().unix() && ServerTime.now().unix() < contestTeam.getContestEndTime() ? new Duration((ServerTime.now().unix() - contestTeam.getContestStartTime()) * 1000).format("HH:mm") : "");
            }
          },
          rawValue: contestTeam => {
            return contestTeam.getPublicUser().username || "publicuser-" + contestTeam.userId;
          },
          headerName: "Team",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }];
      }
      getDefaultColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "left",
          margin: "auto",
          verticalAlign: "middle"
        };
        let columns = [{
          value: (contestTeam, index) => index + 1,
          headerName: "#",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: numberStyle
        }, ...this.getUserColumn(), ...this.getUniversityAndRegionColumns()];
        if (this.options.contest.hasStarted()) {
          columns.push({
            value: contestTeam => contestTeam.totalScore,
            rawValue: contestTeam => contestTeam.totalScore,
            headerName: "Total Score",
            sortDescending: true,
            headerStyle: centerStyle,
            cellStyle: centerStyle
          });
        }
        return columns;
      }
    }
    class IEEEXtremeScoreboardEntriesManager extends ScoreboardEntriesManager {
      cacheEntries() {
        const officialEntries = this.getRawEntries().filter(entry => isXtremeParticipant(entry));
        Contest.calculateRanks(officialEntries);
        for (let entry of officialEntries) {
          entry.globalRank = entry.rank;
        }
        const entries = this.filterEntries(this.getRawEntries());
        Contest.calculateRanks(entries);
        this.cachedEntries = this.sortEntries(entries);
        this.dispatchChange();
      }
    }
    class IEEEXtremeScoreboardTable extends ScoreboardTable {
      shouldShowTaskColumns() {
        return this.options.showFullScoreboard;
      }
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new IEEEXtremeScoreboardEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }
        return this.entriesManager;
      }
      getContestUserAndContestTaskCellRawValue(contestUser, contestTask) {
        if (!contestUser.scores) {
          return -1;
        }
        let userTaskSummary = contestUser.scores[contestTask.id];
        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }
        if (!userTaskSummary) {
          return -1;
        }
        if (contestTask.hasPartialScore()) {
          return userTaskSummary.score;
        }
        if (userTaskSummary.score) {
          return 1;
        }
        return 0;
      }
      renderContestUserAndContestTaskCell(contestUser, contestTask) {
        if (!contestUser.scores) {
          return "-";
        }
        let userTaskSummary = contestUser.scores[contestTask.id];
        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }
        if (!userTaskSummary) {
          return "-";
        }
        const userScore = userTaskSummary.score || 0;
        let score, penalty;
        if (contestTask.hasPartialScore()) {
          score = UI$1.createElement("span", null, Formatter.truncate(userScore * contestTask.pointsWorth, 2));
        } else if (userScore == 1) {
          score = UI$1.createElement("span", {
            className: "fa fa-check fa-lg",
            style: {
              color: "green"
            }
          });
        } else {
          score = UI$1.createElement("span", {
            className: "fa fa-times fa-lg",
            style: {
              color: "red"
            }
          });
        }
        if (contestTask.hasPenalty()) {
          let contestStartTime = new StemDate(contestUser.getContestStartTime());
          let solutionTime = new StemDate(userTaskSummary.scoreTime);
          let solutionTimeRelative = solutionTime.diffDuration(contestStartTime);
          if (contestTask.hasPartialScore() || userScore == 1) {
            penalty = UI$1.createElement("div", {
              style: {
                fontSize: "0.8em",
                color: "grey"
              }
            }, solutionTimeRelative.format("HH:mm"));
          }
        }
        return UI$1.createElement("div", {
          onClick: () => this.showSubmissions(contestUser, contestTask)
        }, [score, penalty]);
      }
      getDefaultColumns(options) {
        const columns = super.getDefaultColumns(options);
        columns.splice(1, 1, ...this.getUserColumn());
        if (!this.options.showFullScoreboard) {
          columns.splice(3, 0, ...this.getUniversityAndRegionColumns());
        }
        delete this.options?.columns; // TODO we do this to not overwrite us

        return columns;
      }
    }
    IEEEXtremeScoreboardTable.prototype.getUniversityAndRegionColumns = IEEEXtremeContestUsersTable.prototype.getUniversityAndRegionColumns;
    IEEEXtremeScoreboardTable.prototype.getUserColumn = IEEEXtremeContestUsersTable.prototype.getUserColumn;
    class IEEEXtremeScoreboard extends Scoreboard {
      getContestUsersFilter() {
        return UI$1.createElement(IEEEXtremeContestUsersFilter, {
          ref: "contestUsersFilter",
          contest: this.options.contest
        });
      }
      getContestUsersTableClass() {
        return IEEEXtremeContestUsersTable;
      }
      getScoreboardTableClass() {
        return IEEEXtremeScoreboardTable;
      }
      toggleScoreboard() {
        this.showFullScoreboard = !this.showFullScoreboard;
        this.showFullScoreboardButton.setLabel(this.showFullScoreboard ? "Show region & university" : "Show scores on tasks");
        this.scoreboardTable.updateOptions({
          showFullScoreboard: this.showFullScoreboard
        });
      }
      async downloadScores() {
        const {
          contest
        } = this.options;
        let contestUsers = Array.from(contest.contestUsers.values());
        contestUsers = contestUsers.filter(cu => isXtremeParticipant(cu));
        Contest.calculateRanks(contestUsers);
        let csvColumns = [{
          name: "Team Name",
          value: u => u.getPublicUser().name
        }, {
          name: "Internal Team Id",
          value: u => u.getPublicUser().username
        }, {
          name: "Total score",
          value: u => u.totalScore
        }, {
          name: "Penalty",
          value: u => u.penalty
        }, {
          name: "University",
          value: u => u.university || ""
        }, {
          name: "Country",
          value: u => u.getPublicUser().getCountry() || ""
        }, {
          name: "Region",
          value: u => u.region || ""
        }];
        if (window.FULL_IEEE_DATA || USER.id === 1 && confirm("Get full scoreboard with emails?")) {
          const response = await Ajax.getJSON("/contest/all_ieee_teams/", {
            contestId: contest.id
          });
          for (const team of response.state.IEEExtremeTeam) {
            const contestUser = ContestUserStore.get(team.contestUserId);
            contestUser.ieeeData = team.ieeeData;
          }
          csvColumns[0].value = u => u.ieeeData.Name;
          const members = ["Member 1", "Member 2", "Member 3", "Proctor"];
          const fields = ["Email", "ID", "First Name", "Last Name"];
          for (const member of members) {
            for (const field of fields) {
              const keyName = member + " " + field;
              csvColumns.push({
                name: keyName,
                value: u => u.ieeeData?.[keyName] || ""
              });
            }
          }
        }
        for (const contestTask of contest.getContestTasks()) {
          const getStats = contestUser => contestUser.scores[contestTask.id];
          const getScore = contestUser => (getStats(contestUser)?.score || 0) * 100.0;
          const getPenalty = contestUser => (getStats(contestUser)?.scoreTime || contest.startTime) - contest.startTime;
          const name = contestTask.toString();
          csvColumns.push({
            name: name + " Raw Score",
            value: getScore
          });
          csvColumns.push({
            name: name + " Penalty",
            value: getPenalty
          });
        }
        csvColumns.push({
          name: "Judge decision",
          value: contestUser => {
            if (contestUser.isDisqualified()) {
              return "disqualified";
            }
            return "ok";
          }
        });
        CSVBuilder.saveFile(csvColumns, contestUsers, "XtremeScores.csv");
      }
      getScoreboardActionableArea() {
        let buttons = [];
        if (this.options.contest.hasStarted()) {
          buttons.push(UI$1.createElement(Button$1, {
            ref: "showFullScoreboardButton",
            onClick: () => this.toggleScoreboard(),
            label: "Show scores on tasks",
            style: {
              marginLeft: "10px",
              height: "2.2em",
              paddingTop: 0,
              paddingBottom: 0
            },
            level: Level.PRIMARY,
            size: Size.SMALL
          }));
        }
        return [super.getScoreboardActionableArea(), buttons];
      }
    }

    class IEEEXtremeContestScoreTracker extends ContestScoreTracker {
      officialOrLateRegistration(user) {
        return user.ieeeTeamType === IEEETeamType.OFFICIAL || user.ieeeTeamType === IEEETeamType.LATE_REGISTRATION;
      }
      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }
        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();
        if (this.officialOrLateRegistration(user)) {
          contestUsers = contestUsers.filter(contestUser => {
            return this.officialOrLateRegistration(contestUser);
          });
        }
        let rank = 1;
        for (let contestUser of contestUsers) {
          if (compareContestUsers(user, contestUser) > 0) {
            rank += 1;
          }
        }
        return "Rank " + rank + " / " + contestUsers.length;
      }
    }

    class IEEEXtremeTopLevelContestNavigationHandler extends TopLevelContestNavigationHandler {
      getTasksDropdownElements() {
        return [];
      }
      createRankInfo() {
        const tracker = UI$1.createElement(IEEEXtremeContestScoreTracker, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachChangeListener(tracker, () => NavManager.Global.checkForWrap());
        return UI$1.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }
      getLeftChildren() {
        const {
          contest
        } = this;
        return [...super.getLeftChildren(), contest.getSubpages().map(subpage => subpage.showInNav && UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix(subpage.url),
          key: subpage.url,
          value: UI$1.T(subpage.name)
        }))];
      }
    }
    class IEEEXtremeTopLevelUnauthenticatedNavigationHandler extends IEEEXtremeTopLevelContestNavigationHandler {
      getLeftChildren() {
        return [UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI$1.T("Summary")
        })];
      }
      getRightChildren() {
        return [];
      }
      createPhotos() {
        return UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI$1.T("Photos")
        });
      }
    }

    var _class$5, _descriptor$5, _descriptor2$5, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$3, _dec$5, _class2$4, _class3$1, _descriptor7$3, _dec2$2, _class4$1, _class5, _descriptor8$3, _descriptor9$3, _descriptor10$2, _dec3$1, _class6, _class7, _descriptor11$2, _dec4$1, _class8;
    const IEEE_PRIMARY_COLOR = "#185e9c";
    let CountdownStyle = (_class$5 = class CountdownStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.timeSectionHeight = 180;
        this.timeSectionDigitsContainerHeight = 120;
        this.primaryColor = IEEE_PRIMARY_COLOR;
        _initializerDefineProperty(this, "countdown", _descriptor$5, this);
        // renderTimeSection style
        _initializerDefineProperty(this, "timeSection", _descriptor2$5, this);
        _initializerDefineProperty(this, "timeSectionDigitsContainer", _descriptor3$4, this);
        _initializerDefineProperty(this, "digitContainer", _descriptor4$4, this);
        _initializerDefineProperty(this, "digitContainerSeparator", _descriptor5$4, this);
        _initializerDefineProperty(this, "timeSectionDescription", _descriptor6$3, this);
      }
    }, (_descriptor$5 = _applyDecoratedDescriptor(_class$5.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexWrap: "wrap",
          flexDirection: "row"
        };
      }
    }), _descriptor2$5 = _applyDecoratedDescriptor(_class$5.prototype, "timeSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: "column"
        };
      }
    }), _descriptor3$4 = _applyDecoratedDescriptor(_class$5.prototype, "timeSectionDigitsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex"
        };
      }
    }), _descriptor4$4 = _applyDecoratedDescriptor(_class$5.prototype, "digitContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.timeSectionDigitsContainerHeight,
          width: 75,
          margin: 5,
          borderRadius: "10px",
          boxShadow: "0px 0px 5px " + this.primaryColor,
          background: `linear-gradient(to bottom,` + `${this.primaryColor} 0%, ` + `${this.primaryColor} 49.5%,` + `${enhance(this.primaryColor, 1)} 49.5%,` + `${enhance(this.primaryColor, 1)} 50.5%,` + `${enhance(this.primaryColor, 0.15)} 50.5%,` + `${enhance(this.primaryColor, 0.15)} 100%` + `)`,
          color: enhance(this.primaryColor, 1),
          fontSize: 60,
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor5$4 = _applyDecoratedDescriptor(_class$5.prototype, "digitContainerSeparator", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 20,
          height: this.timeSectionHeight - this.timeSectionDigitsContainerHeight,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          textShadow: "0px 0px 5px " + this.primaryColor,
          fontSize: 40,
          paddingBottom: 60,
          color: this.primaryColor
        };
      }
    }), _descriptor6$3 = _applyDecoratedDescriptor(_class$5.prototype, "timeSectionDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.timeSectionHeight - this.timeSectionDigitsContainerHeight,
          marginLeft: 10,
          marginRight: 10,
          fontSize: 22,
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          color: this.primaryColor
        };
      }
    })), _class$5); // Countdown - gets the StemDate of the end of the event (options.endTime)
    // TODO: This is 1x4 = 4 sections. (days, hours, minutes, seconds)
    // TODO: Add 2x3 = 6 sections (+ years, months)
    // TODO: This is easy to reuse, even after IEE contest. :)
    let Countdown = (_dec$5 = registerStyle(CountdownStyle), _dec$5(_class2$4 = class Countdown extends UI$1.Element {
      getDefaultOptions() {
        return {
          hasDays: true,
          hasHours: true,
          hasMinutes: true,
          hasSeconds: true
        };
      }
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.countdown);
      }
      getTimeLeft() {
        const currentServerTime = ServerTime.now();
        let {
          endTime
        } = this.options;
        endTime = endTime || currentServerTime;
        return endTime.diffDuration(currentServerTime);
      }
      renderTimeSection(digits, description, hasSeparator) {
        if (digits === "") {
          return null;
        }
        const styleSheet = this.styleSheet;
        let separator;
        if (hasSeparator) {
          separator = UI$1.createElement("div", {
            className: styleSheet.digitContainerSeparator
          }, ":");
        }
        return [UI$1.createElement("div", {
          className: styleSheet.timeSection
        }, UI$1.createElement("div", {
          className: styleSheet.timeSectionDigitsContainer
        }, digits.split("").map(digit => {
          return UI$1.createElement("div", {
            className: styleSheet.digitContainer
          }, digit);
        })), UI$1.createElement("div", {
          className: styleSheet.timeSectionDescription
        }, description)), separator];
      }
      formatTimeUnit(value, shouldHideNull = false) {
        if (value === 0 && shouldHideNull) {
          return "";
        }
        if (value < 10) {
          return "0" + String(value);
        }
        return String(value);
      }
      hasEnded() {
        return this.getTimeLeft().valueOf() === 0;
      }
      render() {
        if (this.hasEnded()) {
          return null;
        }
        const timeLeft = this.getTimeLeft();
        return [this.options.hasDays ? this.renderTimeSection(this.formatTimeUnit(timeLeft.toDays(), true), "Days", this.options.hasHours || this.options.hasMinutes || this.options.hasSeconds) : "", this.options.hasHours ? this.renderTimeSection(this.formatTimeUnit(timeLeft.getHours()), "Hours", this.options.hasMinutes || this.options.hasSeconds) : "", this.options.hasMinutes ? this.renderTimeSection(this.formatTimeUnit(timeLeft.getMinutes()), "Minutes", this.options.hasSeconds) : "", this.options.hasSeconds ? this.renderTimeSection(this.formatTimeUnit(timeLeft.getSeconds()), "Seconds") : ""];
      }
      onMount() {
        this.intervalId = setInterval(() => {
          this.redraw();
          if (this.hasEnded()) {
            this.onUnmount();
          }
        }, 1000);
      }
      onUnmount() {
        clearInterval(this.intervalId);
      }
    }) || _class2$4);
    let ContestCountdownStyle = (_class3$1 = class ContestCountdownStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.primaryColor = IEEE_PRIMARY_COLOR;
        _initializerDefineProperty(this, "countdownDescription", _descriptor7$3, this);
      }
    }, (_descriptor7$3 = _applyDecoratedDescriptor(_class3$1.prototype, "countdownDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          color: this.primaryColor,
          fontSize: 25,
          padding: "15px 0"
        };
      }
    })), _class3$1);
    let ContestCountdown = (_dec2$2 = registerStyle(ContestCountdownStyle), _dec2$2(_class4$1 = class ContestCountdown extends UI$1.Element {
      checkEndTimeChange(value) {
        if (value == null || !this.endTime || !this.endTime.isSame(value)) {
          this.endTime = value;
          this.redraw();
        }
      }
      updateEndTime() {
        const {
          contest
        } = this.options;
        if (contest.getStartTime() && !contest.hasStarted()) {
          this.checkEndTimeChange(new StemDate(contest.getStartTime()));
        } else if (contest.getEndTime() && !contest.hasFinished()) {
          this.checkEndTimeChange(new StemDate(contest.getEndTime()));
        } else {
          this.checkEndTimeChange(null);
        }
        this.redraw();
      }
      getCountdownTopDescription() {
        const {
          contest
        } = this.options;
        let description;
        if (!contest.hasStarted()) {
          description = "The contest starts in";
        } else if (contest.hasStarted() && !contest.hasFinished()) {
          description = "The contest ends in";
        } else {
          description = "The contest has ended, congratulations everyone!";
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.countdownDescription
        }, description);
      }
      getCountdownBottomDescription() {
        const {
          contest
        } = this.options;
        if (!contest.hasStarted()) {
          return [UI$1.createElement("div", {
            className: this.styleSheet.countdownDescription
          }, contest.getFormattedStartTime()), UI$1.createElement("div", {
            className: this.styleSheet.countdownDescription
          }, "The first task will open automatically when the contest starts.")];
        }
        return null;
      }
      render() {
        return [this.getCountdownTopDescription(), UI$1.createElement(Countdown, {
          endTime: this.endTime
        }), this.getCountdownBottomDescription()];
      }
      onMount() {
        this.updateEndTime();
        this.intervalId = setInterval(() => this.updateEndTime(), 1000);
      }
      onUnmount() {
        clearInterval(this.intervalId);
      }
    }) || _class4$1);

    // TODO: The Countdown.jsx file should end here.
    let IEEEXtremeCountdownStyle = (_class5 = class IEEEXtremeCountdownStyle extends CountdownStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "digitContainer", _descriptor8$3, this);
        _initializerDefineProperty(this, "digitContainerSeparator", _descriptor9$3, this);
        _initializerDefineProperty(this, "timeSectionDescription", _descriptor10$2, this);
      }
      getResizePercent() {
        if (window.innerWidth > 850) {
          return 0.8;
        }
        if (window.innerWidth > 600) {
          return 0.75;
        }
        if (window.innerWidth > 500) {
          return 0.6;
        }
        return 0.45;
      }
    }, (_descriptor8$3 = _applyDecoratedDescriptor(_class5.prototype, "digitContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.getResizePercent() * this.timeSectionDigitsContainerHeight,
          width: this.getResizePercent() * 75,
          fontSize: this.getResizePercent() * 60
        };
      }
    }), _descriptor9$3 = _applyDecoratedDescriptor(_class5.prototype, "digitContainerSeparator", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: this.getResizePercent() * 20,
          height: this.getResizePercent() * (this.timeSectionHeight - this.timeSectionDigitsContainerHeight),
          fontSize: this.getResizePercent() * 40,
          paddingBottom: this.getResizePercent() * 60
        };
      }
    }), _descriptor10$2 = _applyDecoratedDescriptor(_class5.prototype, "timeSectionDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.getResizePercent() * (this.timeSectionHeight - this.timeSectionDigitsContainerHeight),
          fontSize: this.getResizePercent() * 22
        };
      }
    })), _class5);
    let IEEEXtremeCountdown = (_dec3$1 = registerStyle(IEEEXtremeCountdownStyle), _dec3$1(_class6 = class IEEEXtremeCountdown extends Countdown {}) || _class6);
    let IEEEXtremeContestCountdownStyle = (_class7 = class IEEEXtremeContestCountdownStyle extends ContestCountdownStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "countdownDescription", _descriptor11$2, this);
      }
      getResizePercent() {
        if (window.innerWidth > 850) {
          return 0.8;
        }
        if (window.innerWidth > 600) {
          return 0.75;
        }
        return 0.6;
      }
    }, (_descriptor11$2 = _applyDecoratedDescriptor(_class7.prototype, "countdownDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.getResizePercent() * 25,
          padding: this.getResizePercent() * 5 + "px 0"
        };
      }
    })), _class7);
    let IEEEXtremeContestCountdown = (_dec4$1 = registerStyle(IEEEXtremeContestCountdownStyle), _dec4$1(_class8 = class IEEEXtremeContestCountdown extends ContestCountdown {
      render() {
        return [this.getCountdownTopDescription(), UI$1.createElement(IEEEXtremeCountdown, {
          endTime: this.endTime
        }), this.getCountdownBottomDescription()];
      }
    }) || _class8);

    var _class$4, _descriptor$4, _descriptor2$4, _descriptor3$3, _descriptor4$3, _descriptor5$3, _dec$4, _class2$3;
    let IEEELoginStyle = (_class$4 = class IEEELoginStyle extends LoginStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "loginWidget", _descriptor$4, this);
        _initializerDefineProperty(this, "forgotPassword", _descriptor2$4, this);
        _initializerDefineProperty(this, "signInButtonContainer", _descriptor3$3, this);
        _initializerDefineProperty(this, "signInButton", _descriptor4$3, this);
        _initializerDefineProperty(this, "input", _descriptor5$3, this);
      }
    }, (_descriptor$4 = _applyDecoratedDescriptor(_class$4.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor2$4 = _applyDecoratedDescriptor(_class$4.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor3$3 = _applyDecoratedDescriptor(_class$4.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor4$3 = _applyDecoratedDescriptor(_class$4.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: IEEE_PRIMARY_COLOR$1,
          color: enhance(IEEE_PRIMARY_COLOR$1, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(IEEE_PRIMARY_COLOR$1, 0.15),
            color: enhance(IEEE_PRIMARY_COLOR$1, 1),
            border: 0
          }
        };
      }
    }), _descriptor5$3 = _applyDecoratedDescriptor(_class$4.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1 + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1 + " !important"
          }
        };
      }
    })), _class$4);
    let IEEELoginWidget = (_dec$4 = registerStyle(IEEELoginStyle), _dec$4(_class2$3 = class IEEELoginWidget extends LoginWidget {
      getThirdPartyLogin() {}
      getClearBothArea() {}
    }) || _class2$3);
    class IEEESSOLoginWidget extends IEEELoginWidget {
      getSignInValue() {
        return "Sign in with IEEE Account";
      }
      sendLogin() {
        THIRD_PARTY_LOGIN_HANDLERS.IEEE.loginManager.login();
      }
      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getSignInButton())];
      }
    }
    class IEEEPasswordResetRequestWidget extends IEEELoginWidget {
      getSignInValue() {
        return "Request password reset";
      }
      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue()
        };
        Ajax.postJSON("/ieee_password_reset_request/", data).then(() => this.setErrorMessage({
          message: "An email was sent to all members of your team, or just yourself if you're a proctor."
        }, false), error => this.setErrorMessage(error));
      }
      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput("envelope"), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }
    }

    var _class$3, _descriptor$3, _descriptor2$3, _descriptor3$2, _descriptor4$2, _descriptor5$2, _descriptor6$2, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$1, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15$1, _descriptor16$1, _descriptor17$1, _dec$3, _class2$2;
    let IEEEXtremeContestSummaryStyle = (_class$3 = class IEEEXtremeContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "container", _descriptor$3, this);
        _initializerDefineProperty(this, "logoSectionContainer", _descriptor2$3, this);
        _initializerDefineProperty(this, "sectionContainer", _descriptor3$2, this);
        _initializerDefineProperty(this, "logoContainer", _descriptor4$2, this);
        _initializerDefineProperty(this, "image", _descriptor5$2, this);
        _initializerDefineProperty(this, "countdown", _descriptor6$2, this);
        _initializerDefineProperty(this, "sectionTitleContainer", _descriptor7$2, this);
        _initializerDefineProperty(this, "sectionTitle", _descriptor8$2, this);
        _initializerDefineProperty(this, "sponsorsAndPartners", _descriptor9$2, this);
        _initializerDefineProperty(this, "sponsorContainer", _descriptor10$1, this);
        _initializerDefineProperty(this, "sponsorImageContainer", _descriptor11$1, this);
        _initializerDefineProperty(this, "sponsorImage", _descriptor12$1, this);
        _initializerDefineProperty(this, "sponsorName", _descriptor13$1, this);
        _initializerDefineProperty(this, "textSection", _descriptor14$1, this);
        _initializerDefineProperty(this, "sponsorsAndPartnersLogosContainer", _descriptor15$1, this);
        this.loginContainer = {
          width: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "center"
        };
        _initializerDefineProperty(this, "infoLinesContainer", _descriptor16$1, this);
        _initializerDefineProperty(this, "infoLine", _descriptor17$1, this);
      }
    }, (_descriptor$3 = _applyDecoratedDescriptor(_class$3.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 1200,
          // backgroundColor: "#ddd",
          margin: "0 auto",
          maxWidth: "100%"
        };
      }
    }), _descriptor2$3 = _applyDecoratedDescriptor(_class$3.prototype, "logoSectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 1125 ? "column" : "row"
        };
      }
    }), _descriptor3$2 = _applyDecoratedDescriptor(_class$3.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 850 ? "column" : "row"
        };
      }
    }), _descriptor4$2 = _applyDecoratedDescriptor(_class$3.prototype, "logoContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor5$2 = _applyDecoratedDescriptor(_class$3.prototype, "image", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: Device.isMobileDevice() ? "100%" : 450
        };
      }
    }), _descriptor6$2 = _applyDecoratedDescriptor(_class$3.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: Device.isMobileDevice() ? "100%" : 670
        };
      }
    }), _descriptor7$2 = _applyDecoratedDescriptor(_class$3.prototype, "sectionTitleContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 30
        };
      }
    }), _descriptor8$2 = _applyDecoratedDescriptor(_class$3.prototype, "sectionTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: 32,
          lineHeight: 30,
          paddingBottom: 20,
          textAlign: "center",
          fontSize: 25,
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1,
          display: "flex",
          justifyContent: "center",
          color: IEEE_SECONDARY_COLOR,
          marginTop: Device.isMobileDevice() ? 0 : 30,
          marginBottom: 20
        };
      }
    }), _descriptor9$2 = _applyDecoratedDescriptor(_class$3.prototype, "sponsorsAndPartners", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center"
        };
      }
    }), _descriptor10$1 = _applyDecoratedDescriptor(_class$3.prototype, "sponsorContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 200,
          color: "inherit",
          cursor: "pointer",
          width: "40%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between"
        };
      }
    }), _descriptor11$1 = _applyDecoratedDescriptor(_class$3.prototype, "sponsorImageContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flex: 1
        };
      }
    }), _descriptor12$1 = _applyDecoratedDescriptor(_class$3.prototype, "sponsorImage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 120,
          display: "flex"
        };
      }
    }), _descriptor13$1 = _applyDecoratedDescriptor(_class$3.prototype, "sponsorName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          // alignItems: "center",
          paddingTop: 10,
          flex: 1,
          textAlign: "center",
          fontSize: 17,
          maxHeight: 50,
          letterSpacing: 0.5
        };
      }
    }), _descriptor14$1 = _applyDecoratedDescriptor(_class$3.prototype, "textSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          // paddingLeft: "5%",
          // paddingRight: "5%",
          textAlign: "justify",
          lineHeight: 22,
          letterSpacing: 0.5,
          display: "flex",
          flexDirection: "column",
          flex: 1,
          paddingLeft: 30,
          paddingRight: 30
        };
      }
    }), _descriptor15$1 = _applyDecoratedDescriptor(_class$3.prototype, "sponsorsAndPartnersLogosContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center"
        };
      }
    }), _descriptor16$1 = _applyDecoratedDescriptor(_class$3.prototype, "infoLinesContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexWrap: "wrap",
          flexDirection: "row",
          width: "100%",
          justifyContent: "center"
        };
      }
    }), _descriptor17$1 = _applyDecoratedDescriptor(_class$3.prototype, "infoLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          textAlign: "center",
          color: IEEE_PRIMARY_COLOR$1,
          fontSize: 15,
          fontWeight: 700
        };
      }
    })), _class$3);
    let IEEEXtremeContestSummary = (_dec$3 = registerStyle(IEEEXtremeContestSummaryStyle), _dec$3(_class2$2 = class IEEEXtremeContestSummary extends ContestSummary {
      getRegisterButton() {
        return null;
      }
      renderInfoLines() {
        const {
          contest
        } = this.options;
        const stats = contest.getStatistics() || {};
        const infoLines = [{
          label: UI$1.T("Teams Registered"),
          value: contest.getNumUsers() || "N/A"
        }, {
          label: UI$1.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI$1.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI$1.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI$1.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI$1.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
        return UI$1.createElement("div", {
          className: this.styleSheet.infoLinesContainer
        }, infoLines.map(infoLine => {
          return UI$1.createElement("div", {
            className: this.styleSheet.infoLine
          }, infoLine.label, " - ", infoLine.value);
        }));
      }
      getSectionTitle(title) {
        return [UI$1.createElement("div", {
          className: this.styleSheet.sectionTitleContainer
        }, UI$1.createElement("div", {
          className: this.styleSheet.sectionTitle
        }, title))];
      }
      getUnauthenticated() {
        if (USER.isAuthenticated) {
          return null;
        }
        const {
          contest
        } = this.options;
        return UI$1.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, UI$1.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in with IEEE Account"), UI$1.createElement("p", null, "Login using your IEEE member account to continue to ", contest.longName, ":"), UI$1.createElement("div", {
          className: this.styleSheet.loginWidget
        }, UI$1.createElement(IEEESSOLoginWidget, null))), UI$1.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in"), UI$1.createElement("p", null, "Login using your team account from the official email to continue to ", contest.longName, ":"), UI$1.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI$1.createElement(IEEELoginWidget, null))), UI$1.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Forgot password?"), UI$1.createElement("p", null, "Enter your email address below, and an email with further instructions on how to reset your password will be sent to all members of your team:"), UI$1.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI$1.createElement(IEEEPasswordResetRequestWidget, null))));
      }
      getAboutIEEEXtreme() {
        const {
          contest
        } = this.options;
        return [UI$1.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("IEEEXtreme"), UI$1.createElement("p", null, UI$1.createElement(Link, {
          href: "https://ieeextreme.org/",
          newTab: true
        }, "IEEEXtreme"), " is a global challenge in which teams of IEEE Student members \u2013 advised and proctored by an IEEE member, and often supported by an IEEE Student Branch \u2013 compete in a 24-hour time span against each other to solve a set of programming problems."), UI$1.createElement("p", null, "See the full ", contest.longName, " rules ", UI$1.createElement(Link, {
          href: "https://ieeextreme.org/rules/",
          newTab: true
        }, "here"), "."))];
      }
      getPlatformHelp() {
        return [UI$1.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Programming Environment"), UI$1.createElement("p", null, "You can find out more about the CS Academy environment from the ", UI$1.createElement(Link, {
          href: "/about",
          newTab: true
        }, " about page"), "."), UI$1.createElement("p", null, "To familiarize yourself with the platform, and try to solve some problems with the past IEEEXtreme competitions, please access the ", UI$1.createElement(Link, {
          href: "/ieeextreme-practice/",
          newTab: true
        }, "the practice community"), "."))];
      }
      renderSponsor(sponsorInfo) {
        const [name, imageURL, websiteURL] = sponsorInfo;
        return [UI$1.createElement(Link, {
          className: this.styleSheet.sponsorContainer,
          href: websiteURL,
          newTab: true
        }, UI$1.createElement("div", {
          className: this.styleSheet.sponsorImageContainer
        }, UI$1.createElement(Image, {
          src: imageURL,
          className: this.styleSheet.sponsorImage
        })), UI$1.createElement("div", {
          className: this.styleSheet.sponsorName
        }, name))];
      }
      renderPartners() {
        const {
          contest
        } = this.options;
        const {
          partners
        } = contest.getExtraSummary();
        return [UI$1.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners,
          style: {
            flex: .4
          }
        }, this.getSectionTitle("Partners"), UI$1.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, (partners || []).map(partner => this.renderSponsor(partner)))), UI$1.createElement("div", {
          style: {
            paddingBottom: 50
          }
        })];
      }
      renderSponsors() {
        const {
          contest
        } = this.options;
        const {
          sponsors
        } = contest.getExtraSummary();
        return [UI$1.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners,
          style: {
            flex: 1
          }
        }, this.getSectionTitle("Sponsors"), UI$1.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, (sponsors || []).map(sponsor => this.renderSponsor(sponsor))))];
      }
      renderLogo() {
        const {
          contest
        } = this.options;
        return UI$1.createElement("div", {
          className: `${this.styleSheet.logoContainer} ${this.styleSheet.textSection}`
        }, UI$1.createElement(Link, {
          href: "https://ieeextreme.org",
          newTab: true
        }, UI$1.createElement(Image, {
          src: contest.getLogoURL(),
          className: this.styleSheet.image
        })), this.renderInfoLines());
      }
      render() {
        const {
          contest
        } = this.options;
        return [UI$1.createElement("div", {
          className: this.styleSheet.logoSectionContainer
        }, this.renderLogo(), UI$1.createElement(IEEEXtremeContestCountdown, {
          contest: contest,
          className: `${this.styleSheet.countdown} ${this.styleSheet.textSection}`
        })), this.getUnauthenticated(), UI$1.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, this.getAboutIEEEXtreme(), this.getPlatformHelp()), UI$1.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, this.renderPartners(), this.renderSponsors()), UI$1.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI$1.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI$1.createElement("hr", null), UI$1.createElement("h4", null, "For any technical issues, please send an email to contact@csacademy.com"), UI$1.createElement("h4", null, "Please try to provide as many details as possible for your problem (OS, browser, steps to reproduce, etc)."), UI$1.createElement("h4", null, "Have a great contest experience!"))), UI$1.createElement("div", {
          style: {
            height: 50,
            width: "100%"
          }
        })];
      }
    }) || _class2$2);

    class IEEEXtremeUnauthenticatedPanel extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelUnauthenticatedNavigationHandler(this.getContest(), this);
      }
      getContest() {
        return this.options.contest;
      }
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }
      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }
      getSummaryPanel() {
        return UI.createElement(IEEEXtremeContestSummary, {
          contest: this.getContest()
        });
      }
      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel())];
      }
      onMount() {
        super.onMount();
        this.navHandler.apply();
      }
    }

    var _class$2, _descriptor$2, _descriptor2$2, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10, _dec$2, _class2$1, _class3, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _dec2$1, _class4;
    const formatFloat = score => {
      score = Math.ceil(parseFloat(score) * 100);
      if (score % 100 === 0) {
        return parseInt(score / 100);
      } else if (score % 10 === 0) {
        return parseFloat(score / 100).toFixed(1);
      } else {
        return parseFloat(score / 100).toFixed(2);
      }
    };
    function hiddenBelowWidth(width) {
      return window.innerWidth <= width ? "none !important" : null;
    }
    let IEEEXtremeContestTaskBubbleStyle = (_class$2 = class IEEEXtremeContestTaskBubbleStyle extends ContestTaskBubbleStyle {
      constructor(...args) {
        super(...args);
        this.height = 100;
        _initializerDefineProperty(this, "className", _descriptor$2, this);
        _initializerDefineProperty(this, "timeAdded", _descriptor2$2, this);
        _initializerDefineProperty(this, "averageScore", _descriptor3$1, this);
        _initializerDefineProperty(this, "attemptsCount", _descriptor4$1, this);
        _initializerDefineProperty(this, "taskDescription", _descriptor5$1, this);
        _initializerDefineProperty(this, "taskName", _descriptor6$1, this);
        _initializerDefineProperty(this, "pointsWorth", _descriptor7$1, this);
        _initializerDefineProperty(this, "attempted", _descriptor8$1, this);
        _initializerDefineProperty(this, "average", _descriptor9$1, this);
        _initializerDefineProperty(this, "userScore", _descriptor10, this);
      }
    }, (_descriptor$2 = _applyDecoratedDescriptor(_class$2.prototype, "className", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "row"
        };
      }
    }), _descriptor2$2 = _applyDecoratedDescriptor(_class$2.prototype, "timeAdded", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#999",
          fontSize: "14px",
          lineHeight: this.height / 2,
          textAlign: "left"
        };
      }
    }), _descriptor3$1 = _applyDecoratedDescriptor(_class$2.prototype, "averageScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          lineHeight: this.height / 2,
          fontSize: "30px",
          marginTop: "15px",
          marginBottom: "-15px"
        };
      }
    }), _descriptor4$1 = _applyDecoratedDescriptor(_class$2.prototype, "attemptsCount", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          lineHeight: this.height / 2
        };
      }
    }), _descriptor5$1 = _applyDecoratedDescriptor(_class$2.prototype, "taskDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          paddingLeft: "5%",
          overflow: "hidden",
          position: "relative"
        };
      }
    }), _descriptor6$1 = _applyDecoratedDescriptor(_class$2.prototype, "taskName", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "left",
          paddingLeft: 0,
          marginBottom: "-10px",
          marginTop: "10px"
        };
      }
    }), _descriptor7$1 = _applyDecoratedDescriptor(_class$2.prototype, "pointsWorth", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "94px",
          fontSize: "20px",
          fontWeight: "bold",
          color: "black",
          display: hiddenBelowWidth(672)
        };
      }
    }), _descriptor8$1 = _applyDecoratedDescriptor(_class$2.prototype, "attempted", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: hiddenBelowWidth(772),
          minWidth: "100px"
        };
      }
    }), _descriptor9$1 = _applyDecoratedDescriptor(_class$2.prototype, "average", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: hiddenBelowWidth(872),
          minWidth: "90px"
        };
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class$2.prototype, "userScore", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "100px"
        };
      }
    })), _class$2);
    let IEEEXtremeContestTaskBubble = (_dec$2 = registerStyle(IEEEXtremeContestTaskBubbleStyle), _dec$2(_class2$1 = class IEEEXtremeContestTaskBubble extends ContestTaskBubble {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          circleStrokeWidth: 4,
          circlePadding: 4
        });
      }
      getTaskDescriptionSection() {
        const timeAdded = this.getContestTask().getBroadcastDelay();
        let timeAddedMessage;
        if (timeAdded > 0) {
          timeAddedMessage = "added after " + Formatter.duration(timeAdded, {
            hours: true,
            minutes: true,
            lastSeparator: " and "
          });
        } else {
          timeAddedMessage = "added at contest start";
        }
        let newLabel;
        const duration = ServerTime.now().diffDuration(this.getContestTask().getTimeAvailable());
        if (timeAdded > 0 && duration.toMinutes() < 10) {
          newLabel = UI$1.createElement(Label, {
            label: "NEW !",
            level: Level.DANGER,
            style: {
              position: "absolute",
              left: "-28px",
              top: "14px",
              padding: "0 30px",
              transform: "rotate(-45deg)",
              pointerEvents: "none",
              userSelect: "none"
            }
          });
          setTimeout(() => this.redraw(), 10 * 60 * 1000 - duration.toMilliseconds() + 2000);
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.taskDescription
        }, newLabel, UI$1.createElement("div", {
          className: this.styleSheet.taskName
        }, UI$1.T(this.getContestTask().longName)), UI$1.createElement("div", {
          className: this.styleSheet.timeAdded
        }, timeAddedMessage));
      }
      getPointsWorthSection() {
        const pointsWorth = formatFloat(this.getContestTask().pointsWorth);
        return UI$1.createElement("div", {
          className: this.styleSheet.pointsWorth,
          ref: "pointsWorth"
        }, pointsWorth);
      }
      getCircleArgs() {
        return Object.assign({}, super.getCircleArgs(), {
          radius: (this.styleSheet.height * 0.8 - this.options.circleStrokeWidth) / 2 - this.options.circlePadding,
          stroke: this.getScoreColor(this.getContestTask().getContest().getUser(USER.id).scores[this.getContestTask().id].score)
        });
      }
      getSVGContent(firstText, secondText, hasCircle, circleRatio, fill = "black") {
        let circle;
        if (hasCircle) {
          circle = this.getCircleArc(circleRatio);
        }
        return [circle, UI$1.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 - 9,
          text: firstText,
          fontSize: "16",
          fill: fill
        }), UI$1.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 + 9,
          text: secondText,
          fontSize: "10",
          fill: fill
        })];
      }
      getUserScoreSection() {
        const contestTask = this.getContestTask();
        let contestUser = contestTask.getContest().getUser(USER.id);
        let pointsSVG;
        if (contestUser && contestUser.scores && contestUser.scores[contestTask.id]) {
          const scoreRatio = contestUser.scores[contestTask.id].score;
          const score = formatFloat(scoreRatio * this.getContestTask().pointsWorth);
          const scorePercent = formatFloat(scoreRatio * 100) + "%";
          pointsSVG = UI$1.createElement(SVG.SVGRoot, {
            height: this.styleSheet.height,
            width: this.styleSheet.height
          }, this.getSVGContent(score + "p", scorePercent, true, scoreRatio, this.getScoreColor(scoreRatio)));
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.userScore
        }, pointsSVG);
      }
      getAttemptedSection() {
        let content;
        const userCount = this.getContestTask().getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2).length;
        if (this.getContestTask().getContest()._loadedScoreboard) {
          const attemptsRatio = this.attemptsCount / userCount;
          const attemptsPercent = formatFloat(attemptsRatio ? attemptsRatio * 100 : 0) + "%";
          const attemptsMessage = this.attemptsCount ? this.attemptsCount == 1 ? "1 team" : this.attemptsCount + " teams" : "no attempts";
          content = UI$1.createElement(SVG.SVGRoot, {
            height: this.styleSheet.height,
            width: this.styleSheet.height
          }, this.getSVGContent(attemptsPercent, attemptsMessage, false, 0));
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.attempted,
          ref: "attempted"
        }, content);
      }
      redraw() {
        if (!this.redrawThrottler) {
          this.redrawThrottler = new CallThrottler({
            throttle: 1000
          });
          this.redrawThrottled = this.redrawThrottler.wrap(() => super.redraw());
        }
        this.redrawThrottled();
      }
      getAverageSection() {
        let content;
        if (this.getContestTask().getContest()._loadedScoreboard) {
          const average = this.attemptsCount ? this.averageScore + "p" : "-";
          const averageRatio = this.averageScore / this.getContestTask().pointsWorth;
          const averagePercent = formatFloat(averageRatio * 100) + "%";
          content = UI$1.createElement(SVG.SVGRoot, {
            height: this.styleSheet.height,
            width: this.styleSheet.height
          }, this.getSVGContent(average, averagePercent, false, 0));
        }
        return UI$1.createElement("div", {
          className: this.styleSheet.average,
          ref: "averageScore"
        }, content);
      }
      computeStatistics() {
        let count = 0,
          sum = 0;
        const contestTask = this.getContestTask();
        const users = contestTask.getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2);
        for (const user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            count += 1;
            sum += user.scores[contestTask.id].score;
          }
        }
        this.attemptsCount = count;
        this.averageScore = formatFloat(count ? sum / count * this.getContestTask().pointsWorth : 0);
      }
      render() {
        this.computeStatistics();
        return [this.getTaskDescriptionSection(), this.getUserScoreSection(), this.getPointsWorthSection(), this.getAttemptedSection(), this.getAverageSection()];
      }
      getScoreColor(percent) {
        const colorSuccess = "#185f9c";
        const colorDanger = "#e2722d";
        return Color$1.interpolate(colorDanger, colorSuccess, percent);
      }
    }) || _class2$1);
    class IEEEXtremeColumnContentGetters extends ColumnContentGetters {
      static getTimeAdded(contestTask, isArchive) {
        // TODO: Add code for Archive when needed.
        return contestTask.getBroadcastDelay();
      }
      static getAverageScore(contestTask, isArchive) {
        // TODO: Add code for Archive when needed.
        let count = 0,
          sum = 0;
        const users = contestTask.getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2);
        for (const user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            count += 1;
            sum += user.scores[contestTask.id].score;
          }
        }
        return sum / count;
      }
      static getPointsWorth(contestTask, isArchive) {
        return contestTask.pointsWorth;
      }
      static getTried(contestTask, isArchive) {
        let users = contestTask.getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2);
        let tried = 0;
        for (let user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            tried += 1;
          }
        }
        return tried;
      }
    }
    let IEEEXtremeContestTaskListHeaderStyle = (_class3 = class IEEEXtremeContestTaskListHeaderStyle extends ContestTaskListHeaderStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "className", _descriptor11, this);
        _initializerDefineProperty(this, "timeAdded", _descriptor12, this);
        _initializerDefineProperty(this, "taskDescription", _descriptor13, this);
        _initializerDefineProperty(this, "userScore", _descriptor14, this);
        _initializerDefineProperty(this, "pointsWorth", _descriptor15, this);
        _initializerDefineProperty(this, "attempted", _descriptor16, this);
        _initializerDefineProperty(this, "averageScore", _descriptor17, this);
        _initializerDefineProperty(this, "taskName", _descriptor18, this);
      }
    }, (_descriptor11 = _applyDecoratedDescriptor(_class3.prototype, "className", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          textAlign: "left"
        };
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class3.prototype, "timeAdded", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height,
          lineHeight: this.height + "px",
          minWidth: "34%",
          color: "rgb(55,55,55)",
          fontSize: "14px"
        };
      }
    }), _descriptor13 = _applyDecoratedDescriptor(_class3.prototype, "taskDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          flexDirection: "row"
        };
      }
    }), _descriptor14 = _applyDecoratedDescriptor(_class3.prototype, "userScore", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "100px"
        };
      }
    }), _descriptor15 = _applyDecoratedDescriptor(_class3.prototype, "pointsWorth", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "94px",
          display: hiddenBelowWidth(672)
        };
      }
    }), _descriptor16 = _applyDecoratedDescriptor(_class3.prototype, "attempted", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "100px",
          display: hiddenBelowWidth(872)
        };
      }
    }), _descriptor17 = _applyDecoratedDescriptor(_class3.prototype, "averageScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "90px",
          display: hiddenBelowWidth(772)
        };
      }
    }), _descriptor18 = _applyDecoratedDescriptor(_class3.prototype, "taskName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "-10px"
        };
      }
    })), _class3);
    let IEEEXtremeTaskListHeader = (_dec2$1 = registerStyle(IEEEXtremeContestTaskListHeaderStyle), _dec2$1(_class4 = class IEEEXtremeTaskListHeader extends ContestTaskListHeader {
      createSortableHeaders() {
        this.NameSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getName);
        this.ScoreSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getScore, this.NameSort.cmp);
        this.AttemptedSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getTried, this.NameSort.cmp);
        this.PointsWorthSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getPointsWorth, this.NameSort.cmp);
        this.TimeAddedSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getTimeAdded, this.NameSort.cmp);
        this.AverageScoreSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getAverageScore, this.NameSort.cmp);
      }
      render() {
        this.headers = [];
        const name = UI$1.createElement(this.NameSort, {
          name: UI$1.T("Task"),
          className: this.styleSheet.taskName,
          style: {
            marginRight: "2px",
            display: "inline-block"
          }
        });
        const timeAdded = UI$1.createElement(this.TimeAddedSort, {
          name: UI$1.T("Time added"),
          state: -1
        });
        const score = UI$1.createElement(this.ScoreSort, {
          name: UI$1.T("Your score"),
          className: this.styleSheet.userScore
        });
        const pointsWorth = UI$1.createElement(this.PointsWorthSort, {
          ref: "pointsWorth",
          name: UI$1.T("Points worth"),
          className: this.styleSheet.pointsWorth
        });
        const attempted = UI$1.createElement(this.AttemptedSort, {
          ref: "attempted",
          name: UI$1.T("Teams tried"),
          className: this.styleSheet.attempted
        });
        const averageScore = UI$1.createElement(this.AverageScoreSort, {
          ref: "averageScore",
          name: UI$1.T("Average score"),
          className: this.styleSheet.averageScore
        });
        this.headers.push(...[name, score, timeAdded, attempted, averageScore]);
        return [UI$1.createElement("div", {
          className: this.styleSheet.className
        }, UI$1.createElement("div", {
          className: this.styleSheet.taskDescription
        }, name, "|", timeAdded), score, pointsWorth, attempted, averageScore)];
      }
    }) || _class4);
    class NextTaskIntervalCounter extends UI$1.Element {
      getDefaultOptions() {
        return {
          style: {
            textAlign: "center"
          }
        };
      }
      render() {
        let nextTaskAnnouncement;
        const nextTaskUnix = this.options.contest.getNextTaskTimestamp();
        const formatUnit = value => {
          if (value <= 9) {
            return "0" + value;
          }
          return value;
        };
        if (nextTaskUnix) {
          let diff = (nextTaskUnix - ServerTime.now().unix()) * 1000;
          if (diff >= -30 * 1000) {
            if (diff < 0) {
              diff = 0;
            }
            const diffDuration = new Duration(diff);
            const diffFormat = formatUnit(diffDuration.getHours()) + ":" + formatUnit(diffDuration.getMinutes()) + ":" + formatUnit(diffDuration.getSeconds());
            const message = `Next task will be added in ${diffFormat}`;
            nextTaskAnnouncement = UI$1.createElement("h3", null, message);
          }
        }
        return nextTaskAnnouncement;
      }
      onMount() {
        this.interval = setInterval(() => this.redraw(), 1000);
      }
      onUnmount() {
        clearInterval(this.interval);
      }
    }
    class IEEEXtremeContestTasksList extends ContestTaskList {
      getHeader() {
        return UI$1.createElement(IEEEXtremeTaskListHeader, {
          ref: "header",
          isArchive: this.options.isArchive,
          contest: this.getContest()
        });
      }
      getContestTaskBubble(task) {
        return UI$1.createElement(IEEEXtremeContestTaskBubble, {
          key: task.id,
          isArchive: this.options.isArchive,
          contestTask: task
        });
      }
      handleResize() {
        if (window.innerWidth > 1106) {
          this.setStyle("margin", null);
        }
        if (window.innerWidth <= 1106) {
          this.setStyle("margin", "0");
        }
      }
      render() {
        return [UI$1.createElement(NextTaskIntervalCounter, {
          contest: this.getContest()
        }), ...super.render()];
      }
      onMount() {
        super.onMount();
        this.handleResize();
        window.addEventListener("resize", () => this.handleResize());
      }
    }

    class IEEEXtremeContestPanel extends ContestPanel {
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelContestNavigationHandler(this.getContest(), this);
      }
      getSummaryPanel() {
        return UI.createElement(IEEEXtremeContestSummary, {
          contest: this.getContest()
        });
      }
      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(IEEEXtremeScoreboard, {
          ref: this.refLink("scoreboard"),
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }
      getTasksListPanel() {
        return UI.createElement(IEEEXtremeContestTasksList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }
    }

    class IEEEXtremeContestPage extends DelayedArchiveOrContestPanel {
      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }
      renderLoaded() {
        if (!USER.isAuthenticated) {
          return UI$1.createElement(IEEEXtremeUnauthenticatedPanel, {
            ref: "child",
            contest: ContestStore.get(this.contestId)
          });
        }
        if (this.options.error) {
          return this.renderError();
        }
        return UI$1.createElement(IEEEXtremeContestPanel, {
          contestId: this.contestId,
          ref: "child"
        });
      }
    }

    const IEEEXTREME_URL = "ieeextreme-practice";
    class IEEEXtremePracticeContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        attr.setStyle({
          margin: "auto",
          maxWidth: 800
        });
      }
      getRegisterButton() {
        return null;
      }
      getNeedLoginMessage() {
        if (USER.isAuthenticated) {
          return;
        }
        return UI$1.createElement("h4", null, "You need to be authenticated to submit a solution, please login.");
      }
      getDescription() {
        return UI$1.createElement("div", {
          style: {
            marginTop: "20px"
          }
        }, UI$1.createElement("h3", null, "Welcome to the practice community for IEEEXtreme!"), UI$1.createElement("h4", null, "Please familiarize yourself with the contest interface."), this.getNeedLoginMessage(), UI$1.createElement("h4", null, "You can read more about the environment your sources will he evaluated with ", UI$1.createElement(Link, {
          href: "/about/environment",
          newTab: true
        }, "here")), UI$1.createElement("h4", null, "We recommend you also try the ", UI$1.createElement(Link, {
          value: "CS Academy archive",
          href: "/contest/archive/",
          newTab: true
        }), " of problems where you will find some easier, and also not so easy tasks."));
      }
      render() {
        return [UI$1.createElement(Image, {
          src: "/static/svg/XtremeLogo_practice_community.svg"
        }),
        // this.getInfo(false),
        this.getDescription()];
      }
    }
    class IEEEXtremePracticeNavigationHandler extends TopLevelArchiveNavigationHandler {
      getLeftChildren() {
        return [UI$1.createElement(NavLinkElement, {
          href: this.getURLPrefix(),
          value: UI$1.T("Summary")
        }), ...super.getLeftChildren()];
      }
    }
    class IEEEXtremePracticeArchivePanel extends ArchivePanel {
      getURLPrefix(str) {
        let url = "/" + this.getArchive().name + "/";
        if (str) {
          url += str + "/";
        }
        return url;
      }
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremePracticeNavigationHandler(this.getArchive(), this);
      }
      getSummaryPanel() {
        return UI$1.createElement(IEEEXtremePracticeContestSummary, {
          contest: this.getArchive()
        });
      }
      getTasks() {
        return UI$1.createElement(ContestTaskListWithFilters, {
          contest: this.getArchive(),
          isArchive: true
        });
      }
      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), [new Route("tasks", () => this.getTasks()), new Route("task", () => this.getTasks(), [new TerminalRoute("%s", options => {
          const contestTask = ContestTaskStore.getByContestIdAndUrlName(this.getArchive().baseContestId, options.args[0]);
          return contestTask && UI$1.createElement(DelayedContestTaskPanel, {
            contestTaskId: contestTask.id
          });
        })]), new Route("scoreboard", () => this.getScoreboard()), new Route("submissions", () => this.getSubmissions()), new Route("chat", () => this.getChat())]);
        return this.routes;
      }
    }
    class IEEEXtremePracticeContestPanelWrapper extends DelayedArchiveOrContestPanel {
      getAjaxUrl() {
        return "/" + IEEEXTREME_URL + "/";
      }
      renderLoaded() {
        return UI$1.createElement(IEEEXtremePracticeArchivePanel, {
          archiveId: this.archiveId,
          ref: "child"
        });
      }
    }

    // TODO should this be removed?
    class IEEEPasswordResetWidget extends IEEELoginWidget {
      getSignInValue() {
        return "Set password";
      }
      sendLogin() {
        this.clearErrorMessage();
        const password = this.passwordInput.getValue();
        const passwordConfirm = this.passwordConfirmInput.getValue();
        if (password !== passwordConfirm) {
          this.setErrorMessage({
            message: "Passwords don't match."
          });
          return;
        }
        Ajax.postJSON("/accounts/password_change/", {
          newPassword: password
        }).then(() => this.setErrorMessage({
          message: "Successfully set the new password"
        }, false), error => this.setErrorMessage(error));
      }
      render() {
        return [UI$1.createElement("form", {
          ref: "form"
        }, this.getPasswordInput(), this.getPasswordInput({
          ref: "passwordConfirmInput",
          name: "passwordConfirm",
          placeholder: "Confirm Password"
        }), this.getSignInButton(), UI$1.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }
    }

    // TODO @ieee why the inheritance? UI.Element not ok?
    class IEEEXtremePasswordResetPage extends StateDependentElement(IEEEXtremeContestSummary) {
      getPasswordResetArea() {
        let text = "Enter a new password:";
        let passwordResetWidget = null;
        if (this.options.error) {
          text = UI$1.createElement("span", {
            style: {
              color: "red"
            }
          }, this.options.error.message);
        } else {
          passwordResetWidget = UI$1.createElement("div", {
            className: this.styleSheet.loginContainer,
            style: {
              width: 500
            }
          }, UI$1.createElement(IEEEPasswordResetWidget, null));
        }
        return [UI$1.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column"
          }
        }, UI$1.createElement("div", {
          className: this.styleSheet.textSection
        }, UI$1.createElement("p", null, text)), passwordResetWidget)];
      }
      getLogo() {
        return [];
      }
      renderLoaded() {
        return [this.getLogo(), this.getSectionTitle("Password reset"), this.getPasswordResetArea()];
      }
      onDelayedMount() {}
    }

    class GenericErrorView extends UI$1.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.EXTRA_SMALL);
      }
      render() {
        return StateDependentElement.renderError(ErrorHandlers.PAGE_NOT_FOUND);
      }
    }
    class PageNotFoundRoute extends Route {
      constructor() {
        super([], GenericErrorView, [], "Page not found11");
      }
      matches(urlParts) {
        return {
          args: [],
          urlParts: urlParts
        };
      }
      matchesOwnNode() {
        return true;
      }
    }

    class RichEditorTest extends UI$1.Element {
      constructor(...args) {
        super(...args);
        this.Cls = null;
      }
      render() {
        const Cls = this.Cls;
        if (Cls) {
          return UI$1.createElement(Cls, null);
        }
        ensure("/static/js/RichEditorWrapper.js", modules => {
          console.log("Modules", modules);
          window["require"](["RichEditorWrapper"], exports => {
            this.Cls = exports.RichEditorWrapper;
            this.redraw();
          });
        });
        return UI$1.createElement("h1", null, "Loading....");
      }
    }

    class CheckerEditor extends UI$1.Element {
      render() {
        return UI$1.createElement("h1", null, "Checker editor");
      }
    }

    class IEEEXtremeContestRoute extends TerminalRoute {
      constructor(options = {}) {
        super("ieeextreme", IEEEXtremeContestPage, options);
      }
      matches(urlParts) {
        const contestName = urlParts[0];
        if (!contestName?.startsWith("ieeextreme")) {
          return null;
        }
        return {
          args: contestName,
          urlParts: urlParts.slice(1)
        };
      }
    }

    // TODO Are we missing the page title for these??
    const ROUTES = new Route(null, StateDependentElement(FrontPagePanel), [new TerminalRoute("about", CSAAboutPage, [], "About CS Academy"), new TerminalRoute("rich-editor-test", RichEditorTest, [], "Rich Editor Test"), new Route("problem-setting", ProblemSetting), new Route("lessons", StateDependentElement(LessonList), [], "Lessons"), new Route(["lesson", "%s"], StateDependentElement(LessonPanel)), new Route("ratings", StateDependentElement(GlobalRatings), [], "Ratings Leaderboard"), new Route("real_ratings", StateDependentElement(GlobalRatings)), new Route("reputations", StateDependentElement(GlobalRatings)), new Route(["code", "%s"], StateDependentElement(CustomRunWidget), [], "CS Academy - Code"), new Route(["submission", "%s"], SubmissionWidget, [], "CS Academy - Submission"), new BlogRoute(), new ForumRoute(), new Route(["eval", "global"], StateDependentElement(SubmissionSummaryGlobalFilter)), new Route(["eval", "manager"], EvalTaskManager), new Route(["eval", "checkers"], StateDependentElement(CheckerManager)), new TerminalRoute(["eval", "checker", "%s"], StateDependentElement(CheckerEditor)), new TerminalRoute(["task", "%s", "edit"], StateDependentElement(EvalTaskEditor)), new Route(["article", "manager"], ArticleManager), new Route(["article", "%s", "edit"], StateDependentElement(ArticleEditor)), new Route("app", null, [new Route("graph_editor", GraphEditor, [], "Graph Editor"), new Route("diffing_tool", DiffWidgetApp), new Route("geometry_widget", CSAGeometryWidget, [], "Geometry Widget")]), new Route("contests", StateDependentElement(ContestList), [], "Contests"), new Route("contest", null, [new Route("manager", StateDependentElement(ContestManager)), new Route(["invite", "%s"], StateDependentElement(ContestInvitePage)), new Route(["%s", "edit"], StateDependentElement(ContestEditPanel)), new TerminalRoute("%s", DelayedArchiveOrContestPanel)]), new Route("private-archives", StateDependentElement(PrivateArchiveList)), new Route("private-archive", null, [new TerminalRoute("%s", StateDependentElement(PrivateArchivePanelWrapper))]), new Route("interview", StateDependentElement(InterviewApp), [new TerminalRoute("%s", StateDependentElement(InterviewPanelWrapper))]), new Route("accounts", null, [new TerminalRoute("settings", StateDependentElement(AccountSettingsPanel)), new Route("workspace_settings", StateDependentElement(UserWorkspaceSettingsPanel)), new Route(["email_address_verify", "%s"], StateDependentElement(EmailConfirmed)), new Route(["email_unsubscribe", "%s"], StateDependentElement(EmailUnsubscribe)), new Route("password_reset", PasswordReset, [new Route("%s", StateDependentElement(PasswordResetFromKey))]), new Route(["activate", "%s"], AccountActivation)]), new Route(["user", "%s"], StateDependentElement(UserProfilePanel)), new Route(["userid", "%s"], StateDependentElement(UserProfilePanel)), new TerminalRoute("messages", MessagesPanel), new TerminalRoute("workspace", WorkspaceManagerWrapper), new TerminalRoute(["email", "manager"], StateDependentElement(EmailManager)), new Route(["baseconfig", "command", "manager"], StateDependentElement(CommandManager)), new Route("manage", StateDependentElement(AdminPanel), [new TerminalRoute("icarus", StateDependentElement(Icarus)), new Route("users", StateDependentElement(UserStats)), new Route("charts", StatisticCharts, [], "Statistics"), new TerminalRoute("translation", StateDependentElement(TranslationManager))]), new TerminalRoute(["storage", "manager"], StateDependentElement(StorageManager)), new DocumentationRoute(), new TerminalRoute("ieeextreme-practice", IEEEXtremePracticeContestPanelWrapper), new IEEEXtremeContestRoute(), new Route(["ieee_password_reset", "%s"], IEEEXtremePasswordResetPage), new Route(["questionnaire", "%s", "answers"], DelayedQuestionnaireAnswersPanel), new Route("analytics", AnalyticsPanel), new Route("donate", Donate), new PageNotFoundRoute()]);

    class ChatPlugin extends Plugin {
      linkToParent(parent) {
        this.chatWidget = parent;
      }
      getChatbox() {
        return this.chatWidget.chatInput;
      }
    }

    class UserMentionPlugin extends ChatPlugin {
      constructor() {
        super(...arguments);
        if (!this.getChatbox()) {
          return;
        }
        if (this.chatWidget.getPlugin("EnterToSendPlugin")) {
          this.chatWidget.removePlugin("EnterToSendPlugin");
          this._enterToSend = true;
        }
        this.getChatbox().addNodeListener("keydown", event => {
          if (event.keyCode === 39 || event.keyCode === 37) {
            // Left and right arrows
            setTimeout(() => {
              // This needs to be wrapped in a setTimeout as the getCaretPosition needs selectionEnd which
              // updates async and does not have an event attached to it.
              this.handleChange();
            }, 0);
          }
          if (event.shiftKey || event.ctrlKey) {
            return;
          }
          if (event.key === "Enter" || event.keyCode === 13) {
            if (!this.duringAutocomplete && this._enterToSend) {
              this.chatWidget.sendMessage();
              event.preventDefault();
            }
          }
          AutocompleteWindow.handleKeydownEvent(this, event);
        });
        this.getChatbox().addNodeListener("input", () => {
          this.handleChange();
        });
        this.getChatbox().addClickListener(() => {
          setTimeout(() => {
            this.handleChange();
          }, 0);
        });
        this.addListener("autocomplete", userIds => {
          AutocompleteWindow.handleAutocomplete(this, userIds, this.getChatbox());
        });
        this.getChatbox().addListener("messageSent", () => {
          this.duringAutocomplete = false;
          this.dispatch("autocomplete", []);
        });
      }
      autocompleteUser(userId) {
        this.getChatbox().node.focus();
        let caretPosition = this.getCaretPosition();
        let text = this.getChatbox().getValue();
        let lastAtPosition = this.getLastAtPosition(caretPosition);
        const userMarkup = "<User id=\"" + userId + "\" /> ";
        text = text.substring(0, lastAtPosition + 1) + userMarkup + text.substring(caretPosition);
        this.getChatbox().setValue(text);
        this.setCaretPosition(lastAtPosition + 1 + userMarkup.length);
        this.dispatch("autocomplete", []);
      }
      handleChange() {
        let caretPosition = this.getCaretPosition();
        let lastAtPosition = this.getLastAtPosition(caretPosition);
        if (lastAtPosition === -1) {
          this.dispatch("autocomplete", []);
        } else {
          let prefix = this.getChatbox().getValue().substring(lastAtPosition + 1, caretPosition);
          AbstractUsernameAutocomplete.loadUsersForPrefix(prefix, userIds => {
            this.dispatch("autocomplete", userIds);
          });
        }
      }
      getCaretPosition() {
        let textArea = this.getChatbox().node;
        if (typeof textArea.selectionStart === "number" && typeof textArea.selectionEnd === "number") {
          return textArea.selectionEnd;
        }
        let range = document.selection.createRange();
        if (range && range.parentElement() == textArea) {
          let len = textArea.value.length;
          let normalizedValue = textArea.value.replace(/\r\n/g, "\n");

          // Create a working TextRange that lives only in the input
          let textInputRange = textArea.createTextRange();
          textInputRange.moveToBookmark(range.getBookmark());

          // Check if the start and end of the selection are at the very end
          // of the input, since moveStart/moveEnd doesn't return what we want
          // in those cases
          let endRange = textArea.createTextRange();
          endRange.collapse(false);
          if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
            return len;
          }
          let end = -textInputRange.moveEnd("character", -len);
          end += normalizedValue.slice(0, end).split("\n").length - 1;
          return end;
        }
        return null;
      }
      setCaretPosition(caretPosition) {
        let node = this.getChatbox().node;
        if (node.createTextRange) {
          let range = node.createTextRange();
          range.move("character", caretPosition);
          range.select();
        } else {
          node.focus();
          if (node.selectionStart) {
            node.setSelectionRange(caretPosition, caretPosition);
          }
        }
      }
      getLastAtPosition(caret) {
        let text = this.getChatbox().getValue();
        if (arguments.length < 1) {
          caret = text.length;
        }
        let lastAtPosition = caret - 1;
        while (lastAtPosition >= 0 && text.charCodeAt(lastAtPosition) !== 64) {
          let char = text[lastAtPosition];
          if (char !== "." && char !== "_" && !char.match(/\d/) && !char.match(/\w/)) {
            lastAtPosition = -1;
            break;
          }
          lastAtPosition -= 1;
        }
        return lastAtPosition;
      }
    }

    class EnterToSendPlugin extends ChatPlugin {
      constructor() {
        super(...arguments);
        if (!this.getChatbox()) {
          return;
        }
        this.callback = event => {
          if (!(event.shiftKey || event.ctrlKey) && (event.key === "Enter" || event.keyCode === 13)) {
            this.chatWidget.sendMessage();
            event.preventDefault();
          }
        };
        this.getChatbox().addNodeListener("keydown", this.callback);
      }
      remove() {
        this.getChatbox().removeNodeListener("keydown", this.callback);
      }
    }

    class StemApp extends UI$1.Element {
      static init() {
        self.GlobalState = GlobalState$1; // Expose it for debugging
        self.appInstance = this.create(document.body);
        return self.appInstance;
      }
      getRoutes() {
        return this.options.routes;
      }
      getBeforeContainer() {
        return null;
      }
      getRouterOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }
      handleRouteChange() {
        document.body.click(); // TODO Really bro?
        Dispatcher.Global.dispatch("closeAllModals");
      }
      getRouter() {
        return UI$1.createElement(Router, _extends({
          ref: "router",
          routes: this.getRoutes(),
          onChange: (...args) => this.handleRouteChange(...args)
        }, this.getRouterOptions()));
      }
      getContainer() {
        return UI$1.createElement(GlobalContainer, null, this.getRouter());
      }
      getAfterContainer() {
        return null;
      }
      render() {
        return [this.getBeforeContainer(), this.getContainer(), this.getAfterContainer()];
      }
    }

    var _dec$1, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _class$1, _descriptor$1, _descriptor2$1, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;
    let GlobalStyleSheet = (_dec$1 = styleRuleCustom({
      selector: "body"
    }), _dec2 = styleRuleCustom({
      selector: ".hidden"
    }), _dec3 = styleRuleCustom({
      selector: "*"
    }), _dec4 = styleRuleCustom({
      selector: "a"
    }), _dec5 = styleRuleCustom({
      selector: "hr"
    }), _dec6 = styleRuleCustom({
      selector: "code, pre"
    }), _dec7 = styleRuleCustom({
      selector: "code"
    }), _dec8 = styleRuleCustom({
      selector: "pre"
    }), _dec9 = styleRuleCustom({
      selector: "pre code"
    }), (_class$1 = class GlobalStyleSheet extends StyleSheet {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "body", _descriptor$1, this);
        _initializerDefineProperty(this, "hidden", _descriptor2$1, this);
        _initializerDefineProperty(this, "everything", _descriptor3, this);
        _initializerDefineProperty(this, "a", _descriptor4, this);
        _initializerDefineProperty(this, "hr", _descriptor5, this);
        _initializerDefineProperty(this, "codeAndPre", _descriptor6, this);
        _initializerDefineProperty(this, "code", _descriptor7, this);
        _initializerDefineProperty(this, "pre", _descriptor8, this);
        _initializerDefineProperty(this, "preInCode", _descriptor9, this);
      }
    }, (_descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "body", [_dec$1], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: 0,
          fontSize: this.themeProps.FONT_SIZE_DEFAULT,
          fontFamily: this.themeProps.FONT_FAMILY_DEFAULT
        };
      }
    }), _descriptor2$1 = _applyDecoratedDescriptor(_class$1.prototype, "hidden", [_dec2], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "none !important"
        };
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class$1.prototype, "everything", [_dec3], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxSizing: "border-box"
        };
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class$1.prototype, "a", [_dec4], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textDecoration: "none",
          color: this.themeProps.COLOR_LINK
        };
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class$1.prototype, "hr", [_dec5], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 0,
          marginTop: "20px",
          marginBottom: "20px",
          border: 0,
          borderTop: "1px solid #eee",
          boxSizing: "content-box"
        };
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class$1.prototype, "codeAndPre", [_dec6], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontFamily: this.themeProps.FONT_FAMILY_MONOSPACE
        };
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class$1.prototype, "code", [_dec7], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "2px 4px",
          // TODO: should be in rem
          fontSize: "90%",
          color: "#345 !important",
          // TODO: take colors from theme
          backgroundColor: "#f8f2f4 !important",
          borderRadius: this.themeProps.BUTTON_BORDER_RADIUS
        };
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class$1.prototype, "pre", [_dec8], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: "auto",
          display: "block",
          padding: 4,
          margin: "0 0 10px",
          fontSize: "13px",
          lineHeight: "1.42857143",
          color: "#333",
          wordBreak: "break-all",
          wordWrap: "break-word",
          backgroundColor: "#f5f5f5",
          border: "1px solid #ccc"
        };
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class$1.prototype, "preInCode", [_dec9], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          fontSize: "inherit",
          color: "inherit",
          whiteSpace: "pre-wrap",
          backgroundColor: "transparent",
          borderRadius: 0
        };
      }
    })), _class$1));

    class EstablishmentApp extends StemApp {
      // Iphone 6

      static init() {
        this.loadPublicState();
        this.addAjaxProcessors();
        this.registerWebsocketStreams();
        this.initializeViewportMeta();
        this.configureTheme();
        this.initializeGlobalStyle();
        return super.init();
      }
      static loadPublicState() {
        GlobalState$1.importState(self.PUBLIC_STATE || {});
      }
      static addAjaxProcessors() {
        // Add the csrf cookie and credential for all requests
        Ajax.addPreprocessor(options => {
          if (!options.disableCredentials) {
            options.credentials = options.credentials || "include";
            options.headers.set("X-CSRFToken", getCookie("csrftoken"));
          }
        });

        // Add a postprocessor to load any state received from an Ajax response
        Ajax.addPostprocessor((payload, xhrPromise) => {
          if (payload.state && !xhrPromise.options.disableStateImport) {
            GlobalState$1.importState(payload.state);
          }
        });

        // Sync server time
        Ajax.addPostprocessor((payload, xhrPromise) => {
          const responseHeaders = xhrPromise.getResponseHeaders();
          const responseDate = responseHeaders.get("date");
          if (responseDate) {
            // Estimate server time, with 500ms rounding and 100 ms latency
            const estimatedServerTime = new StemDate(responseDate).add(600);
            ServerTime.set(estimatedServerTime, true);
          }
        });

        // Raise any error, to be handled by the error processor
        Ajax.addPostprocessor(payload => {
          if (payload.error) {
            throw payload.error;
          }
        });

        // Prettify any error, so it's in a standardized format
        Ajax.addErrorPostprocessor(error => {
          return ErrorHandlers.wrapError(error);
        });

        // Add a default error handler
        Ajax.errorHandler = error => ErrorHandlers.showErrorAlert(error);
      }
      static registerWebsocketStreams() {
        // TODO: first check if websockets are enabled
        GlobalState$1.registerStream = function (streamName) {
          WebsocketSubscriber.addListener(streamName, GlobalState$1.applyEventWrapper);
        };

        //Register on the global event stream
        GlobalState$1.registerStream("global-events");

        //Register on the user event stream
        if (self.USER && self.USER.id) {
          GlobalState$1.registerStream("user-" + self.USER.id + "-events");
        }
      }
      static initializeViewportMeta() {
        return this.viewportMeta = ViewportMeta.create(document.head);
      }
      static configureTheme() {
        // Nothing to do by default
      }
      static initializeGlobalStyle() {
        GlobalStyleSheet.initialize();
      }
    }
    EstablishmentApp.MIN_VIEWPORT_META_WIDTH = 375;

    function logout() {
      Dispatcher.Global.dispatch("logout");
      Ajax.postJSON("/accounts/logout/", {}).then(() => {
        Dispatcher.Global.dispatch("logoutSuccess");
        location.reload();
      });
    }

    // TODO Shit to not break old code
    Array.prototype.last = function () {
      return this[this.length - 1];
    };
    attachProfileThemeListeners();
    PageTitleManager.setDefaultTitle("CS Academy");
    ServerTime.setPageLoadTime(window.SERVER_PAGE_LOAD);
    Ajax.addPreprocessor(jQueryCompatibilityPreprocessor);
    EstablishmentApp.addAjaxProcessors();
    GlobalStyleSheet.initialize();
    Theme.register(TabArea, MinimalistTabAreaStyle);
    ArticleEditor.DiffWidgetClass = DelayedDiffWidget;
    CodeEditor.requireAce = function (callback) {
      return ensure("/static/ext/ace/ace.js", () => {
        CodeEditor.AceRange = window.ace.require("ace/range").Range;
        callback && callback();
      });
    };
    BlockCodeModifier.prototype.getElement = content => {
      return {
        tag: "CodeSnippet",
        value: content
      };
    };
    StateDependentElement.renderLoading = () => {
      return UI$1.createElement("div", {
        style: {
          textAlign: "center"
        }
      }, UI$1.createElement(CSALoadingLogo, {
        size: 250,
        style: {
          marginTop: "100px"
        }
      }));
    };
    StateDependentElement.renderError = error => {
      const ieeeErrorString = "login";

      // TODO: @IEEE this should cause a relogin as the team user (if we want to)
      let extraElements = [];
      if (error.message.indexOf(ieeeErrorString) >= 0 && USER.isAuthenticated) {
        extraElements.push(UI$1.createElement(Button$1, {
          level: Level.PRIMARY,
          label: "Log out",
          onClick: logout
        }));
      }
      return UI$1.createElement("div", {
        style: {
          textAlign: "center"
        }
      }, UI$1.createElement(CSALogo, {
        size: 250,
        style: {
          marginTop: "100px"
        }
      }), UI$1.createElement("h3", null, "Error: ", error.message), extraElements);
    };
    THIRD_PARTY_LOGIN_HANDLERS.IEEE = {
      name: "IEEE",
      color: IEEE_PRIMARY_COLOR$1,
      icon: "ieee",
      loginManager: {
        getInstance() {
          return this;
        },
        login() {
          window.location = location.origin + "/ieee/login-with-ieee/";
        }
      }
    };
    SetMakeIcon((icon, options) => {
      if (icon === "ieee") {
        return UI$1.createElement(Image, {
          src: "/static/svg/ieee_logo_white.svg",
          style: {
            marginRight: 8,
            height: 20
          }
        });
      }
      return DefaultMakeIcon(icon, options);
    });
    ChatWidget.defaultPlugins = [EnterToSendPlugin, UserMentionPlugin];
    CommentWidget.defaultPlugins = [UserMentionPlugin];

    // TODO: get rid of this!
    const oldSetOptions = SVG.Element.prototype.setOptions;
    SVG.Element.prototype.setOptions = function (options) {
      if (typeof this.getDefaultOptions === "function") {
        let defaultOptions = this.getDefaultOptions(options) || {};
        // TODO: consider this deep copy, seems really shady!
        const goodRef = options.ref;
        options = deepCopy({}, defaultOptions, options);
        if (goodRef) {
          options.ref = goodRef;
        }
      }
      oldSetOptions.call(this, options);
    };

    // Require ace, to be sure we have it if needed
    setTimeout(() => CodeEditor.requireAce(() => {}), 250);

    // TODO: extend Establishment app
    class CSAApp extends UI$1.Element {
      render() {
        return [UI$1.createElement(CSANavManager, {
          ref: "navManager"
        }), UI$1.createElement(GlobalContainer, null, UI$1.createElement(Router, {
          routes: ROUTES,
          ref: "router",
          style: {
            height: "100%"
          }
        }))];
      }
      onMount() {
        Dispatcher.Global.addListener("externalURLChange", () => {
          if (this.navManager.leftSidePanel.visible) {
            this.navManager.toggleLeftSidePanel();
          }
        });
        this.router.addListener("change", () => {
          document.body.click();
          Dispatcher.Global.dispatch("closeAllModals");
          BasePopup.clearBodyPopups();
        });
        this.navManager.initGlobalRouterListener();
        Dispatcher.Global.dispatch("initNavManagerDone");
        this.addClickListener(() => BasePopup.clearBodyPopups());
      }
    }
    const viewportMeta = ViewportMeta.create(document.head, {
      minDeviceWidth: 450
    });
    window.UI = UI$1;
    window.GlobalState = GlobalState$1;
    window.Theme = Theme;

    class VisualListElement extends SVG.Group {
      getDefaultOptions() {
        return {
          cellWidth: 40,
          cellHeight: 25,
          lineLength: 25,
          fill: "white",
          color: "black",
          strokeWidth: 1.5,
          textStrokeWidth: 1,
          fontSize: 15
        };
      }
      getLineCoords() {
        // Name shorteners
        let orientation = this.options.orientation;
        let x = this.options.coords.x;
        let y = this.options.coords.y;
        let cellWidth = this.options.cellWidth;
        let cellHeight = this.options.cellHeight;
        let lineLength = this.options.lineLength;
        return {
          x1: function () {
            if (orientation === "right") {
              return x + cellWidth;
            } else if (orientation === "left") {
              return x;
            } else {
              // orientation === "up" || orientation === "down"
              return x + cellWidth / 2;
            }
          }(),
          y1: function () {
            if (orientation === "down") {
              return y + cellHeight;
            } else if (orientation === "up") {
              return y;
            } else {
              // orientation === "left" || orientation === "right"
              return y + cellHeight / 2;
            }
          }(),
          x2: function () {
            if (orientation === "right") {
              return x + cellWidth + lineLength;
            } else if (orientation === "left") {
              return x - lineLength;
            } else {
              // orientation === "up" || orientation === "down"
              return x + cellWidth / 2;
            }
          }(),
          y2: function () {
            if (orientation === "down") {
              return y + cellHeight + lineLength;
            } else if (orientation === "up") {
              return y - lineLength;
            } else {
              // orientation === "left" || orientation === "right"
              return y + cellHeight / 2;
            }
          }()
        };
      }
      getCoords() {
        return this.options.coords;
      }
      setCoords(coords) {
        this.options.coords = coords;
        this.rect.setX(coords.x);
        this.rect.setY(coords.y);
        this.label.setPosition(coords.x + this.options.cellWidth / 2, coords.y + this.options.cellHeight / 2);
        if (this.options.hasLine) {
          let lineCoords = this.getLineCoords();
          this.line.setLine(lineCoords.x1, lineCoords.y1, lineCoords.x2, lineCoords.y2);
        }
        let clipPathRect = this.getClipPathRect();
        this.clipPathRect.setX(clipPathRect.x);
        this.clipPathRect.setY(clipPathRect.y);
        this.clipPathRect.setHeight(clipPathRect.height);
        this.clipPathRect.setWidth(clipPathRect.width);
      }
      getLabel() {
        return this.options.label;
      }
      setLabel(label) {
        this.options.label = label;
        this.label.setText(this.options.label);
      }
      hideLineTransition(duration, dependsOn = [], startTime = 0) {
        let createLineModifier = new Modifier({
          func: () => {
            this.toggleLine(true);
            this.line.setAttribute("opacity", 1);
          },
          reverseFunc: () => {
            this.toggleLine(false);
          }
        });
        let changeOpacityTransition = new Transition$1({
          func: (t, context) => {
            if (this.line) {
              this.line.setAttribute("opacity", context.opacity * (1 - t));
            }
          },
          context: {
            opacity: 1
          },
          duration: duration,
          dependsOn: [createLineModifier]
        });
        let removeLineModifier = new Modifier({
          func: () => {
            this.toggleLine(false);
          },
          reverseFunc: () => {
            this.toggleLine(true);
            this.line.setAttribute("opacity", 1);
          },
          startTime: duration,
          dependsOn: [createLineModifier, changeOpacityTransition]
        });
        let list = new TransitionList();
        list.dependsOn = dependsOn;
        list.push(createLineModifier, false);
        list.push(changeOpacityTransition, false);
        list.push(removeLineModifier, false);
        list.setStartTime(startTime);
        return list;
      }
      showLineTransition(duration, dependsOn = [], startTime = 0) {
        let ensureHasLineModifier = new Modifier({
          func: context => {
            context.addedLine = !this.line;
            this.toggleLine(true);
          },
          reverseFunc: context => {
            if (context.addedLine) {
              this.toggleLine(false);
            }
          },
          context: {}
        });
        let changeOpacityTransition = new Transition$1({
          func: (t, context) => {
            if (this.line) {
              this.line.setAttribute("opacity", context.opacity + (1 - context.opacity) * t);
            }
          },
          context: {
            opacity: 0
          },
          duration: duration,
          dependsOn: [ensureHasLineModifier]
        });
        let list = new TransitionList();
        list.dependsOn = dependsOn;
        list.push(ensureHasLineModifier, false);
        list.push(changeOpacityTransition, false);
        list.setStartTime(startTime);
        return list;
      }
      showTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setAttribute("opacity", context.opacity + (1 - context.opacity) * t);
          },
          context: {
            opacity: 0
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
      hideTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setAttribute("opacity", context.opacity * (1 - t));
          },
          context: {
            opacity: 1
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
      toggleLine(boolFlag) {
        if (boolFlag === this.options.hasLine) {
          return;
        }
        this.options.hasLine = boolFlag;
        if (this.options.hasLine) {
          let lineCoords = this.getLineCoords();
          this.appendChild(UI$1.createElement(SVG.Line, {
            ref: this.refLink("line"),
            x1: lineCoords.x1,
            y1: lineCoords.y1,
            x2: lineCoords.x2,
            y2: lineCoords.y2,
            stroke: this.options.color,
            strokeWidth: this.options.strokeWidth
          }));
        } else {
          this.eraseChild(this.line);
          delete this.line;
        }
      }
      render() {
        this.options.children = [];
        this.options.children.push(UI$1.createElement(SVG.Group, {
          ref: "cellGroup",
          clipPath: "url(#visualListElementClipPath" + uniqueId(this) + ")"
        }, UI$1.createElement(SVG.Rect, {
          ref: this.refLink("rect"),
          x: this.options.coords.x,
          y: this.options.coords.y,
          width: this.options.cellWidth,
          height: this.options.cellHeight,
          fill: this.options.fill,
          stroke: this.options.color,
          strokeWidth: this.options.strokeWidth
        }), UI$1.createElement(SVG.Text, {
          ref: this.refLink("label"),
          x: this.options.coords.x + this.options.cellWidth / 2,
          y: this.options.coords.y + this.options.cellHeight / 2,
          text: this.options.label,
          fill: this.options.color,
          stroke: this.options.color,
          strokeWidth: this.options.textStrokeWidth,
          fontSize: this.options.fontSize,
          textAnchor: "middle",
          dy: "0.35em"
        }), UI$1.createElement(SVG.Defs, {
          ref: this.refLink("defs")
        }, UI$1.createElement(SVG.ClipPath, {
          id: "visualListElementClipPath" + uniqueId(this)
        }, UI$1.createElement(SVG.Rect, _extends({
          ref: this.refLink("clipPathRect")
        }, this.getClipPathRect()))))));
        if (this.options.hasLine) {
          let lineCoords = this.getLineCoords();
          this.options.children.push(UI$1.createElement(SVG.Line, {
            ref: this.refLink("line"),
            x1: lineCoords.x1,
            y1: lineCoords.y1,
            x2: lineCoords.x2,
            y2: lineCoords.y2,
            stroke: this.options.color,
            strokeWidth: this.options.strokeWidth
          }));
        }
        return this.options.children;
      }
      getClipPathRect() {
        // Name shorteners
        let strokeWidth = this.options.strokeWidth;
        let cellWidth = this.options.cellWidth;
        let cellHeight = this.options.cellHeight;
        let x = this.options.coords.x;
        let y = this.options.coords.y;
        return {
          x: x - strokeWidth / 2,
          y: y - strokeWidth / 2,
          width: cellWidth + strokeWidth,
          height: cellHeight + strokeWidth
        };
      }
      getColor() {
        return this.options.color;
      }
      setColor(color) {
        this.options.color = color;
        this.rect.setAttribute("stroke", color);
        this.label.setColor(color);
      }
      setFill(color) {
        this.rect.setAttribute("fill", color);
      }
      moveTransition(coords, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setCoords({
              x: coords.x * t + context.coords.x * (1 - t),
              y: coords.y * t + context.coords.y * (1 - t)
            });
          },
          context: {
            coords: this.options.coords
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
      slideNewValueTransition(newValue, direction, duration, dependsOn = [], startTime = 0, inMovie = true) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        // Name shorteners
        let cellWidth = this.options.cellWidth;
        let cellHeight = this.options.cellHeight;
        let x = this.options.coords.x;
        let y = this.options.coords.y;
        let dummyStartX;
        let dummyStartY;
        let labelFinalX;
        let labelFinalY;
        if (direction === "up") {
          dummyStartX = x + cellWidth / 2;
          dummyStartY = y + cellHeight * 3 / 2;
          labelFinalX = x + cellWidth / 2;
          labelFinalY = y - cellHeight * 3 / 2;
        } else if (direction === "down") {
          dummyStartX = x + cellWidth / 2;
          dummyStartY = y - cellHeight / 2;
          labelFinalX = x + cellWidth / 2;
          labelFinalY = y + cellHeight * 3 / 2;
        } else if (direction === "left") {
          dummyStartX = x + cellWidth * 3 / 2;
          dummyStartY = y + cellHeight / 2;
          labelFinalX = x - cellWidth / 2;
          labelFinalY = y + cellHeight / 2;
        } else if (direction === "right") {
          dummyStartX = x - cellWidth / 2;
          dummyStartY = y + cellHeight / 2;
          labelFinalX = config.x + config.VisualListCell_width * 3 / 2;
          labelFinalY = config.y + config.VisualListCell_height / 2;
        }
        let dummy = UI$1.createElement(SVG.Text, {
          x: dummyStartX,
          y: dummyStartY,
          text: newValue,
          fill: this.options.color,
          stroke: this.options.color,
          strokeWidth: this.options.textStrokeWidth,
          fontSize: this.options.fontSize,
          textAnchor: "middle",
          dy: "0.35em"
        });

        // Add the dummy in DOM at start coords
        let appendChildModifier = new Modifier({
          func: () => {
            this.cellGroup.appendChild(dummy);
            dummy.setPosition(dummyStartX, dummyStartY);
          },
          reverseFunc: () => {
            this.cellGroup.eraseChild(dummy, !inMovie);
          }
        });
        transitionList.push(appendChildModifier, false);
        let moveStartTime = transitionList.getLength();
        // Move the dummy
        let t1 = dummy.moveTransition({
          x: this.label.getX(),
          y: this.label.getY()
        }, duration, [appendChildModifier], moveStartTime);
        transitionList.add(t1, false);
        // Move the label
        let t2 = this.label.moveTransition({
          x: labelFinalX,
          y: labelFinalY
        }, duration, [appendChildModifier], moveStartTime);
        transitionList.add(t2, false);

        // Replace dummy with real label
        let labelX = this.label.getX();
        let labelY = this.label.getY();
        let labelText = this.label.getText();
        transitionList.push(new Modifier({
          func: () => {
            this.setLabel(newValue);
            this.label.setPosition(labelX, labelY);
            this.cellGroup.eraseChild(dummy, !inMovie);
          },
          reverseFunc: () => {
            this.setLabel(labelText);
            this.cellGroup.appendChild(dummy);
          },
          dependsOn: [t1, t2]
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
    }
    class VisualList extends SVG.Group {
      getDefaultOptions() {
        return {
          orientation: "right",
          batchSpacing: 12,
          box: {
            x: 0,
            y: 0,
            width: 400,
            height: 400
          },
          elementOptions: VisualListElement.prototype.getDefaultOptions()
        };
      }
      render() {
        let elements = [];
        if (this.options.labels) {
          let batchCapacity = this.getBatchCapacity();
          for (let i = 0; i < this.options.labels.length; i += 1) {
            elements.push(UI$1.createElement(VisualListElement, _extends({
              coords: this.getCellCoords(i),
              label: this.options.labels[i],
              orientation: this.options.orientation,
              hasLine: i % batchCapacity !== batchCapacity - 1 && i !== this.options.labels.length - 1
            }, this.options.elementOptions)));
          }
        }
        this.options.children = [];
        // Add a clipPath
        this.options.children.push(UI$1.createElement(SVG.Defs, {
          ref: "defs"
        }, UI$1.createElement(SVG.ClipPath, {
          id: "visualListClipPath" + uniqueId(this)
        }, UI$1.createElement(SVG.Rect, _extends({
          ref: this.refLink("clipPathRect")
        }, this.getClipPathRect())))));
        this.options.clipPath = "url(#visualListClipPath" + uniqueId(this) + ")";
        // Add the list elements
        this.options.children.push(UI$1.createElement(SVG.Group, {
          ref: "elementsGroup"
        }, elements));
        return this.options.children;
      }
      getCell(cellLabel) {
        for (let i = 0; i < this.elements.length; i += 1) {
          let element = this.elements[i];
          if (element.getLabel() === cellLabel) {
            return element;
          }
        }
      }
      setBox(box) {
        this.options.box = box;
        let clipPathBox = this.getClipPathRect();
        this.clipPathRect.setX(clipPathBox.x);
        this.clipPathRect.setY(clipPathBox.y);
        this.clipPathRect.setWidth(clipPathBox.width);
        this.clipPathRect.setHeight(clipPathBox.height);
        if (this.options.labels) {
          let batchCapacity = this.getBatchCapacity();
          for (let i = 0; i < this.elements.length; i += 1) {
            let element = this.elements[i];
            element.setCoords(this.getCellCoords(i));
            element.toggleLine(i % batchCapacity !== batchCapacity - 1 && i !== this.elements.length - 1);
          }
        }
      }
      setLabels(labels) {
        let newElements = [];
        let batchCapacity = this.getBatchCapacity();
        for (let i = 0; i < labels.length; i += 1) {
          newElements.push(UI$1.createElement(VisualListElement, _extends({
            coords: this.getCellCoords(i),
            label: labels[i],
            orientation: this.options.orientation,
            hasLine: i % batchCapacity !== batchCapacity - 1 && i !== labels.length - 1
          }, this.options.elementOptions)));
        }
        while (this.elementsGroup.options.children.length > 0) {
          this.elementsGroup.eraseChildAtIndex(0, true);
        }
        this.elementsGroup.options.children = newElements;
        this.elementsGroup.redraw();
      }
      get elements() {
        return this.elementsGroup.children;
      }
      getBatchCapacity() {
        let batchLength;
        let cellLength;
        if (this.options.orientation === "left" || this.options.orientation === "right") {
          batchLength = this.options.box.width;
          cellLength = this.options.elementOptions.cellWidth;
        } else {
          batchLength = this.options.box.height;
          cellLength = this.options.elementOptions.cellHeight;
        }
        if (batchLength < cellLength) {
          console.log("ERROR: Tried to create a visual list with batchLength < cellLength");
        }
        return Math.floor((batchLength - cellLength) / (cellLength + this.options.elementOptions.lineLength)) + 1;
      }
      getCellCoords(cellIndex) {
        let batchCapacity = this.getBatchCapacity();

        // Name shorteners
        let x = this.options.box.x;
        let y = this.options.box.y;
        let orientation = this.options.orientation;
        let batchSpacing = this.options.batchSpacing;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        let lineLength = this.options.elementOptions.lineLength;
        if (orientation === "right") {
          return {
            x: x + (cellWidth + lineLength) * (cellIndex % batchCapacity),
            y: y + (cellHeight + batchSpacing) * Math.floor(cellIndex / batchCapacity)
          };
        } else if (orientation === "left") {
          return {
            x: x - (cellWidth + lineLength) * (cellIndex % batchCapacity) - cellWidth,
            y: y + (cellHeight + batchSpacing) * Math.floor(cellIndex / batchCapacity)
          };
        } else if (orientation === "down") {
          return {
            x: x + (cellWidth + batchSpacing) * Math.floor(cellIndex / batchCapacity),
            y: y + (cellHeight + lineLength) * (cellIndex % batchCapacity)
          };
        } else if (orientation === "up") {
          return {
            x: x + (cellWidth + batchSpacing) * Math.floor(cellIndex / batchCapacity),
            y: y - (cellHeight + lineLength) * (cellIndex % batchCapacity) - cellHeight
          };
        } else {
          console.log("ERROR: Wrong visual list orientation.");
        }
      }
      getClipPathRect() {
        let batchCapacity = this.getBatchCapacity();

        // Name shorteners
        let x = this.options.box.x;
        let y = this.options.box.y;
        let width = this.options.box.width;
        let height = this.options.box.height;
        let orientation = this.options.orientation;
        let strokeWidth = this.options.elementOptions.strokeWidth;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        let lineLength = this.options.elementOptions.lineLength;

        // TODO: replace string with Direction/Orientation
        if (orientation === "right") {
          return {
            x: x - strokeWidth / 2,
            y: y - strokeWidth / 2,
            width: (batchCapacity - 1) * (cellWidth + lineLength) + cellWidth + strokeWidth,
            height: height + strokeWidth
          };
        } else if (orientation === "left") {
          // TODO(@wefgef): Fix strokeWidth stuff
          return {
            x: x - ((batchCapacity - 1) * (cellWidth + lineLength) + cellWidth) - strokeWidth,
            y: y - strokeWidth,
            width: (batchCapacity - 1) * (cellWidth + lineLength) + cellWidth + 2 * strokeWidth,
            height: height + 2 * strokeWidth
          };
        } else if (orientation === "down") {
          return {
            x: x - strokeWidth,
            y: y - strokeWidth,
            width: width + 2 * strokeWidth,
            height: (batchCapacity - 1) * (cellHeight + lineLength) + cellHeight + 2 * strokeWidth
          };
        } else if (orientation === "up") {
          return {
            x: x - strokeWidth,
            y: y - ((batchCapacity - 1) * (cellHeight + lineLength) + cellHeight) - strokeWidth,
            width: width + 2 * strokeWidth,
            height: (batchCapacity - 1) * (cellHeight + lineLength) + cellHeight + 2 * strokeWidth
          };
        } else {
          console.log("VisualList.config.VisualList_orientation is not valid: " + orientation);
        }
      }
      getNextDummyCoords(batchIndex) {
        let batchCapacity = this.getBatchCapacity();

        // Name shorteners
        let x = this.options.box.x;
        let y = this.options.box.y;
        let orientation = this.options.orientation;
        let batchSpacing = this.options.batchSpacing;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        var lineLength = this.options.elementOptions.lineLength;
        if (orientation == "up") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y - cellHeight - lineLength
          };
        } else if (orientation == "down") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y + (cellHeight + lineLength) * batchCapacity
          };
        } else if (orientation == "left") {
          return {
            x: x - cellWidth - lineLength,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else if (orientation == "right") {
          return {
            x: x + (cellWidth + lineLength) * batchCapacity,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else {
          console.log("ERROR: Wrong visual list orientation.");
        }
      }
      getPrevDummyCoords(batchIndex) {
        let batchCapacity = this.getBatchCapacity();

        // Name shorteners
        let x = this.options.box.x;
        let y = this.options.box.y;
        let orientation = this.options.orientation;
        let batchSpacing = this.options.batchSpacing;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        var lineLength = this.options.elementOptions.lineLength;
        if (orientation == "up") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y + (cellHeight + lineLength) * batchCapacity
          };
        } else if (orientation == "down") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y - cellHeight - lineLength
          };
        } else if (orientation == "left") {
          return {
            x: x + (cellWidth + lineLength) * batchCapacity,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else if (orientation == "right") {
          return {
            x: x - cellWidth - lineLength,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else {
          console.log("ERROR: Wrong visual list orientation.");
        }
      }
      insertTransition(cellIndex, label, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let batchCapacity = this.getBatchCapacity();
        let elements = this.elements;

        // Data validation
        cellIndex = Math.max(cellIndex, 0);
        cellIndex = Math.min(cellIndex, elements.length);

        // Step1: Delete before line. Should satisfy:
        // a. The cell not added at the end of list
        // b. The cell is not first on its row
        // c. Lines have positive length
        let dep = [];
        if (cellIndex !== elements.length && cellIndex % batchCapacity !== 0 && this.options.elementOptions.lineLength) {
          let step1Duration = 0.25 * maxDuration;
          let t = elements[cellIndex - 1].hideLineTransition(step1Duration);
          transitionList.push(t, false);
          dep = [t];
        }

        // Step2: Create the gap. Should satisfy: the cell not added at the end of list
        if (cellIndex !== elements.length) {
          let step2Duration = 0.25 * maxDuration;
          // Create the dummies
          let dummies = [];
          for (let i = cellIndex + 1; i <= elements.length; i += 1) {
            if (i % batchCapacity === 0) {
              dummies.push(UI$1.createElement(VisualListElement, {
                coords: this.getPrevDummyCoords(i / batchCapacity),
                label: elements[i - 1].getLabel(),
                orientation: this.options.orientation,
                hasLine: i !== elements.length
              }));
            }
          }
          let setDummyCoordsModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;
              for (let i = cellIndex + 1; i <= elements.length; i += 1) {
                if (i % batchCapacity === 0) {
                  let dummy = dummies[dummyIndex];
                  dummyIndex += 1;
                  this.appendChild(dummy);
                  dummy.setCoords(this.getPrevDummyCoords(i / batchCapacity));
                }
              }
            },
            reverseFunc: () => {
              for (let i = 0; i < dummies.length; i += 1) {
                let dummy = dummies[i];
                this.eraseChild(dummy, !inMovie);
              }
            },
            dependsOn: dep
          });
          transitionList.push(setDummyCoordsModifier, false);

          // Move the cells to create the gap
          let moveTransition = new TransitionList();
          moveTransition.dependsOn = [setDummyCoordsModifier];
          for (let i = cellIndex; i < elements.length; i += 1) {
            if (i % batchCapacity === batchCapacity - 1) {
              moveTransition.add(elements[i].moveTransition(this.getNextDummyCoords((i + 1) / batchCapacity - 1), step2Duration), false);
            } else {
              moveTransition.add(elements[i].moveTransition(this.getCellCoords(i + 1), step2Duration), false);
            }
          }
          let dummyIndex = 0;
          for (let i = cellIndex + 1; i <= elements.length; i += 1) {
            if (i % batchCapacity === 0) {
              let dummy = dummies[dummyIndex];
              moveTransition.add(dummy.moveTransition(this.getCellCoords(i), step2Duration), false);
              dummyIndex += 1;
            }
          }
          transitionList.push(moveTransition, false);

          // Replace the dummies with the real elements
          let replaceModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;
              for (let i = cellIndex + 1; i <= elements.length; i += 1) {
                if (i % batchCapacity === 0) {
                  let element = elements[i - 1];
                  let dummy = dummies[dummyIndex];
                  element.setCoords(this.getCellCoords(i));
                  if (i !== elements.length && batchCapacity > 1) {
                    element.toggleLine(true);
                  }
                  this.eraseChild(dummy, !inMovie);
                  dummyIndex += 1;
                }
              }
            },
            reverseFunc: () => {
              let dummyIndex = 0;
              for (let i = cellIndex + 1; i <= elements.length; i += 1) {
                if (i % batchCapacity === 0) {
                  let element = elements[i - 1];
                  let dummy = dummies[dummyIndex];
                  if (dummy) {
                    element.toggleLine(false);
                    this.appendChild(dummy);
                  }
                  dummyIndex += 1;
                }
              }
            },
            dependsOn: [moveTransition]
          });
          transitionList.push(replaceModifier, false);
          dep = [replaceModifier];
        }

        // Step3: Create new element
        let step3Duration = 0.25 * maxDuration;
        let newElement = UI$1.createElement(VisualListElement, _extends({
          coords: this.getCellCoords(cellIndex),
          label: label,
          orientation: this.options.orientation,
          hasLine: false
        }, this.options.elementOptions));
        let createChildModifier = new Modifier({
          func: () => {
            this.elementsGroup.insertChild(newElement, cellIndex);
            newElement.setAttribute("opacity", 0);
          },
          reverseFunc: () => {
            newElement.setAttribute("opacity", 1);
            this.elementsGroup.eraseChild(newElement, !inMovie);
          },
          dependsOn: dep
        });
        transitionList.push(createChildModifier, false);
        let transition = newElement.showTransition(step3Duration, [createChildModifier]);
        transitionList.push(transition, false);

        // Step 4: Add missing lines. Should satisfy: lines have positive length
        if (this.options.elementOptions.lineLength) {
          let step4Duration = 0.25 * maxDuration;
          let startTime = transitionList.getLength();
          // Show new element line if not last in its row or last in the list
          if (cellIndex % batchCapacity !== batchCapacity - 1 && cellIndex !== elements.length) {
            transitionList.add(newElement.showLineTransition(step4Duration, [transition], startTime), false);
          }
          // Show previous element line if new element is not first in its row
          if (cellIndex % batchCapacity !== 0) {
            transitionList.add(elements[cellIndex - 1].showLineTransition(step4Duration, [transition], startTime), false);
          }
        }
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      deleteTransition(cellIndex, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let batchCapacity = this.getBatchCapacity();
        let elements = this.elements;
        if (cellIndex < 0 || cellIndex >= elements.length) {
          return;
        }
        let dep = [];
        // Step1: Remove adjacent lines.
        if (this.options.elementOptions.lineLength) {
          let step1Duration = 0.25 * maxDuration;
          let removeStartTime = transitionList.getLength();
          // Remove previous line
          if (cellIndex % batchCapacity !== 0) {
            let hideLineTransition = elements[cellIndex - 1].hideLineTransition(step1Duration, [], removeStartTime);
            transitionList.add(hideLineTransition, false);
            let toggleLineModifier = new Modifier({
              func: () => {
                elements[cellIndex - 1].toggleLine(false);
              },
              reverseFunc: () => {
                elements[cellIndex - 1].toggleLine(true);
              },
              dependsOn: [hideLineTransition],
              startTime: removeStartTime + step1Duration + 1
            });
            transitionList.add(toggleLineModifier, false);
            dep = [toggleLineModifier];
          }
          // Remove element line
          if (cellIndex % batchCapacity !== batchCapacity - 1 && cellIndex !== elements.length - 1) {
            let hideLineTransition2 = elements[cellIndex].hideLineTransition(step1Duration, dep, removeStartTime);
            transitionList.add(hideLineTransition2, false);
            let toggleLineModifier2 = new Modifier({
              func: () => {
                elements[cellIndex].toggleLine(false);
              },
              reverseFunc: () => {
                elements[cellIndex].toggleLine(true);
              },
              dependsOn: [hideLineTransition2],
              startTime: removeStartTime + step1Duration + 1
            });
            transitionList.add(toggleLineModifier2, false);
            dep = [toggleLineModifier2];
          }
        }

        // Step2: Remove the element
        let step2Duration = 0.25 * maxDuration;
        let element = elements[cellIndex];
        let elementHideTransition = element.hideTransition(step2Duration, dep);
        transitionList.push(elementHideTransition);
        let removeElementModifier = new Modifier({
          func: () => {
            this.elementsGroup.eraseChild(element, !inMovie);
          },
          reverseFunc: () => {
            this.elementsGroup.insertChild(element, cellIndex);
          },
          dependsOn: [elementHideTransition]
        });
        transitionList.push(removeElementModifier, false);

        // Step3: Close gap. Should satisfy: element not last
        if (cellIndex !== elements.length - 1) {
          let step3Duration = 0.25 * maxDuration;
          let dummies = [];
          for (let i = cellIndex; i + 1 < elements.length; i += 1) {
            // If last in its batch
            if (i % batchCapacity === batchCapacity - 1) {
              let dummy = UI$1.createElement(VisualListElement, _extends({
                coords: this.getNextDummyCoords((i + 1) / batchCapacity - 1),
                label: elements[i + 1].getLabel(),
                orientation: this.options.orientation,
                hasLine: false
              }, this.options.elementOptions));
              dummies.push(dummy);
            }
          }

          // Set initial dummy coords
          let setDummyCoordsModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;
              for (let i = cellIndex; i < elements.length; i += 1) {
                if (i % batchCapacity === batchCapacity - 1) {
                  let dummy = dummies[dummyIndex];
                  if (!dummy) {
                    return;
                  }
                  this.appendChild(dummy);
                  dummy.setCoords(this.getNextDummyCoords((i + 1) / batchCapacity - 1));
                  dummyIndex += 1;
                }
              }
            },
            reverseFunc: () => {
              for (let i = 0; i < dummies.length; i += 1) {
                let dummy = dummies[i];
                if (!dummy) {
                  return;
                }
                this.eraseChild(dummy, !inMovie);
              }
            },
            dependsOn: [removeElementModifier]
          });
          transitionList.push(setDummyCoordsModifier, false);

          // Add missing lines
          let addMissingLinesModifier = new Modifier({
            func: () => {
              for (let i = cellIndex; i + 1 < elements.length; i += 1) {
                if ((i + 1) % batchCapacity === batchCapacity - 1) {
                  let element = elements[i];
                  element.toggleLine(true);
                }
              }
            },
            reverseFunc: () => {
              for (let i = cellIndex + 1; i + 1 < elements.length; i += 1) {
                if ((i + 1) % batchCapacity === batchCapacity - 1) {
                  let element = elements[i];
                  element.toggleLine(false);
                }
              }
            },
            dependsOn: [removeElementModifier, setDummyCoordsModifier]
          });
          transitionList.push(addMissingLinesModifier, false);

          // Move the cells to create the gap
          let moveTransition = new TransitionList();
          moveTransition.dependsOn = [removeElementModifier, setDummyCoordsModifier, addMissingLinesModifier];
          for (let i = cellIndex + 1; i < elements.length; i += 1) {
            if (i % batchCapacity == 0) {
              moveTransition.add(elements[i].moveTransition(this.getPrevDummyCoords(i / batchCapacity), step3Duration), false);
            } else {
              moveTransition.add(elements[i].moveTransition(elements[i - 1].getCoords(), step3Duration), false);
            }
          }
          let dummyIndex = 0;
          for (let i = cellIndex; i + 1 < elements.length; i += 1) {
            if (i % batchCapacity === batchCapacity - 1) {
              let dummy = dummies[dummyIndex];
              moveTransition.add(dummy.moveTransition(elements[i].getCoords(), step3Duration), false);
              dummyIndex += 1;
            }
          }
          transitionList.push(moveTransition, false);

          // Replace the dummies with the real elements
          let replaceModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;
              for (let i = cellIndex; i < elements.length; i += 1) {
                if (i % batchCapacity === batchCapacity - 1) {
                  let element = elements[i];
                  let dummy = dummies[dummyIndex];
                  element.setCoords(dummy.getCoords());
                  this.eraseChild(dummy, !inMovie);
                  dummyIndex += 1;
                }
              }
            },
            reverseFunc: () => {
              for (let i = 0; i < dummies.length; i += 1) {
                let dummy = dummies[i];
                this.appendChild(dummy);
              }
            },
            dependsOn: [moveTransition]
          });
          transitionList.push(replaceModifier, false);
          dep = [replaceModifier];
        }

        // Step4: Add missing line. Should satisfy:
        // a. The cell is deleted from the end of the list
        // b. The cell is first in its batch
        if (cellIndex !== elements.length - 1 && cellIndex % batchCapacity !== 0) {
          let step4Duration = 0.25 * maxDuration;
          transitionList.push(elements[cellIndex - 1].showLineTransition(step4Duration, dep), false);
        }
        transitionList.setStartTime(startTime);
        return transitionList;
      }
      changeValueTransition(cellIndex, newLabel, direction, duration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.elements[cellIndex].slideNewValueTransition(newLabel, direction, duration, dependsOn, startTime, inMovie);
      }
    }

    var _class, _descriptor, _descriptor2, _dec, _class2;
    class CSAPlayerContainer extends UI$1.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          width: "100%",
          height: "100%",
          position: "relative",
          display: "inline-block"
        });
      }
    }
    let PlayerCardPanelStyle = (_class = class PlayerCardPanelStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);
        _initializerDefineProperty(this, "heading", _descriptor, this);
        _initializerDefineProperty(this, "body", _descriptor2, this);
      }
    }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "heading", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#DBDBDB",
          color: "white"
        };
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "body", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          height: "100%",
          width: "100%",
          position: "relative",
          overflow: "hidden"
        };
      }
    })), _class);
    let PlayerCardPanel = (_dec = registerStyle(PlayerCardPanelStyle), _dec(_class2 = class PlayerCardPanel extends CardPanel {
      setOptions(options) {
        options = Object.assign({
          // level: "default",
          color: "#DBDBDB"
        }, options);
        super.setOptions(options);
        this.focused = false;
        return options;
      }
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          marginBottom: "20px",
          display: "flex",
          flexDirection: "column",
          height: this.options.height + "px",
          width: this.options.width + "px"
        });
      }
      render() {
        return UI$1.createElement(SVG.SVGRoot, {
          ref: "svg",
          width: "100%",
          height: "100%"
        }, this.options.children);
      }
      getChildrenToRender() {
        return [this.options.nonSVGChildren, super.getChildrenToRender()];
      }
      setColor(color) {
        this.options.color = color;
        if (this.node) {
          this.panelTitle.setStyle("background-color", color);
          this.setStyle("border-color", color);
        }
      }
      toggleFocus(duration, dependsOn = [], startTime = 0) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let modifier = new Modifier({
          func: () => {
            this.focused = !this.focused;
          },
          reverseFunc: () => {
            this.focused = !this.focused;
          }
        });
        transitionList.push(modifier, false);
        let targetColor = this.focused ? "#DBDBDB" : "#87ACCC";
        transitionList.push(new Transition$1({
          func: (t, context) => {
            this.setColor(Color$1.interpolate(context.color, targetColor, t));
          },
          context: {
            color: this.options.color
          },
          duration: duration,
          dependsOn: [modifier]
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }
    }) || _class2);
    class CSAPlayer extends UI$1.Element {
      getDefaultOptions() {
        return {
          speedFactor: 1,
          fullPlayer: true,
          speedInterpolationArray: [{
            x: 0,
            y: 0.5
          }, {
            x: 0.25,
            y: 0.75
          }, {
            x: 0.5,
            y: 1
          }, {
            x: 0.75,
            y: 2
          }, {
            x: 1,
            y: 4
          }]
        };
      }
      setOptions(options) {
        if (this.getDefaultOptions) {
          let defaultOptions = this.getDefaultOptions();
          super.setOptions(Object.assign(defaultOptions, options));
        } else {
          super.setOptions(options);
        }
      }
      redraw() {
        this.pause();
        super.redraw();
        if (this.movie) {
          delete this.movie;
        }
      }
      render() {
        let buttonOptions = {
          style: {
            "margin": "0 5px",
            borderRadius: "4px"
          }
        };
        let result = [UI$1.createElement(ProgressBar, {
          ref: "progressBar",
          active: "true",
          value: "0",
          disableTransition: true,
          style: {
            height: "9px",
            "margin-bottom": "10px",
            cursor: "pointer"
          }
        }), UI$1.createElement(Button$1, {
          ref: "playButton",
          level: "default",
          size: Size.SMALL,
          style: buttonOptions.style,
          icon: "play"
        }), UI$1.createElement(Button$1, {
          ref: "pauseButton",
          level: "default",
          className: "hidden",
          size: Size.SMALL,
          style: buttonOptions.style,
          icon: "pause"
        }), UI$1.createElement(Button$1, {
          ref: "repeatButton",
          level: "default",
          className: "hidden",
          size: Size.SMALL,
          style: buttonOptions.style,
          icon: "repeat"
        })];
        if (this.options.fullPlayer === true) {
          result.push(UI$1.createElement(Button$1, {
            ref: "plusButton",
            level: "default",
            className: "pull-right",
            size: Size.SMALL,
            style: buttonOptions.style,
            icon: "plus-circle"
          }));
          result.push(UI$1.createElement(HorizontalSlideBar, {
            ref: "speedBar",
            className: "pull-right",
            width: 100,
            barWidth: 5,
            value: "0.5",
            style: {
              margin: "0 8px"
            }
          }));
          result.push(UI$1.createElement(Button$1, {
            ref: "minusButton",
            level: "default",
            className: "pull-right",
            size: Size.SMALL,
            style: buttonOptions.style,
            icon: "minus-circle"
          }));
        }
        return result;
      }
      setSpeedFactor(speedFactor) {
        this.options.speedFactor = speedFactor;
        if (this.movie) {
          this.movie.setSpeedFactor(speedFactor);
        }
      }
      pause() {
        this.options.paused = true;
        if (this.movie) {
          this.movie.pause();
        }
        if (this.pauseButton) {
          this.pauseButton.hide();
        }
        if (this.playButton) {
          this.playButton.show();
        }
      }
      play() {
        this.options.paused = false;
        if (this.movie) {
          this.movie.resume();
        } else {
          this.buildMovie();
          this.movie.setSpeedFactor(this.options.speedFactor);
          this.movie.startAtPercent(0);
        }
        this.playButton.hide();
        this.pauseButton.show();
      }
      repeat() {
        this.movie.startAtPercent(0);
        this.repeatButton.hide();
        this.pauseButton.show();
      }
      setProgressValue(progressValue) {
        this.progressBar.set(progressValue);
        if (progressValue === 1) {
          this.playButton.hide();
          this.pauseButton.hide();
          this.repeatButton.show();
        }
      }
      onMount() {
        if (this.options.fullPlayer) {
          this.speedBar.addListener("change", newValue => {
            this.setSpeedFactor(interpolationValue(this.options.speedInterpolationArray, newValue));
          });
          this.minusButton.addClickListener(() => {
            let newSpeed = this.options.speedInterpolationArray[0].x;
            for (let i = 0; i < this.options.speedInterpolationArray.length; i += 1) {
              let speed = this.options.speedInterpolationArray[i];
              if (speed.y < this.options.speedFactor) {
                newSpeed = speed.x;
              }
            }
            this.speedBar.setValue(newSpeed);
          });
          this.plusButton.addClickListener(() => {
            let newSpeed = this.options.speedInterpolationArray.last().x;
            for (let i = this.options.speedInterpolationArray.length - 1; i >= 0; i -= 1) {
              let speed = this.options.speedInterpolationArray[i];
              if (speed.y > this.options.speedFactor) {
                newSpeed = speed.x;
              }
            }
            this.speedBar.setValue(newSpeed);
          });
        }
        this.playButton.addClickListener(() => {
          this.play();
        });
        this.progressBar.addClickListener(event => {
          if (!this.movie) {
            this.buildMovie();
            this.options.paused = false;
          }
          this.repeatButton.hide();
          if (this.options.paused) {
            this.playButton.show();
            this.pauseButton.hide();
          } else {
            this.playButton.hide();
            this.pauseButton.show();
          }
          let t = (Device.getEventX(event) - getOffset(this.progressBar).left) / this.progressBar.getWidth();
          this.movie.startAtPercent(t);
        });
        this.pauseButton.addClickListener(() => {
          this.pause();
        });
        this.repeatButton.addClickListener(() => {
          this.repeat();
        });
      }
      focusTransition(focusPanels, duration, dependsOn = [], startTime = 0) {
        let transitions = new TransitionList();
        transitions.dependsOn = dependsOn;
        if (!Array.isArray(focusPanels)) {
          focusPanels = [focusPanels];
        }
        for (let i = 0; i < this.panels.length; i += 1) {
          let panel = this.panels[i];
          if (panel.focused && focusPanels.indexOf(panel) === -1) {
            transitions.add(panel.toggleFocus(duration), false);
          }
        }
        for (let i = 0; i < focusPanels.length; i += 1) {
          let panel = focusPanels[i];
          if (!panel.focused) {
            transitions.add(panel.toggleFocus(duration), false);
          }
        }
        transitions.setStartTime(startTime);
        return transitions;
      }
      delayTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: () => {},
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }
    }

    class VisualArray extends VisualList {
      getDefaultOptions() {
        return deepCopy({}, super.getDefaultOptions(), {
          indexFontSize: 14,
          elementOptions: {
            lineLength: 0
          }
        });
      }
      render() {
        let result = super.render();
        this.indices = [];
        let fontSize = this.options.indexFontSize;
        let cellHeight = this.options.elementOptions.cellHeight;
        let cellWidth = this.options.elementOptions.cellWidth;
        let color = this.options.elementOptions.color;
        let strokeWidth = this.options.elementOptions.textStrokeWidth;
        for (let i = 0; i < this.options.labels.length; i += 1) {
          let cellCoords = this.getCellCoords(i);
          let x = cellCoords.x + cellWidth / 2;
          let y = cellCoords.y + cellHeight + fontSize;
          this.indices.push(UI$1.createElement(SVG.Text, {
            text: i,
            x: x,
            y: y,
            fill: color,
            stroke: color,
            strokeWidth: strokeWidth,
            fontSize: fontSize,
            textAnchor: "middle",
            dy: "0.35em"
          }));
        }
        return result.concat(this.indices);
      }
      decrementValueTransition(cellIndex, duration, dependsOn = [], inMovie = true, startTime = 0) {
        let newValue = parseInt(this.elements[cellIndex].getLabel()) - 1;
        return this.changeValueTransition(cellIndex, newValue, "up", duration, dependsOn, startTime, inMovie);
      }
      getPopupPosition(index, deltaX = 0, deltaY = 0) {
        let position = this.elements[index].getCoords();
        return {
          x: position.x + deltaX,
          y: position.y + deltaY
        };
      }
      hideTransition(index, duration, dependsOn = [], startTime = 0, inMovie = true) {
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        result.add(this.elements[index].changeOpacityTransition(0, duration, [], 0, inMovie), false);
        result.add(this.indices[index].changeOpacityTransition(0, duration, [], 0, inMovie), false);
        result.setStartTime(startTime);
        return result;
      }
      moveElementTransition(index, finalPosition, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            let fontSize = this.options.indexFontSize;
            let cellHeight = this.options.elementOptions.cellHeight;
            let cellWidth = this.options.elementOptions.cellWidth;
            let cellCoords = {
              x: context.coords.x * (1 - t) + finalPosition.x * t,
              y: context.coords.y * (1 - t) + finalPosition.y * t
            };
            this.elements[index].setCoords(cellCoords);
            this.indices[index].setAttribute("x", cellCoords.x + cellWidth / 2);
            this.indices[index].setAttribute("y", cellCoords.y + cellHeight + fontSize);
          },
          context: {
            coords: this.elements[index].getCoords()
          },
          dependsOn: dependsOn,
          startTime: startTime,
          duration: duration
        });
      }
    }

    class CustomIntegerInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.initialValue = options.initialValue || "";
        options.children = [UI$1.createElement(TextInput, {
          ref: this.refLink("input"),
          style: {
            maxWidth: "70px"
          },
          value: this.options.initialValue
        })];
        super.setOptions(options);
      }
      getValue() {
        return parseInt(this.input.getValue());
      }
      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
        this.input.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.options.parent.setInput();
          }
        });
      }
    }
    class CustomArrayInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.initialValue = options.initialValue || [];
        for (let x of options.initialValue) {
        }
        options.children = [UI$1.createElement(TextInput, {
          ref: this.refLink("input"),
          style: {
            maxWidth: "300px"
          },
          value: this.options.initialValue.join(' ')
        })];
        super.setOptions(options);
      }
      getValue() {
        return parseIntegers(this.input.getValue());
      }
      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
        this.input.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.options.parent.setInput();
          }
        });
      }
    }
    class CustomStringInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.initialValue = options.initialValue || "";
        options.children = [UI$1.createElement(TextInput, {
          ref: this.refLink("input"),
          style: {
            maxWidth: "300px"
          },
          value: this.options.initialValue
        })];
        super.setOptions(options);
      }
      getValue() {
        return this.input.getValue();
      }
      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
        this.input.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.options.parent.setInput();
          }
        });
      }
    }
    class CustomObjectInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        super.setOptions(options);
      }
      getValue() {
        let data = {};
        for (let child of this.options.children) {
          data[child.options.name] = child.getValue();
        }
        return data;
      }
      render() {
        return UI$1.createElement("div", null, super.render());
      }
    }
    const CustomInputable = BaseClass => class CustomInputableClass extends UI$1.Element {
      getValue() {
        let options = {};
        for (let field of this.fields) {
          options[field.options.name] = field.getValue();
        }
        return options;
      }
      setOptions(options) {
        if (!options.hasOwnProperty("hiddenForm")) {
          options.hiddenForm = true;
        }
        if (!options.hasOwnProperty("dynamicApply")) {
          options.dynamicApply = false;
        }
        super.setOptions(options);
      }

      //function should return "ok" if the input given by the user is valid,
      //or an appropriate error message otherwise
      inputChecker(options) {
        return "ok";
      }
      optionsModifier(options) {
        return options;
      }
      getForm() {
        this.fields = this.getFormFields();
        return UI$1.createElement(Form, null, this.fields);
      }
      render() {
        let form;
        if (!this.options.dynamicApply) {
          form = [this.getForm(), UI$1.createElement(Button$1, {
            ref: "setInputButton",
            label: "Apply",
            level: Level.SUCCESS
          }), UI$1.createElement("div", {
            style: {
              display: "inline-block",
              float: "left"
            }
          }, UI$1.createElement(TemporaryMessageArea, {
            ref: "error"
          }))];
        } else {
          form = [this.getForm(), UI$1.createElement(TemporaryMessageArea, {
            ref: "error"
          })];
        }
        this.drawing = this.drawing || this.generateNewElement(this.options);
        let result = [this.drawing];
        if (this.options.hiddenForm) {
          result.push(UI$1.createElement(Button$1, {
            ref: "customInputButton",
            label: "Set Custom Input",
            icon: "chevron-right",
            level: Level.INFO,
            style: {
              display: "block",
              margin: "20px"
            }
          }));
          result.push(UI$1.createElement("div", {
            className: "hidden",
            ref: "customInputForm"
          }, form));
        } else {
          result.push(UI$1.createElement("div", {
            ref: "customInputForm"
          }, form));
        }
        return result;
      }
      getElementClass() {
        return BaseClass;
      }
      generateNewElement(options) {
        const ElementClass = this.getElementClass();
        return UI$1.createElement(ElementClass, _extends({
          key: Math.random()
        }, options));
      }
      setUserOptions(options) {
        Object.assign(this.options, options);
        this.drawing.destroyNode();
        this.drawing = this.generateNewElement(options);
        if (this.customInputButton) {
          this.drawing.mount(this, this.customInputButton.node);
        } else if (!this.options.hiddenForm) {
          this.drawing.mount(this, this.customInputForm.node);
        } else {
          this.drawing.mount(this);
        }
      }
      setInput() {
        let options = Object.assign({}, this.options);
        let inputOptions = this.getValue();
        options = Object.assign(options, inputOptions);
        let msg = this.inputChecker(inputOptions);
        if (msg !== "ok") {
          if (this.options.dynamicApply) {
            this.error.showMessage(msg, "black", 1000 * 24 * 60 * 60);
          } else {
            this.error.showMessage(msg, "black", 4000);
          }
        } else {
          this.error.clear();
          options = this.optionsModifier(options);
          this.setUserOptions(options);
        }
      }
      onMount() {
        if (this.customInputButton) {
          this.customInputButton.addClickListener(() => {
            if (this.customInputForm.hasClass("hidden")) {
              this.customInputButton.setIcon("chevron-down");
              this.customInputForm.removeClass("hidden");
            } else {
              this.customInputButton.setIcon("chevron-right");
              this.customInputForm.addClass("hidden");
            }
          });
        }
        if (this.setInputButton) {
          this.setInputButton.addClickListener(() => {
            this.setInput();
          });
        }
      }
    };

    const SLOWING_FACTOR = 5;
    class CSAForceTransition extends Transition$1 {
      constructor(options) {
        super({
          func: t => {
            let frameIndex = Math.floor(t * (this.nodeFrames.length - 1));
            let frame = this.nodeFrames[frameIndex];
            if (frame === this.nodeFrames.length - 1) {
              return;
            }
            let nextFrame = this.nodeFrames[frameIndex + 1];
            let percent = 1 - (t * (this.nodeFrames.length - 1) - frameIndex);
            for (let node of this.graph.nodes) {
              let currentCoords = frame.get(node);
              let nextCoords;
              if (nextFrame) {
                nextCoords = nextFrame.get(node);
              } else {
                nextCoords = currentCoords;
              }
              node.setCenter({
                x: percent * currentCoords.x + (1 - percent) * nextCoords.x,
                y: percent * currentCoords.y + (1 - percent) * nextCoords.y
              });
            }
            frame = this.edgeFrames[frameIndex];
            nextFrame = this.edgeFrames[frameIndex + 1];
            percent = 1 - (t * (this.edgeFrames.length - 1) - frameIndex);
            for (let edge of this.graph.edges) {
              let currentArcRadius = frame.get(edge).curveArcRadius;
              let nextArcRadius;
              if (nextFrame) {
                nextArcRadius = nextFrame.get(edge).curveArcRadius;
              } else {
                nextArcRadius = currentArcRadius;
              }
              edge.setCurveArcRadius(percent * currentArcRadius + (1 - percent) * nextArcRadius);
              edge.update();
            }
          },
          startTime: options.startTime,
          duration: options.duration
        });
        //TODO(@darius) Name these nodes and edges
        this.points = new Map();
        for (let i = 0; i < options.graph.nodes.length; i += 1) {
          this.points.set(options.graph.nodes[i], options.graph.nodes[i].getCenter());
        }
        this.lines = new Map();
        for (let i = 0; i < options.graph.edges.length; i += 1) {
          this.lines.set(options.graph.edges[i], {
            curveArcRadius: options.graph.edges[i].getCurveArcRadius()
          });
        }
        this.graph = options.graph;
        this.fps = options.fps || 60;
        this.realFps = options.realFps || 10;
        this.nodeFrames = [];
        this.edgeFrames = [];
        this.auxiliaryTransitions = [];
      }
      setDuration(duration) {
        this.duration = duration;
      }
      generateNewFrame() {
        let graph = this.graph;

        // Generate first frame
        if (this.nodeFrames.length === 0) {
          this.nodeFrames.push(new Map(this.points));
          this.edgeFrames.push(new Map(this.lines));
          return;
        }

        // Create a force layout and run 1 step
        let forceLayout = new CSAForceLayout({
          points: this.graph.nodes.map(node => {
            return this.points.get(node);
          }),
          edges: graph.options.edges.map(edge => {
            return {
              first: edge.source,
              second: edge.target
            };
          }),
          gravityCenter: graph.getGravityCenter()
        });
        let points = forceLayout.calculateVectors(1);
        for (let i = 0; i < graph.nodes.length; i += 1) {
          let node = graph.nodes[i];
          let coords = {
            x: points[i].x + points[i].dx,
            y: points[i].y + points[i].dy
          };
          if (!node.isFixed()) {
            this.points.delete(node);
            this.points.set(node, coords);
          }
        }

        //Calculate edge bending
        if (graph.options.supportsBending) {
          let bendingDelta = this.getBendingDelta();
          for (let i = 0; i < graph.edges.length; i += 1) {
            let edge = graph.edges[i];
            let currentValue = this.lines.get(edge).curveArcRadius;
            if (edge.options.supportsBending) {
              this.lines.set(edge, {
                curveArcRadius: currentValue + bendingDelta[i]
              });
            }
          }
        }

        // Run auxiliary transitions
        let frameTime = this.nodeFrames.length * 1000 / this.realFps;
        this.runAuxiliaryTransitions(frameTime);
        this.nodeFrames.push(new Map(this.points));
        this.edgeFrames.push(new Map(this.lines));
      }
      getBendingDelta() {
        let delta = new Array(this.graph.edges.length);
        for (let i = 0; i < this.graph.edges.length; i += 1) {
          let edge = this.graph.edges[i];
          if (!edge.options.supportsBending) {
            delta[i] = 0;
            return;
          }
          let edgeStartCoords = this.points.get(edge.getSource());
          let edgeEndCoords = this.points.get(edge.getTarget());
          let edgeLine = lineEquation(edgeStartCoords, edgeEndCoords);
          let biggestNode = null;
          for (let i = 0; i < this.graph.nodes.length; i += 1) {
            if (this.graph.nodes[i] === edge.getSource() || this.graph.nodes[i] === edge.getTarget()) {
              continue;
            }
            let nodeCoords = this.points.get(this.graph.nodes[i]);

            // Take the node's projection on this line
            let nodeProjection = perpendicularFoot(nodeCoords, edgeLine);

            // If the node almost intersects the line and
            // If the node's projection si on the segment determined by the edge points
            // In other words, if the node almost intersects the segemnt determined by the edge
            if (distancePointLine(nodeCoords, edgeLine) <= this.graph.nodes[i].getRadius() + 10 && pointOnSegment(nodeProjection, edgeStartCoords, edgeEndCoords)) {
              // Store the node with the biggest radius out of all the ones that respect the above restrictions
              if (biggestNode === null || this.graph.nodes[i].getRadius() > biggestNode.getRadius()) {
                biggestNode = this.graph.nodes[i];
              }
            }
          }

          // Note that the code below is a little different than the one in CSAGraph
          // of the interactive graph
          // This one is slower and behaves more smoothly
          let currentCurveArcRadius = this.lines.get(edge).curveArcRadius;
          let targetCurveArcRadius;
          // If there exists a node that almost intersects the edge
          if (biggestNode !== null) {
            // If the current edge's arc radius is 0
            if (currentCurveArcRadius === 0) {
              // Set the target arc radius to be opposite of the direction from which the node is coming
              // Set it proportional to the node's radius
              targetCurveArcRadius = 2.5 * biggestNode.getRadius() * (signedDistancePointLine(this.points.get(biggestNode), edgeLine) > 0 ? -1 : 1);
            } else {
              // Set the target arc radius radius to be in the direction that it's already going in
              // This is to minimize annoying wiggling by the edges
              targetCurveArcRadius = 2.5 * biggestNode.getRadius() * (currentCurveArcRadius < 0 ? -1 : 1);
            }
          } else {
            // Set the edge to be straight
            targetCurveArcRadius = 0;
          }

          // With this delta, the edge will head towards its target radius with exponentially decaying speed
          delta[i] = (targetCurveArcRadius - currentCurveArcRadius) / SLOWING_FACTOR;
        }
        return delta;
      }
      forceFinish() {
        let totalFrames = 1 + Math.ceil(this.duration * this.realFps / 1000);
        while (this.nodeFrames.length < totalFrames) {
          this.generateNewFrame();
        }
        return this;
      }
      runAuxiliaryTransitions(time) {
        for (let i = 0; i < this.auxiliaryTransitions.length; i += 1) {
          let transition = this.auxiliaryTransitions[i];
          if (time < transition.startTime || transition.isStopped()) {
            continue;
          }
          transition.nextStep(time);
        }
      }
      moveNodeTransition(options) {
        return new Transition$1({
          func: (t, context) => {
            this.points.set(context.node, {
              x: (1 - t) * context.coords.x + t * options.newCoords.x,
              y: (1 - t) * context.coords.y + t * options.newCoords.y
            });
          },
          context: {
            coords: this.points.get(options.node),
            node: options.node
          },
          duration: options.duration,
          startTime: options.startTime,
          dependsOn: options.dependsOn
        });
      }
      addTransition(transition) {
        this.auxiliaryTransitions.push(transition);
      }
    }

    class VisualQueue extends VisualList {
      pushTransition(label, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.insertTransition(this.elements.length, label, maxDuration, dependsOn, startTime, inMovie);
      }
      popTransition(maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.deleteTransition(0, maxDuration, dependsOn, startTime, inMovie);
      }
      getPushQueuePosition(deltaX = 0, deltaY = 0) {
        let cellCoords = this.getCellCoords(this.elements.length - 1);
        return {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
      }
      getPopQueuePosition(deltaX = 0, deltaY = 0) {
        let cellCoords = this.getCellCoords(0);
        return {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
      }
    }

    class Arrow extends SVG.Polygon {
      getDefaultOptions() {
        return {
          x: 0,
          y: 0,
          length: 10
        };
      }
      setOptions(options) {
        super.setOptions(options);
        let arrowShaftLength = this.options.length * 0.6;
        let arrowHeadLength = this.options.length * 0.3;
        let arrowShaftWidth = this.options.length * 0.1;
        let arrowHeadWidth = this.options.length * 0.4;
        let spacing = this.options.length * 0.05;
        let startX = this.options.x + spacing;
        let startY = this.options.y - arrowShaftWidth / 2;
        this.options.points = [{
          x: startX,
          y: startY
        }, {
          x: startX + arrowShaftLength,
          y: startY
        }, {
          x: startX + arrowShaftLength,
          y: startY - (arrowHeadWidth - arrowShaftWidth) / 2
        }, {
          x: startX + arrowShaftLength + arrowHeadLength,
          y: startY + arrowShaftWidth / 2
        }, {
          x: startX + arrowShaftLength,
          y: startY + arrowShaftWidth + (arrowHeadWidth - arrowShaftWidth) / 2
        }, {
          x: startX + arrowShaftLength,
          y: startY + arrowShaftWidth
        }, {
          x: startX,
          y: startY + arrowShaftWidth
        }];
      }
      setCoords(x, y) {
        this.options.x = x;
        this.options.y = y;
        // TODO(@mikester): Why doesn't simple this.redraw() work?
        this.setOptions(this.options);
        this.redraw();
      }
    }
    class AdjacencyList extends SVG.Group {
      getDefaultOptions() {
        return {
          box: {
            x: 0,
            y: 0,
            width: 1000,
            height: 1000
          },
          visualListOptions: VisualList.prototype.getDefaultOptions()
        };
      }
      render() {
        this.options.children = [];

        // Name shortener
        let elementOptions = this.options.visualListOptions.elementOptions;

        // Create the main label
        this.options.children.push(UI$1.createElement(SVG.Text, {
          ref: "mainLabel",
          text: this.options.mainLabel,
          fontSize: elementOptions.fontSize,
          fill: elementOptions.color,
          stroke: elementOptions.color,
          strokeWidth: elementOptions.textStrokeWidth,
          x: this.options.box.x + elementOptions.cellWidth / 2,
          y: this.options.box.y + elementOptions.cellHeight / 2
        }));

        // Create the main arrow
        let arrowOptions = {
          x: this.options.box.x + elementOptions.cellWidth,
          y: this.options.box.y + elementOptions.cellHeight / 2,
          length: elementOptions.lineLength
        };
        this.options.children.push(UI$1.createElement(Arrow, _extends({
          ref: "arrow"
        }, arrowOptions)));

        // Set visual list box
        this.options.visualListOptions.box = {
          x: this.options.box.x + elementOptions.cellWidth * 1.5 + elementOptions.lineLength,
          y: this.options.box.y,
          width: this.options.box.width - elementOptions.cellWidth * 1.5 - elementOptions.lineLength,
          height: this.options.box.height
        };

        // Create the visual list
        this.options.children.push(UI$1.createElement(VisualList, _extends({
          ref: "visualList",
          labels: this.options.labels
        }, this.options.visualListOptions)));
        return this.options.children;
      }
      getDesiredHeight() {
        let lastCell = this.visualList.elements.last();
        if (typeof lastCell === "undefined") {
          return 0;
        }
        return lastCell.options.coords.y + lastCell.options.cellHeight - this.options.box.y;
      }
      getCell(cellLabel) {
        return this.visualList.getCell(cellLabel);
      }
      setBox(box) {
        let elementOptions = this.options.visualListOptions.elementOptions;
        this.options.box = box;
        this.mainLabel.setPosition(this.options.box.x + elementOptions.cellWidth / 2, this.options.box.y + elementOptions.cellHeight / 2);
        this.arrow.setCoords(this.options.box.x + elementOptions.cellWidth, this.options.box.y + elementOptions.cellHeight / 2);
        this.visualList.setBox({
          x: this.options.box.x + elementOptions.cellWidth * 1.5 + elementOptions.lineLength,
          y: this.options.box.y,
          width: this.options.box.width - elementOptions.cellWidth * 1.5 - elementOptions.lineLength,
          height: this.options.box.height
        });
      }
    }
    class AdjacencyLists extends SVG.Group {
      getDefaultOptions() {
        return {
          box: {
            x: 0,
            y: 0,
            width: 1000,
            height: 1000
          },
          listSpacing: 20,
          directed: false,
          indexType: "0",
          visibleLists: "all",
          listOptions: AdjacencyList.prototype.getDefaultOptions()
        };
      }
      getNodeLabel(nodeIndex) {
        if (this.options.indexType === "0") {
          return nodeIndex;
        } else if (this.options.indexType === "1") {
          return nodeIndex + 1;
        } else {
          return this.nodes[nodeIndex].label || "N/A";
        }
      }
      getAdjacentLabels(nodeIndex) {
        let result = [];
        for (let i = 0; i < this.options.edges.length; i += 1) {
          let edgeData = this.options.edges[i];
          if (edgeData.source === nodeIndex) {
            result.push(this.getNodeLabel(edgeData.target));
          } else if (edgeData.target === nodeIndex && !edgeData.directed === true && !this.options.directed) {
            result.push(this.getNodeLabel(edgeData.source));
          }
        }
        return result;
      }
      render() {
        this.lists = [];
        for (let i = 0; i < this.options.nodes.length; i += 1) {
          let listOptions = deepCopy({}, this.options.listOptions);
          deepCopy(listOptions.box, this.options.box);
          this.lists.push(UI$1.createElement(AdjacencyList, _extends({
            mainLabel: this.getNodeLabel(i),
            labels: this.getAdjacentLabels(i)
          }, listOptions)));
        }
        this.options.children = [];
        for (let i = 0; i < this.lists.length; i += 1) {
          let list = this.lists[i];
          this.options.children.push(list);
        }
        return this.options.children;
      }
      setVisibleLists(visibleLists) {
        for (let i = this.options.children.length - 1; i >= 0; i -= 1) {
          let list = this.options.children[i];
          this.eraseChild(list, false);
        }
        this.options.visibleLists = visibleLists;
        if (this.options.visibleLists === "all") {
          for (let i = 0; i < this.lists.length; i += 1) {
            let list = this.lists[i];
            this.insertChild(list, i);
          }
        } else if (Array.isArray(this.options.visibleLists)) {
          for (let i = 0; i < this.options.visibleLists.length; i += 1) {
            let list = this.lists[this.options.visibleLists[i]];
            this.insertChild(list, i);
          }
        } else if (Number.isInteger(this.options.visibleLists)) {
          let list = this.lists[this.options.visibleLists];
          this.insertChild(list, 0);
        }
        this.recomputeListHeights();
      }
      getVisibleLists() {
        return this.options.visibleLists;
      }
      recomputeListHeights() {
        let heightSum = 0;
        for (let i = 0; i < this.options.children.length; i += 1) {
          let list = this.options.children[i];
          list.setBox({
            x: this.options.box.x,
            y: this.options.box.y + heightSum,
            width: this.options.box.width,
            height: this.options.box.height
          });
          let listHeight = list.getDesiredHeight();
          list.options.box.height = listHeight;
          heightSum += this.options.listSpacing + listHeight;
        }
      }
      getCell(listIndex, cellLabel) {
        return this.lists[listIndex].getCell(cellLabel);
      }
      getPopupPosition(listIndex, cellLabel, deltaX = 0, deltaY = 0) {
        let result;
        let cellCoords = this.getCell(listIndex, cellLabel).getCoords();
        result = {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
        return result;
      }
      redraw() {
        // Draw the adjacency lists
        super.redraw();
        this.setVisibleLists(this.options.visibleLists);
      }
    }
    class AdjacencyListsSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 1000,
          height: 1000,
          marginLeft: 20,
          marginTop: 40,
          directed: false
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }
      render() {
        return [UI$1.createElement(AdjacencyLists, _extends({
          ref: "adjacencyLists"
        }, this.options, {
          box: {
            x: this.options.marginLeft,
            y: this.options.marginTop,
            width: this.options.width - this.options.marginLeft,
            height: this.options.height - this.options.marginTop
          }
        }))];
      }
    }

    class VisualStack extends VisualList {
      getDefaultOptions() {
        return {
          orientation: "up",
          batchSpacing: 12,
          box: {
            x: 0,
            y: 0,
            width: 400,
            height: 400
          },
          elementOptions: Object.assign(VisualListElement.prototype.getDefaultOptions(), {
            lineLength: 0,
            cellHeight: 25,
            cellWidth: 40,
            fontSize: 15
          })
        };
      }
      getPopupPosition(deltaX = 0, deltaY = 0) {
        let cellCoords = this.getCellCoords(this.elements.length - 1);
        return {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
      }
      pushTransition(label, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.insertTransition(this.elements.length, label, maxDuration, dependsOn, startTime, inMovie);
      }
      popTransition(maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.deleteTransition(this.elements.length - 1, maxDuration, dependsOn, startTime, inMovie);
      }
    }

    class DebuggerVariable extends SVG.Group {
      render() {
        return [UI$1.createElement(SVG.Rect, {
          ref: "rect",
          x: this.options.x,
          width: 10000,
          y: this.options.y - this.options.height / 2,
          height: this.options.height,
          stroke: "yellow",
          fill: "yellow",
          opacity: "0"
        }), UI$1.createElement(SVG.Text, {
          ref: "text",
          text: this.options.name + ": " + this.options.value,
          x: this.options.x,
          y: this.options.y,
          fontFamily: "courier",
          textAnchor: "left"
        })];
      }
      setText(text) {
        this.text.setText(text);
      }
      getText() {
        return this.options.name + ": " + this.options.value;
      }
      flashTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: t => {
            if (t === 0) {
              this.rect.setAttribute("opacity", 0);
            } else {
              this.rect.setAttribute("opacity", 0.33 * (1 - t));
            }
          },
          startTime: startTime,
          duration: duration,
          dependsOn: dependsOn
        });
      }
    }

    class AdjacencyMatrixCell extends SVG.Group {
      getDefaultOptions() {
        return {
          x: 0,
          y: 0,
          size: 40,
          fontSize: 20,
          label: 0,
          strokeWidth: 2,
          textStrokeWidth: 1
        };
      }
      render() {
        return [UI$1.createElement(SVG.Rect, {
          ref: "rect",
          x: this.options.x,
          y: this.options.y,
          width: this.options.size,
          height: this.options.size,
          fill: "white",
          stroke: "black",
          strokeWidth: this.options.strokeWidth
        }), UI$1.createElement(SVG.Text, {
          ref: "text",
          text: this.options.label,
          x: this.options.x + this.options.size / 2,
          y: this.options.y + this.options.size / 2,
          strokeWidth: this.options.textStrokeWidth,
          stroke: "black"
        })];
      }
      setFill(color) {
        this.rect.setAttribute("fill", color);
      }
    }
    class AdjacencyMatrix extends SVG.Group {
      getDefaultOptions() {
        return {
          cellOptions: AdjacencyMatrixCell.prototype.getDefaultOptions(),
          directed: false
        };
      }
      setOptions(options) {
        super.setOptions(options);
      }
      render() {
        let nodeCount = this.options.nodes.length;
        this.rowNumbers = [];
        this.colNumbers = [];
        for (let i = 0; i < nodeCount; i += 1) {
          this.rowNumbers.push(UI$1.createElement(SVG.Text, {
            text: this.options.nodes[i].label,
            x: this.options.box.x + this.options.cellOptions.size / 2,
            y: this.options.box.y + this.options.cellOptions.size * (i + 1.5)
          }));
          this.colNumbers.push(UI$1.createElement(SVG.Text, {
            text: this.options.nodes[i].label,
            x: this.options.box.x + this.options.cellOptions.size * (i + 1.5),
            y: this.options.box.y + this.options.cellOptions.size / 2
          }));
        }

        // Create the cells
        let labels = new Array(nodeCount);
        for (let i = 0; i < nodeCount; i += 1) {
          labels[i] = new Array(nodeCount);
          for (let j = 0; j < nodeCount; j += 1) {
            labels[i][j] = 0;
          }
        }
        for (let i = 0; i < this.options.edges.length; i += 1) {
          let edge = this.options.edges[i];
          labels[edge.source][edge.target] += 1;
          if (!this.options.directed && !edge.directed) {
            labels[edge.target][edge.source] += 1;
          }
        }
        this.cells = new Array(nodeCount);
        for (let i = 0; i < nodeCount; i += 1) {
          this.cells[i] = new Array(nodeCount);
        }
        for (let i = 0; i < nodeCount; i += 1) {
          for (let j = 0; j < nodeCount; j += 1) {
            this.cells[i][j] = UI$1.createElement(AdjacencyMatrixCell, {
              x: this.options.box.x + (j + 1) * this.options.cellOptions.size,
              y: this.options.box.y + (i + 1) * this.options.cellOptions.size,
              label: labels[i][j]
            });
          }
        }
        return [UI$1.createElement(SVG.Group, null, this.rowNumbers), UI$1.createElement(SVG.Group, null, this.colNumbers), UI$1.createElement(SVG.Group, null, this.cells)];
      }
    }
    class AdjacencyMatrixSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 400,
          height: 400,
          padding: 10,
          directed: false
        };
      }
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }
      setOptions(options) {
        super.setOptions(options);
      }
      render() {
        return [UI$1.createElement(AdjacencyMatrix, _extends({
          ref: "adjacencyMatrix"
        }, this.options, {
          box: {
            x: this.options.padding,
            y: this.options.padding,
            width: this.options.width - 2 * this.options.padding,
            height: this.options.height - 2 * this.options.padding
          }
        }))];
      }
    }

    exports.AdjacencyLists = AdjacencyLists;
    exports.AdjacencyListsSVG = AdjacencyListsSVG;
    exports.AdjacencyMatrixSVG = AdjacencyMatrixSVG;
    exports.Button = Button$1;
    exports.CSAApp = CSAApp;
    exports.CSAForceTransition = CSAForceTransition;
    exports.CSAGeometryWidgetSVG = CSAGeometryWidgetSVG;
    exports.CSAPlayer = CSAPlayer;
    exports.CSAPlayerContainer = CSAPlayerContainer;
    exports.CardPanel = CardPanel;
    exports.CodeEditor = CodeEditor;
    exports.Color = Color$1;
    exports.CustomArrayInput = CustomArrayInput;
    exports.CustomInputable = CustomInputable;
    exports.CustomIntegerInput = CustomIntegerInput;
    exports.CustomObjectInput = CustomObjectInput;
    exports.CustomStringInput = CustomStringInput;
    exports.DebuggerVariable = DebuggerVariable;
    exports.Device = Device;
    exports.Direction = Direction;
    exports.EvalTaskStore = EvalTaskStore;
    exports.FormField = FormField;
    exports.Graph = Graph;
    exports.GraphSVG = GraphSVG;
    exports.HorizontalSlideBar = HorizontalSlideBar;
    exports.Level = Level;
    exports.Modifier = Modifier;
    exports.NumberInput = NumberInput;
    exports.Orientation = Orientation$1;
    exports.PlayerCardPanel = PlayerCardPanel;
    exports.PlayerPopup = PlayerPopup;
    exports.RawHTML = RawHTML;
    exports.SVG = SVG;
    exports.SVGGrid = SVGGrid;
    exports.Select = Select;
    exports.Size = Size;
    exports.StaticCodeHighlighter = StaticCodeHighlighter;
    exports.StyleElement = StyleElement;
    exports.StyleInstance = StyleInstance;
    exports.StyleSheet = StyleSheet;
    exports.TemporaryMessageArea = TemporaryMessageArea;
    exports.TextArea = TextArea;
    exports.TextInput = TextInput;
    exports.Transition = Transition$1;
    exports.TransitionList = TransitionList;
    exports.UI = UI$1;
    exports.VisualArray = VisualArray;
    exports.VisualList = VisualList;
    exports.VisualListElement = VisualListElement;
    exports.VisualQueue = VisualQueue;
    exports.VisualStack = VisualStack;
    exports._applyDecoratedDescriptor = _applyDecoratedDescriptor;
    exports._extends = _extends;
    exports._initializerDefineProperty = _initializerDefineProperty;
    exports.computeDFSCoordsDirected = computeDFSCoordsDirected;
    exports.computeDFSCoordsUndirected = computeDFSCoordsUndirected;
    exports.deepCopy = deepCopy;
    exports.distance = distance;
    exports.getComputedStyle = getComputedStyle;
    exports.getTextWidth = getTextWidth;
    exports.parseIntegers = parseIntegers;
    exports.registerStyle = registerStyle;
    exports.rotatePoint = rotatePoint;
    exports.styleRule = styleRule;
    exports.viewportMeta = viewportMeta;

}));
//# sourceMappingURL=bundle.js.map
